From 0716102b674b2d694962833463cbf7804aa49933 Mon Sep 17 00:00:00 2001
From: Omar Ramirez Luna <omar.ramirez@ti.com>
Date: Mon, 29 Mar 2010 11:35:08 -0600
Subject: [PATCH] DSPBRIDGE: patch for L23.I3.6-PRE2

Bridge feature branch not merged into kernel
integration tree. This patch delivers the 10 missing
patches.
Branch: for-L23I3-next
Commit: 313026069f3a5e83677fda4e70c528d0cbf3c87e

Signed-off-by: Xavier Boudet <x-boudet@ti.com>
---
 arch/arm/configs/omap_3430sdp_defconfig            |    7 +-
 arch/arm/configs/omap_3630sdp_defconfig            |    2 +-
 arch/arm/configs/omap_zoom2_defconfig              |    7 +-
 arch/arm/configs/omap_zoom3_defconfig              |    2 +-
 arch/arm/plat-omap/include/dspbridge/_chnl_sm.h    |  218 +-
 arch/arm/plat-omap/include/dspbridge/_dcd.h        |  163 +-
 arch/arm/plat-omap/include/dspbridge/brddefs.h     |   18 +-
 arch/arm/plat-omap/include/dspbridge/cfg.h         |  130 +-
 arch/arm/plat-omap/include/dspbridge/cfgdefs.h     |   83 +-
 arch/arm/plat-omap/include/dspbridge/chnl.h        |   74 +-
 arch/arm/plat-omap/include/dspbridge/chnldefs.h    |   55 +-
 arch/arm/plat-omap/include/dspbridge/chnlpriv.h    |   73 +-
 arch/arm/plat-omap/include/dspbridge/clk.h         |   91 +-
 arch/arm/plat-omap/include/dspbridge/cmm.h         |  224 +-
 arch/arm/plat-omap/include/dspbridge/cmmdefs.h     |  102 +-
 arch/arm/plat-omap/include/dspbridge/cod.h         |  189 +-
 arch/arm/plat-omap/include/dspbridge/dbc.h         |   16 +-
 arch/arm/plat-omap/include/dspbridge/dbdcd.h       |  179 +-
 arch/arm/plat-omap/include/dspbridge/dbdcddef.h    |   57 +-
 arch/arm/plat-omap/include/dspbridge/dbdefs.h      |  592 ++--
 arch/arm/plat-omap/include/dspbridge/dbldefs.h     |   95 +-
 arch/arm/plat-omap/include/dspbridge/dbll.h        |   64 +-
 arch/arm/plat-omap/include/dspbridge/dblldefs.h    |  323 +-
 arch/arm/plat-omap/include/dspbridge/dbtype.h      |   38 +-
 arch/arm/plat-omap/include/dspbridge/dehdefs.h     |    6 +-
 arch/arm/plat-omap/include/dspbridge/dev.h         |  408 ++--
 arch/arm/plat-omap/include/dspbridge/devdefs.h     |    4 +-
 arch/arm/plat-omap/include/dspbridge/disp.h        |  136 +-
 arch/arm/plat-omap/include/dspbridge/dispdefs.h    |   22 +-
 arch/arm/plat-omap/include/dspbridge/dmm.h         |   56 +-
 arch/arm/plat-omap/include/dspbridge/drv.h         |  206 +-
 arch/arm/plat-omap/include/dspbridge/drvdefs.h     |    4 +-
 arch/arm/plat-omap/include/dspbridge/dspdrv.h      |   14 +-
 .../plat-omap/include/dspbridge/dynamic_loader.h   |  281 +-
 arch/arm/plat-omap/include/dspbridge/errbase.h     |   18 +-
 arch/arm/plat-omap/include/dspbridge/gb.h          |   40 +-
 arch/arm/plat-omap/include/dspbridge/getsection.h  |   50 +-
 arch/arm/plat-omap/include/dspbridge/gh.h          |   19 +-
 arch/arm/plat-omap/include/dspbridge/gs.h          |   30 +-
 arch/arm/plat-omap/include/dspbridge/host_os.h     |   13 +-
 arch/arm/plat-omap/include/dspbridge/io.h          |   60 +-
 arch/arm/plat-omap/include/dspbridge/io_sm.h       |  193 +-
 arch/arm/plat-omap/include/dspbridge/iodefs.h      |   18 +-
 arch/arm/plat-omap/include/dspbridge/ldr.h         |    4 +-
 arch/arm/plat-omap/include/dspbridge/list.h        |   97 +-
 arch/arm/plat-omap/include/dspbridge/mbx_sh.h      |   12 +-
 arch/arm/plat-omap/include/dspbridge/mem.h         |  124 +-
 arch/arm/plat-omap/include/dspbridge/memdefs.h     |   12 +-
 arch/arm/plat-omap/include/dspbridge/mgr.h         |  123 +-
 arch/arm/plat-omap/include/dspbridge/mgrpriv.h     |   22 +-
 arch/arm/plat-omap/include/dspbridge/msg.h         |   52 +-
 arch/arm/plat-omap/include/dspbridge/msgdefs.h     |   13 +-
 arch/arm/plat-omap/include/dspbridge/nldr.h        |   54 +-
 arch/arm/plat-omap/include/dspbridge/nldrdefs.h    |  226 +-
 arch/arm/plat-omap/include/dspbridge/node.h        |  401 ++--
 arch/arm/plat-omap/include/dspbridge/nodedefs.h    |    6 +-
 arch/arm/plat-omap/include/dspbridge/nodepriv.h    |  149 +-
 arch/arm/plat-omap/include/dspbridge/ntfy.h        |  276 +-
 arch/arm/plat-omap/include/dspbridge/proc.h        |  353 +-
 arch/arm/plat-omap/include/dspbridge/procpriv.h    |    5 +-
 arch/arm/plat-omap/include/dspbridge/pwr.h         |   20 +-
 arch/arm/plat-omap/include/dspbridge/pwr_sh.h      |    2 +-
 arch/arm/plat-omap/include/dspbridge/reg.h         |   42 +-
 .../plat-omap/include/dspbridge/resourcecleanup.h  |   55 +-
 arch/arm/plat-omap/include/dspbridge/rmm.h         |   86 +-
 arch/arm/plat-omap/include/dspbridge/rms_sh.h      |   82 +-
 arch/arm/plat-omap/include/dspbridge/rmstypes.h    |    6 +-
 arch/arm/plat-omap/include/dspbridge/services.h    |   10 +-
 arch/arm/plat-omap/include/dspbridge/std.h         |   13 +-
 arch/arm/plat-omap/include/dspbridge/strm.h        |  296 +-
 arch/arm/plat-omap/include/dspbridge/strmdefs.h    |   35 +-
 arch/arm/plat-omap/include/dspbridge/sync.h        |  332 +--
 arch/arm/plat-omap/include/dspbridge/utildefs.h    |   14 +-
 arch/arm/plat-omap/include/dspbridge/uuidutil.h    |   28 +-
 arch/arm/plat-omap/include/dspbridge/wcd.h         |    4 +-
 arch/arm/plat-omap/include/dspbridge/wcdioctl.h    |  475 ++--
 arch/arm/plat-omap/include/dspbridge/wmd.h         |  773 +++---
 arch/arm/plat-omap/include/dspbridge/wmdchnl.h     |   71 +-
 arch/arm/plat-omap/include/dspbridge/wmddeh.h      |   28 +-
 arch/arm/plat-omap/include/dspbridge/wmdio.h       |   18 +-
 arch/arm/plat-omap/include/dspbridge/wmdioctl.h    |   34 +-
 arch/arm/plat-omap/include/dspbridge/wmdmsg.h      |   40 +-
 drivers/dsp/bridge/dynload/cload.c                 |  754 +++--
 drivers/dsp/bridge/dynload/dload_internal.h        |  194 +-
 drivers/dsp/bridge/dynload/doff.h                  |  194 +-
 drivers/dsp/bridge/dynload/getsection.c            |  164 +-
 drivers/dsp/bridge/dynload/header.h                |    4 +-
 drivers/dsp/bridge/dynload/module_list.h           |   22 +-
 drivers/dsp/bridge/dynload/params.h                |   46 +-
 drivers/dsp/bridge/dynload/reloc.c                 |  261 +-
 drivers/dsp/bridge/dynload/reloc_table.h           |   22 +-
 drivers/dsp/bridge/dynload/tramp.c                 |  527 ++--
 drivers/dsp/bridge/dynload/tramp_table_c6000.c     |   94 +-
 drivers/dsp/bridge/gen/gb.c                        |   70 +-
 drivers/dsp/bridge/gen/gh.c                        |  139 +-
 drivers/dsp/bridge/gen/gs.c                        |   22 +-
 drivers/dsp/bridge/gen/uuidutil.c                  |   41 +-
 drivers/dsp/bridge/hw/EasiGlobal.h                 |   11 +-
 drivers/dsp/bridge/hw/GlobalTypes.h                |  229 +-
 drivers/dsp/bridge/hw/IPIAccInt.h                  |    2 +-
 drivers/dsp/bridge/hw/MLBAccInt.h                  |   94 +-
 drivers/dsp/bridge/hw/MLBRegAcM.h                  |  174 +-
 drivers/dsp/bridge/hw/MMUAccInt.h                  |   74 +-
 drivers/dsp/bridge/hw/MMURegAcM.h                  |  158 +-
 drivers/dsp/bridge/hw/PRCMAccInt.h                 |  243 +-
 drivers/dsp/bridge/hw/PRCMRegAcM.h                 |  317 +-
 drivers/dsp/bridge/hw/hw_defs.h                    |   60 +-
 drivers/dsp/bridge/hw/hw_dspssC64P.c               |   14 +-
 drivers/dsp/bridge/hw/hw_dspssC64P.h               |   24 +-
 drivers/dsp/bridge/hw/hw_mmu.c                     |  690 ++--
 drivers/dsp/bridge/hw/hw_mmu.h                     |  162 +-
 drivers/dsp/bridge/hw/hw_prcm.c                    |   98 +-
 drivers/dsp/bridge/hw/hw_prcm.h                    |  243 +-
 drivers/dsp/bridge/pmgr/chnl.c                     |  105 +-
 drivers/dsp/bridge/pmgr/chnlobj.h                  |   35 +-
 drivers/dsp/bridge/pmgr/cmm.c                      | 1197 ++++----
 drivers/dsp/bridge/pmgr/cod.c                      |  554 ++--
 drivers/dsp/bridge/pmgr/dbll.c                     | 1589 +++++-----
 drivers/dsp/bridge/pmgr/dev.c                      | 1183 ++++----
 drivers/dsp/bridge/pmgr/dmm.c                      |  491 ++--
 drivers/dsp/bridge/pmgr/io.c                       |   92 +-
 drivers/dsp/bridge/pmgr/ioobj.h                    |   18 +-
 drivers/dsp/bridge/pmgr/msg.c                      |   89 +-
 drivers/dsp/bridge/pmgr/msgobj.h                   |   13 +-
 drivers/dsp/bridge/pmgr/wcd.c                      | 1487 +++++-----
 drivers/dsp/bridge/rmgr/dbdcd.c                    | 1300 ++++----
 drivers/dsp/bridge/rmgr/disp.c                     |  683 ++--
 drivers/dsp/bridge/rmgr/drv.c                      | 1176 ++++----
 drivers/dsp/bridge/rmgr/drv_interface.c            |  257 +-
 drivers/dsp/bridge/rmgr/drv_interface.h            |    5 +-
 drivers/dsp/bridge/rmgr/dspdrv.c                   |   99 +-
 drivers/dsp/bridge/rmgr/mgr.c                      |  354 +-
 drivers/dsp/bridge/rmgr/nldr.c                     | 1853 ++++++-----
 drivers/dsp/bridge/rmgr/node.c                     | 3468 ++++++++++----------
 drivers/dsp/bridge/rmgr/proc.c                     | 1369 ++++----
 drivers/dsp/bridge/rmgr/pwr.c                      |  155 +-
 drivers/dsp/bridge/rmgr/rmm.c                      |  384 ++--
 drivers/dsp/bridge/rmgr/strm.c                     |  800 +++---
 drivers/dsp/bridge/services/cfg.c                  |  211 +-
 drivers/dsp/bridge/services/clk.c                  |  203 +-
 drivers/dsp/bridge/services/mem.c                  |  206 +-
 drivers/dsp/bridge/services/ntfy.c                 |  279 +--
 drivers/dsp/bridge/services/reg.c                  |   85 +-
 drivers/dsp/bridge/services/regsup.c               |  209 +-
 drivers/dsp/bridge/services/regsup.h               |   35 +-
 drivers/dsp/bridge/services/services.c             |   62 +-
 drivers/dsp/bridge/services/sync.c                 |  465 +---
 drivers/dsp/bridge/wmd/_cmm.h                      |    4 +-
 drivers/dsp/bridge/wmd/_deh.h                      |   14 +-
 drivers/dsp/bridge/wmd/_msg_sm.h                   |  123 +-
 drivers/dsp/bridge/wmd/_tiomap.h                   |  187 +-
 drivers/dsp/bridge/wmd/_tiomap_mmu.h               |   20 +-
 drivers/dsp/bridge/wmd/_tiomap_pwr.h               |   55 +-
 drivers/dsp/bridge/wmd/_tiomap_util.h              |   12 +-
 drivers/dsp/bridge/wmd/chnl_sm.c                   |  919 +++---
 drivers/dsp/bridge/wmd/io_sm.c                     | 2011 ++++++------
 drivers/dsp/bridge/wmd/mmu_fault.c                 |  105 +-
 drivers/dsp/bridge/wmd/mmu_fault.h                 |   11 +-
 drivers/dsp/bridge/wmd/msg_sm.c                    |  687 ++--
 drivers/dsp/bridge/wmd/tiomap3430.c                | 1924 ++++++------
 drivers/dsp/bridge/wmd/tiomap3430_pwr.c            |  605 ++--
 drivers/dsp/bridge/wmd/tiomap_io.c                 |  504 ++--
 drivers/dsp/bridge/wmd/tiomap_io.h                 |   70 +-
 drivers/dsp/bridge/wmd/ue_deh.c                    |  320 +-
 164 files changed, 20882 insertions(+), 21120 deletions(-)

diff --git a/arch/arm/configs/omap_3430sdp_defconfig b/arch/arm/configs/omap_3430sdp_defconfig
index 912d2d3..4a0570d 100644
--- a/arch/arm/configs/omap_3430sdp_defconfig
+++ b/arch/arm/configs/omap_3430sdp_defconfig
@@ -1592,12 +1592,7 @@ CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
 # CONFIG_BRIDGE_DEBUG is not set
 CONFIG_BRIDGE_WDT3=y
 CONFIG_BRIDGE_RECOVERY=y
-# CONFIG_BRIDGE_CACHE_LINE_CHECK is not set
-
-#
-# Bridge Hacking
-#
-# CONFIG_BRIDGE_CHECK_ALIGN_128 is not set
+CONFIG_BRIDGE_CACHE_LINE_CHECK=y
 
 #
 # Bridge Notifications
diff --git a/arch/arm/configs/omap_3630sdp_defconfig b/arch/arm/configs/omap_3630sdp_defconfig
index bddb184..0b5eee7 100644
--- a/arch/arm/configs/omap_3630sdp_defconfig
+++ b/arch/arm/configs/omap_3630sdp_defconfig
@@ -1697,7 +1697,7 @@ CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
 # CONFIG_BRIDGE_DEBUG is not set
 CONFIG_BRIDGE_WDT3=y
 CONFIG_BRIDGE_RECOVERY=y
-# CONFIG_BRIDGE_CACHE_LINE_CHECK is not set
+CONFIG_BRIDGE_CACHE_LINE_CHECK=y
 
 #
 # Bridge Notifications
diff --git a/arch/arm/configs/omap_zoom2_defconfig b/arch/arm/configs/omap_zoom2_defconfig
index e89a85e..d047982 100644
--- a/arch/arm/configs/omap_zoom2_defconfig
+++ b/arch/arm/configs/omap_zoom2_defconfig
@@ -1646,12 +1646,7 @@ CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
 # CONFIG_BRIDGE_DEBUG is not set
 CONFIG_BRIDGE_WDT3=y
 CONFIG_BRIDGE_RECOVERY=y
-# CONFIG_BRIDGE_CACHE_LINE_CHECK is not set
-
-#
-# Bridge Hacking
-#
-# CONFIG_BRIDGE_CHECK_ALIGN_128 is not set
+CONFIG_BRIDGE_CACHE_LINE_CHECK=y
 
 #
 # Bridge Notifications
diff --git a/arch/arm/configs/omap_zoom3_defconfig b/arch/arm/configs/omap_zoom3_defconfig
index 5d41fc3..0a7a865 100644
--- a/arch/arm/configs/omap_zoom3_defconfig
+++ b/arch/arm/configs/omap_zoom3_defconfig
@@ -1774,7 +1774,7 @@ CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
 # CONFIG_BRIDGE_DEBUG is not set
 CONFIG_BRIDGE_WDT3=y
 CONFIG_BRIDGE_RECOVERY=y
-# CONFIG_BRIDGE_CACHE_LINE_CHECK is not set
+CONFIG_BRIDGE_CACHE_LINE_CHECK=y
 
 #
 # Bridge Notifications
diff --git a/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h b/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
index 78d15de..f8bdc93 100644
--- a/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
+++ b/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
@@ -46,140 +46,138 @@
 #define MAXOPPS 16
 
 /* Shared memory config options */
-#define SHM_CURROPP	0	/* Set current OPP in SHM */
+#define SHM_CURROPP	0	/* Set current OPP in shm */
 #define SHM_OPPINFO	1	/* Set dsp voltage and freq table values */
 #define SHM_GETOPP	2	/* Get opp requested by DSP */
 
-struct oppTableEntry {
-    u32 voltage;
-    u32 frequency;
-    u32 minFreq;
-    u32 maxFreq;
-} ;
+struct opp_table_entry {
+	u32 voltage;
+	u32 frequency;
+	u32 min_freq;
+	u32 max_freq;
+};
 
-struct oppStruct {
-    u32 currOppPt;
-    u32 numOppPts;
-    struct oppTableEntry oppPoint[MAXOPPS];
-} ;
+struct opp_struct {
+	u32 curr_opp_pt;
+	u32 num_opp_pts;
+	struct opp_table_entry opp_point[MAXOPPS];
+};
 
 /* Request to MPU */
-struct oppRqstStruct {
-    u32 rqstDspFreq;
-    u32 rqstOppPt;
+struct opp_rqst_struct {
+	u32 rqst_dsp_freq;
+	u32 rqst_opp_pt;
 };
 
 /* Info to MPU */
-struct loadMonStruct {
-    u32 currDspLoad;
-    u32 currDspFreq;
-    u32 predDspLoad;
-    u32 predDspFreq;
+struct load_mon_struct {
+	u32 curr_dsp_load;
+	u32 curr_dsp_freq;
+	u32 pred_dsp_load;
+	u32 pred_dsp_freq;
 };
 
-/* Structure in shared between DSP and PC for communication.*/
-	struct SHM {
-		u32 dspFreeMask;	/* Written by DSP, read by PC. */
-		u32 hostFreeMask;	/* Written by PC, read by DSP */
+/* Structure in shared between DSP and PC for communication. */
+struct shm {
+	u32 dsp_free_mask;	/* Written by DSP, read by PC. */
+	u32 host_free_mask;	/* Written by PC, read by DSP */
 
-		u32 inputFull;	/* Input channel has unread data. */
-		u32 inputId;	/* Channel for which input is available. */
-		u32 inputSize;	/* Size of data block (in DSP words). */
+	u32 input_full;		/* Input channel has unread data. */
+	u32 input_id;		/* Channel for which input is available. */
+	u32 input_size;		/* Size of data block (in DSP words). */
 
-		u32 outputFull;	/* Output channel has unread data. */
-		u32 outputId;	/* Channel for which output is available. */
-		u32 outputSize;	/* Size of data block (in DSP words). */
+	u32 output_full;	/* Output channel has unread data. */
+	u32 output_id;		/* Channel for which output is available. */
+	u32 output_size;	/* Size of data block (in DSP words). */
 
-		u32 arg;	/* Arg for Issue/Reclaim (23 bits for 55x). */
-		u32 resvd;	/* Keep structure size even for 32-bit DSPs */
+	u32 arg;		/* Arg for Issue/Reclaim (23 bits for 55x). */
+	u32 resvd;		/* Keep structure size even for 32-bit DSPs */
 
-		/* Operating Point structure */
-		struct oppStruct  oppTableStruct;
-		/* Operating Point Request structure */
-		struct oppRqstStruct oppRequest;
-		/* load monitor information structure*/
-		struct loadMonStruct loadMonInfo;
+	/* Operating Point structure */
+	struct opp_struct opp_table_struct;
+	/* Operating Point Request structure */
+	struct opp_rqst_struct opp_request;
+	/* load monitor information structure */
+	struct load_mon_struct load_mon_info;
 #ifdef CONFIG_BRIDGE_WDT3
-		/* Flag for WDT enable/disable F/I clocks */
-		u32 wdt_setclocks;
-		u32 wdt_overflow;	/* WDT overflow time */
-		char dummy[176];	/* padding to 256 byte boundary */
+	/* Flag for WDT enable/disable F/I clocks */
+	u32 wdt_setclocks;
+	u32 wdt_overflow;	/* WDT overflow time */
+	char dummy[176];	/* padding to 256 byte boundary */
 #else
-		char dummy[184];	/* padding to 256 byte boundary */
+	char dummy[184];	/* padding to 256 byte boundary */
 #endif
-		u32 shm_dbg_var[64];	/* shared memory debug variables */
-	} ;
+	u32 shm_dbg_var[64];	/* shared memory debug variables */
+};
 
 	/* Channel Manager: only one created per board: */
-	struct CHNL_MGR {
-		u32 dwSignature;	/* Used for object validation */
-		/* Function interface to WMD */
-		struct WMD_DRV_INTERFACE *pIntfFxns;
-		struct IO_MGR *hIOMgr;	/* IO manager */
-		/* Device this board represents */
-		struct DEV_OBJECT *hDevObject;
-
-		/* These fields initialized in WMD_CHNL_Create():    */
-		u32 dwOutputMask; /* Host output channels w/ full buffers */
-		u32 dwLastOutput;	/* Last output channel fired from DPC */
-		/* Critical section object handle */
-		struct SYNC_CSOBJECT *hCSObj;
-		u32 uWordSize;	/* Size in bytes of DSP word */
-		u32 cChannels;	/* Total number of channels */
-		u32 cOpenChannels;	/* Total number of open channels */
-		struct CHNL_OBJECT **apChannel;	/* Array of channels */
-		u32 dwType;	/* Type of channel class library */
-		/* If no SHM syms, return for CHNL_Open */
-		DSP_STATUS chnlOpenStatus;
-	} ;
+struct chnl_mgr {
+	u32 dw_signature;	/* Used for object validation */
+	/* Function interface to WMD */
+	struct bridge_drv_interface *intf_fxns;
+	struct io_mgr *hio_mgr;	/* IO manager */
+	/* Device this board represents */
+	struct dev_object *hdev_obj;
+
+	/* These fields initialized in bridge_chnl_create(): */
+	u32 dw_output_mask;	/* Host output channels w/ full buffers */
+	u32 dw_last_output;	/* Last output channel fired from DPC */
+	/* Critical section object handle */
+	spinlock_t chnl_mgr_lock;
+	u32 word_size;		/* Size in bytes of DSP word */
+	u32 max_channels;	/* Total number of channels */
+	u32 open_channels;	/* Total number of open channels */
+	struct chnl_object **ap_channel;	/* Array of channels */
+	u32 dw_type;		/* Type of channel class library */
+	/* If no shm syms, return for CHNL_Open */
+	dsp_status chnl_open_status;
+};
 
 /*
  *  Channel: up to CHNL_MAXCHANNELS per board or if DSP-DMA supported then
  *     up to CHNL_MAXCHANNELS + CHNL_MAXDDMACHNLS per board.
  */
-	struct CHNL_OBJECT {
-		u32 dwSignature;	/* Used for object validation */
-		/* Pointer back to channel manager */
-		struct CHNL_MGR *pChnlMgr;
-		u32 uId;	/* Channel id */
-		u32 dwState;	/* Current channel state */
-		u32 uMode;	/* Chnl mode and attributes */
-		/* Chnl I/O completion event (user mode) */
-		HANDLE hUserEvent;
-		/* Abstract syncronization object */
-		struct SYNC_OBJECT *hSyncEvent;
-		/* Name of Sync event */
-		char szEventName[SYNC_MAXNAMELENGTH + 1];
-		u32 hProcess;   /* Process which created this channel */
-		u32 pCBArg;	/* Argument to use with callback */
-		struct LST_LIST *pIORequests;	/* List of IOR's to driver */
-		s32 cIOCs;	/* Number of IOC's in queue */
-		s32 cIOReqs;	/* Number of IORequests in queue */
-		s32 cChirps;	/* Initial number of free Irps */
-		/* List of IOC's from driver */
-		struct LST_LIST *pIOCompletions;
-		struct LST_LIST *pFreeList;	/* List of free Irps */
-		struct NTFY_OBJECT *hNtfy;
-		u32 cBytesMoved;	/* Total number of bytes transfered */
-
-		/* For DSP-DMA */
-
-		/* Type of chnl transport:CHNL_[PCPY][DDMA] */
-		u32 uChnlType;
-	} ;
+struct chnl_object {
+	u32 dw_signature;	/* Used for object validation */
+	/* Pointer back to channel manager */
+	struct chnl_mgr *chnl_mgr_obj;
+	u32 chnl_id;		/* Channel id */
+	u32 dw_state;		/* Current channel state */
+	u32 chnl_mode;		/* Chnl mode and attributes */
+	/* Chnl I/O completion event (user mode) */
+	bhandle user_event;
+	/* Abstract syncronization object */
+	struct sync_object *sync_event;
+	u32 process;		/* Process which created this channel */
+	u32 pcb_arg;		/* Argument to use with callback */
+	struct lst_list *pio_requests;	/* List of IOR's to driver */
+	s32 cio_cs;		/* Number of IOC's in queue */
+	s32 cio_reqs;		/* Number of IORequests in queue */
+	s32 chnl_packets;	/* Initial number of free Irps */
+	/* List of IOC's from driver */
+	struct lst_list *pio_completions;
+	struct lst_list *free_packets_list;	/* List of free Irps */
+	struct ntfy_object *ntfy_obj;
+	u32 bytes_moved;	/* Total number of bytes transfered */
+
+	/* For DSP-DMA */
+
+	/* Type of chnl transport:CHNL_[PCPY][DDMA] */
+	u32 chnl_type;
+};
 
 /* I/O Request/completion packet: */
-	struct CHNL_IRP {
-		struct list_head link;	/* Link to next CHIRP in queue. */
-		/* Buffer to be filled/emptied. (User)   */
-		u8 *pHostUserBuf;
-		/* Buffer to be filled/emptied. (System) */
-		u8 *pHostSysBuf;
-		u32 dwArg;	/* Issue/Reclaim argument.               */
-		u32 uDspAddr;	/* Transfer address on DSP side.         */
-		u32 cBytes;	/* Bytes transferred.                    */
-		u32 cBufSize;	/* Actual buffer size when allocated.    */
-		u32 status;	/* Status of IO completion.              */
-	} ;
-
-#endif				/* _CHNL_SM_ */
+struct chnl_irp {
+	struct list_head link;	/* Link to next CHIRP in queue. */
+	/* Buffer to be filled/emptied. (User) */
+	u8 *host_user_buf;
+	/* Buffer to be filled/emptied. (System) */
+	u8 *host_sys_buf;
+	u32 dw_arg;		/* Issue/Reclaim argument. */
+	u32 dsp_tx_addr;	/* Transfer address on DSP side. */
+	u32 byte_size;		/* Bytes transferred. */
+	u32 buf_size;		/* Actual buffer size when allocated. */
+	u32 status;		/* Status of IO completion. */
+};
+
+#endif /* _CHNL_SM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/_dcd.h b/arch/arm/plat-omap/include/dspbridge/_dcd.h
index c6bc61d..1350feb 100644
--- a/arch/arm/plat-omap/include/dspbridge/_dcd.h
+++ b/arch/arm/plat-omap/include/dspbridge/_dcd.h
@@ -23,7 +23,7 @@
 #include <dspbridge/wcdioctl.h>
 
 /*
- *  ======== WCD_CallDevIOCtl ========
+ *  ======== wcd_call_dev_io_ctl ========
  *  Purpose:
  *      Call the (wrapper) function for the corresponding WCD IOCTL.
  *  Parameters:
@@ -36,12 +36,12 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS WCD_CallDevIOCtl(unsigned int cmd,
-					   union Trapped_Args *args,
-					   u32 *pResult, void *pr_ctxt);
+extern dsp_status wcd_call_dev_io_ctl(unsigned int cmd,
+				      union Trapped_Args *args,
+				      u32 *pResult, void *pr_ctxt);
 
 /*
- *  ======== WCD_Init ========
+ *  ======== wcd_init ========
  *  Purpose:
  *      Initialize WCD modules, and export WCD services to WMD's.
  *      This procedure is called when the class driver is loaded.
@@ -51,13 +51,13 @@
  *  Requires:
  *  Ensures:
  */
-	extern bool WCD_Init(void);
+extern bool wcd_init(void);
 
 /*
- *  ======== WCD_InitComplete2 ========
+ *  ======== wcd_init_complete2 ========
  *  Purpose:
  *      Perform any required WCD, and WMD initialization which
- *      cannot not be performed in WCD_Init(void) or DEV_StartDevice() due
+ *      cannot not be performed in wcd_init(void) or dev_start_device() due
  *      to the fact that some services are not yet
  *      completely initialized.
  *  Parameters:
@@ -68,108 +68,85 @@
  *      WCD initialized.
  *  Ensures:
  */
-	extern DSP_STATUS WCD_InitComplete2(void);
+extern dsp_status wcd_init_complete2(void);
 
 /*
- *  ======== WCD_Exit ========
+ *  ======== wcd_exit ========
  *  Purpose:
- *      Exit all modules initialized in WCD_Init(void).
+ *      Exit all modules initialized in wcd_init(void).
  *      This procedure is called when the class driver is unloaded.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      WCD_Init(void) was previously called.
+ *      wcd_init(void) was previously called.
  *  Ensures:
- *      Resources acquired in WCD_Init(void) are freed.
+ *      Resources acquired in wcd_init(void) are freed.
  */
-	extern void WCD_Exit(void);
+extern void wcd_exit(void);
 
 /* MGR wrapper functions */
-	extern u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 MGRWRAP_RegisterObject(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 MGRWRAP_UnregisterObject(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args,
-			void *pr_ctxt);
+extern u32 mgrwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt);
+extern u32 mgrwrap_enum_proc_info(union Trapped_Args *args, void *pr_ctxt);
+extern u32 mgrwrap_register_object(union Trapped_Args *args, void *pr_ctxt);
+extern u32 mgrwrap_unregister_object(union Trapped_Args *args, void *pr_ctxt);
+extern u32 mgrwrap_wait_for_bridge_events(union Trapped_Args *args,
+					  void *pr_ctxt);
 
-	extern u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args,
-			void *pr_ctxt);
+extern u32 mgrwrap_get_process_resources_info(union Trapped_Args *args,
+					      void *pr_ctxt);
 
 /* CPRC (Processor) wrapper Functions */
-	extern u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_Ctrl(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_EnumResources(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_GetState(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_GetTrace(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_RegisterNotify(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_ReserveMemory(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_FlushMemory(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args,
-			void *pr_ctxt);
+extern u32 procwrap_attach(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_ctrl(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_detach(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_enum_resources(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_get_state(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_get_trace(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_register_notify(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_start(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_reserve_memory(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_un_reserve_memory(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_map(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_un_map(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_flush_memory(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_stop(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_invalidate_memory(union Trapped_Args *args, void *pr_ctxt);
 
 /* NODE wrapper functions */
-	extern u32 NODEWRAP_Allocate(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_ChangePriority(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_Connect(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_Create(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_Delete(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_GetAttr(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_GetMessage(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_Pause(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_PutMessage(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_RegisterNotify(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_Run(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_Terminate(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args,
-			void *pr_ctxt);
+extern u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_alloc_msg_buf(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_change_priority(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_connect(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_create(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_delete(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_free_msg_buf(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_get_attr(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_get_message(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_pause(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_put_message(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_register_notify(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_run(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_terminate(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_get_uuid_props(union Trapped_Args *args, void *pr_ctxt);
 
 /* STRM wrapper functions */
-	extern u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_FreeBuffer(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 STRMWRAP_GetEventHandle(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 STRMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_Idle(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_Open(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_Reclaim(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_RegisterNotify(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 STRMWRAP_Select(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_allocate_buffer(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_close(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_free_buffer(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_get_event_handle(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_get_info(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_idle(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_issue(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_open(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_reclaim(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_register_notify(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_select(union Trapped_Args *args, void *pr_ctxt);
 
-	extern u32 CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 CMMWRAP_GetHandle(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 CMMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt);
+extern u32 cmmwrap_calloc_buf(union Trapped_Args *args, void *pr_ctxt);
+extern u32 cmmwrap_free_buf(union Trapped_Args *args, void *pr_ctxt);
+extern u32 cmmwrap_get_handle(union Trapped_Args *args, void *pr_ctxt);
+extern u32 cmmwrap_get_info(union Trapped_Args *args, void *pr_ctxt);
 
-#endif				/* _WCD_ */
+#endif /* _WCD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/brddefs.h b/arch/arm/plat-omap/include/dspbridge/brddefs.h
index ff83166..fefddb9 100644
--- a/arch/arm/plat-omap/include/dspbridge/brddefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/brddefs.h
@@ -21,19 +21,19 @@
 
 /* platform status values */
 #define BRD_STOPPED     0x0	/* No Monitor Loaded, Not running. */
-#define BRD_IDLE        0x1	/* Monitor Loaded, but suspended.  */
-#define BRD_RUNNING     0x2	/* Monitor loaded, and executing.  */
+#define BRD_IDLE        0x1	/* Monitor Loaded, but suspended. */
+#define BRD_RUNNING     0x2	/* Monitor loaded, and executing. */
 #define BRD_UNKNOWN     0x3	/* Board state is indeterminate. */
 #define BRD_SYNCINIT    0x4
 #define BRD_LOADED      0x5
 #define BRD_LASTSTATE   BRD_LOADED	/* Set to highest legal board state. */
-#define BRD_SLEEP_TRANSITION 0x6	/* Sleep transition in progress  */
-#define BRD_HIBERNATION 0x7		/* MPU initiated hibernation */
-#define BRD_RETENTION     0x8       /* Retention mode */
-#define BRD_DSP_HIBERNATION     0x9       /* DSP initiated hibernation */
-#define BRD_ERROR		0xA       /* Board state is Error */
+#define BRD_SLEEP_TRANSITION 0x6	/* Sleep transition in progress */
+#define BRD_HIBERNATION 0x7	/* MPU initiated hibernation */
+#define BRD_RETENTION     0x8	/* Retention mode */
+#define BRD_DSP_HIBERNATION     0x9	/* DSP initiated hibernation */
+#define BRD_ERROR		0xA	/* Board state is Error */
 
 /* BRD Object */
-	struct BRD_OBJECT;
+struct brd_object;
 
-#endif				/* BRDDEFS_ */
+#endif /* BRDDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/cfg.h b/arch/arm/plat-omap/include/dspbridge/cfg.h
index 62cb6df..80c8fde 100644
--- a/arch/arm/plat-omap/include/dspbridge/cfg.h
+++ b/arch/arm/plat-omap/include/dspbridge/cfg.h
@@ -22,39 +22,39 @@
 #include <dspbridge/cfgdefs.h>
 
 /*
- *  ======== CFG_Exit ========
+ *  ======== cfg_exit ========
  *  Purpose:
  *      Discontinue usage of the CFG module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      CFG_Init(void) was previously called.
+ *      cfg_init(void) was previously called.
  *  Ensures:
- *      Resources acquired in CFG_Init(void) are freed.
+ *      Resources acquired in cfg_init(void) are freed.
  */
-	extern void CFG_Exit(void);
+extern void cfg_exit(void);
 
 /*
- *  ======== CFG_GetAutoStart ========
+ *  ======== cfg_get_auto_start ========
  *  Purpose:
  *      Retreive the autostart mask, if any, for this board.
  *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      dev_node_obj:       Handle to the dev_node who's WMD we are querying.
  *      pdwAutoStart:   Ptr to location for 32 bit autostart mask.
  *  Returns:
  *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: Unable to retreive resource.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
  *      DSP_SOK:        *pdwAutoStart contains autostart mask for this devnode.
  */
-	extern DSP_STATUS CFG_GetAutoStart(IN struct CFG_DEVNODE *hDevNode,
-					   OUT u32 *pdwAutoStart);
+extern dsp_status cfg_get_auto_start(IN struct cfg_devnode *dev_node_obj,
+				     OUT u32 *pdwAutoStart);
 
 /*
- *  ======== CFG_GetCDVersion ========
+ *  ======== cfg_get_cd_version ========
  *  Purpose:
  *      Retrieves the version of the PM Class Driver.
  *  Parameters:
@@ -70,18 +70,19 @@
  *      DSP_SOK:    Success.
  *      else:       *pdwVersion is NULL.
  */
-	extern DSP_STATUS CFG_GetCDVersion(OUT u32 *pdwVersion);
+extern dsp_status cfg_get_cd_version(OUT u32 *pdwVersion);
 
 /*
- *  ======== CFG_GetDevObject ========
+ *  ======== cfg_get_dev_object ========
  *  Purpose:
  *      Retrieve the Device Object handle for a given devnode.
  *  Parameters:
- *      hDevNode:       Platform's DevNode handle from which to retrieve value.
+ *      dev_node_obj:	Platform's dev_node handle from which to retrieve
+ *      		value.
  *      pdwValue:       Ptr to location to store the value.
  *  Returns:
  *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_INVALIDPOINTER:   phDevObject is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
  *  Requires:
@@ -90,19 +91,19 @@
  *      DSP_SOK:    *pdwValue is set to the retrieved u32.
  *      else:       *pdwValue is set to 0L.
  */
-	extern DSP_STATUS CFG_GetDevObject(IN struct CFG_DEVNODE *hDevNode,
-					   OUT u32 *pdwValue);
+extern dsp_status cfg_get_dev_object(IN struct cfg_devnode *dev_node_obj,
+				     OUT u32 *pdwValue);
 
 /*
- *  ======== CFG_GetDSPResources ========
+ *  ======== cfg_get_dsp_resources ========
  *  Purpose:
  *      Get the DSP resources available to a given device.
  *  Parameters:
- *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
+ *      dev_node_obj:	Handle to the DEVNODE who's resources we are querying.
  *      pDSPResTable:   Ptr to a location to store the DSP resource table.
  *  Returns:
  *      DSP_SOK:                On success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The DSP Resource information is not
  *                              available
  *  Requires:
@@ -111,45 +112,43 @@
  *      DSP_SOK:    pDSPResTable points to a filled table of resources allocated
  *                  for the specified WMD.
  */
-	extern DSP_STATUS CFG_GetDSPResources(IN struct CFG_DEVNODE *hDevNode,
-				      OUT struct CFG_DSPRES *pDSPResTable);
-
+extern dsp_status cfg_get_dsp_resources(IN struct cfg_devnode *dev_node_obj,
+					OUT struct cfg_dspres *pDSPResTable);
 
 /*
- *  ======== CFG_GetExecFile ========
+ *  ======== cfg_get_exec_file ========
  *  Purpose:
  *      Retreive the default executable, if any, for this board.
  *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
+ *      dev_node_obj:       Handle to the dev_node who's WMD we are querying.
+ *      buf_size:       Size of buffer.
  *      pstrExecFile:   Ptr to character buf to hold ExecFile.
  *  Returns:
  *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_INVALIDPOINTER:   pstrExecFile is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
- *      DSP_SOK:    Not more than cBufSize bytes were copied into pstrExecFile,
+ *      DSP_SOK:    Not more than buf_size bytes were copied into pstrExecFile,
  *                  and *pstrExecFile contains default executable for this
  *                  devnode.
  */
-	extern DSP_STATUS CFG_GetExecFile(IN struct CFG_DEVNODE *hDevNode,
-					  IN u32 cBufSize,
-					  OUT char *pstrExecFile);
+extern dsp_status cfg_get_exec_file(IN struct cfg_devnode *dev_node_obj,
+				    IN u32 buf_size, OUT char *pstrExecFile);
 
 /*
- *  ======== CFG_GetHostResources ========
+ *  ======== cfg_get_host_resources ========
  *  Purpose:
  *      Get the Host PC allocated resources assigned to a given device.
  *  Parameters:
- *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
+ *      dev_node_obj:	Handle to the DEVNODE who's resources we are querying.
  *      pHostResTable:  Ptr to a location to store the host resource table.
  *  Returns:
  *      DSP_SOK:                On success.
  *      CFG_E_INVALIDPOINTER:   pHostResTable is invalid.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
  *  Requires:
  *      CFG initialized.
@@ -158,16 +157,16 @@
  *                  allocated for the specified WMD.
  *
  */
-	extern DSP_STATUS CFG_GetHostResources(IN struct CFG_DEVNODE *hDevNode,
-				       OUT struct CFG_HOSTRES *pHostResTable);
+extern dsp_status cfg_get_host_resources(IN struct cfg_devnode *dev_node_obj,
+					 OUT struct cfg_hostres *pHostResTable);
 
 /*
- *  ======== CFG_GetObject ========
+ *  ======== cfg_get_object ========
  *  Purpose:
  *      Retrieve the Driver Object handle From the Registry
  *  Parameters:
  *      pdwValue:   Ptr to location to store the value.
- *      dwType      Type of Object to Get
+ *      dw_type      Type of Object to Get
  *  Returns:
  *      DSP_SOK:    Success.
  *  Requires:
@@ -176,10 +175,10 @@
  *      DSP_SOK:    *pdwValue is set to the retrieved u32(non-Zero).
  *      else:       *pdwValue is set to 0L.
  */
-	extern DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType);
+extern dsp_status cfg_get_object(OUT u32 *pdwValue, u32 dw_type);
 
 /*
- *  ======== CFG_GetPerfValue ========
+ *  ======== cfg_get_perf_value ========
  *  Purpose:
  *      Retrieve a flag indicating whether PERF should log statistics for the
  *      PM class driver.
@@ -192,57 +191,56 @@
  *      pfEnablePerf != NULL;
  *  Ensures:
  */
-	extern void CFG_GetPerfValue(OUT bool *pfEnablePerf);
+extern void cfg_get_perf_value(OUT bool *pfEnablePerf);
 
 /*
- *  ======== CFG_GetWMDFileName ========
+ *  ======== cfg_get_wmd_file_name ========
  *  Purpose:
  *    Get the mini-driver file name for a given device.
  *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
+ *      dev_node_obj:       Handle to the dev_node who's WMD we are querying.
+ *      buf_size:       Size of buffer.
  *      pWMDFileName:   Ptr to a character buffer to hold the WMD filename.
  *  Returns:
  *      DSP_SOK:                On success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The filename is not available.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
- *      DSP_SOK:        Not more than cBufSize bytes were copied
+ *      DSP_SOK:        Not more than buf_size bytes were copied
  *                      into pWMDFileName.
  *
  */
-	extern DSP_STATUS CFG_GetWMDFileName(IN struct CFG_DEVNODE *hDevNode,
-					     IN u32 cBufSize,
-					     OUT char *pWMDFileName);
+extern dsp_status cfg_get_wmd_file_name(IN struct cfg_devnode *dev_node_obj,
+					IN u32 buf_size,
+					OUT char *pWMDFileName);
 
 /*
- *  ======== CFG_GetZLFile ========
+ *  ======== cfg_get_zl_file ========
  *  Purpose:
  *      Retreive the ZLFile, if any, for this board.
  *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
+ *      dev_node_obj:       Handle to the dev_node who's WMD we are querying.
+ *      buf_size:       Size of buffer.
  *      pstrZLFileName: Ptr to character buf to hold ZLFileName.
  *  Returns:
  *      DSP_SOK:                Success.
  *      CFG_E_INVALIDPOINTER:   pstrZLFileName is invalid.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: couldn't find the ZLFileName.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
- *      DSP_SOK:    Not more than cBufSize bytes were copied into
+ *      DSP_SOK:    Not more than buf_size bytes were copied into
  *                  pstrZLFileName, and *pstrZLFileName contains ZLFileName
  *                  for this devnode.
  */
-	extern DSP_STATUS CFG_GetZLFile(IN struct CFG_DEVNODE *hDevNode,
-					IN u32 cBufSize,
-					OUT char *pstrZLFileName);
+extern dsp_status cfg_get_zl_file(IN struct cfg_devnode *dev_node_obj,
+				  IN u32 buf_size, OUT char *pstrZLFileName);
 
 /*
- *  ======== CFG_Init ========
+ *  ======== cfg_init ========
  *  Purpose:
  *      Initialize the CFG module's private state.
  *  Parameters:
@@ -252,26 +250,26 @@
  *  Ensures:
  *      A requirement for each of the other public CFG functions.
  */
-	extern bool CFG_Init(void);
+extern bool cfg_init(void);
 
 /*
- *  ======== CFG_SetDevObject ========
+ *  ======== cfg_set_dev_object ========
  *  Purpose:
  *      Store the Device Object handle for a given devnode.
  *  Parameters:
- *      hDevNode:   Platform's DevNode handle we are storing value with.
+ *      dev_node_obj:   Platform's dev_node handle we are storing value with.
  *      dwValue:    Arbitrary value to store.
  *  Returns:
  *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      DSP_EFAIL:              Internal Error.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
  *      DSP_SOK:    The Private u32 was successfully set.
  */
-	extern DSP_STATUS CFG_SetDevObject(IN struct CFG_DEVNODE *hDevNode,
-					   IN u32 dwValue);
+extern dsp_status cfg_set_dev_object(IN struct cfg_devnode *dev_node_obj,
+				     IN u32 dwValue);
 
 /*
  *  ======== CFG_SetDrvObject ========
@@ -279,7 +277,7 @@
  *      Store the Driver Object handle.
  *  Parameters:
  *      dwValue:        Arbitrary value to store.
- *      dwType          Type of Object to Store
+ *      dw_type          Type of Object to Store
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Internal Error.
@@ -288,6 +286,6 @@
  *  Ensures:
  *      DSP_SOK:        The Private u32 was successfully set.
  */
-	extern DSP_STATUS CFG_SetObject(IN u32 dwValue, IN u32 dwType);
+extern dsp_status cfg_set_object(IN u32 dwValue, IN u32 dw_type);
 
-#endif				/* CFG_ */
+#endif /* CFG_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/cfgdefs.h b/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
index 9e204f4..bd24611 100644
--- a/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
@@ -25,7 +25,7 @@
 /* Maximum length of general paths. */
 #define CFG_MAXPATH             255
 
-/* Host Resources:  */
+/* Host Resources: */
 #define CFG_MAXMEMREGISTERS     9
 #define CFG_MAXIOPORTS          20
 #define CFG_MAXIRQS             7
@@ -39,54 +39,55 @@
 #define CFG_DEFAULT_NUM_WINDOWS 1	/* We support only one window. */
 
 /* A platform-related device handle: */
-	struct CFG_DEVNODE;
+struct cfg_devnode;
 
 /*
  *  Host resource structure.
  */
-	struct CFG_HOSTRES {
-		u32 wNumMemWindows;	/* Set to default */
-		/* This is the base.memory */
-		u32 dwMemBase[CFG_MAXMEMREGISTERS];  /* SHM virtual address */
-		u32 dwMemLength[CFG_MAXMEMREGISTERS]; /* Length of the Base */
-		u32 dwMemPhys[CFG_MAXMEMREGISTERS]; /* SHM Physical address */
-		u8 bIRQRegisters;	/* IRQ Number */
-		u8 bIRQAttrib;	/* IRQ Attribute */
-		u32 dwOffsetForMonitor;	/* The Shared memory starts from
-					 * dwMemBase + this offset */
+struct cfg_hostres {
+	u32 num_mem_windows;	/* Set to default */
+	/* This is the base.memory */
+	u32 dw_mem_base[CFG_MAXMEMREGISTERS];	/* shm virtual address */
+	u32 dw_mem_length[CFG_MAXMEMREGISTERS];	/* Length of the Base */
+	u32 dw_mem_phys[CFG_MAXMEMREGISTERS];	/* shm Physical address */
+	u8 birq_registers;	/* IRQ Number */
+	u8 birq_attrib;		/* IRQ Attribute */
+	u32 dw_offset_for_monitor;	/* The Shared memory starts from
+					 * dw_mem_base + this offset */
 	/*
 	 *  Info needed by NODE for allocating channels to communicate with RMS:
-	 *      dwChnlOffset:       Offset of RMS channels. Lower channels are
+	 *      dw_chnl_offset:       Offset of RMS channels. Lower channels are
 	 *                          reserved.
-	 *      dwChnlBufSize:      Size of channel buffer to send to RMS
-	 *      dwNumChnls:       Total number of channels (including reserved).
+	 *      dw_chnl_buf_size:      Size of channel buffer to send to RMS
+	 *      dw_num_chnls:		Total number of channels
+	 *      			(including reserved).
 	 */
-		u32 dwChnlOffset;
-		u32 dwChnlBufSize;
-		u32 dwNumChnls;
-		void __iomem *dwPrmBase;
-		void __iomem *dwCmBase;
-		void __iomem *dwPerBase;
-		u32 dwPerPmBase;
-		u32 dwCorePmBase;
-		void __iomem *dwWdTimerDspBase;
-		void __iomem *dwDmmuBase;
-		void __iomem *dwSysCtrlBase;
-	} ;
+	u32 dw_chnl_offset;
+	u32 dw_chnl_buf_size;
+	u32 dw_num_chnls;
+	void __iomem *dw_prm_base;
+	void __iomem *dw_cm_base;
+	void __iomem *dw_per_base;
+	u32 dw_per_pm_base;
+	u32 dw_core_pm_base;
+	void __iomem *dw_wd_timer_dsp_base;
+	void __iomem *dw_dmmu_base;
+	void __iomem *dw_sys_ctrl_base;
+};
 
-	struct CFG_DSPMEMDESC {
-		u32 uMemType;	/* Type of memory.                        */
-		u32 ulMin;	/* Minimum amount of memory of this type. */
-		u32 ulMax;	/* Maximum amount of memory of this type. */
-	} ;
+struct cfg_dspmemdesc {
+	u32 mem_type;		/* Type of memory. */
+	u32 ul_min;		/* Minimum amount of memory of this type. */
+	u32 ul_max;		/* Maximum amount of memory of this type. */
+};
 
-	struct CFG_DSPRES {
-		u32 uChipType;	/* DSP chip type.               */
-		u32 uWordSize;	/* Number of bytes in a word    */
-		u32 cChips;	/* Number of chips.             */
-		u32 cMemTypes;	/* Types of memory.             */
-		struct CFG_DSPMEMDESC aMemDesc[CFG_DSPMAXMEMTYPES];
-		/* DSP Memory types */
-	} ;
+struct cfg_dspres {
+	u32 chip_type;		/* DSP chip type. */
+	u32 word_size;		/* Number of bytes in a word */
+	u32 chip_number;	/* Number of chips. */
+	u32 mem_types;		/* Types of memory. */
+	struct cfg_dspmemdesc mem_desc[CFG_DSPMAXMEMTYPES];
+	/* DSP Memory types */
+};
 
-#endif				/* CFGDEFS_ */
+#endif /* CFGDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/chnl.h b/arch/arm/plat-omap/include/dspbridge/chnl.h
index 4a6e4d5..da9115b 100644
--- a/arch/arm/plat-omap/include/dspbridge/chnl.h
+++ b/arch/arm/plat-omap/include/dspbridge/chnl.h
@@ -25,100 +25,98 @@
 #include <dspbridge/chnlpriv.h>
 
 /*
- *  ======== CHNL_Close ========
+ *  ======== chnl_close ========
  *  Purpose:
  *      Ensures all pending I/O on this channel is cancelled, discards all
  *      queued I/O completion notifications, then frees the resources allocated
  *      for this channel, and makes the corresponding logical channel id
  *      available for subsequent use.
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *  Requires:
- *      CHNL_Init(void) called.
+ *      chnl_init(void) called.
  *      No thread must be blocked on this channel's I/O completion event.
  *  Ensures:
  *      DSP_SOK:        The I/O completion event for this channel is freed.
- *                      hChnl is no longer valid.
+ *                      chnl_obj is no longer valid.
  */
-	extern DSP_STATUS CHNL_Close(struct CHNL_OBJECT *hChnl);
-
+extern dsp_status chnl_close(struct chnl_object *chnl_obj);
 
 /*
- *  ======== CHNL_Create ========
+ *  ======== chnl_create ========
  *  Purpose:
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given board.
  *  Parameters:
  *      phChnlMgr:      Location to store a channel manager object on output.
- *      hDevObject:     Handle to a device object.
+ *      hdev_obj:     Handle to a device object.
  *      pMgrAttrs:      Channel manager attributes.
- *      pMgrAttrs->cChannels:   Max channels
- *      pMgrAttrs->bIRQ:        Channel's I/O IRQ number.
- *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->max_channels:   Max channels
+ *      pMgrAttrs->birq:        Channel's I/O IRQ number.
+ *      pMgrAttrs->irq_shared:     TRUE if the IRQ is shareable.
+ *      pMgrAttrs->word_size:   DSP Word size in equivalent PC bytes..
  *  Returns:
  *      DSP_SOK:                Success;
- *      DSP_EHANDLE:            hDevObject is invalid.
- *      DSP_EINVALIDARG:        cChannels is 0.
+ *      DSP_EHANDLE:            hdev_obj is invalid.
+ *      DSP_EINVALIDARG:        max_channels is 0.
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
  *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
  *      CHNL_E_MAXCHANNELS:     This manager cannot handle this many channels.
- *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
+ *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= birq <= 15.
  *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
  *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
  *      CHNL_E_MGREXISTS:       Channel manager already exists for this device.
  *  Requires:
- *      CHNL_Init(void) called.
+ *      chnl_init(void) called.
  *      phChnlMgr != NULL.
  *      pMgrAttrs != NULL.
  *  Ensures:
- *      DSP_SOK:                Subsequent calls to CHNL_Create() for the same
+ *      DSP_SOK:                Subsequent calls to chnl_create() for the same
  *                              board without an intervening call to
- *                              CHNL_Destroy() will fail.
+ *                              chnl_destroy() will fail.
  */
-	extern DSP_STATUS CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct CHNL_MGRATTRS *pMgrAttrs);
+extern dsp_status chnl_create(OUT struct chnl_mgr **phChnlMgr,
+			      struct dev_object *hdev_obj,
+			      IN CONST struct chnl_mgrattrs *pMgrAttrs);
 
 /*
- *  ======== CHNL_Destroy ========
+ *  ======== chnl_destroy ========
  *  Purpose:
  *      Close all open channels, and destroy the channel manager.
  *  Parameters:
- *      hChnlMgr:           Channel manager object.
+ *      hchnl_mgr:           Channel manager object.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        hChnlMgr was invalid.
+ *      DSP_EHANDLE:        hchnl_mgr was invalid.
  *  Requires:
- *      CHNL_Init(void) called.
+ *      chnl_init(void) called.
  *  Ensures:
  *      DSP_SOK:            Cancels I/O on each open channel.
  *                          Closes each open channel.
- *                          CHNL_Create may subsequently be called for the
+ *                          chnl_create may subsequently be called for the
  *                          same board.
  */
-	extern DSP_STATUS CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
+extern dsp_status chnl_destroy(struct chnl_mgr *hchnl_mgr);
 
 /*
- *  ======== CHNL_Exit ========
+ *  ======== chnl_exit ========
  *  Purpose:
  *      Discontinue usage of the CHNL module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      CHNL_Init(void) previously called.
+ *      chnl_init(void) previously called.
  *  Ensures:
- *      Resources, if any acquired in CHNL_Init(void), are freed when the last
- *      client of CHNL calls CHNL_Exit(void).
+ *      Resources, if any acquired in chnl_init(void), are freed when the last
+ *      client of CHNL calls chnl_exit(void).
  */
-	extern void CHNL_Exit(void);
-
+extern void chnl_exit(void);
 
 /*
- *  ======== CHNL_Init ========
+ *  ======== chnl_init ========
  *  Purpose:
  *      Initialize the CHNL module's private state.
  *  Parameters:
@@ -128,8 +126,6 @@
  *  Ensures:
  *      A requirement for each of the other public CHNL functions.
  */
-	extern bool CHNL_Init(void);
-
-
+extern bool chnl_init(void);
 
-#endif				/* CHNL_ */
+#endif /* CHNL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/chnldefs.h b/arch/arm/plat-omap/include/dspbridge/chnldefs.h
index 43df8b7..a12870e 100644
--- a/arch/arm/plat-omap/include/dspbridge/chnldefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/chnldefs.h
@@ -23,46 +23,45 @@
 #define CHNL_PICKFREE       (~0UL)	/* Let manager pick a free channel. */
 
 /* Channel manager limits: */
-#define CHNL_INITIOREQS      4	/* Default # of I/O requests.       */
+#define CHNL_INITIOREQS      4	/* Default # of I/O requests. */
 
 /* Channel modes */
-#define CHNL_MODETODSP       0x0000	/* Data streaming to the DSP.      */
-#define CHNL_MODEFROMDSP     0x0001	/* Data streaming from the DSP.    */
+#define CHNL_MODETODSP       0x0000	/* Data streaming to the DSP. */
+#define CHNL_MODEFROMDSP     0x0001	/* Data streaming from the DSP. */
 
 /* GetIOCompletion flags */
 #define CHNL_IOCINFINITE     0xffffffff	/* Wait forever for IO completion. */
-#define CHNL_IOCNOWAIT       0x0	/* Dequeue an IOC, if available.   */
+#define CHNL_IOCNOWAIT       0x0	/* Dequeue an IOC, if available. */
 
 /* IO Completion Record status: */
-#define CHNL_IOCSTATCOMPLETE 0x0000	/* IO Completed.             */
-#define CHNL_IOCSTATCANCEL   0x0002	/* IO was cancelled          */
-#define CHNL_IOCSTATTIMEOUT  0x0008	/* Wait for IOC timed out.   */
-#define CHNL_IOCSTATEOS      0x8000	/* End Of Stream reached.    */
+#define CHNL_IOCSTATCOMPLETE 0x0000	/* IO Completed. */
+#define CHNL_IOCSTATCANCEL   0x0002	/* IO was cancelled */
+#define CHNL_IOCSTATTIMEOUT  0x0008	/* Wait for IOC timed out. */
+#define CHNL_IOCSTATEOS      0x8000	/* End Of Stream reached. */
 
 /* Macros for checking I/O Completion status: */
-#define CHNL_IsEOS(ioc)         (ioc.status & CHNL_IOCSTATEOS)
-#define CHNL_IsIOComplete(ioc)  (!(ioc.status & ~CHNL_IOCSTATEOS))
-#define CHNL_IsIOCancelled(ioc) (ioc.status & CHNL_IOCSTATCANCEL)
-#define CHNL_IsTimedOut(ioc)    (ioc.status & CHNL_IOCSTATTIMEOUT)
-
+#define CHNL_IS_EOS(ioc)         (ioc.status & CHNL_IOCSTATEOS)
+#define CHNL_IS_IO_COMPLETE(ioc)  (!(ioc.status & ~CHNL_IOCSTATEOS))
+#define CHNL_IS_IO_CANCELLED(ioc) (ioc.status & CHNL_IOCSTATCANCEL)
+#define CHNL_IS_TIMED_OUT(ioc)    (ioc.status & CHNL_IOCSTATTIMEOUT)
 
 /* Channel attributes: */
-	struct CHNL_ATTRS {
-		u32 uIOReqs;	/* Max # of preallocated I/O requests.    */
-		HANDLE hEvent;	/* User supplied auto-reset event object. */
-		char *pstrEventName;	/* Ptr to name of user event object.  */
-		HANDLE hReserved1;	/* Reserved for future use.         */
-		u32 hReserved2;	/* Reserved for future use.        */
+struct chnl_attr {
+	u32 uio_reqs;		/* Max # of preallocated I/O requests. */
+	bhandle event_obj;	/* User supplied auto-reset event object. */
+	char *pstr_event_name;	/* Ptr to name of user event object. */
+	bhandle reserved1;	/* Reserved for future use. */
+	u32 reserved2;		/* Reserved for future use. */
 
-	};
+};
 
 /* I/O completion record: */
-	struct CHNL_IOC {
-		void *pBuf;	/* Buffer to be filled/emptied.           */
-		u32 cBytes;	/* Bytes transferred.                     */
-		u32 cBufSize;	/* Actual buffer size in bytes            */
-		u32 status;	/* Status of IO completion.               */
-		u32 dwArg;	/* User argument associated with pBuf.    */
-	} ;
+struct chnl_ioc {
+	void *pbuf;		/* Buffer to be filled/emptied. */
+	u32 byte_size;		/* Bytes transferred. */
+	u32 buf_size;		/* Actual buffer size in bytes */
+	u32 status;		/* Status of IO completion. */
+	u32 dw_arg;		/* User argument associated with pbuf. */
+};
 
-#endif				/* CHNLDEFS_ */
+#endif /* CHNLDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/chnlpriv.h b/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
index 2eadfa0..9fe7a74 100644
--- a/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
+++ b/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
@@ -30,7 +30,6 @@
 /* Channel manager limits: */
 #define CHNL_MAXCHANNELS    32	/* Max channels available per transport */
 
-
 /*
  *  Trans port channel Id definitions:(must match dsp-side).
  *
@@ -50,16 +49,16 @@
 #define CHNL_MODEMASK       0x1001
 
 /* Higher level channel states: */
-#define CHNL_STATEREADY     0x0000	/* Channel ready for I/O.    */
-#define CHNL_STATECANCEL    0x0001	/* I/O was cancelled.        */
-#define CHNL_STATEEOS       0x0002	/* End Of Stream reached.    */
+#define CHNL_STATEREADY     0x0000	/* Channel ready for I/O. */
+#define CHNL_STATECANCEL    0x0001	/* I/O was cancelled. */
+#define CHNL_STATEEOS       0x0002	/* End Of Stream reached. */
 
-/* Determine if user supplied an event for this channel:  */
-#define CHNL_IsUserEvent(mode)  (mode & CHNL_MODEUSEREVENT)
+/* Determine if user supplied an event for this channel: */
+#define CHNL_IS_USER_EVENT(mode)  (mode & CHNL_MODEUSEREVENT)
 
 /* Macros for checking mode: */
-#define CHNL_IsInput(mode)      (mode & CHNL_MODEFROMDSP)
-#define CHNL_IsOutput(mode)     (!CHNL_IsInput(mode))
+#define CHNL_IS_INPUT(mode)      (mode & CHNL_MODEFROMDSP)
+#define CHNL_IS_OUTPUT(mode)     (!CHNL_IS_INPUT(mode))
 
 /* Types of channel class libraries: */
 #define CHNL_TYPESM         1	/* Shared memory driver. */
@@ -71,39 +70,35 @@
 /* Max memory pages lockable in CHNL_PrepareBuffer() - change if needed */
 #define CHNL_MAXLOCKPAGES   64
 
-/* Channel info.  */
-	 struct CHNL_INFO {
-		struct CHNL_MGR *hChnlMgr;	/* Owning channel manager.   */
-		u32 dwID;	/* Channel ID.                            */
-		HANDLE hEvent;	/* Channel I/O completion event.          */
-		/*Abstraction of I/O completion event.*/
-		struct SYNC_OBJECT *hSyncEvent;
-		u32 dwMode;	/* Channel mode.                          */
-		u32 dwState;	/* Current channel state.                 */
-		u32 cPosition;	/* Total bytes transferred.        */
-		u32 cIOCs;	/* Number of IOCs in queue.               */
-		u32 cIOReqs;	/* Number of IO Requests in queue.        */
-		u32 hProcess;   /* Process owning this channel.     */
-		/*
-		 * Name of channel I/O completion event. Not required in Linux
-		 */
-		char szEventName[CHNL_MAXEVTNAMELEN + 1];
-	} ;
+/* Channel info. */
+struct chnl_info {
+	struct chnl_mgr *hchnl_mgr;	/* Owning channel manager. */
+	u32 cnhl_id;		/* Channel ID. */
+	bhandle event_obj;	/* Channel I/O completion event. */
+	/*Abstraction of I/O completion event. */
+	struct sync_object *sync_event;
+	u32 dw_mode;		/* Channel mode. */
+	u32 dw_state;		/* Current channel state. */
+	u32 bytes_tx;		/* Total bytes transferred. */
+	u32 cio_cs;		/* Number of IOCs in queue. */
+	u32 cio_reqs;		/* Number of IO Requests in queue. */
+	u32 process;		/* Process owning this channel. */
+};
 
 /* Channel manager info: */
-	struct CHNL_MGRINFO {
-		u32 dwType;	/* Type of channel class library.         */
-		/* Channel handle, given the channel id. */
-		struct CHNL_OBJECT *hChnl;
-		u32 cOpenChannels;	/* Number of open channels.     */
-		u32 cChannels;	/* total # of chnls supported */
-	} ;
+struct chnl_mgrinfo {
+	u32 dw_type;		/* Type of channel class library. */
+	/* Channel handle, given the channel id. */
+	struct chnl_object *chnl_obj;
+	u32 open_channels;	/* Number of open channels. */
+	u32 max_channels;	/* total # of chnls supported */
+};
 
 /* Channel Manager Attrs: */
-	struct CHNL_MGRATTRS {
-		/* Max number of channels this manager can use. */
-		u32 cChannels;
-		u32 uWordSize;	/* DSP Word size.                       */
-	} ;
+struct chnl_mgrattrs {
+	/* Max number of channels this manager can use. */
+	u32 max_channels;
+	u32 word_size;		/* DSP Word size. */
+};
 
-#endif				/* CHNLPRIV_ */
+#endif /* CHNLPRIV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/clk.h b/arch/arm/plat-omap/include/dspbridge/clk.h
index 08a647b..521a028 100644
--- a/arch/arm/plat-omap/include/dspbridge/clk.h
+++ b/arch/arm/plat-omap/include/dspbridge/clk.h
@@ -20,38 +20,38 @@
 #define _CLK_H
 
 	/* Generic TIMER object: */
-	struct TIMER_OBJECT;
-	enum SERVICES_ClkId {
-		SERVICESCLK_iva2_ck,
-		SERVICESCLK_gpt5_fck,
-		SERVICESCLK_gpt5_ick,
-		SERVICESCLK_gpt6_fck,
-		SERVICESCLK_gpt6_ick,
-		SERVICESCLK_gpt7_fck,
-		SERVICESCLK_gpt7_ick,
-		SERVICESCLK_gpt8_fck,
-		SERVICESCLK_gpt8_ick,
-		SERVICESCLK_wdt3_fck,
-		SERVICESCLK_wdt3_ick,
-		SERVICESCLK_mcbsp1_fck,
-		SERVICESCLK_mcbsp1_ick,
-		SERVICESCLK_mcbsp2_fck,
-		SERVICESCLK_mcbsp2_ick,
-		SERVICESCLK_mcbsp3_fck,
-		SERVICESCLK_mcbsp3_ick,
-		SERVICESCLK_mcbsp4_fck,
-		SERVICESCLK_mcbsp4_ick,
-		SERVICESCLK_mcbsp5_fck,
-		SERVICESCLK_mcbsp5_ick,
-		SERVICESCLK_ssi_fck,
-		SERVICESCLK_ssi_ick,
-		SERVICESCLK_sys_32k_ck,
-		SERVICESCLK_sys_ck,
-		SERVICESCLK_NOT_DEFINED
-	} ;
+struct timer_object;
+enum services_clk_id {
+	SERVICESCLK_IVA2_CK,
+	SERVICESCLK_GPT5_FCK,
+	SERVICESCLK_GPT5_ICK,
+	SERVICESCLK_GPT6_FCK,
+	SERVICESCLK_GPT6_ICK,
+	SERVICESCLK_GPT7_FCK,
+	SERVICESCLK_GPT7_ICK,
+	SERVICESCLK_GPT8_FCK,
+	SERVICESCLK_GPT8_ICK,
+	SERVICESCLK_WDT3_FCK,
+	SERVICESCLK_WDT3_ICK,
+	SERVICESCLK_MCBSP1_FCK,
+	SERVICESCLK_MCBSP1_ICK,
+	SERVICESCLK_MCBSP2_FCK,
+	SERVICESCLK_MCBSP2_ICK,
+	SERVICESCLK_MCBSP3_FCK,
+	SERVICESCLK_MCBSP3_ICK,
+	SERVICESCLK_MCBSP4_FCK,
+	SERVICESCLK_MCBSP4_ICK,
+	SERVICESCLK_MCBSP5_FCK,
+	SERVICESCLK_MCBSP5_ICK,
+	SERVICESCLK_SSI_FCK,
+	SERVICESCLK_SSI_ICK,
+	SERVICESCLK_SYS32K_CK,
+	SERVICESCLK_SYS_CK,
+	SERVICESCLK_NOT_DEFINED
+};
 
 /*
- *  ======== CLK_Exit ========
+ *  ======== clk_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -62,10 +62,10 @@
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void CLK_Exit(void);
+extern void clk_exit(void);
 
 /*
- *  ======== CLK_Init ========
+ *  ======== services_clk_init ========
  *  Purpose:
  *      Initializes private state of CLK module.
  *  Parameters:
@@ -75,11 +75,10 @@
  *  Ensures:
  *      CLK initialized.
  */
-	extern bool CLK_Init(void);
-
+extern bool services_clk_init(void);
 
 /*
- *  ======== CLK_Enable ========
+ *  ======== services_clk_enable ========
  *  Purpose:
  *      Enables the clock requested.
  *  Parameters:
@@ -89,10 +88,10 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id);
+extern dsp_status services_clk_enable(IN enum services_clk_id clk_id);
 
 /*
- *  ======== CLK_Disable ========
+ *  ======== services_clk_disable ========
  *  Purpose:
  *      Disables the clock requested.
  *  Parameters:
@@ -102,10 +101,10 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS CLK_Disable(IN enum SERVICES_ClkId clk_id);
+extern dsp_status services_clk_disable(IN enum services_clk_id clk_id);
 
 /*
- *  ======== CLK_GetRate ========
+ *  ======== services_clk_get_rate ========
  *  Purpose:
  *      Get the clock rate of requested clock.
  *  Parameters:
@@ -115,10 +114,10 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS CLK_GetRate(IN enum SERVICES_ClkId clk_id,
-				     u32 *speedMhz);
+extern dsp_status services_clk_get_rate(IN enum services_clk_id clk_id,
+					u32 *speedMhz);
 /*
- *  ======== CLK_Set_32KHz ========
+ *  ======== clk_set32k_hz ========
  *  Purpose:
  *      Set the requested clock to 32KHz.
  *  Parameters:
@@ -128,8 +127,8 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id);
-	extern void SSI_Clk_Prepare(bool FLAG);
+extern dsp_status clk_set32k_hz(IN enum services_clk_id clk_id);
+extern void ssi_clk_prepare(bool FLAG);
 
 /*
  *  ======== CLK_Get_RefCnt ========
@@ -142,6 +141,6 @@
  *  Requires:
  *  Ensures:
  */
-	extern s32 CLK_Get_UseCnt(IN enum SERVICES_ClkId clk_id);
+extern s32 clk_get_use_cnt(IN enum services_clk_id clk_id);
 
-#endif				/* _SYNC_H */
+#endif /* _SYNC_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/cmm.h b/arch/arm/plat-omap/include/dspbridge/cmm.h
index 31911b9..797323a 100644
--- a/arch/arm/plat-omap/include/dspbridge/cmm.h
+++ b/arch/arm/plat-omap/include/dspbridge/cmm.h
@@ -16,7 +16,7 @@
  * to/from the DSP address space.
  *
  * Notes:
- *   CMM_XlatorAllocBuf - Used by Node and Stream modules for SM address
+ *   cmm_xlator_alloc_buf - Used by Node and Stream modules for SM address
  *			  translation.
  *
  * Copyright (C) 2008 Texas Instruments, Inc.
@@ -39,38 +39,39 @@
 #include <dspbridge/host_os.h>
 
 /*
- *  ======== CMM_CallocBuf ========
+ *  ======== cmm_calloc_buf ========
  *  Purpose:
  *      Allocate memory buffers that can be used for data streaming or
  *      messaging.
  *  Parameters:
- *      hCmmMgr:   Cmm Mgr handle.
- *      uSize:     Number of bytes to allocate.
- *      pAttr:     Attributes of memory to allocate.
- *      ppBufVA:   Address of where to place VA.
+ *      hcmm_mgr:   Cmm Mgr handle.
+ *      usize:     Number of bytes to allocate.
+ *      pattr:     Attributes of memory to allocate.
+ *      pp_buf_va:   Address of where to place VA.
  *  Returns:
  *      Pointer to a zero'd block of SM memory;
  *      NULL if memory couldn't be allocated,
- *      or if cBytes == 0,
+ *      or if byte_size == 0,
  *  Requires:
- *      Valid hCmmMgr.
+ *      Valid hcmm_mgr.
  *      CMM initialized.
  *  Ensures:
  *      The returned pointer, if not NULL, points to a valid memory block of
  *      the size requested.
  *
  */
-	extern void *CMM_CallocBuf(struct CMM_OBJECT *hCmmMgr,
-				   u32 uSize, struct CMM_ATTRS *pAttrs,
-				   OUT void **ppBufVA);
+extern void *cmm_calloc_buf(struct cmm_object *hcmm_mgr,
+			    u32 usize, struct cmm_attrs *pattrs,
+			    OUT void **pp_buf_va);
 
 /*
- *  ======== CMM_Create ========
+ *  ======== cmm_create ========
  *  Purpose:
  *      Create a communication memory manager object.
  *  Parameters:
- *      phCmmMgr:   Location to store a communication manager handle on output.
- *      hDevObject: Handle to a device object.
+ *      ph_cmm_mgr:	Location to store a communication manager handle on
+ *      		output.
+ *      hdev_obj: Handle to a device object.
  *      pMgrAttrs:  Comm mem manager attributes.
  *  Returns:
  *      DSP_SOK:        Success;
@@ -78,22 +79,22 @@
  *      DSP_EFAIL:      Failed to initialize critical sect sync object.
  *
  *  Requires:
- *      CMM_Init(void) called.
- *      phCmmMgr != NULL.
- *      pMgrAttrs->ulMinBlockSize >= 4 bytes.
+ *      cmm_init(void) called.
+ *      ph_cmm_mgr != NULL.
+ *      pMgrAttrs->ul_min_block_size >= 4 bytes.
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     IN CONST struct CMM_MGRATTRS *pMgrAttrs);
+extern dsp_status cmm_create(OUT struct cmm_object **ph_cmm_mgr,
+			     struct dev_object *hdev_obj,
+			     IN CONST struct cmm_mgrattrs *pMgrAttrs);
 
 /*
- *  ======== CMM_Destroy ========
+ *  ======== cmm_destroy ========
  *  Purpose:
  *      Destroy the communication memory manager object.
  *  Parameters:
- *      hCmmMgr:   Cmm Mgr handle.
+ *      hcmm_mgr:   Cmm Mgr handle.
  *      bForce:    Force deallocation of all cmm memory immediately if set TRUE.
  *                 If FALSE, and outstanding allocations will return DSP_EFAIL
  *                 status.
@@ -103,14 +104,14 @@
  *      DSP_EHANDLE:    Unable to free CMM due to bad handle.
  *  Requires:
  *      CMM is initialized.
- *      hCmmMgr != NULL.
+ *      hcmm_mgr != NULL.
  *  Ensures:
  *      Memory resources used by Cmm Mgr are freed.
  */
-	extern DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce);
+extern dsp_status cmm_destroy(struct cmm_object *hcmm_mgr, bool bForce);
 
 /*
- *  ======== CMM_Exit ========
+ *  ======== cmm_exit ========
  *  Purpose:
  *     Discontinue usage of module. Cleanup CMM module if CMM cRef reaches zero.
  *  Parameters:
@@ -121,55 +122,56 @@
  *     CMM is initialized.
  *  Ensures:
  */
-	extern void CMM_Exit(void);
+extern void cmm_exit(void);
 
 /*
- *  ======== CMM_FreeBuf ========
+ *  ======== cmm_free_buf ========
  *  Purpose:
  *      Free the given buffer.
  *  Parameters:
- *      hCmmMgr:    Cmm Mgr handle.
- *      pBuf:       Pointer to memory allocated by CMM_CallocBuf().
- *      ulSegId:    SM segment Id used in CMM_Calloc() attrs.
+ *      hcmm_mgr:    Cmm Mgr handle.
+ *      pbuf:       Pointer to memory allocated by cmm_calloc_buf().
+ *      ul_seg_id:    SM segment Id used in CMM_Calloc() attrs.
  *                  Set to 0 to use default segment.
  *  Returns:
  *      DSP_SOK
  *      DSP_EFAIL
  *  Requires:
  *      CMM initialized.
- *      pBufPA != NULL
+ *      buf_pa != NULL
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT *hCmmMgr,
-				      void *pBufPA, u32 ulSegId);
+extern dsp_status cmm_free_buf(struct cmm_object *hcmm_mgr,
+			       void *buf_pa, u32 ul_seg_id);
 
 /*
- *  ======== CMM_GetHandle ========
+ *  ======== cmm_get_handle ========
  *  Purpose:
  *      Return the handle to the cmm mgr for the given device obj.
  *  Parameters:
- *      hProcessor:   Handle to a Processor.
- *      phCmmMgr:     Location to store the shared memory mgr handle on output.
+ *      hprocessor:   Handle to a Processor.
+ *      ph_cmm_mgr:	Location to store the shared memory mgr handle on
+ *      		output.
  *
  *  Returns:
  *      DSP_SOK:        Cmm Mgr opaque handle returned.
  *      DSP_EHANDLE:    Invalid handle.
  *  Requires:
- *      phCmmMgr != NULL
- *      hDevObject != NULL
+ *      ph_cmm_mgr != NULL
+ *      hdev_obj != NULL
  *  Ensures:
  */
-	extern DSP_STATUS CMM_GetHandle(void *hProcessor,
-					OUT struct CMM_OBJECT **phCmmMgr);
+extern dsp_status cmm_get_handle(void *hprocessor,
+				 OUT struct cmm_object **ph_cmm_mgr);
 
 /*
- *  ======== CMM_GetInfo ========
+ *  ======== cmm_get_info ========
  *  Purpose:
  *      Return the current SM and VM utilization information.
  *  Parameters:
- *      hCmmMgr:     Handle to a Cmm Mgr.
- *      pCmmInfo:    Location to store the Cmm information on output.
+ *      hcmm_mgr:     Handle to a Cmm Mgr.
+ *      cmm_info_obj:    Location to store the Cmm information on output.
  *
  *  Returns:
  *      DSP_SOK:        Success.
@@ -179,11 +181,11 @@
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_GetInfo(struct CMM_OBJECT *hCmmMgr,
-				      OUT struct CMM_INFO *pCmmInfo);
+extern dsp_status cmm_get_info(struct cmm_object *hcmm_mgr,
+			       OUT struct cmm_info *cmm_info_obj);
 
 /*
- *  ======== CMM_Init ========
+ *  ======== cmm_init ========
  *  Purpose:
  *      Initializes private state of CMM module.
  *  Parameters:
@@ -193,73 +195,72 @@
  *  Ensures:
  *      CMM initialized.
  */
-	extern bool CMM_Init(void);
+extern bool cmm_init(void);
 
 /*
- *  ======== CMM_RegisterGPPSMSeg ========
+ *  ======== cmm_register_gppsm_seg ========
  *  Purpose:
  *      Register a block of SM with the CMM.
  *  Parameters:
- *      hCmmMgr:         Handle to a Cmm Mgr.
+ *      hcmm_mgr:         Handle to a Cmm Mgr.
  *      lpGPPBasePA:     GPP Base Physical address.
- *      ulSize:          Size in GPP bytes.
+ *      ul_size:          Size in GPP bytes.
  *      dwDSPAddrOffset  GPP PA to DSP PA Offset.
- *      cFactor:         Add offset if CMM_ADDTODSPPA, sub if CMM_SUBFROMDSPPA.
- *      dwDSPBase:       DSP virtual base byte address.
- *      ulDSPSize:       Size of DSP segment in bytes.
+ *      c_factor:         Add offset if CMM_ADDTODSPPA, sub if CMM_SUBFROMDSPPA.
+ *      dw_dsp_base:       DSP virtual base byte address.
+ *      ul_dsp_size:       Size of DSP segment in bytes.
  *      pulSegId:        Address to store segment Id.
  *
  *  Returns:
  *      DSP_SOK:         Success.
- *      DSP_EHANDLE:     Invalid hCmmMgr handle.
+ *      DSP_EHANDLE:     Invalid hcmm_mgr handle.
  *      DSP_EINVALIDARG: Invalid input argument.
  *      DSP_EFAIL:       Unable to register.
  *      - On success *pulSegId is a valid SM segment ID.
  *  Requires:
- *      ulSize > 0
+ *      ul_size > 0
  *      pulSegId != NULL
- *      dwGPPBasePA != 0
- *      cFactor = CMM_ADDTODSPPA || cFactor = CMM_SUBFROMDSPPA
+ *      dw_gpp_base_pa != 0
+ *      c_factor = CMM_ADDTODSPPA || c_factor = CMM_SUBFROMDSPPA
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
-					       unsigned int dwGPPBasePA,
-					       u32 ulSize,
-					       u32 dwDSPAddrOffset,
-					       s8  cFactor,
-					       unsigned int dwDSPBase,
-					       u32 ulDSPSize,
-					       u32 *pulSegId,
-					       u32 dwGPPBaseBA);
+extern dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
+					 unsigned int dw_gpp_base_pa,
+					 u32 ul_size,
+					 u32 dwDSPAddrOffset,
+					 s8 c_factor,
+					 unsigned int dw_dsp_base,
+					 u32 ul_dsp_size,
+					 u32 *pulSegId, u32 dwGPPBaseBA);
 
 /*
- *  ======== CMM_UnRegisterGPPSMSeg ========
+ *  ======== cmm_un_register_gppsm_seg ========
  *  Purpose:
  *      Unregister the given memory segment that was previously registered
- *      by CMM_RegisterGPPSMSeg.
+ *      by cmm_register_gppsm_seg.
  *  Parameters:
- *      hCmmMgr:    Handle to a Cmm Mgr.
- *      ulSegId     Segment identifier returned by CMM_RegisterGPPSMSeg.
+ *      hcmm_mgr:    Handle to a Cmm Mgr.
+ *      ul_seg_id     Segment identifier returned by cmm_register_gppsm_seg.
  *  Returns:
  *       DSP_SOK:         Success.
  *       DSP_EHANDLE:     Invalid handle.
- *       DSP_EINVALIDARG: Invalid ulSegId.
+ *       DSP_EINVALIDARG: Invalid ul_seg_id.
  *       DSP_EFAIL:       Unable to unregister for unknown reason.
  *  Requires:
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
-						 u32 ulSegId);
+extern dsp_status cmm_un_register_gppsm_seg(struct cmm_object *hcmm_mgr,
+					    u32 ul_seg_id);
 
 /*
- *  ======== CMM_XlatorAllocBuf ========
+ *  ======== cmm_xlator_alloc_buf ========
  *  Purpose:
  *      Allocate the specified SM buffer and create a local memory descriptor.
  *      Place on the descriptor on the translator's HaQ (Host Alloc'd Queue).
  *  Parameters:
- *      hXlator:    Handle to a Xlator object.
+ *      xlator:    Handle to a Xlator object.
  *      pVaBuf:     Virtual address ptr(client context)
  *      uPaSize:    Size of SM memory to allocate.
  *  Returns:
@@ -270,18 +271,18 @@
  *  Ensures:
  *
  */
-	extern void *CMM_XlatorAllocBuf(struct CMM_XLATOROBJECT *hXlator,
-					void *pVaBuf, u32 uPaSize);
+extern void *cmm_xlator_alloc_buf(struct cmm_xlatorobject *xlator,
+				  void *pVaBuf, u32 uPaSize);
 
 /*
- *  ======== CMM_XlatorCreate ========
+ *  ======== cmm_xlator_create ========
  *  Purpose:
  *     Create a translator(xlator) object used for process specific Va<->Pa
  *     address translation. Node messaging and streams use this to perform
  *     inter-processor(GPP<->DSP) zero-copy data transfer.
  *  Parameters:
  *     phXlator:       Address to place handle to a new Xlator handle.
- *     hCmmMgr:        Handle to Cmm Mgr associated with this translator.
+ *     hcmm_mgr:        Handle to Cmm Mgr associated with this translator.
  *     pXlatorAttrs:   Translator attributes used for the client NODE or STREAM.
  *  Returns:
  *     DSP_SOK:            Success.
@@ -289,41 +290,41 @@
  *     DSP_EMEMORY:   Insufficient memory(local) for requested resources.
  *  Requires:
  *     phXlator != NULL
- *     hCmmMgr != NULL
+ *     hcmm_mgr != NULL
  *     pXlatorAttrs != NULL
  *  Ensures:
  *
  */
-      extern DSP_STATUS CMM_XlatorCreate(OUT struct CMM_XLATOROBJECT **phXlator,
-					 struct CMM_OBJECT *hCmmMgr,
-					 struct CMM_XLATORATTRS *pXlatorAttrs);
+extern dsp_status cmm_xlator_create(OUT struct cmm_xlatorobject **phXlator,
+				    struct cmm_object *hcmm_mgr,
+				    struct cmm_xlatorattrs *pXlatorAttrs);
 
 /*
- *  ======== CMM_XlatorDelete ========
+ *  ======== cmm_xlator_delete ========
  *  Purpose:
  *      Delete translator resources
  *  Parameters:
- *      hXlator:    handle to translator.
+ *      xlator:    handle to translator.
  *      bForce:     bForce = TRUE will free XLators SM buffers/dscriptrs.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Bad translator handle.
  *      DSP_EFAIL:      Unable to free translator resources.
  *  Requires:
- *      cRefs > 0
+ *      refs > 0
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_XlatorDelete(struct CMM_XLATOROBJECT *hXlator,
-					   bool bForce);
+extern dsp_status cmm_xlator_delete(struct cmm_xlatorobject *xlator,
+				    bool bForce);
 
 /*
- *  ======== CMM_XlatorFreeBuf ========
+ *  ======== cmm_xlator_free_buf ========
  *  Purpose:
  *      Free SM buffer and descriptor.
  *      Does not free client process VM.
  *  Parameters:
- *      hXlator:    handle to translator.
+ *      xlator:    handle to translator.
  *      pBufVa      Virtual address of PA to free.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -332,55 +333,54 @@
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator,
-					    void *pBufVa);
+extern dsp_status cmm_xlator_free_buf(struct cmm_xlatorobject *xlator,
+				      void *pBufVa);
 
 /*
- *  ======== CMM_XlatorInfo ========
+ *  ======== cmm_xlator_info ========
  *  Purpose:
  *      Set/Get process specific "translator" address info.
  *      This is used to perform fast virtaul address translation
  *      for shared memory buffers between the GPP and DSP.
  *  Parameters:
- *     hXlator:     handle to translator.
- *     pAddr:       Virtual base address of segment.
- *     ulSize:      Size in bytes.
+ *     xlator:     handle to translator.
+ *     paddr:       Virtual base address of segment.
+ *     ul_size:      Size in bytes.
  *     uSegId:      Segment identifier of SM segment(s)
- *     bSetInfo     Set xlator fields if TRUE, else return base addr
+ *     set_info     Set xlator fields if TRUE, else return base addr
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Bad translator handle.
  *  Requires:
- *      (cRefs > 0)
- *      (pAddr != NULL)
- *      (ulSize > 0)
+ *      (refs > 0)
+ *      (paddr != NULL)
+ *      (ul_size > 0)
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator,
-					 IN OUT u8 **pAddr,
-					 u32 ulSize, u32 uSegId,
-					 bool bSetInfo);
+extern dsp_status cmm_xlator_info(struct cmm_xlatorobject *xlator,
+				  IN OUT u8 **paddr,
+				  u32 ul_size, u32 uSegId, bool set_info);
 
 /*
- *  ======== CMM_XlatorTranslate ========
+ *  ======== cmm_xlator_translate ========
  *  Purpose:
  *      Perform address translation VA<->PA for the specified stream or
  *      message shared memory buffer.
  *  Parameters:
- *     hXlator: handle to translator.
- *     pAddr    address of buffer to translate.
+ *     xlator: handle to translator.
+ *     paddr    address of buffer to translate.
  *     xType    Type of address xlation. CMM_PA2VA or CMM_VA2PA.
  *  Returns:
  *     Valid address on success, else NULL.
  *  Requires:
- *      cRefs > 0
- *      pAddr != NULL
+ *      refs > 0
+ *      paddr != NULL
  *      xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA)
  *  Ensures:
  *
  */
-	extern void *CMM_XlatorTranslate(struct CMM_XLATOROBJECT *hXlator,
-					 void *pAddr, enum CMM_XLATETYPE xType);
+extern void *cmm_xlator_translate(struct cmm_xlatorobject *xlator,
+				  void *paddr, enum cmm_xlatetype xType);
 
-#endif				/* CMM_ */
+#endif /* CMM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/cmmdefs.h b/arch/arm/plat-omap/include/dspbridge/cmmdefs.h
index c6eb6dd..fbff372 100644
--- a/arch/arm/plat-omap/include/dspbridge/cmmdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/cmmdefs.h
@@ -21,23 +21,23 @@
 
 #include <dspbridge/list.h>
 
-/* Cmm attributes used in CMM_Create() */
-	struct CMM_MGRATTRS {
-		/* Minimum SM allocation; default 32 bytes.  */
-		u32 ulMinBlockSize;
-	} ;
+/* Cmm attributes used in cmm_create() */
+struct cmm_mgrattrs {
+	/* Minimum SM allocation; default 32 bytes. */
+	u32 ul_min_block_size;
+};
 
 /* Attributes for CMM_AllocBuf() & CMM_AllocDesc() */
-	struct CMM_ATTRS {
-		u32 ulSegId;	/*  1,2... are SM segments. 0 is not. */
-		u32 ulAlignment;	/*  0,1,2,4....ulMinBlockSize */
-	} ;
+struct cmm_attrs {
+	u32 ul_seg_id;		/*  1,2... are SM segments. 0 is not. */
+	u32 ul_alignment;	/*  0,1,2,4....ul_min_block_size */
+};
 
 /*
  *  DSPPa to GPPPa Conversion Factor.
  *
  *  For typical platforms:
- *      converted Address = PaDSP + ( cFactor * addressToConvert).
+ *      converted Address = PaDSP + ( c_factor * addressToConvert).
  */
 #define CMM_SUBFROMDSPPA	-1
 #define CMM_ADDTODSPPA		1
@@ -51,55 +51,55 @@
  *  This info is used by the GPP to xlate DSP allocated PAs.
  */
 
-	struct CMM_SEGINFO {
-		u32 dwSegBasePa;	/* Start Phys address of SM segment */
-		/* Total size in bytes of segment: DSP+GPP */
-		u32 ulTotalSegSize;
-		u32 dwGPPBasePA;	/* Start Phys addr of Gpp SM seg */
-		u32 ulGPPSize;	/* Size of Gpp SM seg in bytes */
-		u32 dwDSPBaseVA;	/* DSP virt base byte address */
-		u32 ulDSPSize;	/* DSP seg size in bytes */
-		/* # of current GPP allocations from this segment */
-		u32 ulInUseCnt;
-		u32 dwSegBaseVa;	/* Start Virt address of SM seg */
+struct cmm_seginfo {
+	u32 dw_seg_base_pa;	/* Start Phys address of SM segment */
+	/* Total size in bytes of segment: DSP+GPP */
+	u32 ul_total_seg_size;
+	u32 dw_gpp_base_pa;	/* Start Phys addr of Gpp SM seg */
+	u32 ul_gpp_size;	/* Size of Gpp SM seg in bytes */
+	u32 dw_dsp_base_va;	/* DSP virt base byte address */
+	u32 ul_dsp_size;	/* DSP seg size in bytes */
+	/* # of current GPP allocations from this segment */
+	u32 ul_in_use_cnt;
+	u32 dw_seg_base_va;	/* Start Virt address of SM seg */
 
-	} ;
+};
 
 /* CMM useful information */
-	struct CMM_INFO {
-		/* # of SM segments registered with this Cmm. */
-		u32 ulNumGPPSMSegs;
-		/* Total # of allocations outstanding for CMM */
-		u32 ulTotalInUseCnt;
-		/* Min SM block size allocation from CMM_Create() */
-		u32 ulMinBlockSize;
-		/* Info per registered SM segment. */
-		struct CMM_SEGINFO segInfo[CMM_MAXGPPSEGS];
-	} ;
+struct cmm_info {
+	/* # of SM segments registered with this Cmm. */
+	u32 ul_num_gppsm_segs;
+	/* Total # of allocations outstanding for CMM */
+	u32 ul_total_in_use_cnt;
+	/* Min SM block size allocation from cmm_create() */
+	u32 ul_min_block_size;
+	/* Info per registered SM segment. */
+	struct cmm_seginfo seg_info[CMM_MAXGPPSEGS];
+};
 
 /* XlatorCreate attributes */
-	struct CMM_XLATORATTRS {
-		u32 ulSegId;	/* segment Id used for SM allocations */
-		u32 dwDSPBufs;	/* # of DSP-side bufs */
-		u32 dwDSPBufSize;	/* size of DSP-side bufs in GPP bytes */
-		/* Vm base address alloc'd in client process context */
-		void *pVmBase;
-		/* dwVmSize must be >= (dwMaxNumBufs * dwMaxSize) */
-		u32 dwVmSize;
-	} ;
+struct cmm_xlatorattrs {
+	u32 ul_seg_id;		/* segment Id used for SM allocations */
+	u32 dw_dsp_bufs;	/* # of DSP-side bufs */
+	u32 dw_dsp_buf_size;	/* size of DSP-side bufs in GPP bytes */
+	/* Vm base address alloc'd in client process context */
+	void *vm_base;
+	/* dw_vm_size must be >= (dwMaxNumBufs * dwMaxSize) */
+	u32 dw_vm_size;
+};
 
 /*
  * Cmm translation types. Use to map SM addresses to process context.
  */
-	enum CMM_XLATETYPE {
-		CMM_VA2PA = 0,	/* Virtual to GPP physical address xlation */
-		CMM_PA2VA = 1,	/* GPP Physical to virtual  */
-		CMM_VA2DSPPA = 2,	/* Va to DSP Pa  */
-		CMM_PA2DSPPA = 3,	/* GPP Pa to DSP Pa */
-		CMM_DSPPA2PA = 4,	/* DSP Pa to GPP Pa */
-	} ;
+enum cmm_xlatetype {
+	CMM_VA2PA = 0,		/* Virtual to GPP physical address xlation */
+	CMM_PA2VA = 1,		/* GPP Physical to virtual */
+	CMM_VA2DSPPA = 2,	/* Va to DSP Pa */
+	CMM_PA2DSPPA = 3,	/* GPP Pa to DSP Pa */
+	CMM_DSPPA2PA = 4,	/* DSP Pa to GPP Pa */
+};
 
-	struct CMM_OBJECT;
-	struct CMM_XLATOROBJECT;
+struct cmm_object;
+struct cmm_xlatorobject;
 
-#endif				/* CMMDEFS_ */
+#endif /* CMMDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/cod.h b/arch/arm/plat-omap/include/dspbridge/cod.h
index b2f82fd..3d76a6b 100644
--- a/arch/arm/plat-omap/include/dspbridge/cod.h
+++ b/arch/arm/plat-omap/include/dspbridge/cod.h
@@ -33,35 +33,33 @@
 #define COD_NOLOAD              DBLL_NOLOAD
 #define COD_SYMB                DBLL_SYMB
 
-/* Flags passed to COD_Open */
-	typedef DBLL_Flags COD_FLAGS;
+/* Flags passed to cod_open */
+typedef dbll_flags cod_flags;
 
 /* COD code manager handle */
-	struct COD_MANAGER;
+struct cod_manager;
 
 /* COD library handle */
-	struct COD_LIBRARYOBJ;
+struct cod_libraryobj;
 
 /* COD attributes */
-	 struct COD_ATTRS {
-		u32 ulReserved;
-	} ;
+struct cod_attrs {
+	u32 ul_reserved;
+};
 
 /*
  *  Function prototypes for writing memory to a DSP system, allocating
  *  and freeing DSP memory.
  */
-       typedef u32(*COD_WRITEFXN) (void *pPrivRef, u32 ulDspAddr,
-					     void *pBuf, u32 ulNumBytes,
-					     u32 nMemSpace);
-
+typedef u32(*cod_writefxn) (void *priv_ref, u32 ulDspAddr,
+			    void *pbuf, u32 ul_num_bytes, u32 nMemSpace);
 
 /*
- *  ======== COD_Close ========
+ *  ======== cod_close ========
  *  Purpose:
- *      Close a library opened with COD_Open().
+ *      Close a library opened with cod_open().
  *  Parameters:
- *      lib             - Library handle returned by COD_Open().
+ *      lib             - Library handle returned by cod_open().
  *  Returns:
  *      None.
  *  Requires:
@@ -70,16 +68,16 @@
  *  Ensures:
  *
  */
-       extern void COD_Close(struct COD_LIBRARYOBJ *lib);
+extern void cod_close(struct cod_libraryobj *lib);
 
 /*
- *  ======== COD_Create ========
+ *  ======== cod_create ========
  *  Purpose:
  *      Create an object to manage code on a DSP system. This object can be
  *      used to load an initial program image with arguments that can later
  *      be expanded with dynamically loaded object files.
  *      Symbol table information is managed by this object and can be retrieved
- *      using the COD_GetSymValue() function.
+ *      using the cod_get_sym_value() function.
  *  Parameters:
  *      phManager:      created manager object
  *      pstrZLFile:     ZL DLL filename, of length < COD_MAXPATHLENGTH.
@@ -96,27 +94,27 @@
  *      pstrZLFile != NULL
  *  Ensures:
  */
-       extern DSP_STATUS COD_Create(OUT struct COD_MANAGER **phManager,
-				    char *pstrZLFile,
-				    IN OPTIONAL CONST struct COD_ATTRS *attrs);
+extern dsp_status cod_create(OUT struct cod_manager **phManager,
+			     char *pstrZLFile,
+			     IN OPTIONAL CONST struct cod_attrs *attrs);
 
 /*
- *  ======== COD_Delete ========
+ *  ======== cod_delete ========
  *  Purpose:
  *      Delete a code manager object.
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *  Returns:
  *      None.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *  Ensures:
  */
-       extern void COD_Delete(struct COD_MANAGER *hManager);
+extern void cod_delete(struct cod_manager *cod_mgr_obj);
 
 /*
- *  ======== COD_Exit ========
+ *  ======== cod_exit ========
  *  Purpose:
  *      Discontinue usage of the COD module.
  *  Parameters:
@@ -126,91 +124,91 @@
  *  Requires:
  *      COD initialized.
  *  Ensures:
- *      Resources acquired in COD_Init(void) are freed.
+ *      Resources acquired in cod_init(void) are freed.
  */
-       extern void COD_Exit(void);
+extern void cod_exit(void);
 
 /*
- *  ======== COD_GetBaseLib ========
+ *  ======== cod_get_base_lib ========
  *  Purpose:
  *      Get handle to the base image DBL library.
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *      plib:       location to store library handle on output.
  *  Returns:
  *      DSP_SOK:    Success.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      plib != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetBaseLib(struct COD_MANAGER *hManager,
-					       struct DBLL_LibraryObj **plib);
+extern dsp_status cod_get_base_lib(struct cod_manager *cod_mgr_obj,
+				   struct dbll_library_obj **plib);
 
 /*
- *  ======== COD_GetBaseName ========
+ *  ======== cod_get_base_name ========
  *  Purpose:
  *      Get the name of the base image DBL library.
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *      pszName:    location to store library name on output.
- *      uSize:       size of name buffer.
+ *      usize:       size of name buffer.
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  Buffer too small.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      pszName != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager,
-						char *pszName, u32 uSize);
+extern dsp_status cod_get_base_name(struct cod_manager *cod_mgr_obj,
+				    char *pszName, u32 usize);
 
 /*
- *  ======== COD_GetEntry ========
+ *  ======== cod_get_entry ========
  *  Purpose:
  *      Retrieve the entry point of a loaded DSP program image
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *      pulEntry:   pointer to location for entry point
  *  Returns:
  *      DSP_SOK:       Success.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      pulEntry != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetEntry(struct COD_MANAGER *hManager,
-					     u32 *pulEntry);
+extern dsp_status cod_get_entry(struct cod_manager *cod_mgr_obj,
+				u32 *pulEntry);
 
 /*
- *  ======== COD_GetLoader ========
+ *  ======== cod_get_loader ========
  *  Purpose:
  *      Get handle to the DBL loader.
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *      phLoader:   location to store loader handle on output.
  *  Returns:
  *      DSP_SOK:    Success.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      phLoader != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
-					      struct DBLL_TarObj **phLoader);
+extern dsp_status cod_get_loader(struct cod_manager *cod_mgr_obj,
+				 struct dbll_tar_obj **phLoader);
 
 /*
- *  ======== COD_GetSection ========
+ *  ======== cod_get_section ========
  *  Purpose:
  *      Retrieve the starting address and length of a section in the COFF file
  *      given the section name.
  *  Parameters:
- *      lib         Library handle returned from COD_Open().
+ *      lib         Library handle returned from cod_open().
  *      pstrSect:   name of the section, with or without leading "."
  *      puAddr:     Location to store address.
  *      puLen:      Location to store length.
@@ -220,7 +218,7 @@
  *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      pstrSect != NULL;
  *      puAddr != NULL;
  *      puLen != NULL;
@@ -230,19 +228,18 @@
  *      else:  *puAddr == 0 and *puLen == 0;
  *
  */
-       extern DSP_STATUS COD_GetSection(struct COD_LIBRARYOBJ *lib,
-					       IN char *pstrSect,
-					       OUT u32 *puAddr,
-					       OUT u32 *puLen);
+extern dsp_status cod_get_section(struct cod_libraryobj *lib,
+				  IN char *pstrSect,
+				  OUT u32 *puAddr, OUT u32 *puLen);
 
 /*
- *  ======== COD_GetSymValue ========
+ *  ======== cod_get_sym_value ========
  *  Purpose:
  *      Retrieve the value for the specified symbol. The symbol is first
  *      searched for literally and then, if not found, searched for as a
  *      C symbol.
  *  Parameters:
- *      lib:        library handle returned from COD_Open().
+ *      lib:        library handle returned from cod_open().
  *      pstrSymbol: name of the symbol
  *      value:      value of the symbol
  *  Returns:
@@ -251,17 +248,16 @@
  *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
  *  Requires:
  *      COD module initialized.
- *      Valid hManager.
+ *      Valid cod_mgr_obj.
  *      pstrSym != NULL.
- *      pulValue != NULL.
+ *      pul_value != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetSymValue(struct COD_MANAGER *hManager,
-						IN char *pstrSym,
-						OUT u32 *pulValue);
+extern dsp_status cod_get_sym_value(struct cod_manager *cod_mgr_obj,
+				    IN char *pstrSym, OUT u32 * pul_value);
 
 /*
- *  ======== COD_Init ========
+ *  ======== cod_init ========
  *  Purpose:
  *      Initialize the COD module's private state.
  *  Parameters:
@@ -272,21 +268,21 @@
  *  Ensures:
  *      A requirement for each of the other public COD functions.
  */
-       extern bool COD_Init(void);
+extern bool cod_init(void);
 
 /*
- *  ======== COD_LoadBase ========
+ *  ======== cod_load_base ========
  *  Purpose:
  *      Load the initial program image, optionally with command-line arguments,
  *      on the DSP system managed by the supplied handle. The program to be
  *      loaded must be the first element of the args array and must be a fully
  *      qualified pathname.
  *  Parameters:
- *      hMgr:       manager to load the code with
+ *      hmgr:       manager to load the code with
  *      nArgc:      number of arguments in the args array
  *      args:       array of strings for arguments to DSP program
- *      writeFxn:   board-specific function to write data to DSP system
- *      pArb:       arbitrary pointer to be passed as first arg to writeFxn
+ *      write_fxn:   board-specific function to write data to DSP system
+ *      pArb:       arbitrary pointer to be passed as first arg to write_fxn
  *      envp:       array of environment strings for DSP exec.
  *  Returns:
  *      DSP_SOK:                   Success.
@@ -294,51 +290,49 @@
  *      COD_E_LOADFAILED:       Failed to load code onto target.
  *  Requires:
  *      COD module initialized.
- *      hMgr is valid.
+ *      hmgr is valid.
  *      nArgc > 0.
  *      aArgs != NULL.
  *      aArgs[0] != NULL.
- *      pfnWrite != NULL.
+ *      pfn_write != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_LoadBase(struct COD_MANAGER *hManager,
-					     u32 nArgc, char *aArgs[],
-					     COD_WRITEFXN pfnWrite, void *pArb,
-					     char *envp[]);
-
+extern dsp_status cod_load_base(struct cod_manager *cod_mgr_obj,
+				u32 nArgc, char *aArgs[],
+				cod_writefxn pfn_write, void *pArb,
+				char *envp[]);
 
 /*
- *  ======== COD_Open ========
+ *  ======== cod_open ========
  *  Purpose:
  *      Open a library for reading sections. Does not load or set the base.
  *  Parameters:
- *      hMgr:           manager to load the code with
+ *      hmgr:           manager to load the code with
  *      pszCoffPath:    Coff file to open.
  *      flags:          COD_NOLOAD (don't load symbols) or COD_SYMB (load
  *                      symbols).
- *      pLib:           Handle returned that can be used in calls to COD_Close
- *                      and COD_GetSection.
+ *      pLib:           Handle returned that can be used in calls to cod_close
+ *                      and cod_get_section.
  *  Returns:
  *      S_OK:                   Success.
  *      COD_E_OPENFAILED:       Failed to open target code.
  *  Requires:
  *      COD module initialized.
- *      hMgr is valid.
+ *      hmgr is valid.
  *      flags == COD_NOLOAD || flags == COD_SYMB.
  *      pszCoffPath != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS COD_Open(struct COD_MANAGER *hMgr,
-				   IN char *pszCoffPath,
-				   COD_FLAGS flags,
-				   OUT struct COD_LIBRARYOBJ **pLib);
+extern dsp_status cod_open(struct cod_manager *hmgr,
+			   IN char *pszCoffPath,
+			   cod_flags flags, OUT struct cod_libraryobj **pLib);
 
 /*
- *  ======== COD_OpenBase ========
+ *  ======== cod_open_base ========
  *  Purpose:
  *      Open base image for reading sections. Does not load the base.
  *  Parameters:
- *      hMgr:           manager to load the code with
+ *      hmgr:           manager to load the code with
  *      pszCoffPath:    Coff file to open.
  *      flags:          Specifies whether to load symbols.
  *  Returns:
@@ -346,19 +340,19 @@
  *      COD_E_OPENFAILED:   Failed to open target code.
  *  Requires:
  *      COD module initialized.
- *      hMgr is valid.
+ *      hmgr is valid.
  *      pszCoffPath != NULL.
  *  Ensures:
  */
-extern DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
-				       DBLL_Flags flags);
+extern dsp_status cod_open_base(struct cod_manager *hmgr, IN char *pszCoffPath,
+				dbll_flags flags);
 
 /*
- *  ======== COD_ReadSection ========
+ *  ======== cod_read_section ========
  *  Purpose:
  *      Retrieve the content of a code section given the section name.
  *  Parameters:
- *      hManager    - manager in which to search for the symbol
+ *      cod_mgr_obj    - manager in which to search for the symbol
  *      pstrSect    - name of the section, with or without leading "."
  *      pstrContent - buffer to store content of the section.
  *  Returns:
@@ -367,17 +361,14 @@ extern DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
  *      COD_E_READFAILED: Failed to read content of code section.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      pstrSect != NULL;
  *      pstrContent != NULL;
  *  Ensures:
  *      DSP_SOK:  *pstrContent stores the content of the named section.
  */
-       extern DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib,
-						IN char *pstrSect,
-						OUT char *pstrContent,
-						IN u32 cContentSize);
-
-
+extern dsp_status cod_read_section(struct cod_libraryobj *lib,
+				   IN char *pstrSect,
+				   OUT char *pstrContent, IN u32 cContentSize);
 
-#endif				/* COD_ */
+#endif /* COD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbc.h b/arch/arm/plat-omap/include/dspbridge/dbc.h
index b02b268..193c16d 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbc.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbc.h
@@ -28,21 +28,21 @@
 /* Assertion Macros: */
 #ifdef CONFIG_BRIDGE_DEBUG
 
-#define DBC_Assert(exp) 						       \
+#define DBC_ASSERT(exp) 						       \
 do {									       \
 	if (!(exp))							       \
 		pr_err("%s, line %d: Assertion (" #exp ") failed.\n", \
 		__FILE__, __LINE__);					       \
 } while (0)
-#define DBC_Require DBC_Assert	/* Function Precondition.  */
-#define DBC_Ensure  DBC_Assert	/* Function Postcondition. */
+#define DBC_REQUIRE DBC_ASSERT	/* Function Precondition.  */
+#define DBC_ENSURE  DBC_ASSERT	/* Function Postcondition. */
 
 #else
 
-#define DBC_Assert(exp) {}
-#define DBC_Require(exp) {}
-#define DBC_Ensure(exp) {}
+#define DBC_ASSERT(exp) {}
+#define DBC_REQUIRE(exp) {}
+#define DBC_ENSURE(exp) {}
 
-#endif				/* DEBUG */
+#endif /* DEBUG */
 
-#endif				/* DBC_ */
+#endif /* DBC_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdcd.h b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
index 5939058..c782c8d 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdcd.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
@@ -24,12 +24,12 @@
 #include <dspbridge/nldrdefs.h>
 
 /*
- *  ======== DCD_AutoRegister ========
+ *  ======== dcd_auto_register ========
  *  Purpose:
  *      This function automatically registers DCD objects specified in a
  *      special COFF section called ".dcd_register"
  *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
+ *      hdcd_mgr:                A DCD manager handle.
  *      pszCoffPath:            Pointer to name of COFF file containing DCD
  *                              objects to be registered.
  *  Returns:
@@ -46,16 +46,16 @@
  *      COFF file to contain the right COFF sections, especially
  *      ".dcd_register", which is used for auto registration.
  */
-	extern DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
-					   IN char *pszCoffPath);
+extern dsp_status dcd_auto_register(IN struct dcd_manager *hdcd_mgr,
+				    IN char *pszCoffPath);
 
 /*
- *  ======== DCD_AutoUnregister ========
+ *  ======== dcd_auto_unregister ========
  *  Purpose:
  *      This function automatically unregisters DCD objects specified in a
  *      special COFF section called ".dcd_register"
  *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
+ *      hdcd_mgr:                A DCD manager handle.
  *      pszCoffPath:            Pointer to name of COFF file containing
  *                              DCD objects to be unregistered.
  *  Returns:
@@ -72,11 +72,11 @@
  *      COFF file to contain the right COFF sections, especially
  *      ".dcd_register", which is used for auto unregistration.
  */
-	extern DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
-					     IN char *pszCoffPath);
+extern dsp_status dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
+				      IN char *pszCoffPath);
 
 /*
- *  ======== DCD_CreateManager ========
+ *  ======== dcd_create_manager ========
  *  Purpose:
  *      This function creates a DCD module manager.
  *  Parameters:
@@ -93,15 +93,15 @@
  *  Ensures:
  *      A DCD manager handle is created.
  */
-	extern DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
-					    OUT struct DCD_MANAGER **phDcdMgr);
+extern dsp_status dcd_create_manager(IN char *pszZlDllName,
+				     OUT struct dcd_manager **phDcdMgr);
 
 /*
- *  ======== DCD_DestroyManager ========
+ *  ======== dcd_destroy_manager ========
  *  Purpose:
  *      This function destroys a DCD module manager.
  *  Parameters:
- *      hDcdMgr:        A DCD manager handle.
+ *      hdcd_mgr:        A DCD manager handle.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid DCD manager handle.
@@ -109,35 +109,35 @@
  *      DCD initialized.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr);
+extern dsp_status dcd_destroy_manager(IN struct dcd_manager *hdcd_mgr);
 
 /*
- *  ======== DCD_EnumerateObject ========
+ *  ======== dcd_enumerate_object ========
  *  Purpose:
  *      This function enumerates currently visible DSP/BIOS Bridge objects
  *      and returns the UUID and type of each enumerated object.
  *  Parameters:
  *      cIndex:             The object enumeration index.
- *      objType:            Type of object to enumerate.
- *      pUuid:              Pointer to a DSP_UUID object.
+ *      obj_type:            Type of object to enumerate.
+ *      uuid_obj:              Pointer to a dsp_uuid object.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EFAIL:          Unable to enumerate through the DCD database.
  *      DSP_SENUMCOMPLETE:  Enumeration completed. This is not an error code.
  *  Requires:
  *      DCD initialized.
- *      pUuid is a valid pointer.
+ *      uuid_obj is a valid pointer.
  *  Ensures:
  *  Details:
- *      This function can be used in conjunction with DCD_GetObjectDef to
+ *      This function can be used in conjunction with dcd_get_object_def to
  *      retrieve object properties.
  */
-	extern DSP_STATUS DCD_EnumerateObject(IN s32 cIndex,
-					      IN enum DSP_DCDOBJTYPE objType,
-					      OUT struct DSP_UUID *pUuid);
+extern dsp_status dcd_enumerate_object(IN s32 cIndex,
+				       IN enum dsp_dcdobjtype obj_type,
+				       OUT struct dsp_uuid *uuid_obj);
 
 /*
- *  ======== DCD_Exit ========
+ *  ======== dcd_exit ========
  *  Purpose:
  *      This function cleans up the DCD module.
  *  Parameters:
@@ -146,17 +146,17 @@
  *      DCD initialized.
  *  Ensures:
  */
-	extern void DCD_Exit(void);
+extern void dcd_exit(void);
 
 /*
- *  ======== DCD_GetDepLibs ========
+ *  ======== dcd_get_dep_libs ========
  *  Purpose:
  *      Given the uuid of a library and size of array of uuids, this function
  *      fills the array with the uuids of all dependent libraries of the input
  *      library.
  *  Parameters:
- *      hDcdMgr: A DCD manager handle.
- *      pUuid: Pointer to a DSP_UUID for a library.
+ *      hdcd_mgr: A DCD manager handle.
+ *      uuid_obj: Pointer to a dsp_uuid for a library.
  *      numLibs: Size of uuid array (number of library uuids).
  *      pDepLibUuids: Array of dependent library uuids to be filled in.
  *      pPersistentDepLibs: Array indicating if corresponding lib is persistent.
@@ -168,26 +168,26 @@
  *      DSP_EFAIL: General failure.
  *  Requires:
  *      DCD initialized.
- *      Valid hDcdMgr.
- *      pUuid != NULL
+ *      Valid hdcd_mgr.
+ *      uuid_obj != NULL
  *      pDepLibUuids != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_GetDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-					 IN struct DSP_UUID *pUuid,
-					 u16 numLibs,
-					 OUT struct DSP_UUID *pDepLibUuids,
-					 OUT bool *pPersistentDepLibs,
-					 IN enum NLDR_PHASE phase);
+extern dsp_status dcd_get_dep_libs(IN struct dcd_manager *hdcd_mgr,
+				   IN struct dsp_uuid *uuid_obj,
+				   u16 numLibs,
+				   OUT struct dsp_uuid *pDepLibUuids,
+				   OUT bool *pPersistentDepLibs,
+				   IN enum nldr_phase phase);
 
 /*
- *  ======== DCD_GetNumDepLibs ========
+ *  ======== dcd_get_num_dep_libs ========
  *  Purpose:
  *      Given the uuid of a library, determine its number of dependent
  *      libraries.
  *  Parameters:
- *      hDcdMgr:        A DCD manager handle.
- *      pUuid:          Pointer to a DSP_UUID for a library.
+ *      hdcd_mgr:        A DCD manager handle.
+ *      uuid_obj:          Pointer to a dsp_uuid for a library.
  *      pNumLibs:       Size of uuid array (number of library uuids).
  *      pNumPersLibs:   number of persistent dependent library.
  *      phase:          Phase to obtain correct input library
@@ -198,58 +198,58 @@
  *      DSP_EFAIL: General failure.
  *  Requires:
  *      DCD initialized.
- *      Valid hDcdMgr.
- *      pUuid != NULL
+ *      Valid hdcd_mgr.
+ *      uuid_obj != NULL
  *      pNumLibs != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_GetNumDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-					    IN struct DSP_UUID *pUuid,
-					    OUT u16 *pNumLibs,
-					    OUT u16 *pNumPersLibs,
-					    IN enum NLDR_PHASE phase);
+extern dsp_status dcd_get_num_dep_libs(IN struct dcd_manager *hdcd_mgr,
+				       IN struct dsp_uuid *uuid_obj,
+				       OUT u16 *pNumLibs,
+				       OUT u16 *pNumPersLibs,
+				       IN enum nldr_phase phase);
 
 /*
- *  ======== DCD_GetLibraryName ========
+ *  ======== dcd_get_library_name ========
  *  Purpose:
  *      This function returns the name of a (dynamic) library for a given
  *      UUID.
  *  Parameters:
- *      hDcdMgr: A DCD manager handle.
- *      pUuid:          Pointer to a DSP_UUID that represents a unique DSP/BIOS
+ *      hdcd_mgr: A DCD manager handle.
+ *      uuid_obj:	Pointer to a dsp_uuid that represents a unique DSP/BIOS
  *                      Bridge object.
  *      pstrLibName: Buffer to hold library name.
  *      pdwSize: Contains buffer size. Set to string size on output.
  *      phase:          Which phase to load
- *      fPhaseSplit:    Are phases in multiple libraries
+ *      phase_split:    Are phases in multiple libraries
  *  Returns:
  *      DSP_SOK: Success.
  *      DSP_EFAIL: General failure.
  *  Requires:
  *      DCD initialized.
- *      Valid hDcdMgr.
+ *      Valid hdcd_mgr.
  *      pstrLibName != NULL.
- *      pUuid != NULL
+ *      uuid_obj != NULL
  *      pdwSize != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
-					     IN struct DSP_UUID *pUuid,
-					     IN OUT char *pstrLibName,
-					     IN OUT u32 *pdwSize,
-					     IN enum NLDR_PHASE phase,
-					     OUT bool *fPhaseSplit);
+extern dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
+				       IN struct dsp_uuid *uuid_obj,
+				       IN OUT char *pstrLibName,
+				       IN OUT u32 *pdwSize,
+				       IN enum nldr_phase phase,
+				       OUT bool *phase_split);
 
 /*
- *  ======== DCD_GetObjectDef ========
+ *  ======== dcd_get_object_def ========
  *  Purpose:
  *      This function returns the properties/attributes of a DSP/BIOS Bridge
  *      object.
  *  Parameters:
- *      hDcdMgr:            A DCD manager handle.
- *      pUuid:              Pointer to a DSP_UUID that represents a unique
+ *      hdcd_mgr:            A DCD manager handle.
+ *      uuid_obj:              Pointer to a dsp_uuid that represents a unique
  *                          DSP/BIOS Bridge object.
- *      objType:            The type of DSP/BIOS Bridge object to be
+ *      obj_type:            The type of DSP/BIOS Bridge object to be
  *                          referenced (node, processor, etc).
  *      pObjDef:            Pointer to an object definition structure. A
  *                          union of various possible DCD object types.
@@ -267,13 +267,13 @@
  *      pObjDef is non-NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
-					   IN struct DSP_UUID *pObjUuid,
-					   IN enum DSP_DCDOBJTYPE objType,
-					   OUT struct DCD_GENERICOBJ *pObjDef);
+extern dsp_status dcd_get_object_def(IN struct dcd_manager *hdcd_mgr,
+				     IN struct dsp_uuid *pObjUuid,
+				     IN enum dsp_dcdobjtype obj_type,
+				     OUT struct dcd_genericobj *pObjDef);
 
 /*
- *  ======== DCD_GetObjects ========
+ *  ======== dcd_get_objects ========
  *  Purpose:
  *      This function finds all DCD objects specified in a special
  *      COFF section called ".dcd_register", and for each object,
@@ -281,7 +281,7 @@
  *      various actions, such as 1) register nodes in the node database, 2)
  *      unregister nodes from the node database, and 3) add overlay nodes.
  *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
+ *      hdcd_mgr:                A DCD manager handle.
  *      pszCoffPath:            Pointer to name of COFF file containing DCD
  *                              objects.
  *      registerFxn:            Callback fxn to be applied on each located
@@ -301,13 +301,12 @@
  *      COFF file to contain the right COFF sections, especially
  *      ".dcd_register", which is used for auto registration.
  */
-	extern DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr,
-					 IN char *pszCoffPath,
-					 DCD_REGISTERFXN registerFxn,
-					 void *handle);
+extern dsp_status dcd_get_objects(IN struct dcd_manager *hdcd_mgr,
+				  IN char *pszCoffPath,
+				  dcd_registerfxn registerFxn, void *handle);
 
 /*
- *  ======== DCD_Init ========
+ *  ======== dcd_init ========
  *  Purpose:
  *      This function initializes DCD.
  *  Parameters:
@@ -318,49 +317,49 @@
  *  Ensures:
  *      DCD initialized.
  */
-	extern bool DCD_Init(void);
+extern bool dcd_init(void);
 
 /*
- *  ======== DCD_RegisterObject ========
+ *  ======== dcd_register_object ========
  *  Purpose:
  *      This function registers a DSP/BIOS Bridge object in the DCD database.
  *  Parameters:
- *      pUuid:          Pointer to a DSP_UUID that identifies a DSP/BIOS
+ *      uuid_obj:          Pointer to a dsp_uuid that identifies a DSP/BIOS
  *                      Bridge object.
- *      objType:        Type of object.
- *      pszPathName:    Path to the object's COFF file.
+ *      obj_type:        Type of object.
+ *      psz_path_name:    Path to the object's COFF file.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Failed to register object.
  *  Requires:
  *      DCD initialized.
- *      pUuid and szPathName are non-NULL values.
- *      objType is a valid type value.
+ *      uuid_obj and szPathName are non-NULL values.
+ *      obj_type is a valid type value.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
-					     IN enum DSP_DCDOBJTYPE objType,
-					     IN char *pszPathName);
+extern dsp_status dcd_register_object(IN struct dsp_uuid *uuid_obj,
+				      IN enum dsp_dcdobjtype obj_type,
+				      IN char *psz_path_name);
 
 /*
- *  ======== DCD_UnregisterObject ========
+ *  ======== dcd_unregister_object ========
  *  Purpose:
  *      This function de-registers a valid DSP/BIOS Bridge object from the DCD
  *      database.
  *  Parameters:
- *      pUuid:      Pointer to a DSP_UUID that identifies a DSP/BIOS Bridge
+ *      uuid_obj:      Pointer to a dsp_uuid that identifies a DSP/BIOS Bridge
  *                  object.
- *      objType:    Type of object.
+ *      obj_type:    Type of object.
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  Unable to de-register the specified object.
  *  Requires:
  *      DCD initialized.
- *      pUuid is a non-NULL value.
- *      objType is a valid type value.
+ *      uuid_obj is a non-NULL value.
+ *      obj_type is a valid type value.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
-					       IN enum DSP_DCDOBJTYPE objType);
+extern dsp_status dcd_unregister_object(IN struct dsp_uuid *uuid_obj,
+					IN enum dsp_dcdobjtype obj_type);
 
-#endif				/* _DBDCD_H */
+#endif /* _DBDCD_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdcddef.h b/arch/arm/plat-omap/include/dspbridge/dbdcddef.h
index 4abb1cd..7f59bb7 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdcddef.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdcddef.h
@@ -20,7 +20,7 @@
 #define DBDCDDEF_
 
 #include <dspbridge/dbdefs.h>
-#include <dspbridge/mgrpriv.h>		/* for MGR_PROCESSOREXTINFO */
+#include <dspbridge/mgrpriv.h>	/* for mgr_processorextinfo */
 
 /*
  *  The following defines are critical elements for the DCD module:
@@ -33,39 +33,38 @@
 #define DCD_REGISTER_SECTION    ".dcd_register"
 
 /* DCD Manager Object */
-	struct DCD_MANAGER;
+struct dcd_manager;
 
 /* DCD Node Properties */
-	struct DCD_NODEPROPS {
-		struct DSP_NDBPROPS ndbProps;
-		u32 uMsgSegid;
-		u32 uMsgNotifyType;
-		char *pstrCreatePhaseFxn;
-		char *pstrDeletePhaseFxn;
-		char *pstrExecutePhaseFxn;
-		char *pstrIAlgName;
+struct dcd_nodeprops {
+	struct dsp_ndbprops ndb_props;
+	u32 msg_segid;
+	u32 msg_notify_type;
+	char *pstr_create_phase_fxn;
+	char *pstr_delete_phase_fxn;
+	char *pstr_execute_phase_fxn;
+	char *pstr_i_alg_name;
 
-		/* Dynamic load properties */
-		u16 usLoadType;	/* Static, dynamic, overlay */
-		u32 ulDataMemSegMask;	/* Data memory requirements */
-		u32 ulCodeMemSegMask;	/* Code memory requirements */
-	} ;
+	/* Dynamic load properties */
+	u16 us_load_type;	/* Static, dynamic, overlay */
+	u32 ul_data_mem_seg_mask;	/* Data memory requirements */
+	u32 ul_code_mem_seg_mask;	/* Code memory requirements */
+};
 
 /* DCD Generic Object Type */
-	struct DCD_GENERICOBJ {
-		union dcdObjUnion {
-			struct DCD_NODEPROPS nodeObj;	/* node object. */
-			/* processor object. */
-			struct DSP_PROCESSORINFO procObj;
-			/* extended proc object (private) */
-			struct MGR_PROCESSOREXTINFO extProcObj;
-		} objData;
-	} ;
+struct dcd_genericobj {
+	union dcdObjUnion {
+		struct dcd_nodeprops node_obj;	/* node object. */
+		/* processor object. */
+		struct dsp_processorinfo proc_info;
+		/* extended proc object (private) */
+		struct mgr_processorextinfo ext_proc_obj;
+	} obj_data;
+};
 
 /* DCD Internal Callback Type */
-       typedef DSP_STATUS(*DCD_REGISTERFXN) (IN struct DSP_UUID *pUuid,
-						IN enum DSP_DCDOBJTYPE objType,
-						IN void *handle);
-
-#endif				/* DBDCDDEF_ */
+typedef dsp_status(*dcd_registerfxn) (IN struct dsp_uuid *uuid_obj,
+				      IN enum dsp_dcdobjtype obj_type,
+				      IN void *handle);
 
+#endif /* DBDCDDEF_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdefs.h b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
index c5497c3..ebf6456 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
@@ -21,25 +21,25 @@
 
 #include <linux/types.h>
 
-#include <dspbridge/dbtype.h>		/* GPP side type definitions */
-#include <dspbridge/std.h>		/* DSP/BIOS type definitions */
-#include <dspbridge/rms_sh.h>		/* Types shared between GPP and DSP */
+#include <dspbridge/dbtype.h>	/* GPP side type definitions */
+#include <dspbridge/std.h>	/* DSP/BIOS type definitions */
+#include <dspbridge/rms_sh.h>	/* Types shared between GPP and DSP */
 
-#define PG_SIZE_4K 4096
+#define PG_SIZE4K 4096
 #define PG_MASK(pg_size) (~((pg_size)-1))
 #define PG_ALIGN_LOW(addr, pg_size) ((addr) & PG_MASK(pg_size))
 #define PG_ALIGN_HIGH(addr, pg_size) (((addr)+(pg_size)-1) & PG_MASK(pg_size))
 
 /* API return value and calling convention */
-#define DBAPI                       DSP_STATUS
+#define DBAPI                       dsp_status
 
-/* Infinite time value for the uTimeout parameter to DSPStream_Select() */
+/* Infinite time value for the utimeout parameter to DSPStream_Select() */
 #define DSP_FOREVER                 (-1)
 
-/* Maximum length of node name, used in DSP_NDBPROPS */
+/* Maximum length of node name, used in dsp_ndbprops */
 #define DSP_MAXNAMELEN              32
 
-/* uNotifyType values for the RegisterNotify() functions. */
+/* notify_type values for the RegisterNotify() functions. */
 #define DSP_SIGNALEVENT             0x00000001
 
 /* Types of events for processors */
@@ -80,7 +80,8 @@
 #define DSP_RMSUSERCODESTART RMS_USER	/* Start of RMS user cmd codes */
 /* end of user codes */
 #define DSP_RMSUSERCODEEND (RMS_USER + RMS_MAXUSERCODES);
-#define DSP_RMSBUFDESC RMS_BUFDESC	/* MSG contains SM buffer description */
+/* msg_ctrl contains SM buffer description */
+#define DSP_RMSBUFDESC RMS_BUFDESC
 
 /* Shared memory identifier for MEM segment named "SHMSEG0" */
 #define DSP_SHMSEG0     (u32)(-1)
@@ -92,7 +93,7 @@
 #define DSPWORD       unsigned char
 #define DSPWORDSIZE     sizeof(DSPWORD)
 
-/* Success & Failure macros  */
+/* Success & Failure macros */
 #define DSP_SUCCEEDED(Status)      likely((s32)(Status) >= 0)
 #define DSP_FAILED(Status)         unlikely((s32)(Status) < 0)
 
@@ -108,13 +109,14 @@
 #define    MAX_PROFILES     16
 
 /* DSP chip type */
-#define DSPTYPE_64	0x99
+#define DSPTYPE64	0x99
 
 /* Types defined for 'Bridge API */
-	typedef u32 DSP_STATUS;	/* API return code type         */
+typedef u32 dsp_status;		/* API return code type */
 
 /* Handy Macros */
-#define IsValidProcEvent(x) (((x) == 0) || (((x) & (DSP_PROCESSORSTATECHANGE | \
+#define IS_VALID_PROC_EVENT(x) (((x) == 0) || (((x) & \
+				(DSP_PROCESSORSTATECHANGE | \
 				DSP_PROCESSORATTACH | \
 				DSP_PROCESSORDETACH | \
 				DSP_PROCESSORRESTART | \
@@ -137,47 +139,46 @@
 				DSP_PWRERROR | \
 				DSP_WDTOVERFLOW))))
 
-#define IsValidNodeEvent(x)    (((x) == 0) || (((x) & (DSP_NODESTATECHANGE | \
-				DSP_NODEMESSAGEREADY)) && \
-				!((x) & ~(DSP_NODESTATECHANGE | \
-				DSP_NODEMESSAGEREADY))))
+#define IS_VALID_NODE_EVENT(x)    (((x) == 0) || \
+	(((x) & (DSP_NODESTATECHANGE | DSP_NODEMESSAGEREADY)) && \
+	!((x) & ~(DSP_NODESTATECHANGE | DSP_NODEMESSAGEREADY))))
 
-#define IsValidStrmEvent(x)     (((x) == 0) || (((x) & (DSP_STREAMDONE | \
+#define IS_VALID_STRM_EVENT(x)     (((x) == 0) || (((x) & (DSP_STREAMDONE | \
 				DSP_STREAMIOCOMPLETION)) && \
 				!((x) & ~(DSP_STREAMDONE | \
 				DSP_STREAMIOCOMPLETION))))
 
-#define IsValidNotifyMask(x)   ((x) & DSP_SIGNALEVENT)
+#define IS_VALID_NOTIFY_MASK(x)   ((x) & DSP_SIGNALEVENT)
 
 /* The Node UUID structure */
-	struct DSP_UUID {
-		u32 ulData1;
-		u16 usData2;
-		u16 usData3;
-		u8 ucData4;
-		u8 ucData5;
-		u8 ucData6[6];
-	};
+struct dsp_uuid {
+	u32 ul_data1;
+	u16 us_data2;
+	u16 us_data3;
+	u8 uc_data4;
+	u8 uc_data5;
+	u8 uc_data6[6];
+};
 
 /* DCD types */
-	enum DSP_DCDOBJTYPE {
-		DSP_DCDNODETYPE,
-		DSP_DCDPROCESSORTYPE,
-		DSP_DCDLIBRARYTYPE,
-		DSP_DCDCREATELIBTYPE,
-		DSP_DCDEXECUTELIBTYPE,
-		DSP_DCDDELETELIBTYPE,
-		/* DSP_DCDMAXOBJTYPE is meant to be the last DCD object type */
-		DSP_DCDMAXOBJTYPE
-	} ;
+enum dsp_dcdobjtype {
+	DSP_DCDNODETYPE,
+	DSP_DCDPROCESSORTYPE,
+	DSP_DCDLIBRARYTYPE,
+	DSP_DCDCREATELIBTYPE,
+	DSP_DCDEXECUTELIBTYPE,
+	DSP_DCDDELETELIBTYPE,
+	/* DSP_DCDMAXOBJTYPE is meant to be the last DCD object type */
+	DSP_DCDMAXOBJTYPE
+};
 
 /* Processor states */
-	enum DSP_PROCSTATE {
-		PROC_STOPPED,
-		PROC_LOADED,
-		PROC_RUNNING,
-		PROC_ERROR
-	} ;
+enum dsp_procstate {
+	PROC_STOPPED,
+	PROC_LOADED,
+	PROC_RUNNING,
+	PROC_ERROR
+};
 
 /*
  *  Node types: Message node, task node, xDAIS socket node, and
@@ -185,304 +186,304 @@
  *  between a task or socket node and the GPP.
  *
  */
-	enum NODE_TYPE {
-		NODE_DEVICE,
-		NODE_TASK,
-		NODE_DAISSOCKET,
-		NODE_MESSAGE,
-		NODE_GPP
-	} ;
+enum node_type {
+	NODE_DEVICE,
+	NODE_TASK,
+	NODE_DAISSOCKET,
+	NODE_MESSAGE,
+	NODE_GPP
+};
 
 /*
- *  ======== NODE_STATE ========
+ *  ======== node_state ========
  *  Internal node states.
  */
-	enum NODE_STATE {
-		NODE_ALLOCATED,
-		NODE_CREATED,
-		NODE_RUNNING,
-		NODE_PAUSED,
-		NODE_DONE,
-		NODE_CREATING,
-		NODE_STARTING,
-		NODE_PAUSING,
-		NODE_TERMINATING,
-		NODE_DELETING,
-	} ;
+enum node_state {
+	NODE_ALLOCATED,
+	NODE_CREATED,
+	NODE_RUNNING,
+	NODE_PAUSED,
+	NODE_DONE,
+	NODE_CREATING,
+	NODE_STARTING,
+	NODE_PAUSING,
+	NODE_TERMINATING,
+	NODE_DELETING,
+};
 
 /* Stream states */
-	enum DSP_STREAMSTATE {
-		STREAM_IDLE,
-		STREAM_READY,
-		STREAM_PENDING,
-		STREAM_DONE
-	} ;
+enum dsp_streamstate {
+	STREAM_IDLE,
+	STREAM_READY,
+	STREAM_PENDING,
+	STREAM_DONE
+};
 
 /* Stream connect types */
-	enum DSP_CONNECTTYPE {
-		CONNECTTYPE_NODEOUTPUT,
-		CONNECTTYPE_GPPOUTPUT,
-		CONNECTTYPE_NODEINPUT,
-		CONNECTTYPE_GPPINPUT
-	} ;
+enum dsp_connecttype {
+	CONNECTTYPE_NODEOUTPUT,
+	CONNECTTYPE_GPPOUTPUT,
+	CONNECTTYPE_NODEINPUT,
+	CONNECTTYPE_GPPINPUT
+};
 
 /* Stream mode types */
-	enum DSP_STRMMODE {
-		STRMMODE_PROCCOPY, /* Processor(s) copy stream data payloads */
-		STRMMODE_ZEROCOPY, /* Strm buffer ptrs swapped no data copied */
-		STRMMODE_LDMA,	/* Local DMA : OMAP's System-DMA device */
-		STRMMODE_RDMA	/* Remote DMA: OMAP's DSP-DMA device */
-	} ;
+enum dsp_strmmode {
+	STRMMODE_PROCCOPY,	/* Processor(s) copy stream data payloads */
+	STRMMODE_ZEROCOPY,	/* Strm buffer ptrs swapped no data copied */
+	STRMMODE_LDMA,		/* Local DMA : OMAP's System-DMA device */
+	STRMMODE_RDMA		/* Remote DMA: OMAP's DSP-DMA device */
+};
 
 /* Resource Types */
-	enum DSP_RESOURCEINFOTYPE {
-		DSP_RESOURCE_DYNDARAM = 0,
-		DSP_RESOURCE_DYNSARAM,
-		DSP_RESOURCE_DYNEXTERNAL,
-		DSP_RESOURCE_DYNSRAM,
-		DSP_RESOURCE_PROCLOAD
-	} ;
+enum dsp_resourceinfotype {
+	DSP_RESOURCE_DYNDARAM = 0,
+	DSP_RESOURCE_DYNSARAM,
+	DSP_RESOURCE_DYNEXTERNAL,
+	DSP_RESOURCE_DYNSRAM,
+	DSP_RESOURCE_PROCLOAD
+};
 
 /* Memory Segment Types */
-	enum DSP_MEMTYPE {
-		DSP_DYNDARAM = 0,
-		DSP_DYNSARAM,
-		DSP_DYNEXTERNAL,
-		DSP_DYNSRAM
-	} ;
+enum dsp_memtype {
+	DSP_DYNDARAM = 0,
+	DSP_DYNSARAM,
+	DSP_DYNEXTERNAL,
+	DSP_DYNSRAM
+};
 
 /* Memory Flush Types */
-       enum DSP_FLUSHTYPE {
-		PROC_INVALIDATE_MEM = 0,
-		PROC_WRITEBACK_MEM,
-		PROC_WRITEBACK_INVALIDATE_MEM,
-		PROC_WRBK_INV_ALL
-	} ;
+enum dsp_flushtype {
+	PROC_INVALIDATE_MEM = 0,
+	PROC_WRITEBACK_MEM,
+	PROC_WRITEBACK_INVALIDATE_MEM,
+	PROC_WRBK_INV_ALL
+};
 
 /* Memory Segment Status Values */
-	struct DSP_MEMSTAT {
-		u32 ulSize;
-		u32 ulTotalFreeSize;
-		u32 ulLenMaxFreeBlock;
-		u32 ulNumFreeBlocks;
-		u32 ulNumAllocBlocks;
-	} ;
+struct dsp_memstat {
+	u32 ul_size;
+	u32 ul_total_free_size;
+	u32 ul_len_max_free_block;
+	u32 ul_num_free_blocks;
+	u32 ul_num_alloc_blocks;
+};
 
 /* Processor Load information Values */
-	 struct DSP_PROCLOADSTAT {
-		u32 uCurrLoad;
-		u32 uPredictedLoad;
-		u32 uCurrDspFreq;
-		u32 uPredictedFreq;
-	} ;
+struct dsp_procloadstat {
+	u32 curr_load;
+	u32 predicted_load;
+	u32 curr_dsp_freq;
+	u32 predicted_freq;
+};
 
 /* Attributes for STRM connections between nodes */
-	struct DSP_STRMATTR {
-		u32 uSegid;	/* Memory segment on DSP to allocate buffers */
-		u32 uBufsize;	/* Buffer size (DSP words) */
-		u32 uNumBufs;	/* Number of buffers */
-		u32 uAlignment;	/* Buffer alignment */
-		u32 uTimeout;	/* Timeout for blocking STRM calls */
-		enum DSP_STRMMODE lMode;	/* mode of stream when opened */
-		/* DMA chnl id if DSP_STRMMODE is LDMA or RDMA */
-		u32 uDMAChnlId;
-		u32 uDMAPriority;  /* DMA channel priority 0=lowest, >0=high */
-	} ;
-
-/* The DSP_CBDATA structure */
-	struct DSP_CBDATA {
-		u32 cbData;
-		u8 cData[1];
-	} ;
-
-/* The DSP_MSG structure */
-	struct DSP_MSG {
-		u32 dwCmd;
-		u32 dwArg1;
-		u32 dwArg2;
-	} ;
-
-/* The DSP_RESOURCEREQMTS structure for node's resource requirements  */
-	struct DSP_RESOURCEREQMTS {
-		u32 cbStruct;
-		u32 uStaticDataSize;
-		u32 uGlobalDataSize;
-		u32 uProgramMemSize;
-		u32 uWCExecutionTime;
-		u32 uWCPeriod;
-		u32 uWCDeadline;
-		u32 uAvgExectionTime;
-		u32 uMinimumPeriod;
-	} ;
+struct dsp_strmattr {
+	u32 seg_id;		/* Memory segment on DSP to allocate buffers */
+	u32 buf_size;		/* Buffer size (DSP words) */
+	u32 num_bufs;		/* Number of buffers */
+	u32 buf_alignment;	/* Buffer alignment */
+	u32 utimeout;		/* Timeout for blocking STRM calls */
+	enum dsp_strmmode strm_mode;	/* mode of stream when opened */
+	/* DMA chnl id if dsp_strmmode is LDMA or RDMA */
+	u32 udma_chnl_id;
+	u32 udma_priority;	/* DMA channel priority 0=lowest, >0=high */
+};
+
+/* The dsp_cbdata structure */
+struct dsp_cbdata {
+	u32 cb_data;
+	u8 node_data[1];
+};
+
+/* The dsp_msg structure */
+struct dsp_msg {
+	u32 dw_cmd;
+	u32 dw_arg1;
+	u32 dw_arg2;
+};
+
+/* The dsp_resourcereqmts structure for node's resource requirements */
+struct dsp_resourcereqmts {
+	u32 cb_struct;
+	u32 static_data_size;
+	u32 global_data_size;
+	u32 program_mem_size;
+	u32 uwc_execution_time;
+	u32 uwc_period;
+	u32 uwc_deadline;
+	u32 avg_exection_time;
+	u32 minimum_period;
+};
 
 /*
- * The DSP_STREAMCONNECT structure describes a stream connection
+ * The dsp_streamconnect structure describes a stream connection
  * between two nodes, or between a node and the GPP
  */
-	struct DSP_STREAMCONNECT {
-		u32 cbStruct;
-		enum DSP_CONNECTTYPE lType;
-		u32 uThisNodeStreamIndex;
-		void *hConnectedNode;
-		struct DSP_UUID uiConnectedNodeID;
-		u32 uConnectedNodeStreamIndex;
-	} ;
-
-	struct DSP_NODEPROFS {
-		u32 ulHeapSize;
-	} ;
-
-/* The DSP_NDBPROPS structure reports the attributes of a node */
-	struct DSP_NDBPROPS {
-		u32 cbStruct;
-		struct DSP_UUID uiNodeID;
-		char acName[DSP_MAXNAMELEN];
-		enum NODE_TYPE uNodeType;
-		u32 bCacheOnGPP;
-		struct DSP_RESOURCEREQMTS dspResourceReqmts;
-		s32 iPriority;
-		u32 uStackSize;
-		u32 uSysStackSize;
-		u32 uStackSeg;
-		u32 uMessageDepth;
-		u32 uNumInputStreams;
-		u32 uNumOutputStreams;
-		u32 uTimeout;
-		u32 uCountProfiles;	/* Number of supported profiles */
-		/* Array of profiles */
-		struct DSP_NODEPROFS aProfiles[MAX_PROFILES];
-		u32 uStackSegName; /* Stack Segment Name */
-	} ;
-
-	/* The DSP_NODEATTRIN structure describes the attributes of a
+struct dsp_streamconnect {
+	u32 cb_struct;
+	enum dsp_connecttype connect_type;
+	u32 this_node_stream_index;
+	void *connected_node;
+	struct dsp_uuid ui_connected_node_id;
+	u32 connected_node_stream_index;
+};
+
+struct dsp_nodeprofs {
+	u32 ul_heap_size;
+};
+
+/* The dsp_ndbprops structure reports the attributes of a node */
+struct dsp_ndbprops {
+	u32 cb_struct;
+	struct dsp_uuid ui_node_id;
+	char ac_name[DSP_MAXNAMELEN];
+	enum node_type ntype;
+	u32 cache_on_gpp;
+	struct dsp_resourcereqmts dsp_resource_reqmts;
+	s32 prio;
+	u32 stack_size;
+	u32 sys_stack_size;
+	u32 stack_seg;
+	u32 message_depth;
+	u32 num_input_streams;
+	u32 num_output_streams;
+	u32 utimeout;
+	u32 count_profiles;	/* Number of supported profiles */
+	/* Array of profiles */
+	struct dsp_nodeprofs node_profiles[MAX_PROFILES];
+	u32 stack_seg_name;	/* Stack Segment Name */
+};
+
+	/* The dsp_nodeattrin structure describes the attributes of a
 	 * node client */
-	struct DSP_NODEATTRIN {
-		u32 cbStruct;
-		s32 iPriority;
-		u32 uTimeout;
-		u32    uProfileID;
-		/* Reserved, for Bridge Internal use only */
-		u32    uHeapSize;
-		void *pGPPVirtAddr; /* Reserved, for Bridge Internal use only */
-	} ;
-
-	/* The DSP_NODEINFO structure is used to retrieve information
+struct dsp_nodeattrin {
+	u32 cb_struct;
+	s32 prio;
+	u32 utimeout;
+	u32 profile_id;
+	/* Reserved, for Bridge Internal use only */
+	u32 heap_size;
+	void *pgpp_virt_addr;	/* Reserved, for Bridge Internal use only */
+};
+
+	/* The dsp_nodeinfo structure is used to retrieve information
 	 * about a node */
-	struct DSP_NODEINFO {
-		u32 cbStruct;
-		struct DSP_NDBPROPS nbNodeDatabaseProps;
-		u32 uExecutionPriority;
-		enum NODE_STATE nsExecutionState;
-		void *hDeviceOwner;
-		u32 uNumberStreams;
-		struct DSP_STREAMCONNECT scStreamConnection[16];
-		u32 uNodeEnv;
-	} ;
-
-	/* The DSP_NODEATTR structure describes the attributes of a node */
-	struct DSP_NODEATTR {
-		u32 cbStruct;
-		struct DSP_NODEATTRIN inNodeAttrIn;
-		u32 uInputs;
-		u32 uOutputs;
-		struct DSP_NODEINFO iNodeInfo;
-	} ;
+struct dsp_nodeinfo {
+	u32 cb_struct;
+	struct dsp_ndbprops nb_node_database_props;
+	u32 execution_priority;
+	enum node_state ns_execution_state;
+	void *device_owner;
+	u32 number_streams;
+	struct dsp_streamconnect sc_stream_connection[16];
+	u32 node_env;
+};
+
+	/* The dsp_nodeattr structure describes the attributes of a node */
+struct dsp_nodeattr {
+	u32 cb_struct;
+	struct dsp_nodeattrin in_node_attr_in;
+	u32 node_attr_inputs;
+	u32 node_attr_outputs;
+	struct dsp_nodeinfo node_info;
+};
 
 /*
  *  Notification type: either the name of an opened event, or an event or
  *  window handle.
  */
-	struct DSP_NOTIFICATION {
-		char *psName;
-		HANDLE handle;
-	} ;
-
-/* The DSP_PROCESSORATTRIN structure describes the attributes of a processor */
-	struct DSP_PROCESSORATTRIN{
-		u32 cbStruct;
-		u32 uTimeout;
-	} ;
+struct dsp_notification {
+	char *ps_name;
+	bhandle handle;
+};
+
+/* The dsp_processorattrin structure describes the attributes of a processor */
+struct dsp_processorattrin {
+	u32 cb_struct;
+	u32 utimeout;
+};
 /*
- * The DSP_PROCESSORINFO structure describes basic capabilities of a
+ * The dsp_processorinfo structure describes basic capabilities of a
  * DSP processor
  */
-	struct DSP_PROCESSORINFO {
-		u32 cbStruct;
-		long uProcessorFamily;
-		long uProcessorType;
-		u32 uClockRate;
-		u32 ulInternalMemSize;
-		u32 ulExternalMemSize;
-		u32 uProcessorID;
-		long tyRunningRTOS;
-		s32 nNodeMinPriority;
-		s32 nNodeMaxPriority;
-	} ;
+struct dsp_processorinfo {
+	u32 cb_struct;
+	long processor_family;
+	long processor_type;
+	u32 clock_rate;
+	u32 ul_internal_mem_size;
+	u32 ul_external_mem_size;
+	u32 processor_id;
+	long ty_running_rtos;
+	s32 node_min_priority;
+	s32 node_max_priority;
+};
 
 /* Error information of last DSP exception signalled to the GPP */
-	struct DSP_ERRORINFO {
-		u32 dwErrMask;
-		u32 dwVal1;
-		u32 dwVal2;
-		u32 dwVal3;
-	} ;
-
-/* The DSP_PROCESSORSTATE structure describes the state of a DSP processor */
-	struct DSP_PROCESSORSTATE {
-		u32 cbStruct;
-		enum DSP_PROCSTATE iState;
-		struct DSP_ERRORINFO errInfo;
-	} ;
+struct dsp_errorinfo {
+	u32 dw_err_mask;
+	u32 dw_val1;
+	u32 dw_val2;
+	u32 dw_val3;
+};
+
+/* The dsp_processorstate structure describes the state of a DSP processor */
+struct dsp_processorstate {
+	u32 cb_struct;
+	enum dsp_procstate proc_state;
+	struct dsp_errorinfo err_info;
+};
 
 /*
- * The DSP_RESOURCEINFO structure is used to retrieve information about a
+ * The dsp_resourceinfo structure is used to retrieve information about a
  * processor's resources
  */
-	struct DSP_RESOURCEINFO {
-		u32 cbStruct;
-		enum DSP_RESOURCEINFOTYPE uResourceType;
-		union {
-			u32 ulResource;
-			struct DSP_MEMSTAT memStat;
-			struct DSP_PROCLOADSTAT procLoadStat;
-		} result;
-	} ;
+struct dsp_resourceinfo {
+	u32 cb_struct;
+	enum dsp_resourceinfotype resource_type;
+	union {
+		u32 ul_resource;
+		struct dsp_memstat mem_stat;
+		struct dsp_procloadstat proc_load_stat;
+	} result;
+};
 
 /*
- * The DSP_STREAMATTRIN structure describes the attributes of a stream,
+ * The dsp_streamattrin structure describes the attributes of a stream,
  * including segment and alignment of data buffers allocated with
  * DSPStream_AllocateBuffers(), if applicable
  */
-	struct DSP_STREAMATTRIN {
-		u32 cbStruct;
-		u32 uTimeout;
-		u32 uSegment;
-		u32 uAlignment;
-		u32 uNumBufs;
-		enum DSP_STRMMODE lMode;
-		u32 uDMAChnlId;
-		u32 uDMAPriority;
-	} ;
-
-/* The DSP_BUFFERATTR structure describes the attributes of a data buffer */
-	struct DSP_BUFFERATTR {
-		u32 cbStruct;
-		u32 uSegment;
-		u32 uAlignment;
-	} ;
+struct dsp_streamattrin {
+	u32 cb_struct;
+	u32 utimeout;
+	u32 segment_id;
+	u32 buf_alignment;
+	u32 num_bufs;
+	enum dsp_strmmode strm_mode;
+	u32 udma_chnl_id;
+	u32 udma_priority;
+};
+
+/* The dsp_bufferattr structure describes the attributes of a data buffer */
+struct dsp_bufferattr {
+	u32 cb_struct;
+	u32 segment_id;
+	u32 buf_alignment;
+};
 
 /*
- *  The DSP_STREAMINFO structure is used to retrieve information
+ *  The dsp_streaminfo structure is used to retrieve information
  *  about a stream.
  */
-	struct DSP_STREAMINFO {
-		u32 cbStruct;
-		u32 uNumberBufsAllowed;
-		u32 uNumberBufsInStream;
-		u32 ulNumberBytes;
-		HANDLE hSyncObjectHandle;
-		enum DSP_STREAMSTATE ssStreamState;
-	} ;
+struct dsp_streaminfo {
+	u32 cb_struct;
+	u32 number_bufs_allowed;
+	u32 number_bufs_in_stream;
+	u32 ul_number_bytes;
+	bhandle sync_object_handle;
+	enum dsp_streamstate ss_stream_state;
+};
 
 /* DMM MAP attributes
 It is a bit mask with each bit value indicating a specific attribute
@@ -529,7 +530,6 @@ bit 15 - Output (writeable) buffer
 #define GEM_CACHE_LINE_SIZE     128
 #define GEM_L1P_PREFETCH_SIZE   128
 
-
 /*
  * Definitions from dbreg.h
  */
@@ -549,10 +549,10 @@ bit 15 - Output (writeable) buffer
 
 /* MiniDriver related definitions */
 #define DEFEXEC		"DefaultExecutable"	/* Default executable */
-#define AUTOSTART	"AutoStart"		/* Statically load flag */
-#define CURRENTCONFIG	"CurrentConfig"		/* Current resources */
-#define SHMSIZE		"SHMSize"		/* Size of SHM reservd on MPU */
-#define TCWORDSWAP	"TCWordSwap"		/* Traffic Controller WordSwp */
+#define AUTOSTART	"AutoStart"	/* Statically load flag */
+#define CURRENTCONFIG	"CurrentConfig"	/* Current resources */
+#define SHMSIZE		"SHMSize"	/* Size of shm reservd on MPU */
+#define TCWORDSWAP	"TCWordSwap"	/* Traffic Controller WordSwp */
 #define DSPRESOURCES	"DspTMSResources"	/* C55 DSP resurces on OMAP */
 
-#endif				/* DBDEFS_ */
+#endif /* DBDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbldefs.h b/arch/arm/plat-omap/include/dspbridge/dbldefs.h
index df37ec0..7a94441 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbldefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbldefs.h
@@ -18,7 +18,7 @@
 #define DBLDEFS_
 
 /*
- *  Bit masks for DBL_Flags.
+ *  Bit masks for dbl_flags.
  */
 #define DBL_NOLOAD   0x0	/* Don't load symbols, code, or data */
 #define DBL_SYMB     0x1	/* load symbols */
@@ -30,67 +30,65 @@
 #define DBL_MAXPATHLENGTH       255
 
 /*
- *  ======== DBL_Flags ========
+ *  ======== dbl_flags ========
  *  Specifies whether to load code, data, or symbols
  */
-typedef s32 DBL_Flags;
+typedef s32 dbl_flags;
 
 /*
- *  ======== DBL_SectInfo ========
+ *  ======== dbl_sect_info ========
  *  For collecting info on overlay sections
  */
-struct DBL_SectInfo {
+struct dbl_sect_info {
 	const char *name;	/* name of section */
-	u32 runAddr;		/* run address of section */
-	u32 loadAddr;		/* load address of section */
+	u32 sect_run_addr;	/* run address of section */
+	u32 sect_load_addr;	/* load address of section */
 	u32 size;		/* size of section (target MAUs) */
-	DBL_Flags type;		/* Code, data, or BSS */
-} ;
+	dbl_flags type;		/* Code, data, or BSS */
+};
 
 /*
- *  ======== DBL_Symbol ========
+ *  ======== dbl_symbol ========
  *  (Needed for dynamic load library)
  */
-struct DBL_Symbol {
+struct dbl_symbol {
 	u32 value;
 };
 
 /*
- *  ======== DBL_AllocFxn ========
+ *  ======== dbl_alloc_fxn ========
  *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
  *  "size" bytes of memory from segment "space" and return the address in
  *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
  *  success, or an error code on failure.
  */
-typedef s32(*DBL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
-			u32 *dspAddr, s32 segId, s32 req, bool reserved);
-
-
+typedef s32(*dbl_alloc_fxn) (void *hdl, s32 space, u32 size, u32 align,
+			     u32 *dspAddr, s32 seg_id, s32 req, bool reserved);
 
 /*
- *  ======== DBL_FreeFxn ========
+ *  ======== dbl_free_fxn ========
  *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
  *  bytes of memory from segment "space"
  */
-typedef bool(*DBL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
-			    bool reserved);
+typedef bool(*dbl_free_fxn) (void *hdl, u32 addr, s32 space, u32 size,
+			     bool reserved);
 
 /*
- *  ======== DBL_LogWriteFxn ========
+ *  ======== dbl_log_write_fxn ========
  *  Function to call when writing data from a section, to log the info.
  *  Can be NULL if no logging is required.
  */
-typedef DSP_STATUS(*DBL_LogWriteFxn) (void *handle, struct DBL_SectInfo *sect,
-				      u32 addr, u32 nBytes);
-
+typedef dsp_status(*dbl_log_write_fxn) (void *handle,
+					struct dbl_sect_info *sect, u32 addr,
+					u32 bytes);
 
 /*
- *  ======== DBL_SymLookup ========
+ *  ======== dbl_sym_lookup ========
  *  Symbol lookup function - Find the symbol name and return its value.
  *
  *  Parameters:
  *      handle          - Opaque handle
- *      pArg            - Opaque argument.
+ *      parg            - Opaque argument.
  *      name            - Name of symbol to lookup.
  *      sym             - Location to store address of symbol structure.
  *
@@ -98,46 +96,45 @@ typedef DSP_STATUS(*DBL_LogWriteFxn) (void *handle, struct DBL_SectInfo *sect,
  *      TRUE:           Success (symbol was found).
  *      FALSE:          Failed to find symbol.
  */
-typedef bool(*DBL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
-			      const char *name, struct DBL_Symbol **sym);
-
+typedef bool(*dbl_sym_lookup) (void *handle, void *parg, void *rmm_handle,
+			       const char *name, struct dbl_symbol ** sym);
 
 /*
- *  ======== DBL_WriteFxn ========
+ *  ======== dbl_write_fxn ========
  *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
  *  starting at address "dspAddr" from the buffer "buf".  The buffer is
  *  formatted as an array of words appropriate for the DSP.
  */
-typedef s32(*DBL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
-			    u32 n, s32 mtype);
+typedef s32(*dbl_write_fxn) (void *hdl, u32 dspAddr, void *buf,
+			     u32 n, s32 mtype);
 
 /*
- *  ======== DBL_Attrs ========
+ *  ======== dbl_attrs ========
  */
-struct DBL_Attrs {
-	DBL_AllocFxn alloc;
-	DBL_FreeFxn free;
-	void *rmmHandle;	/* Handle to pass to alloc, free functions */
-	DBL_WriteFxn write;
-	void *wHandle;		/* Handle to pass to write, cinit function */
+struct dbl_attrs {
+	dbl_alloc_fxn alloc;
+	dbl_free_fxn free;
+	void *rmm_handle;	/* Handle to pass to alloc, free functions */
+	dbl_write_fxn write;
+	void *input_params;	/* Handle to pass to write, cinit function */
 
-	DBL_LogWriteFxn logWrite;
-	void *logWriteHandle;
+	dbl_log_write_fxn log_write;
+	void *log_write_handle;
 
 	/* Symbol matching function and handle to pass to it */
-	DBL_SymLookup symLookup;
-	void *symHandle;
-	void *symArg;
+	dbl_sym_lookup sym_lookup;
+	void *sym_handle;
+	void *sym_arg;
 
 	/*
 	 *  These file manipulation functions should be compatible with the
 	 *  "C" run time library functions of the same name.
 	 */
-	s32(*fread) (void *, size_t, size_t, void *);
-	s32(*fseek) (void *, long, int);
-	s32(*ftell) (void *);
-	s32(*fclose) (void *);
+	 s32(*fread) (void *, size_t, size_t, void *);
+	 s32(*fseek) (void *, long, int);
+	 s32(*ftell) (void *);
+	 s32(*fclose) (void *);
 	void *(*fopen) (const char *, const char *);
-} ;
+};
 
-#endif				/* DBLDEFS_ */
+#endif /* DBLDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbll.h b/arch/arm/plat-omap/include/dspbridge/dbll.h
index 8c6eea7..daf8a0a 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbll.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbll.h
@@ -23,39 +23,33 @@
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/dblldefs.h>
 
-	extern void DBLL_close(struct DBLL_LibraryObj *lib);
-	extern DSP_STATUS DBLL_create(struct DBLL_TarObj **pTarget,
-				      struct DBLL_Attrs *pAttrs);
-	extern void DBLL_delete(struct DBLL_TarObj *target);
-	extern void DBLL_exit(void);
-	extern bool DBLL_getAddr(struct DBLL_LibraryObj *lib, char *name,
-				 struct DBLL_Symbol **ppSym);
-	extern void DBLL_getAttrs(struct DBLL_TarObj *target,
-				  struct DBLL_Attrs *pAttrs);
-	extern bool DBLL_getCAddr(struct DBLL_LibraryObj *lib, char *name,
-				  struct DBLL_Symbol **ppSym);
-	extern DSP_STATUS DBLL_getSect(struct DBLL_LibraryObj *lib, char *name,
-				       u32 *pAddr, u32 *pSize);
-	extern bool DBLL_init(void);
-	extern DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib,
-				    DBLL_Flags flags,
-				    struct DBLL_Attrs *attrs, u32 *pEntry);
-	extern DSP_STATUS DBLL_loadSect(struct DBLL_LibraryObj *lib,
-					char *sectName,
-					struct DBLL_Attrs *attrs);
-	extern DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file,
-				    DBLL_Flags flags,
-				    struct DBLL_LibraryObj **pLib);
-	extern DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib,
-					char *name,
-					char *pBuf, u32 size);
-	extern void DBLL_setAttrs(struct DBLL_TarObj *target,
-				  struct DBLL_Attrs *pAttrs);
-	extern void DBLL_unload(struct DBLL_LibraryObj *lib,
-				struct DBLL_Attrs *attrs);
-	extern DSP_STATUS DBLL_unloadSect(struct DBLL_LibraryObj *lib,
-					  char *sectName,
-					  struct DBLL_Attrs *attrs);
-
-#endif				/* DBLL_ */
+extern void dbll_close(struct dbll_library_obj *lib);
+extern dsp_status dbll_create(struct dbll_tar_obj **target_obj,
+			      struct dbll_attrs *pattrs);
+extern void dbll_delete(struct dbll_tar_obj *target);
+extern void dbll_exit(void);
+extern bool dbll_get_addr(struct dbll_library_obj *lib, char *name,
+			  struct dbll_sym_val **ppSym);
+extern void dbll_get_attrs(struct dbll_tar_obj *target,
+			   struct dbll_attrs *pattrs);
+extern bool dbll_get_c_addr(struct dbll_library_obj *lib, char *name,
+			    struct dbll_sym_val **ppSym);
+extern dsp_status dbll_get_sect(struct dbll_library_obj *lib, char *name,
+				u32 *paddr, u32 *psize);
+extern bool dbll_init(void);
+extern dsp_status dbll_load(struct dbll_library_obj *lib,
+			    dbll_flags flags,
+			    struct dbll_attrs *attrs, u32 * pEntry);
+extern dsp_status dbll_load_sect(struct dbll_library_obj *lib,
+				 char *sectName, struct dbll_attrs *attrs);
+extern dsp_status dbll_open(struct dbll_tar_obj *target, char *file,
+			    dbll_flags flags, struct dbll_library_obj **pLib);
+extern dsp_status dbll_read_sect(struct dbll_library_obj *lib,
+				 char *name, char *pbuf, u32 size);
+extern void dbll_set_attrs(struct dbll_tar_obj *target,
+			   struct dbll_attrs *pattrs);
+extern void dbll_unload(struct dbll_library_obj *lib, struct dbll_attrs *attrs);
+extern dsp_status dbll_unload_sect(struct dbll_library_obj *lib,
+				   char *sectName, struct dbll_attrs *attrs);
 
+#endif /* DBLL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dblldefs.h b/arch/arm/plat-omap/include/dspbridge/dblldefs.h
index 21e661d..e223518 100644
--- a/arch/arm/plat-omap/include/dspbridge/dblldefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dblldefs.h
@@ -18,7 +18,7 @@
 #define DBLLDEFS_
 
 /*
- *  Bit masks for DBL_Flags.
+ *  Bit masks for dbl_flags.
  */
 #define DBLL_NOLOAD   0x0	/* Don't load symbols, code, or data */
 #define DBLL_SYMB     0x1	/* load symbols */
@@ -29,99 +29,99 @@
 
 #define DBLL_MAXPATHLENGTH       255
 
-
 /*
  *  ======== DBLL_Target ========
  *
  */
-struct DBLL_TarObj;
+struct dbll_tar_obj;
 
 /*
- *  ======== DBLL_Flags ========
+ *  ======== dbll_flags ========
  *  Specifies whether to load code, data, or symbols
  */
-typedef s32 DBLL_Flags;
+typedef s32 dbll_flags;
 
 /*
  *  ======== DBLL_Library ========
  *
  */
-struct DBLL_LibraryObj;
+struct dbll_library_obj;
 
 /*
- *  ======== DBLL_SectInfo ========
+ *  ======== dbll_sect_info ========
  *  For collecting info on overlay sections
  */
-struct DBLL_SectInfo {
+struct dbll_sect_info {
 	const char *name;	/* name of section */
-	u32 runAddr;		/* run address of section */
-	u32 loadAddr;		/* load address of section */
+	u32 sect_run_addr;	/* run address of section */
+	u32 sect_load_addr;	/* load address of section */
 	u32 size;		/* size of section (target MAUs) */
-	DBLL_Flags type;	/* Code, data, or BSS */
-} ;
+	dbll_flags type;	/* Code, data, or BSS */
+};
 
 /*
- *  ======== DBLL_Symbol ========
+ *  ======== dbll_sym_val ========
  *  (Needed for dynamic load library)
  */
-struct DBLL_Symbol {
+struct dbll_sym_val {
 	u32 value;
 };
 
 /*
- *  ======== DBLL_AllocFxn ========
+ *  ======== dbll_alloc_fxn ========
  *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
  *  "size" bytes of memory from segment "space" and return the address in
  *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
  *  success, or an error code on failure.
  */
-typedef s32(*DBLL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
-			     u32 *dspAddr, s32 segId, s32 req,
-			     bool reserved);
+typedef s32(*dbll_alloc_fxn) (void *hdl, s32 space, u32 size, u32 align,
+			      u32 *dspAddr, s32 seg_id, s32 req,
+			      bool reserved);
 
 /*
- *  ======== DBLL_CloseFxn ========
+ *  ======== dbll_close_fxn ========
  */
-typedef s32(*DBLL_FCloseFxn) (void *);
+typedef s32(*dbll_f_close_fxn) (void *);
 
 /*
- *  ======== DBLL_FreeFxn ========
+ *  ======== dbll_free_fxn ========
  *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
  *  bytes of memory from segment "space"
  */
-typedef bool(*DBLL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
-			     bool reserved);
+typedef bool(*dbll_free_fxn) (void *hdl, u32 addr, s32 space, u32 size,
+			      bool reserved);
 
 /*
- *  ======== DBLL_FOpenFxn ========
+ *  ======== dbll_f_open_fxn ========
  */
-typedef void *(*DBLL_FOpenFxn) (const char *, const char *);
+typedef void *(*dbll_f_open_fxn) (const char *, const char *);
 
 /*
- *  ======== DBLL_LogWriteFxn ========
+ *  ======== dbll_log_write_fxn ========
  *  Function to call when writing data from a section, to log the info.
  *  Can be NULL if no logging is required.
  */
-typedef DSP_STATUS(*DBLL_LogWriteFxn)(void *handle, struct DBLL_SectInfo *sect,
-				       u32 addr, u32 nBytes);
+typedef dsp_status(*dbll_log_write_fxn) (void *handle,
+					 struct dbll_sect_info *sect, u32 addr,
+					 u32 bytes);
 
 /*
- *  ======== DBLL_ReadFxn ========
+ *  ======== dbll_read_fxn ========
  */
-typedef s32(*DBLL_ReadFxn) (void *, size_t, size_t, void *);
+typedef s32(*dbll_read_fxn) (void *, size_t, size_t, void *);
 
 /*
- *  ======== DBLL_SeekFxn ========
+ *  ======== dbll_seek_fxn ========
  */
-typedef s32(*DBLL_SeekFxn) (void *, long, int);
+typedef s32(*dbll_seek_fxn) (void *, long, int);
 
 /*
- *  ======== DBLL_SymLookup ========
+ *  ======== dbll_sym_lookup ========
  *  Symbol lookup function - Find the symbol name and return its value.
  *
  *  Parameters:
  *      handle          - Opaque handle
- *      pArg            - Opaque argument.
+ *      parg            - Opaque argument.
  *      name            - Name of symbol to lookup.
  *      sym             - Location to store address of symbol structure.
  *
@@ -129,40 +129,40 @@ typedef s32(*DBLL_SeekFxn) (void *, long, int);
  *      TRUE:           Success (symbol was found).
  *      FALSE:          Failed to find symbol.
  */
-typedef bool(*DBLL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
-			       const char *name, struct DBLL_Symbol **sym);
+typedef bool(*dbll_sym_lookup) (void *handle, void *parg, void *rmm_handle,
+				const char *name, struct dbll_sym_val ** sym);
 
 /*
- *  ======== DBLL_TellFxn ========
+ *  ======== dbll_tell_fxn ========
  */
-typedef s32(*DBLL_TellFxn) (void *);
+typedef s32(*dbll_tell_fxn) (void *);
 
 /*
- *  ======== DBLL_WriteFxn ========
+ *  ======== dbll_write_fxn ========
  *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
  *  starting at address "dspAddr" from the buffer "buf".  The buffer is
  *  formatted as an array of words appropriate for the DSP.
  */
-typedef s32(*DBLL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
-			     u32 n, s32 mtype);
+typedef s32(*dbll_write_fxn) (void *hdl, u32 dspAddr, void *buf,
+			      u32 n, s32 mtype);
 
 /*
- *  ======== DBLL_Attrs ========
+ *  ======== dbll_attrs ========
  */
-struct DBLL_Attrs {
-	DBLL_AllocFxn alloc;
-	DBLL_FreeFxn free;
-	void *rmmHandle;	/* Handle to pass to alloc, free functions */
-	DBLL_WriteFxn write;
-	void *wHandle;		/* Handle to pass to write, cinit function */
-	bool baseImage;
-	DBLL_LogWriteFxn logWrite;
-	void *logWriteHandle;
+struct dbll_attrs {
+	dbll_alloc_fxn alloc;
+	dbll_free_fxn free;
+	void *rmm_handle;	/* Handle to pass to alloc, free functions */
+	dbll_write_fxn write;
+	void *input_params;	/* Handle to pass to write, cinit function */
+	bool base_image;
+	dbll_log_write_fxn log_write;
+	void *log_write_handle;
 
 	/* Symbol matching function and handle to pass to it */
-	DBLL_SymLookup symLookup;
-	void *symHandle;
-	void *symArg;
+	dbll_sym_lookup sym_lookup;
+	void *sym_handle;
+	void *sym_arg;
 
 	/*
 	 *  These file manipulation functions should be compatible with the
@@ -173,43 +173,43 @@ struct DBLL_Attrs {
 	 s32(*ftell) (void *);
 	 s32(*fclose) (void *);
 	void *(*fopen) (const char *, const char *);
-} ;
+};
 
 /*
- *  ======== DBLL_close ========
- *  Close library opened with DBLL_open.
+ *  ======== dbll_close ========
+ *  Close library opened with dbll_open.
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *  Returns:
  *  Requires:
  *      DBL initialized.
  *      Valid lib.
  *  Ensures:
  */
-typedef void(*DBLL_CloseFxn) (struct DBLL_LibraryObj *library);
+typedef void (*dbll_close_fxn) (struct dbll_library_obj *library);
 
 /*
- *  ======== DBLL_create ========
+ *  ======== dbll_create ========
  *  Create a target object, specifying the alloc, free, and write functions.
  *  Parameters:
- *      pTarget         - Location to store target handle on output.
- *      pAttrs          - Attributes.
+ *      target_obj         - Location to store target handle on output.
+ *      pattrs          - Attributes.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failed.
  *  Requires:
  *      DBL initialized.
- *      pAttrs != NULL.
- *      pTarget != NULL;
+ *      pattrs != NULL.
+ *      target_obj != NULL;
  *  Ensures:
- *      Success:        *pTarget != NULL.
- *      Failure:        *pTarget == NULL.
+ *      Success:        *target_obj != NULL.
+ *      Failure:        *target_obj == NULL.
  */
-typedef DSP_STATUS(*DBLL_CreateFxn)(struct DBLL_TarObj **pTarget,
-				    struct DBLL_Attrs *attrs);
+typedef dsp_status(*dbll_create_fxn) (struct dbll_tar_obj **target_obj,
+				      struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_delete ========
+ *  ======== dbll_delete ========
  *  Delete target object and free resources for any loaded libraries.
  *  Parameters:
  *      target          - Handle returned from DBLL_Create().
@@ -219,25 +219,25 @@ typedef DSP_STATUS(*DBLL_CreateFxn)(struct DBLL_TarObj **pTarget,
  *      Valid target.
  *  Ensures:
  */
-typedef void(*DBLL_DeleteFxn) (struct DBLL_TarObj *target);
+typedef void (*dbll_delete_fxn) (struct dbll_tar_obj *target);
 
 /*
- *  ======== DBLL_exit ========
+ *  ======== dbll_exit ========
  *  Discontinue use of DBL module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      cRefs > 0.
+ *      refs > 0.
  *  Ensures:
- *      cRefs >= 0.
+ *      refs >= 0.
  */
-typedef void(*DBLL_ExitFxn) (void);
+typedef void (*dbll_exit_fxn) (void);
 
 /*
- *  ======== DBLL_getAddr ========
+ *  ======== dbll_get_addr ========
  *  Get address of name in the specified library.
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      name            - Name of symbol
  *      ppSym           - Location to store symbol address on output.
  *  Returns:
@@ -250,30 +250,30 @@ typedef void(*DBLL_ExitFxn) (void);
  *      ppSym != NULL.
  *  Ensures:
  */
-typedef bool(*DBLL_GetAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
-				struct DBLL_Symbol **ppSym);
+typedef bool(*dbll_get_addr_fxn) (struct dbll_library_obj *lib, char *name,
+				  struct dbll_sym_val **ppSym);
 
 /*
- *  ======== DBLL_getAttrs ========
+ *  ======== dbll_get_attrs ========
  *  Retrieve the attributes of the target.
  *  Parameters:
  *      target          - Handle returned from DBLL_Create().
- *      pAttrs          - Location to store attributes on output.
+ *      pattrs          - Location to store attributes on output.
  *  Returns:
  *  Requires:
  *      DBL initialized.
  *      Valid target.
- *      pAttrs != NULL.
+ *      pattrs != NULL.
  *  Ensures:
  */
-typedef void(*DBLL_GetAttrsFxn) (struct DBLL_TarObj *target,
-				 struct DBLL_Attrs *attrs);
+typedef void (*dbll_get_attrs_fxn) (struct dbll_tar_obj *target,
+				    struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_getCAddr ========
+ *  ======== dbll_get_c_addr ========
  *  Get address of "C" name on the specified library.
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      name            - Name of symbol
  *      ppSym           - Location to store symbol address on output.
  *  Returns:
@@ -286,17 +286,17 @@ typedef void(*DBLL_GetAttrsFxn) (struct DBLL_TarObj *target,
  *      ppSym != NULL.
  *  Ensures:
  */
-typedef bool(*DBLL_GetCAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
-				 struct DBLL_Symbol **ppSym);
+typedef bool(*dbll_get_c_addr_fxn) (struct dbll_library_obj *lib, char *name,
+				    struct dbll_sym_val **ppSym);
 
 /*
- *  ======== DBLL_getSect ========
+ *  ======== dbll_get_sect ========
  *  Get address and size of a named section.
  *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
+ *      lib             - Library handle returned from dbll_open().
  *      name            - Name of section.
- *      pAddr           - Location to store section address on output.
- *      pSize           - Location to store section size on output.
+ *      paddr           - Location to store section address on output.
+ *      psize           - Location to store section size on output.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ENOSECT:    Section not found.
@@ -304,34 +304,34 @@ typedef bool(*DBLL_GetCAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
  *      DBL initialized.
  *      Valid lib.
  *      name != NULL.
- *      pAddr != NULL;
- *      pSize != NULL.
+ *      paddr != NULL;
+ *      psize != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_GetSectFxn) (struct DBLL_LibraryObj *lib, char *name,
-				      u32 *addr, u32 *size);
+typedef dsp_status(*dbll_get_sect_fxn) (struct dbll_library_obj *lib,
+					char *name, u32 * addr, u32 * size);
 
 /*
- *  ======== DBLL_init ========
+ *  ======== dbll_init ========
  *  Initialize DBL module.
  *  Parameters:
  *  Returns:
  *      TRUE:           Success.
  *      FALSE:          Failure.
  *  Requires:
- *      cRefs >= 0.
+ *      refs >= 0.
  *  Ensures:
- *      Success:        cRefs > 0.
- *      Failure:        cRefs >= 0.
+ *      Success:        refs > 0.
+ *      Failure:        refs >= 0.
  */
-typedef bool(*DBLL_InitFxn) (void);
+typedef bool(*dbll_init_fxn) (void);
 
 /*
- *  ======== DBLL_load ========
+ *  ======== dbll_load ========
  *  Load library onto the target.
  *
  *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
+ *      lib             - Library handle returned from dbll_open().
  *      flags           - Load code, data and/or symbols.
  *      attrs           - May contain alloc, free, and write function.
  *      pulEntry        - Location to store program entry on output.
@@ -346,15 +346,15 @@ typedef bool(*DBLL_InitFxn) (void);
  *      pEntry != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_LoadFxn) (struct DBLL_LibraryObj *lib,
-				   DBLL_Flags flags,
-				   struct DBLL_Attrs *attrs, u32 *entry);
+typedef dsp_status(*dbll_load_fxn) (struct dbll_library_obj *lib,
+				    dbll_flags flags,
+				    struct dbll_attrs *attrs, u32 *entry);
 
 /*
- *  ======== DBLL_loadSect ========
+ *  ======== dbll_load_sect ========
  *  Load a named section from an library (for overlay support).
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      sectName        - Name of section to load.
  *      attrs           - Contains write function and handle to pass to it.
  *  Returns:
@@ -369,16 +369,16 @@ typedef DSP_STATUS(*DBLL_LoadFxn) (struct DBLL_LibraryObj *lib,
  *      attrs->write != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_LoadSectFxn) (struct DBLL_LibraryObj *lib,
-				       char *pszSectName,
-				       struct DBLL_Attrs *attrs);
+typedef dsp_status(*dbll_load_sect_fxn) (struct dbll_library_obj *lib,
+					 char *pszSectName,
+					 struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_open ========
- *  DBLL_open() returns a library handle that can be used to load/unload
- *  the symbols/code/data via DBLL_load()/DBLL_unload().
+ *  ======== dbll_open ========
+ *  dbll_open() returns a library handle that can be used to load/unload
+ *  the symbols/code/data via dbll_load()/dbll_unload().
  *  Parameters:
- *      target          - Handle returned from DBLL_create().
+ *      target          - Handle returned from dbll_create().
  *      file            - Name of file to open.
  *      flags           - If flags & DBLL_SYMB, load symbols.
  *      pLib            - Location to store library handle on output.
@@ -393,22 +393,22 @@ typedef DSP_STATUS(*DBLL_LoadSectFxn) (struct DBLL_LibraryObj *lib,
  *      Valid target.
  *      file != NULL.
  *      pLib != NULL.
- *      DBLL_Attrs fopen function non-NULL.
+ *      dbll_attrs fopen function non-NULL.
  *  Ensures:
  *      Success:        Valid *pLib.
  *      Failure:        *pLib == NULL.
  */
-typedef DSP_STATUS(*DBLL_OpenFxn) (struct DBLL_TarObj *target, char *file,
-				   DBLL_Flags flags,
-				   struct DBLL_LibraryObj **pLib);
+typedef dsp_status(*dbll_open_fxn) (struct dbll_tar_obj *target, char *file,
+				    dbll_flags flags,
+				    struct dbll_library_obj **pLib);
 
 /*
- *  ======== DBLL_readSect ========
+ *  ======== dbll_read_sect ========
  *  Read COFF section into a character buffer.
  *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
+ *      lib             - Library handle returned from dbll_open().
  *      name            - Name of section.
- *      pBuf            - Buffer to write section contents into.
+ *      pbuf            - Buffer to write section contents into.
  *      size            - Buffer size
  *  Returns:
  *      DSP_SOK:        Success.
@@ -417,34 +417,35 @@ typedef DSP_STATUS(*DBLL_OpenFxn) (struct DBLL_TarObj *target, char *file,
  *      DBL initialized.
  *      Valid lib.
  *      name != NULL.
- *      pBuf != NULL.
+ *      pbuf != NULL.
  *      size != 0.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_ReadSectFxn) (struct DBLL_LibraryObj *lib, char *name,
-				       char *content, u32 uContentSize);
+typedef dsp_status(*dbll_read_sect_fxn) (struct dbll_library_obj *lib,
+					 char *name, char *content,
+					 u32 uContentSize);
 
 /*
- *  ======== DBLL_setAttrs ========
+ *  ======== dbll_set_attrs ========
  *  Set the attributes of the target.
  *  Parameters:
- *      target          - Handle returned from DBLL_create().
- *      pAttrs          - New attributes.
+ *      target          - Handle returned from dbll_create().
+ *      pattrs          - New attributes.
  *  Returns:
  *  Requires:
  *      DBL initialized.
  *      Valid target.
- *      pAttrs != NULL.
+ *      pattrs != NULL.
  *  Ensures:
  */
-typedef void(*DBLL_SetAttrsFxn)(struct DBLL_TarObj *target,
-				struct DBLL_Attrs *attrs);
+typedef void (*dbll_set_attrs_fxn) (struct dbll_tar_obj *target,
+				    struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_unload ========
- *  Unload library loaded with DBLL_load().
+ *  ======== dbll_unload ========
+ *  Unload library loaded with dbll_load().
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      attrs           - Contains free() function and handle to pass to it.
  *  Returns:
  *  Requires:
@@ -452,14 +453,14 @@ typedef void(*DBLL_SetAttrsFxn)(struct DBLL_TarObj *target,
  *      Valid lib.
  *  Ensures:
  */
-typedef void(*DBLL_UnloadFxn) (struct DBLL_LibraryObj *library,
-			       struct DBLL_Attrs *attrs);
+typedef void (*dbll_unload_fxn) (struct dbll_library_obj *library,
+				 struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_unloadSect ========
+ *  ======== dbll_unload_sect ========
  *  Unload a named section from an library (for overlay support).
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      sectName        - Name of section to load.
  *      attrs           - Contains free() function and handle to pass to it.
  *  Returns:
@@ -472,27 +473,27 @@ typedef void(*DBLL_UnloadFxn) (struct DBLL_LibraryObj *library,
  *      sectName != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_UnloadSectFxn) (struct DBLL_LibraryObj *lib,
-					 char *pszSectName,
-					 struct DBLL_Attrs *attrs);
-
-struct DBLL_Fxns {
-	DBLL_CloseFxn closeFxn;
-	DBLL_CreateFxn createFxn;
-	DBLL_DeleteFxn deleteFxn;
-	DBLL_ExitFxn exitFxn;
-	DBLL_GetAttrsFxn getAttrsFxn;
-	DBLL_GetAddrFxn getAddrFxn;
-	DBLL_GetCAddrFxn getCAddrFxn;
-	DBLL_GetSectFxn getSectFxn;
-	DBLL_InitFxn initFxn;
-	DBLL_LoadFxn loadFxn;
-	DBLL_LoadSectFxn loadSectFxn;
-	DBLL_OpenFxn openFxn;
-	DBLL_ReadSectFxn readSectFxn;
-	DBLL_SetAttrsFxn setAttrsFxn;
-	DBLL_UnloadFxn unloadFxn;
-	DBLL_UnloadSectFxn unloadSectFxn;
-} ;
-
-#endif				/* DBLDEFS_ */
+typedef dsp_status(*dbll_unload_sect_fxn) (struct dbll_library_obj *lib,
+					   char *pszSectName,
+					   struct dbll_attrs *attrs);
+
+struct dbll_fxns {
+	dbll_close_fxn close_fxn;
+	dbll_create_fxn create_fxn;
+	dbll_delete_fxn delete_fxn;
+	dbll_exit_fxn exit_fxn;
+	dbll_get_attrs_fxn get_attrs_fxn;
+	dbll_get_addr_fxn get_addr_fxn;
+	dbll_get_c_addr_fxn get_c_addr_fxn;
+	dbll_get_sect_fxn get_sect_fxn;
+	dbll_init_fxn init_fxn;
+	dbll_load_fxn load_fxn;
+	dbll_load_sect_fxn load_sect_fxn;
+	dbll_open_fxn open_fxn;
+	dbll_read_sect_fxn read_sect_fxn;
+	dbll_set_attrs_fxn set_attrs_fxn;
+	dbll_unload_fxn unload_fxn;
+	dbll_unload_sect_fxn unload_sect_fxn;
+};
+
+#endif /* DBLDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbtype.h b/arch/arm/plat-omap/include/dspbridge/dbtype.h
index 019652e..ff58370 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbtype.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbtype.h
@@ -21,9 +21,9 @@
 #ifndef DBTYPE_
 #define DBTYPE_
 
-/*============================================================================*/
-/*  Argument specification syntax                                             */
-/*============================================================================*/
+/*===========================================================================*/
+/*  Argument specification syntax */
+/*===========================================================================*/
 
 #ifndef IN
 #define IN			/* Following parameter is for input. */
@@ -34,16 +34,16 @@
 #endif
 
 #ifndef OPTIONAL
-#define OPTIONAL	  /* Function may optionally use previous parameter. */
+#define OPTIONAL	/* Function may optionally use previous parameter. */
 #endif
 
 #ifndef CONST
 #define CONST   const
 #endif
 
-/*============================================================================*/
-/*  Boolean constants                                                         */
-/*============================================================================*/
+/*===========================================================================*/
+/*  Boolean constants */
+/*===========================================================================*/
 
 #ifndef FALSE
 #define FALSE   0
@@ -52,32 +52,32 @@
 #define TRUE    1
 #endif
 
-/*============================================================================*/
-/*  NULL    (Definition is language specific)                                 */
-/*============================================================================*/
+/*===========================================================================*/
+/*  NULL    (Definition is language specific) */
+/*===========================================================================*/
 
 #ifndef NULL
 #define NULL    ((void *)0)	/* Null pointer. */
 #endif
 
-/*============================================================================*/
-/*  NULL character   (normally used for string termination)                   */
-/*============================================================================*/
+/*===========================================================================*/
+/*  NULL character   (normally used for string termination) */
+/*===========================================================================*/
 
 #ifndef NULL_CHAR
 #define NULL_CHAR    '\0'	/* Null character. */
 #endif
 
-/*============================================================================*/
-/*  Basic Type definitions (with Prefixes for Hungarian notation)             */
-/*============================================================================*/
+/*===========================================================================*/
+/*  Basic Type definitions (with Prefixes for Hungarian notation) */
+/*===========================================================================*/
 
 #ifndef OMAPBRIDGE_TYPES
 #define OMAPBRIDGE_TYPES
-typedef volatile unsigned short REG_UWORD16;
+typedef volatile unsigned short reg_uword16;
 #endif
 
-typedef void *HANDLE;		/* h    */
+typedef void *bhandle;		/* h */
 
 #define TEXT(x) x
 
@@ -87,4 +87,4 @@ typedef void *HANDLE;		/* h    */
 /* Define DSPAPIDLL correctly in dspapi.h */
 #define _DSPSYSDLL32_
 
-#endif				/* DBTYPE_ */
+#endif /* DBTYPE_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dehdefs.h b/arch/arm/plat-omap/include/dspbridge/dehdefs.h
index 587df7f..f6eff70 100644
--- a/arch/arm/plat-omap/include/dspbridge/dehdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dehdefs.h
@@ -19,14 +19,14 @@
 #ifndef DEHDEFS_
 #define DEHDEFS_
 
-#include <dspbridge/mbx_sh.h>		/* shared mailbox codes */
+#include <dspbridge/mbx_sh.h>	/* shared mailbox codes */
 
 /* DEH object manager */
-	struct DEH_MGR;
+struct deh_mgr;
 
 /* Magic code used to determine if DSP signaled exception. */
 #define DEH_BASE        MBX_DEH_BASE
 #define DEH_USERS_BASE  MBX_DEH_USERS_BASE
 #define DEH_LIMIT       MBX_DEH_LIMIT
 
-#endif				/* _DEHDEFS_H */
+#endif /* _DEHDEFS_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/dev.h b/arch/arm/plat-omap/include/dspbridge/dev.h
index cb594f7..13b0cad 100644
--- a/arch/arm/plat-omap/include/dspbridge/dev.h
+++ b/arch/arm/plat-omap/include/dspbridge/dev.h
@@ -33,19 +33,18 @@
 /*  ----------------------------------- This */
 #include <dspbridge/devdefs.h>
 
-
 /*
- *  ======== DEV_BrdWriteFxn ========
+ *  ======== dev_brd_write_fxn ========
  *  Purpose:
  *      Exported function to be used as the COD write function.  This function
  *      is passed a handle to a DEV_hObject by ZL in pArb, then calls the
- *      device's WMD_BRD_Write() function.
+ *      device's bridge_brd_write() function.
  *  Parameters:
  *      pArb:           Handle to a Device Object.
  *      hDevContext:    Handle to mini-driver defined device info.
  *      dwDSPAddr:      Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
+ *      ul_num_bytes:     Number of bytes to transfer.
  *      ulMemType:      Memory space on DSP to which to transfer.
  *  Returns:
  *      Number of bytes written.  Returns 0 if the DEV_hObject passed in via
@@ -55,13 +54,12 @@
  *      pHostBuf != NULL
  *  Ensures:
  */
-       extern u32 DEV_BrdWriteFxn(void *pArb,
-					   u32 ulDspAddr,
-					   void *pHostBuf,
-					   u32 ulNumBytes, u32 nMemSpace);
+extern u32 dev_brd_write_fxn(void *pArb,
+			     u32 ulDspAddr,
+			     void *pHostBuf, u32 ul_num_bytes, u32 nMemSpace);
 
 /*
- *  ======== DEV_CreateDevice ========
+ *  ======== dev_create_device ========
  *  Purpose:
  *      Called by the operating system to load the 'Bridge Mini Driver for a
  *      'Bridge device.
@@ -71,17 +69,17 @@
  *                      path is not provided, the file is loaded through
  *                      'Bridge's module search path.
  *      pHostConfig:    Host configuration information, to be passed down
- *                      to the WMD when WMD_DEV_Create() is called.
+ *                      to the WMD when bridge_dev_create() is called.
  *      pDspConfig:     DSP resources, to be passed down to the WMD when
- *                      WMD_DEV_Create() is called.
- *      hDevNode:       Platform (Windows) specific device node.
+ *                      bridge_dev_create() is called.
+ *      dev_node_obj:       Platform (Windows) specific device node.
  *  Returns:
  *      DSP_SOK:            Module is loaded, device object has been created
  *      DSP_EMEMORY:        Insufficient memory to create needed resources.
  *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
- *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
+ *      DEV_E_NULLWMDINTF:  WMD passed back a NULL fxn Interface Struct Ptr
  *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
- *                          for this hDevNode.
+ *                          for this dev_node_obj.
  *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
  *      LDR_E_NOMEMORY:         PELDR is out of resources.
  *      DSP_EFAIL:              Unable to find WMD entry point function.
@@ -98,17 +96,16 @@
  *      Otherwise, does not create the device object, ensures the WMD module is
  *      unloaded, and sets *phDevObject to NULL.
  */
-       extern DSP_STATUS DEV_CreateDevice(OUT struct DEV_OBJECT
-						 **phDevObject,
-						 IN CONST char *pstrWMDFileName,
-						 IN CONST struct CFG_HOSTRES
-						 *pHostConfig,
-						 IN CONST struct CFG_DSPRES
-						 *pDspConfig,
-						 struct CFG_DEVNODE *hDevNode);
+extern dsp_status dev_create_device(OUT struct dev_object
+				    **phDevObject,
+				    IN CONST char *pstrWMDFileName,
+				    IN CONST struct cfg_hostres
+				    *pHostConfig, IN CONST struct cfg_dspres
+				    *pDspConfig,
+				    struct cfg_devnode *dev_node_obj);
 
 /*
- *  ======== DEV_CreateIVADevice ========
+ *  ======== dev_create_iva_device ========
  *  Purpose:
  *      Called by the operating system to load the 'Bridge Mini Driver for IVA.
  *  Parameters:
@@ -117,17 +114,17 @@
  *                      path is not provided, the file is loaded through
  *                      'Bridge's module search path.
  *      pHostConfig:    Host configuration information, to be passed down
- *                      to the WMD when WMD_DEV_Create() is called.
+ *                      to the WMD when bridge_dev_create() is called.
  *      pDspConfig:     DSP resources, to be passed down to the WMD when
- *                      WMD_DEV_Create() is called.
- *      hDevNode:       Platform (Windows) specific device node.
+ *                      bridge_dev_create() is called.
+ *      dev_node_obj:       Platform (Windows) specific device node.
  *  Returns:
  *      DSP_SOK:            Module is loaded, device object has been created
  *      DSP_EMEMORY:        Insufficient memory to create needed resources.
  *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
- *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
+ *      DEV_E_NULLWMDINTF:  WMD passed back a NULL fxn Interface Struct Ptr
  *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
- *                          for this hDevNode.
+ *                          for this dev_node_obj.
  *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
  *      LDR_E_NOMEMORY:         PELDR is out of resources.
  *      DSP_EFAIL:              Unable to find WMD entry point function.
@@ -144,81 +141,82 @@
  *      Otherwise, does not create the device object, ensures the WMD module is
  *      unloaded, and sets *phDevObject to NULL.
  */
-       extern DSP_STATUS DEV_CreateIVADevice(OUT struct DEV_OBJECT
-				**phDevObject,
-				IN CONST char *pstrWMDFileName,
-				IN CONST struct CFG_HOSTRES *pHostConfig,
-				IN CONST struct CFG_DSPRES *pDspConfig,
-				struct CFG_DEVNODE *hDevNode);
+extern dsp_status dev_create_iva_device(OUT struct dev_object
+					**phDevObject,
+					IN CONST char *pstrWMDFileName,
+					IN CONST struct cfg_hostres
+					*pHostConfig,
+					IN CONST struct cfg_dspres *pDspConfig,
+					struct cfg_devnode *dev_node_obj);
 
 /*
- *  ======== DEV_Create2 ========
+ *  ======== dev_create2 ========
  *  Purpose:
- *      After successful loading of the image from WCD_InitComplete2
- *      (PROC Auto_Start) or PROC_Load this fxn is called. This creates
+ *      After successful loading of the image from wcd_init_complete2
+ *      (PROC Auto_Start) or proc_load this fxn is called. This creates
  *      the Node Manager and updates the DEV Object.
  *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      hdev_obj: Handle to device object created with dev_create_device().
  *  Returns:
  *      DSP_SOK:    Successful Creation of Node Manager
  *      DSP_EFAIL:  Some Error Occurred.
  *  Requires:
  *      DEV Initialized
- *      Valid hDevObject
+ *      Valid hdev_obj
  *  Ensures:
- *      DSP_SOK and hDevObject->hNodeMgr != NULL
- *      else    hDevObject->hNodeMgr == NULL
+ *      DSP_SOK and hdev_obj->hnode_mgr != NULL
+ *      else    hdev_obj->hnode_mgr == NULL
  */
-       extern DSP_STATUS DEV_Create2(IN struct DEV_OBJECT *hDevObject);
+extern dsp_status dev_create2(IN struct dev_object *hdev_obj);
 
 /*
- *  ======== DEV_Destroy2 ========
+ *  ======== dev_destroy2 ========
  *  Purpose:
  *      Destroys the Node manager for this device.
  *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      hdev_obj: Handle to device object created with dev_create_device().
  *  Returns:
  *      DSP_SOK:    Successful Creation of Node Manager
  *      DSP_EFAIL:  Some Error Occurred.
  *  Requires:
  *      DEV Initialized
- *      Valid hDevObject
+ *      Valid hdev_obj
  *  Ensures:
- *      DSP_SOK and hDevObject->hNodeMgr == NULL
+ *      DSP_SOK and hdev_obj->hnode_mgr == NULL
  *      else    DSP_EFAIL.
  */
-       extern DSP_STATUS DEV_Destroy2(IN struct DEV_OBJECT *hDevObject);
+extern dsp_status dev_destroy2(IN struct dev_object *hdev_obj);
 
 /*
- *  ======== DEV_DestroyDevice ========
+ *  ======== dev_destroy_device ========
  *  Purpose:
  *      Destroys the channel manager for this device, if any, calls
- *      WMD_DEV_Destroy(), and then attempts to unload the WMD module.
+ *      bridge_dev_destroy(), and then attempts to unload the WMD module.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *      DSP_EFAIL:      The WMD failed it's WMD_DEV_Destroy() function.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
+ *      DSP_EFAIL:      The WMD failed it's bridge_dev_destroy() function.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
  */
-       extern DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT
-						  *hDevObject);
+extern dsp_status dev_destroy_device(struct dev_object
+				     *hdev_obj);
 
 /*
- *  ======== DEV_GetChnlMgr ========
+ *  ======== dev_get_chnl_mgr ========
  *  Purpose:
  *      Retrieve the handle to the channel manager created for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phMgr:         Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phMgr != NULL.
  *      DEV Initialized.
@@ -227,21 +225,21 @@
  *                      or NULL.
  *      else:           *phMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetChnlMgr(struct DEV_OBJECT *hDevObject,
-					       OUT struct CHNL_MGR **phMgr);
+extern dsp_status dev_get_chnl_mgr(struct dev_object *hdev_obj,
+				   OUT struct chnl_mgr **phMgr);
 
 /*
- *  ======== DEV_GetCmmMgr ========
+ *  ======== dev_get_cmm_mgr ========
  *  Purpose:
  *      Retrieve the handle to the shared memory manager created for this
  *      device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phMgr:         Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phMgr != NULL.
  *      DEV Initialized.
@@ -250,21 +248,21 @@
  *                      or NULL.
  *      else:           *phMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetCmmMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct CMM_OBJECT **phMgr);
+extern dsp_status dev_get_cmm_mgr(struct dev_object *hdev_obj,
+				  OUT struct cmm_object **phMgr);
 
 /*
- *  ======== DEV_GetDmmMgr ========
+ *  ======== dev_get_dmm_mgr ========
  *  Purpose:
  *      Retrieve the handle to the dynamic memory manager created for this
  *      device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phMgr:         Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phMgr != NULL.
  *      DEV Initialized.
@@ -273,20 +271,20 @@
  *                      or NULL.
  *      else:           *phMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetDmmMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct DMM_OBJECT **phMgr);
+extern dsp_status dev_get_dmm_mgr(struct dev_object *hdev_obj,
+				  OUT struct dmm_object **phMgr);
 
 /*
- *  ======== DEV_GetCodMgr ========
+ *  ======== dev_get_cod_mgr ========
  *  Purpose:
  *      Retrieve the COD manager create for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phCodMgr:      Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phCodMgr != NULL.
  *      DEV Initialized.
@@ -294,19 +292,19 @@
  *      DSP_SOK:        *phCodMgr contains a handle to a COD manager object.
  *      else:           *phCodMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetCodMgr(struct DEV_OBJECT *hDevObject,
-					     OUT struct COD_MANAGER **phCodMgr);
+extern dsp_status dev_get_cod_mgr(struct dev_object *hdev_obj,
+				  OUT struct cod_manager **phCodMgr);
 
 /*
- *  ======== DEV_GetDehMgr ========
+ *  ======== dev_get_deh_mgr ========
  *  Purpose:
  *      Retrieve the DEH manager created for this device.
  *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      hdev_obj: Handle to device object created with dev_create_device().
  *      *phDehMgr:  Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:    Success.
- *      DSP_EHANDLE:   Invalid hDevObject.
+ *      DSP_EHANDLE:   Invalid hdev_obj.
  *  Requires:
  *      phDehMgr != NULL.
  *      DEH Initialized.
@@ -314,20 +312,20 @@
  *      DSP_SOK:    *phDehMgr contains a handle to a DEH manager object.
  *      else:       *phDehMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct DEH_MGR **phDehMgr);
+extern dsp_status dev_get_deh_mgr(struct dev_object *hdev_obj,
+				  OUT struct deh_mgr **phDehMgr);
 
 /*
- *  ======== DEV_GetDevNode ========
+ *  ======== dev_get_dev_node ========
  *  Purpose:
  *      Retrieve the platform specific device ID for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      phDevNode:      Ptr to location to get the device node handle.
  *  Returns:
- *      DSP_SOK:        In Win95, returns a DEVNODE in *hDevNode; In NT, ???
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_SOK:        In Win95, returns a DEVNODE in *dev_node_obj; In NT, ???
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phDevNode != NULL.
  *      DEV Initialized.
@@ -335,20 +333,20 @@
  *      DSP_SOK:        *phDevNode contains a platform specific device ID;
  *      else:           *phDevNode is NULL.
  */
-       extern DSP_STATUS DEV_GetDevNode(struct DEV_OBJECT *hDevObject,
-					OUT struct CFG_DEVNODE **phDevNode);
+extern dsp_status dev_get_dev_node(struct dev_object *hdev_obj,
+				   OUT struct cfg_devnode **phDevNode);
 
 /*
- *  ======== DEV_GetDevType ========
+ *  ======== dev_get_dev_type ========
  *  Purpose:
  *      Retrieve the platform specific device ID for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      phDevNode:      Ptr to location to get the device node handle.
  *  Returns:
  *      DSP_SOK:        Success
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phDevNode != NULL.
  *      DEV Initialized.
@@ -356,11 +354,11 @@
  *      DSP_SOK:        *phDevNode contains a platform specific device ID;
  *      else:           *phDevNode is NULL.
  */
-       extern DSP_STATUS DEV_GetDevType(struct DEV_OBJECT *hdevObject,
-					       u32 *devType);
+extern dsp_status dev_get_dev_type(struct dev_object *hdevObject,
+				   u32 *dev_type);
 
 /*
- *  ======== DEV_GetFirst ========
+ *  ======== dev_get_first ========
  *  Purpose:
  *      Retrieve the first Device Object handle from an internal linked list of
  *      of DEV_OBJECTs maintained by DEV.
@@ -369,27 +367,27 @@
  *      NULL if there are no device objects stored; else
  *      a valid DEV_HOBJECT.
  *  Requires:
- *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
- *      internal device object list) may occur between calls to DEV_GetFirst
- *      and DEV_GetNext.
+ *      No calls to dev_create_device or dev_destroy_device (which my modify the
+ *      internal device object list) may occur between calls to dev_get_first
+ *      and dev_get_next.
  *  Ensures:
  *      The DEV_HOBJECT returned is valid.
- *      A subsequent call to DEV_GetNext will return the next device object in
+ *      A subsequent call to dev_get_next will return the next device object in
  *      the list.
  */
-       extern struct DEV_OBJECT *DEV_GetFirst(void);
+extern struct dev_object *dev_get_first(void);
 
 /*
- *  ======== DEV_GetIntfFxns ========
+ *  ======== dev_get_intf_fxns ========
  *  Purpose:
  *      Retrieve the WMD interface function structure for the loaded WMD.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *ppIntfFxns:    Ptr to location to store fxn interface.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      ppIntfFxns != NULL.
  *      DEV Initialized.
@@ -397,20 +395,20 @@
  *      DSP_SOK:        *ppIntfFxns contains a pointer to the WMD interface;
  *      else:           *ppIntfFxns is NULL.
  */
-       extern DSP_STATUS DEV_GetIntfFxns(struct DEV_OBJECT *hDevObject,
-				OUT struct WMD_DRV_INTERFACE **ppIntfFxns);
+extern dsp_status dev_get_intf_fxns(struct dev_object *hdev_obj,
+				    OUT struct bridge_drv_interface **ppIntfFxns);
 
 /*
- *  ======== DEV_GetIOMgr ========
+ *  ======== dev_get_io_mgr ========
  *  Purpose:
  *      Retrieve the handle to the IO manager created for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phMgr:         Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phMgr != NULL.
  *      DEV Initialized.
@@ -418,58 +416,58 @@
  *      DSP_SOK:        *phMgr contains a handle to an IO manager object.
  *      else:           *phMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
-					     OUT struct IO_MGR **phMgr);
+extern dsp_status dev_get_io_mgr(struct dev_object *hdev_obj,
+				 OUT struct io_mgr **phMgr);
 
 /*
- *  ======== DEV_GetNext ========
+ *  ======== dev_get_next ========
  *  Purpose:
  *      Retrieve the next Device Object handle from an internal linked list of
  *      of DEV_OBJECTs maintained by DEV, after having previously called
- *      DEV_GetFirst() and zero or more DEV_GetNext
+ *      dev_get_first() and zero or more dev_get_next
  *  Parameters:
- *      hDevObject: Handle to the device object returned from a previous
- *                  call to DEV_GetFirst() or DEV_GetNext().
+ *      hdev_obj: Handle to the device object returned from a previous
+ *                  call to dev_get_first() or dev_get_next().
  *  Returns:
- *      NULL if there are no further device objects on the list or hDevObject
+ *      NULL if there are no further device objects on the list or hdev_obj
  *      was invalid;
  *      else the next valid DEV_HOBJECT in the list.
  *  Requires:
- *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
- *      internal device object list) may occur between calls to DEV_GetFirst
- *      and DEV_GetNext.
+ *      No calls to dev_create_device or dev_destroy_device (which my modify the
+ *      internal device object list) may occur between calls to dev_get_first
+ *      and dev_get_next.
  *  Ensures:
  *      The DEV_HOBJECT returned is valid.
- *      A subsequent call to DEV_GetNext will return the next device object in
+ *      A subsequent call to dev_get_next will return the next device object in
  *      the list.
  */
-       extern struct DEV_OBJECT *DEV_GetNext(struct DEV_OBJECT
-						    *hDevObject);
+extern struct dev_object *dev_get_next(struct dev_object
+				       *hdev_obj);
 
 /*
- *  ========= DEV_GetMsgMgr ========
+ *  ========= dev_get_msg_mgr ========
  *  Purpose:
- *      Retrieve the MSG Manager Handle from the DevObject.
+ *      Retrieve the msg_ctrl Manager Handle from the DevObject.
  *  Parameters:
- *      hDevObject: Handle to the Dev Object
- *      phMsgMgr:   Location where MSG Manager handle will be returned.
+ *      hdev_obj: Handle to the Dev Object
+ *      phMsgMgr:   Location where msg_ctrl Manager handle will be returned.
  *  Returns:
  *  Requires:
  *      DEV Initialized.
- *      Valid hDevObject.
+ *      Valid hdev_obj.
  *      phNodeMgr != NULL.
  *  Ensures:
  */
-       extern void DEV_GetMsgMgr(struct DEV_OBJECT *hDevObject,
-					OUT struct MSG_MGR **phMsgMgr);
+extern void dev_get_msg_mgr(struct dev_object *hdev_obj,
+			    OUT struct msg_mgr **phMsgMgr);
 
 /*
- *  ========= DEV_GetNodeManager ========
+ *  ========= dev_get_node_manager ========
  *  Purpose:
  *      Retrieve the Node Manager Handle from the DevObject. It is an
  *      accessor function
  *  Parameters:
- *      hDevObject:     Handle to the Dev Object
+ *      hdev_obj:     Handle to the Dev Object
  *      phNodeMgr:      Location where Handle to the Node Manager will be
  *                      returned..
  *  Returns:
@@ -482,45 +480,44 @@
  *      DSP_SOK:        *phNodeMgr contains a handle to a Node manager object.
  *      else:           *phNodeMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetNodeManager(struct DEV_OBJECT
-					*hDevObject,
-					OUT struct NODE_MGR **phNodeMgr);
+extern dsp_status dev_get_node_manager(struct dev_object
+				       *hdev_obj,
+				       OUT struct node_mgr **phNodeMgr);
 
 /*
- *  ======== DEV_GetSymbol ========
+ *  ======== dev_get_symbol ========
  *  Purpose:
  *      Get the value of a symbol in the currently loaded program.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      pstrSym:        Name of symbol to look up.
- *      pulValue:       Ptr to symbol value.
+ *      pul_value:       Ptr to symbol value.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
  *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
  *  Requires:
  *      pstrSym != NULL.
- *      pulValue != NULL.
+ *      pul_value != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      DSP_SOK:        *pulValue contains the symbol value;
+ *      DSP_SOK:        *pul_value contains the symbol value;
  */
-       extern DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
-					      IN CONST char *pstrSym,
-					      OUT u32 *pulValue);
+extern dsp_status dev_get_symbol(struct dev_object *hdev_obj,
+				 IN CONST char *pstrSym, OUT u32 * pul_value);
 
 /*
- *  ======== DEV_GetWMDContext ========
+ *  ======== dev_get_wmd_context ========
  *  Purpose:
  *      Retrieve the WMD Context handle, as returned by the WMD_Create fxn.
  *  Parameters:
- *      hDevObject:     Handle to device object created with DEV_CreateDevice()
+ *      hdev_obj:     Handle to device object created with dev_create_device()
  *      *phWmdContext:  Ptr to location to store context handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phWmdContext != NULL.
  *      DEV Initialized.
@@ -528,11 +525,12 @@
  *      DSP_SOK:        *phWmdContext contains context handle;
  *      else:           *phWmdContext is NULL;
  */
-       extern DSP_STATUS DEV_GetWMDContext(struct DEV_OBJECT *hDevObject,
-				OUT struct WMD_DEV_CONTEXT **phWmdContext);
+extern dsp_status dev_get_wmd_context(struct dev_object *hdev_obj,
+				      OUT struct wmd_dev_context
+				      **phWmdContext);
 
 /*
- *  ======== DEV_Exit ========
+ *  ======== dev_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
@@ -543,10 +541,10 @@
  *  Ensures:
  *      When reference count == 0, DEV's private resources are freed.
  */
-       extern void DEV_Exit(void);
+extern void dev_exit(void);
 
 /*
- *  ======== DEV_Init ========
+ *  ======== dev_init ========
  *  Purpose:
  *      Initialize DEV's private state, keeping a reference count on each call.
  *  Parameters:
@@ -556,40 +554,40 @@
  *  Ensures:
  *      TRUE: A requirement for the other public DEV functions.
  */
-       extern bool DEV_Init(void);
+extern bool dev_init(void);
 
 /*
- *  ======== DEV_IsLocked ========
+ *  ======== dev_is_locked ========
  *  Purpose:
  *      Predicate function to determine if the device has been
  *      locked by a client for exclusive access.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *  Returns:
  *      DSP_SOK:        TRUE: device has been locked.
  *      DSP_SFALSE:     FALSE: device not locked.
- *      DSP_EHANDLE:    hDevObject was invalid.
+ *      DSP_EHANDLE:    hdev_obj was invalid.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
  */
-       extern DSP_STATUS DEV_IsLocked(IN struct DEV_OBJECT *hDevObject);
+extern dsp_status dev_is_locked(IN struct dev_object *hdev_obj);
 
 /*
- *  ======== DEV_InsertProcObject ========
+ *  ======== dev_insert_proc_object ========
  *  Purpose:
  *      Inserts the Processor Object into the List of PROC Objects
  *      kept in the DEV Object
  *  Parameters:
- *      hProcObject:    Handle to the Proc Object
- *      hDevObject      Handle to the Dev Object
+ *      proc_obj:    Handle to the Proc Object
+ *      hdev_obj      Handle to the Dev Object
  *      bAttachedNew    Specifies if there are already processors attached
  *  Returns:
  *      DSP_SOK:        Successfully inserted into the list
  *  Requires:
- *      hProcObject is not NULL
- *      hDevObject is a valid handle to the DEV.
+ *      proc_obj is not NULL
+ *      hdev_obj is a valid handle to the DEV.
  *      DEV Initialized.
  *      List(of Proc object in Dev) Exists.
  *  Ensures:
@@ -599,52 +597,50 @@
  *      this is the first Processor attaching.
  *      If it is False, there are already processors attached.
  */
-       extern DSP_STATUS DEV_InsertProcObject(IN struct DEV_OBJECT
-						     *hDevObject,
-						     IN u32 hProcObject,
-						     OUT bool *
-						     pbAlreadyAttached);
+extern dsp_status dev_insert_proc_object(IN struct dev_object
+					 *hdev_obj,
+					 IN u32 proc_obj,
+					 OUT bool *pbAlreadyAttached);
 
 /*
- *  ======== DEV_RemoveProcObject ========
+ *  ======== dev_remove_proc_object ========
  *  Purpose:
  *      Search for and remove a Proc object from the given list maintained
  *      by the DEV
  *  Parameters:
- *      pProcObject:        Ptr to ProcObject to insert.
- *      pDevObject:         Ptr to Dev Object where the list is.
+ *      p_proc_object:        Ptr to ProcObject to insert.
+ *      dev_obj:         Ptr to Dev Object where the list is.
  *      pbAlreadyAttached:  Ptr to return the bool
  *  Returns:
  *      DSP_SOK:            If successful.
  *      DSP_EFAIL           Failure to Remove the PROC Object from the list
  *  Requires:
  *      DevObject is Valid
- *      hProcObject != 0
- *      pDevObject->procList != NULL
- *      !LST_IsEmpty(pDevObject->procList)
+ *      proc_obj != 0
+ *      dev_obj->proc_list != NULL
+ *      !LST_IS_EMPTY(dev_obj->proc_list)
  *      pbAlreadyAttached !=NULL
  *  Ensures:
  *  Details:
  *      List will be deleted when the DEV is destroyed.
  *
  */
-       extern DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT
-						     *hDevObject,
-						     u32 hProcObject);
+extern dsp_status dev_remove_proc_object(struct dev_object
+					 *hdev_obj, u32 proc_obj);
 
 /*
- *  ======== DEV_NotifyClients ========
+ *  ======== dev_notify_clients ========
  *  Purpose:
  *      Notify all clients of this device of a change in device status.
  *      Clients may include multiple users of BRD, as well as CHNL.
  *      This function is asychronous, and may be called by a timer event
  *      set up by a watchdog timer.
  *  Parameters:
- *      hDevObject:  Handle to device object created with DEV_CreateDevice().
+ *      hdev_obj:  Handle to device object created with dev_create_device().
  *      ulStatus:    A status word, most likely a BRD_STATUS.
  *  Returns:
  *      DSP_SOK:     All registered clients were asynchronously notified.
- *      DSP_EINVALIDARG:   Invalid hDevObject.
+ *      DSP_EINVALIDARG:   Invalid hdev_obj.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
@@ -652,67 +648,63 @@
  *      delivered to clients.  This function does not ensure that
  *      the notifications will ever be delivered.
  */
-       extern DSP_STATUS DEV_NotifyClients(struct DEV_OBJECT *hDevObject,
-						  u32 ulStatus);
-
-
+extern dsp_status dev_notify_clients(struct dev_object *hdev_obj, u32 ulStatus);
 
 /*
- *  ======== DEV_RemoveDevice ========
+ *  ======== dev_remove_device ========
  *  Purpose:
- *      Destroys the Device Object created by DEV_StartDevice.
+ *      Destroys the Device Object created by dev_start_device.
  *  Parameters:
- *      hDevNode:       Device node as it is know to OS.
+ *      dev_node_obj:       Device node as it is know to OS.
  *  Returns:
  *      DSP_SOK:        If success;
  *      <error code>    Otherwise.
  *  Requires:
  *  Ensures:
  */
-       extern DSP_STATUS DEV_RemoveDevice(struct CFG_DEVNODE *hDevNode);
+extern dsp_status dev_remove_device(struct cfg_devnode *dev_node_obj);
 
 /*
- *  ======== DEV_SetChnlMgr ========
+ *  ======== dev_set_chnl_mgr ========
  *  Purpose:
  *      Set the channel manager for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      hMgr:           Handle to a channel manager, or NULL.
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
+ *      hmgr:           Handle to a channel manager, or NULL.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
  */
-       extern DSP_STATUS DEV_SetChnlMgr(struct DEV_OBJECT *hDevObject,
-					       struct CHNL_MGR *hMgr);
+extern dsp_status dev_set_chnl_mgr(struct dev_object *hdev_obj,
+				   struct chnl_mgr *hmgr);
 
 /*
- *  ======== DEV_SetMsgMgr ========
+ *  ======== dev_set_msg_mgr ========
  *  Purpose:
  *      Set the Message manager for this device.
  *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
- *      hMgr:       Handle to a message manager, or NULL.
+ *      hdev_obj: Handle to device object created with dev_create_device().
+ *      hmgr:       Handle to a message manager, or NULL.
  *  Returns:
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
  */
-       extern void DEV_SetMsgMgr(struct DEV_OBJECT *hDevObject,
-					struct MSG_MGR *hMgr);
+extern void dev_set_msg_mgr(struct dev_object *hdev_obj, struct msg_mgr *hmgr);
 
 /*
- *  ======== DEV_StartDevice ========
+ *  ======== dev_start_device ========
  *  Purpose:
  *      Initializes the new device with the WinBRIDGE environment.  This
  *      involves querying CM for allocated resources, querying the registry
  *      for necessary dsp resources (requested in the INF file), and using
  *      this information to create a WinBRIDGE device object.
  *  Parameters:
- *      hDevNode:       Device node as it is know to OS.
+ *      dev_node_obj:       Device node as it is know to OS.
  *  Returns:
  *      DSP_SOK:        If success;
  *      <error code>    Otherwise.
@@ -720,6 +712,6 @@
  *      DEV initialized.
  *  Ensures:
  */
-       extern DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode);
+extern dsp_status dev_start_device(struct cfg_devnode *dev_node_obj);
 
-#endif				/* DEV_ */
+#endif /* DEV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/devdefs.h b/arch/arm/plat-omap/include/dspbridge/devdefs.h
index 08b2490..8c0adc1 100644
--- a/arch/arm/plat-omap/include/dspbridge/devdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/devdefs.h
@@ -21,6 +21,6 @@
 #define DEVDEFS_
 
 /* WCD Device Object */
-	struct DEV_OBJECT;
+struct dev_object;
 
-#endif				/* DEVDEFS_ */
+#endif /* DEVDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/disp.h b/arch/arm/plat-omap/include/dspbridge/disp.h
index 135f266..a6c8054 100644
--- a/arch/arm/plat-omap/include/dspbridge/disp.h
+++ b/arch/arm/plat-omap/include/dspbridge/disp.h
@@ -25,7 +25,7 @@
 #include <dspbridge/dispdefs.h>
 
 /*
- *  ======== DISP_Create ========
+ *  ======== disp_create ========
  *  Create a NODE Dispatcher object. This object handles the creation,
  *  deletion, and execution of nodes on the DSP target, through communication
  *  with the Resource Manager Server running on the target. Each NODE
@@ -33,56 +33,56 @@
  *
  *  Parameters:
  *      phDispObject:   Location to store node dispatcher object on output.
- *      hDevObject:     Device for this processor.
+ *      hdev_obj:     Device for this processor.
  *      pDispAttrs:     Node dispatcher attributes.
  *  Returns:
  *      DSP_SOK:                Success;
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
  *      DSP_EFAIL:              Unable to create dispatcher.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      pDispAttrs != NULL.
- *      hDevObject != NULL.
+ *      hdev_obj != NULL.
  *      phDispObject != NULL.
  *  Ensures:
- *      DSP_SOK:        IsValid(*phDispObject).
+ *      DSP_SOK:        IS_VALID(*phDispObject).
  *      error:          *phDispObject == NULL.
  */
-	extern DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct DISP_ATTRS *pDispAttrs);
+extern dsp_status disp_create(OUT struct disp_object **phDispObject,
+			      struct dev_object *hdev_obj,
+			      IN CONST struct disp_attr *pDispAttrs);
 
 /*
- *  ======== DISP_Delete ========
+ *  ======== disp_delete ========
  *  Delete the NODE Dispatcher.
  *
  *  Parameters:
  *      hDispObject:  Node Dispatcher object.
  *  Returns:
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
  *  Ensures:
  *      hDispObject is invalid.
  */
-	extern void DISP_Delete(struct DISP_OBJECT *hDispObject);
+extern void disp_delete(struct disp_object *hDispObject);
 
 /*
- *  ======== DISP_Exit ========
+ *  ======== disp_exit ========
  *  Discontinue usage of DISP module.
  *
  *  Parameters:
  *  Returns:
  *  Requires:
- *      DISP_Init(void) previously called.
+ *      disp_init(void) previously called.
  *  Ensures:
- *      Any resources acquired in DISP_Init(void) will be freed when last DISP
- *      client calls DISP_Exit(void).
+ *      Any resources acquired in disp_init(void) will be freed when last DISP
+ *      client calls disp_exit(void).
  */
-	extern void DISP_Exit(void);
+extern void disp_exit(void);
 
 /*
- *  ======== DISP_Init ========
+ *  ======== disp_init ========
  *  Initialize the DISP module.
  *
  *  Parameters:
@@ -90,45 +90,44 @@
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	extern bool DISP_Init(void);
+extern bool disp_init(void);
 
 /*
- *  ======== DISP_NodeChangePriority ========
+ *  ======== disp_node_change_priority ========
  *  Change the priority of a node currently running on the target.
  *
  *  Parameters:
  *      hDispObject:            Node Dispatcher object.
- *      hNode:                  Node object representing a node currently
+ *      hnode:                  Node object representing a node currently
  *                              allocated or running on the DSP.
  *      ulFxnAddress:           Address of RMS function for changing priority.
- *      nodeEnv:                Address of node's environment structure.
- *      nPriority:              New priority level to set node's priority to.
+ *      node_env:                Address of node's environment structure.
+ *      prio:              New priority level to set node's priority to.
  *  Returns:
  *      DSP_SOK:                Success.
  *      DSP_ETIMEOUT:           A timeout occurred before the DSP responded.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
- *      hNode != NULL.
+ *      hnode != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DISP_NodeChangePriority(struct DISP_OBJECT
-						  *hDispObject,
-						  struct NODE_OBJECT *hNode,
-						  u32 ulFxnAddr,
-						  NODE_ENV nodeEnv,
-						  s32 nPriority);
+extern dsp_status disp_node_change_priority(struct disp_object
+					    *hDispObject,
+					    struct node_object *hnode,
+					    u32 ul_fxn_addr,
+					    nodeenv node_env, s32 prio);
 
 /*
- *  ======== DISP_NodeCreate ========
+ *  ======== disp_node_create ========
  *  Create a node on the DSP by remotely calling the node's create function.
  *
  *  Parameters:
  *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node handle obtained from NODE_Allocate().
- *      ulFxnAddr:      Address or RMS create node function.
- *      ulCreateFxn:    Address of node's create function.
- *      pArgs:          Arguments to pass to RMS node create function.
+ *      hnode:          Node handle obtained from node_allocate().
+ *      ul_fxn_addr:      Address or RMS create node function.
+ *      ul_create_fxn:    Address of node's create function.
+ *      pargs:          Arguments to pass to RMS node create function.
  *      pNodeEnv:       Location to store node environment pointer on
  *                      output.
  *  Returns:
@@ -139,71 +138,70 @@
  *      DSP_EUSER:      A user-defined failure occurred.
  *      DSP_EFAIL:      A failure occurred, unable to create node.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
- *      pArgs != NULL.
- *      hNode != NULL.
+ *      pargs != NULL.
+ *      hnode != NULL.
  *      pNodeEnv != NULL.
- *      NODE_GetType(hNode) != NODE_DEVICE.
+ *      node_get_type(hnode) != NODE_DEVICE.
  *  Ensures:
  */
-	extern DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDispObject,
-					  struct NODE_OBJECT *hNode,
-					  u32 ulFxnAddr,
-					  u32 ulCreateFxn,
-					  IN CONST struct NODE_CREATEARGS
-					  *pArgs,
-					  OUT NODE_ENV *pNodeEnv);
+extern dsp_status disp_node_create(struct disp_object *hDispObject,
+				   struct node_object *hnode,
+				   u32 ul_fxn_addr,
+				   u32 ul_create_fxn,
+				   IN CONST struct node_createargs
+				   *pargs, OUT nodeenv *pNodeEnv);
 
 /*
- *  ======== DISP_NodeDelete ========
+ *  ======== disp_node_delete ========
  *  Delete a node on the DSP by remotely calling the node's delete function.
  *
  *  Parameters:
  *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node object representing a node currently
+ *      hnode:          Node object representing a node currently
  *                      loaded on the DSP.
- *      ulFxnAddr:      Address or RMS delete node function.
- *      ulDeleteFxn:    Address of node's delete function.
- *      nodeEnv:        Address of node's environment structure.
+ *      ul_fxn_addr:      Address or RMS delete node function.
+ *      ul_delete_fxn:    Address of node's delete function.
+ *      node_env:        Address of node's environment structure.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
- *      hNode != NULL.
+ *      hnode != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DISP_NodeDelete(struct DISP_OBJECT *hDispObject,
-					  struct NODE_OBJECT *hNode,
-					  u32 ulFxnAddr,
-					  u32 ulDeleteFxn, NODE_ENV nodeEnv);
+extern dsp_status disp_node_delete(struct disp_object *hDispObject,
+				   struct node_object *hnode,
+				   u32 ul_fxn_addr,
+				   u32 ul_delete_fxn, nodeenv node_env);
 
 /*
- *  ======== DISP_NodeRun ========
+ *  ======== disp_node_run ========
  *  Start execution of a node's execute phase, or resume execution of a node
  *  that has been suspended (via DISP_NodePause()) on the DSP.
  *
  *  Parameters:
  *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node object representing a node to be executed
+ *      hnode:          Node object representing a node to be executed
  *                      on the DSP.
- *      ulFxnAddr:      Address or RMS node execute function.
- *      ulExecuteFxn:   Address of node's execute function.
- *      nodeEnv:        Address of node's environment structure.
+ *      ul_fxn_addr:      Address or RMS node execute function.
+ *      ul_execute_fxn:   Address of node's execute function.
+ *      node_env:        Address of node's environment structure.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
- *      hNode != NULL.
+ *      hnode != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DISP_NodeRun(struct DISP_OBJECT *hDispObject,
-				       struct NODE_OBJECT *hNode,
-				       u32 ulFxnAddr,
-				       u32 ulExecuteFxn, NODE_ENV nodeEnv);
+extern dsp_status disp_node_run(struct disp_object *hDispObject,
+				struct node_object *hnode,
+				u32 ul_fxn_addr,
+				u32 ul_execute_fxn, nodeenv node_env);
 
-#endif				/* DISP_ */
+#endif /* DISP_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dispdefs.h b/arch/arm/plat-omap/include/dspbridge/dispdefs.h
index a9a2961..43321c8 100644
--- a/arch/arm/plat-omap/include/dspbridge/dispdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dispdefs.h
@@ -19,17 +19,17 @@
 #ifndef DISPDEFS_
 #define DISPDEFS_
 
-	struct DISP_OBJECT;
+struct disp_object;
 
 /* Node Dispatcher attributes */
-	struct DISP_ATTRS {
-		u32 ulChnlOffset; /* Offset of channel ids reserved for RMS */
-		/* Size of buffer for sending data to RMS */
-		u32 ulChnlBufSize;
-		long procFamily;	/* eg, 5000 */
-		long procType;		/* eg, 5510 */
-		HANDLE hReserved1;	/* Reserved for future use. */
-		u32 hReserved2;	/* Reserved for future use. */
-	} ;
+struct disp_attr {
+	u32 ul_chnl_offset;	/* Offset of channel ids reserved for RMS */
+	/* Size of buffer for sending data to RMS */
+	u32 ul_chnl_buf_size;
+	int proc_family;	/* eg, 5000 */
+	int proc_type;		/* eg, 5510 */
+	bhandle reserved1;	/* Reserved for future use. */
+	u32 reserved2;		/* Reserved for future use. */
+};
 
-#endif				/* DISPDEFS_ */
+#endif /* DISPDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dmm.h b/arch/arm/plat-omap/include/dspbridge/dmm.h
index 688473a..9a7edf3 100644
--- a/arch/arm/plat-omap/include/dspbridge/dmm.h
+++ b/arch/arm/plat-omap/include/dspbridge/dmm.h
@@ -22,51 +22,49 @@
 
 #include <dspbridge/dbdefs.h>
 
-	struct DMM_OBJECT;
+struct dmm_object;
 
-/* DMM attributes used in DMM_Create() */
-	struct DMM_MGRATTRS {
-		u32 reserved;
-	} ;
+/* DMM attributes used in dmm_create() */
+struct dmm_mgrattrs {
+	u32 reserved;
+};
 
-#define DMMPOOLSIZE      0x4000000
+#define DMMPOOLSIZE      0x10000000
 
 /*
- *  ======== DMM_GetHandle ========
+ *  ======== dmm_get_handle ========
  *  Purpose:
  *      Return the dynamic memory manager object for this device.
  *      This is typically called from the client process.
  */
 
-	extern DSP_STATUS DMM_GetHandle(void *hProcessor,
-					OUT struct DMM_OBJECT **phDmmMgr);
+extern dsp_status dmm_get_handle(void *hprocessor,
+				 OUT struct dmm_object **phDmmMgr);
 
-	extern DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr,
-					    u32 size,
-					    u32 *pRsvAddr);
+extern dsp_status dmm_reserve_memory(struct dmm_object *dmm_mgr,
+				     u32 size, u32 *prsv_addr);
 
-	extern DSP_STATUS DMM_UnReserveMemory(struct DMM_OBJECT *hDmmMgr,
-					      u32 rsvAddr);
+extern dsp_status dmm_un_reserve_memory(struct dmm_object *dmm_mgr,
+					u32 rsv_addr);
 
-	extern DSP_STATUS DMM_MapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr,
-					u32 size);
+extern dsp_status dmm_map_memory(struct dmm_object *dmm_mgr, u32 addr,
+				 u32 size);
 
-	extern DSP_STATUS DMM_UnMapMemory(struct DMM_OBJECT *hDmmMgr,
-					  u32 addr,
-					  u32 *pSize);
+extern dsp_status dmm_un_map_memory(struct dmm_object *dmm_mgr,
+				    u32 addr, u32 *psize);
 
-	extern DSP_STATUS DMM_Destroy(struct DMM_OBJECT *hDmmMgr);
+extern dsp_status dmm_destroy(struct dmm_object *dmm_mgr);
 
-	extern DSP_STATUS DMM_DeleteTables(struct DMM_OBJECT *hDmmMgr);
+extern dsp_status dmm_delete_tables(struct dmm_object *dmm_mgr);
 
-	extern DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     IN CONST struct DMM_MGRATTRS *pMgrAttrs);
+extern dsp_status dmm_create(OUT struct dmm_object **phDmmMgr,
+			     struct dev_object *hdev_obj,
+			     IN CONST struct dmm_mgrattrs *pMgrAttrs);
 
-	extern bool DMM_Init(void);
+extern bool dmm_init(void);
 
-	extern void DMM_Exit(void);
+extern void dmm_exit(void);
 
-	extern DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr,
-						u32 addr, u32 size);
-#endif				/* DMM_ */
+extern dsp_status dmm_create_tables(struct dmm_object *dmm_mgr,
+				    u32 addr, u32 size);
+#endif /* DMM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/drv.h b/arch/arm/plat-omap/include/dspbridge/drv.h
index 9e260b7..61ff51e 100644
--- a/arch/arm/plat-omap/include/dspbridge/drv.h
+++ b/arch/arm/plat-omap/include/dspbridge/drv.h
@@ -39,7 +39,6 @@
 #define OMAP_DSP_MEM1_SIZE 0x18000
 #define OMAP_DSP_GEM1_BASE 0x107F8000
 
-
 /* MEM2 is L1P RAM/CACHE space */
 #define OMAP_DSP_MEM2_BASE 0x5CE00000
 #define OMAP_DSP_MEM2_SIZE 0x8000
@@ -50,7 +49,6 @@
 #define OMAP_DSP_MEM3_SIZE 0x14000
 #define OMAP_DSP_GEM3_BASE 0x10F04000
 
-
 #define OMAP_IVA2_PRM_BASE 0x48306000
 #define OMAP_IVA2_PRM_SIZE 0x1000
 
@@ -78,66 +76,65 @@
 #define OMAP_PRCM_VDD1_DOMAIN 1
 #define OMAP_PRCM_VDD2_DOMAIN 2
 
-
 /* GPP PROCESS CLEANUP Data structures */
 
 /* New structure (member of process context) abstracts NODE resource info */
-struct NODE_RES_OBJECT {
-	void *hNode;
-	s32            nodeAllocated; /* Node status */
-	s32            heapAllocated; /* Heap status */
-	s32            streamsAllocated; /* Streams status */
-	struct NODE_RES_OBJECT         *next;
-} ;
+struct node_res_object {
+	void *hnode;
+	s32 node_allocated;	/* Node status */
+	s32 heap_allocated;	/* Heap status */
+	s32 streams_allocated;	/* Streams status */
+	struct node_res_object *next;
+};
 
 /* Used for DMM mapped memory accounting */
-struct DMM_MAP_OBJECT {
-	struct	list_head	link;
-	u32	dsp_addr;
+struct dmm_map_object {
+	struct list_head link;
+	u32 dsp_addr;
 };
 
 /* Used for DMM reserved memory accounting */
-struct DMM_RSV_OBJECT {
-	struct	list_head	link;
-	u32	dsp_reserved_addr;
+struct dmm_rsv_object {
+	struct list_head link;
+	u32 dsp_reserved_addr;
 };
 
 /* New structure (member of process context) abstracts DMM resource info */
-struct DSPHEAP_RES_OBJECT {
-	s32            heapAllocated; /* DMM status */
-	u32           ulMpuAddr;
-	u32           ulDSPAddr;
-	u32           ulDSPResAddr;
-	u32           heapSize;
-	HANDLE          hProcessor;
-	struct DSPHEAP_RES_OBJECT  *next;
-} ;
+struct dspheap_res_object {
+	s32 heap_allocated;	/* DMM status */
+	u32 ul_mpu_addr;
+	u32 ul_dsp_addr;
+	u32 ul_dsp_res_addr;
+	u32 heap_size;
+	bhandle hprocessor;
+	struct dspheap_res_object *next;
+};
 
 /* New structure (member of process context) abstracts stream resource info */
-struct STRM_RES_OBJECT {
-	s32                    streamAllocated; /* Stream status */
-	void *hStream;
-	u32                    uNumBufs;
-	u32                    uDir;
-	struct STRM_RES_OBJECT         *next;
-} ;
+struct strm_res_object {
+	s32 stream_allocated;	/* Stream status */
+	void *hstream;
+	u32 num_bufs;
+	u32 dir;
+	struct strm_res_object *next;
+};
 
 /* Overall Bridge process resource usage state */
-enum GPP_PROC_RES_STATE {
+enum gpp_proc_res_state {
 	PROC_RES_ALLOCATED,
 	PROC_RES_FREED
-} ;
+};
 
 /* Process Context */
-struct PROCESS_CONTEXT{
+struct process_context {
 	/* Process State */
-	enum GPP_PROC_RES_STATE resState;
+	enum gpp_proc_res_state res_state;
 
 	/* Handle to Processor */
-	void *hProcessor;
+	void *hprocessor;
 
 	/* DSP Node resources */
-	struct NODE_RES_OBJECT *pNodeList;
+	struct node_res_object *node_list;
 	struct mutex node_mutex;
 
 	/* DMM mapped memory resources */
@@ -149,16 +146,15 @@ struct PROCESS_CONTEXT{
 	spinlock_t dmm_rsv_lock;
 
 	/* DSP Heap resources */
-	struct DSPHEAP_RES_OBJECT *pDSPHEAPList;
+	struct dspheap_res_object *pdspheap_list;
 
 	/* Stream resources */
-	struct STRM_RES_OBJECT *pSTRMList;
+	struct strm_res_object *pstrm_list;
 	struct mutex strm_mutex;
-} ;
-
+};
 
 /*
- *  ======== DRV_Create ========
+ *  ======== drv_create ========
  *  Purpose:
  *      Creates the Driver Object. This is done during the driver loading.
  *      There is only one Driver Object in the DSP/BIOS Bridge.
@@ -169,12 +165,12 @@ struct PROCESS_CONTEXT{
  *      DSP_EMEMORY:    Failed in Memory allocation
  *      DSP_EFAIL:      General Failure
  *  Requires:
- *      DRV Initialized (cRefs > 0 )
+ *      DRV Initialized (refs > 0 )
  *      phDrvObject != NULL.
  *  Ensures:
  *      DSP_SOK:        - *phDrvObject is a valid DRV interface to the device.
  *                      - List of DevObject Created and Initialized.
- *                      - List of DevNode String created and intialized.
+ *                      - List of dev_node String created and intialized.
  *                      - Registry is updated with the DRV Object.
  *      !DSP_SOK:       DRV Object not created
  *  Details:
@@ -184,81 +180,81 @@ struct PROCESS_CONTEXT{
  *      Also it can hold other neccessary
  *      information in its storage area.
  */
-	extern DSP_STATUS DRV_Create(struct DRV_OBJECT **phDrvObject);
+extern dsp_status drv_create(struct drv_object **phDrvObject);
 
 /*
- *  ======== DRV_Destroy ========
+ *  ======== drv_destroy ========
  *  Purpose:
  *      destroys the Dev Object list, DrvExt list
  *      and destroy the DRV object
  *      Called upon driver unLoading.or unsuccesful loading of the driver.
  *  Parameters:
- *      hDrvObject:     Handle to Driver object .
+ *      hdrv_obj:     Handle to Driver object .
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Failed to destroy DRV Object
  *  Requires:
  *      DRV Initialized (cRegs > 0 )
- *      hDrvObject is not NULL and a valid DRV handle .
+ *      hdrv_obj is not NULL and a valid DRV handle .
  *      List of DevObject is Empty.
  *      List of DrvExt is Empty
  *  Ensures:
- *      DSP_SOK:        - DRV Object destroyed and hDrvObject is not a valid
+ *      DSP_SOK:        - DRV Object destroyed and hdrv_obj is not a valid
  *                        DRV handle.
  *                      - Registry is updated with "0" as the DRV Object.
  */
-	extern DSP_STATUS DRV_Destroy(struct DRV_OBJECT *hDrvObject);
+extern dsp_status drv_destroy(struct drv_object *hdrv_obj);
 
 /*
- *  ======== DRV_Exit ========
+ *  ======== drv_exit ========
  *  Purpose:
- *      Exit the DRV module, freeing any modules initialized in DRV_Init.
+ *      Exit the DRV module, freeing any modules initialized in drv_init.
  *  Parameters:
  *  Returns:
  *  Requires:
  *  Ensures:
  */
-	extern void DRV_Exit(void);
+extern void drv_exit(void);
 
 /*
- *  ======== DRV_GetFirstDevObject ========
+ *  ======== drv_get_first_dev_object ========
  *  Purpose:
  *      Returns the Ptr to the FirstDev Object in the List
  *  Parameters:
  *  Requires:
  *      DRV Initialized
  *  Returns:
- *      dwDevObject:  Ptr to the First Dev Object as a u32
+ *      dw_dev_object:  Ptr to the First Dev Object as a u32
  *      0 if it fails to retrieve the First Dev Object
  *  Ensures:
  */
-	extern u32 DRV_GetFirstDevObject(void);
+extern u32 drv_get_first_dev_object(void);
 
 /*
- *  ======== DRV_GetFirstDevExtension ========
+ *  ======== drv_get_first_dev_extension ========
  *  Purpose:
  *      Returns the Ptr to the First Device Extension in the List
  *  Parameters:
  *  Requires:
  *      DRV Initialized
  *  Returns:
- *      dwDevExtension:     Ptr to the First Device Extension as a u32
+ *      dw_dev_extension:     Ptr to the First Device Extension as a u32
  *      0:                  Failed to Get the Device Extension
  *  Ensures:
  */
-	extern u32 DRV_GetFirstDevExtension(void);
+extern u32 drv_get_first_dev_extension(void);
 
 /*
- *  ======== DRV_GetDevObject ========
+ *  ======== drv_get_dev_object ========
  *  Purpose:
  *      Given a index, returns a handle to DevObject from the list
  *  Parameters:
- *      hDrvObject:     Handle to the Manager
+ *      hdrv_obj:     Handle to the Manager
  *      phDevObject:    Location to store the Dev Handle
  *  Requires:
  *      DRV Initialized
- *      uIndex >= 0
- *      hDrvObject is not NULL and Valid DRV Object
+ *      index >= 0
+ *      hdrv_obj is not NULL and Valid DRV Object
  *      phDevObject is not NULL
  *      Device Object List not Empty
  *  Returns:
@@ -268,28 +264,28 @@ struct PROCESS_CONTEXT{
  *      DSP_SOK:        *phDevObject != NULL
  *      DSP_EFAIL:      *phDevObject = NULL
  */
-	extern DSP_STATUS DRV_GetDevObject(u32 uIndex,
-					   struct DRV_OBJECT *hDrvObject,
-					   struct DEV_OBJECT **phDevObject);
+extern dsp_status drv_get_dev_object(u32 index,
+				     struct drv_object *hdrv_obj,
+				     struct dev_object **phDevObject);
 
 /*
- *  ======== DRV_GetNextDevObject ========
+ *  ======== drv_get_next_dev_object ========
  *  Purpose:
  *      Returns the Ptr to the Next Device Object from the the List
  *  Parameters:
- *      hDevObject:     Handle to the Device Object
+ *      hdev_obj:     Handle to the Device Object
  *  Requires:
  *      DRV Initialized
- *      hDevObject != 0
+ *      hdev_obj != 0
  *  Returns:
- *      dwDevObject:    Ptr to the Next Dev Object as a u32
+ *      dw_dev_object:    Ptr to the Next Dev Object as a u32
  *      0:              If it fail to get the next Dev Object.
  *  Ensures:
  */
-	extern u32 DRV_GetNextDevObject(u32 hDevObject);
+extern u32 drv_get_next_dev_object(u32 hdev_obj);
 
 /*
- *  ======== DRV_GetNextDevExtension ========
+ *  ======== drv_get_next_dev_extension ========
  *  Purpose:
  *      Returns the Ptr to the Next Device Extension from the the List
  *  Parameters:
@@ -298,14 +294,14 @@ struct PROCESS_CONTEXT{
  *      DRV Initialized
  *      hDevExtension != 0.
  *  Returns:
- *      dwDevExtension:     Ptr to the Next Dev Extension
+ *      dw_dev_extension:     Ptr to the Next Dev Extension
  *      0:                  If it fail to Get the next Dev Extension
  *  Ensures:
  */
-	extern u32 DRV_GetNextDevExtension(u32 hDevExtension);
+extern u32 drv_get_next_dev_extension(u32 hDevExtension);
 
 /*
- *  ======== DRV_Init ========
+ *  ======== drv_init ========
  *  Purpose:
  *      Initialize the DRV module.
  *  Parameters:
@@ -314,55 +310,55 @@ struct PROCESS_CONTEXT{
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS DRV_Init(void);
+extern dsp_status drv_init(void);
 
 /*
- *  ======== DRV_InsertDevObject ========
+ *  ======== drv_insert_dev_object ========
  *  Purpose:
  *      Insert a DeviceObject into the list of Driver object.
  *  Parameters:
- *      hDrvObject:     Handle to DrvObject
- *      hDevObject:     Handle to DeviceObject to insert.
+ *      hdrv_obj:     Handle to DrvObject
+ *      hdev_obj:     Handle to DeviceObject to insert.
  *  Returns:
  *      DSP_SOK:        If successful.
  *      DSP_EFAIL:      General Failure:
  *  Requires:
- *      hDrvObject != NULL and Valid DRV Handle.
- *      hDevObject != NULL.
+ *      hdrv_obj != NULL and Valid DRV Handle.
+ *      hdev_obj != NULL.
  *  Ensures:
  *      DSP_SOK:        Device Object is inserted and the List is not empty.
  */
-	extern DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDrvObject,
-					      struct DEV_OBJECT *hDevObject);
+extern dsp_status drv_insert_dev_object(struct drv_object *hdrv_obj,
+					struct dev_object *hdev_obj);
 
 /*
- *  ======== DRV_RemoveDevObject ========
+ *  ======== drv_remove_dev_object ========
  *  Purpose:
  *      Search for and remove a Device object from the given list of Device Obj
  *      objects.
  *  Parameters:
- *      hDrvObject:     Handle to DrvObject
- *      hDevObject:     Handle to DevObject to Remove
+ *      hdrv_obj:     Handle to DrvObject
+ *      hdev_obj:     Handle to DevObject to Remove
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Unable to find pDevObject.
+ *      DSP_EFAIL:      Unable to find dev_obj.
  *  Requires:
- *      hDrvObject != NULL and a Valid DRV Handle.
- *      hDevObject != NULL.
+ *      hdrv_obj != NULL and a Valid DRV Handle.
+ *      hdev_obj != NULL.
  *      List exists and is not empty.
  *  Ensures:
  *      List either does not exist (NULL), or is not empty if it does exist.
-*/
-	extern DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDrvObject,
-					      struct DEV_OBJECT *hDevObject);
+ */
+extern dsp_status drv_remove_dev_object(struct drv_object *hdrv_obj,
+					struct dev_object *hdev_obj);
 
 /*
- *  ======== DRV_RequestResources ========
+ *  ======== drv_request_resources ========
  *  Purpose:
  *      Assigns the Resources or Releases them.
  *  Parameters:
- *      dwContext:          Path to the driver Registry Key.
- *      pDevNodeString:     Ptr to DevNode String stored in the Device Ext.
+ *      dw_context:          Path to the driver Registry Key.
+ *      pDevNodeString:     Ptr to dev_node String stored in the Device Ext.
  *  Returns:
  *      TRUE if success; FALSE otherwise.
  *  Requires:
@@ -373,16 +369,16 @@ struct PROCESS_CONTEXT{
  *      Resource structure is stored in the registry which will be
  *      later used by the CFG module.
  */
-	extern DSP_STATUS DRV_RequestResources(IN u32 dwContext,
-					       OUT u32 *pDevNodeString);
+extern dsp_status drv_request_resources(IN u32 dw_context,
+					OUT u32 *pDevNodeString);
 
 /*
- *  ======== DRV_ReleaseResources ========
+ *  ======== drv_release_resources ========
  *  Purpose:
  *      Assigns the Resources or Releases them.
  *  Parameters:
- *      dwContext:      Path to the driver Registry Key.
- *      hDrvObject:     Handle to the Driver Object.
+ *      dw_context:      Path to the driver Registry Key.
+ *      hdrv_obj:     Handle to the Driver Object.
  *  Returns:
  *      TRUE if success; FALSE otherwise.
  *  Requires:
@@ -390,10 +386,10 @@ struct PROCESS_CONTEXT{
  *      The Resources are released based on Bus type.
  *      Resource structure is deleted from the registry
  */
-	extern DSP_STATUS DRV_ReleaseResources(IN u32 dwContext,
-					       struct DRV_OBJECT *hDrvObject);
+extern dsp_status drv_release_resources(IN u32 dw_context,
+					struct drv_object *hdrv_obj);
 
 #ifdef CONFIG_BRIDGE_RECOVERY
-	void bridge_recover_schedule(void);
+void bridge_recover_schedule(void);
 #endif
-#endif				/* DRV_ */
+#endif /* DRV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/drvdefs.h b/arch/arm/plat-omap/include/dspbridge/drvdefs.h
index 041de39..f084207 100644
--- a/arch/arm/plat-omap/include/dspbridge/drvdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/drvdefs.h
@@ -20,6 +20,6 @@
 #define DRVDEFS_
 
 /* WCD Driver Object */
-	struct DRV_OBJECT;
+struct drv_object;
 
-#endif				/* DRVDEFS_ */
+#endif /* DRVDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspdrv.h b/arch/arm/plat-omap/include/dspbridge/dspdrv.h
index 11add1d..7ee1d98 100644
--- a/arch/arm/plat-omap/include/dspbridge/dspdrv.h
+++ b/arch/arm/plat-omap/include/dspbridge/dspdrv.h
@@ -17,13 +17,13 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#if !defined __DSPDRV_h__
-#define __DSPDRV_h__
+#if !defined _DSPDRV_H_
+#define _DSPDRV_H_
 
 #define MAX_DEV     10		/* Max support of 10 devices */
 
 /*
- *  ======== DSP_Deinit ========
+ *  ======== dsp_deinit ========
  *  Purpose:
  *      This function is called by Device Manager to de-initialize a device.
  *      This function is not called by applications.
@@ -38,15 +38,15 @@
  *      get called.
  *  Ensures:
  */
-extern bool DSP_Deinit(u32 dwDeviceContext);
+extern bool dsp_deinit(u32 dwDeviceContext);
 
 /*
- *  ======== DSP_Init ========
+ *  ======== dsp_init ========
  *  Purpose:
  *      This function is called by Device Manager to initialize a device.
  *      This function is not called by applications
  *  Parameters:
- *      dwContext:  Specifies a pointer to a string containing the registry
+ *      dw_context:  Specifies a pointer to a string containing the registry
  *                  path to the active key for the stream interface driver.
  *                  HKEY_LOCAL_MACHINE\Drivers\Active
  *  Returns:
@@ -57,6 +57,6 @@ extern bool DSP_Deinit(u32 dwDeviceContext);
  *      Succeeded:  device context > 0
  *      Failed:     device Context = 0
  */
-extern u32 DSP_Init(OUT u32 *initStatus);
+extern u32 dsp_init(OUT u32 *init_status);
 
 #endif
diff --git a/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h b/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
index 6491df6..15fcf4d 100644
--- a/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
+++ b/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
@@ -31,16 +31,16 @@
  * that supply the module and system specific functions it requires
  */
 	/* The read functions for the module image to be loaded */
-	struct Dynamic_Loader_Stream;
+struct dynamic_loader_stream;
 
 	/* This class defines "host" symbol and support functions */
-	struct Dynamic_Loader_Sym;
+struct dynamic_loader_sym;
 
 	/* This class defines the allocator for "target" memory */
-	struct Dynamic_Loader_Allocate;
+struct dynamic_loader_allocate;
 
 	/* This class defines the copy-into-target-memory functions */
-	struct Dynamic_Loader_Initialize;
+struct dynamic_loader_initialize;
 
 /*
  * Option flags to modify the behavior of module loading
@@ -49,10 +49,10 @@
 #define DLOAD_BIGEND 0x2	/* require big-endian load module */
 #define DLOAD_LITTLE 0x4	/* require little-endian load module */
 
-	typedef void *DLOAD_mhandle;	/* module handle for loaded modules */
+typedef void *dload_mhandle;	/* module handle for loaded modules */
 
 /*****************************************************************************
- * Procedure Dynamic_Load_Module
+ * Procedure dynamic_load_module
  *
  * Parameters:
  *  module  The input stream that supplies the module image
@@ -72,24 +72,23 @@
  * Returns:
  *  On a successful load, a module handle is placed in *mhandle, and zero is
  * returned.  On error, the number of errors detected is returned.  Individual
- * errors are reported during the load process using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Load_Module(
-				       /* the source for the module image*/
-				       struct Dynamic_Loader_Stream *module,
-				       /* host support for symbols and storage*/
-				       struct Dynamic_Loader_Sym *syms,
-				       /* the target memory allocator*/
-				       struct Dynamic_Loader_Allocate *alloc,
-				       /* the target memory initializer*/
-				       struct Dynamic_Loader_Initialize *init,
-				       unsigned options,       /* option flags*/
-				       /* the returned module handle*/
-				       DLOAD_mhandle *mhandle
-	    );
+ * errors are reported during the load process using syms->error_report().
+ **************************************************************************** */
+extern int dynamic_load_module(
+				      /* the source for the module image */
+				      struct dynamic_loader_stream *module,
+				      /* host support for symbols and storage */
+				      struct dynamic_loader_sym *syms,
+				      /* the target memory allocator */
+				      struct dynamic_loader_allocate *alloc,
+				      /* the target memory initializer */
+				      struct dynamic_loader_initialize *init,
+				      unsigned options,	/* option flags */
+				      /* the returned module handle */
+				      dload_mhandle * mhandle);
 
 /*****************************************************************************
- * Procedure Dynamic_Open_Module
+ * Procedure dynamic_open_module
  *
  * Parameters:
  *  module  The input stream that supplies the module image
@@ -109,27 +108,26 @@
  * Returns:
  *  On a successful load, a module handle is placed in *mhandle, and zero is
  * returned.  On error, the number of errors detected is returned.  Individual
- * errors are reported during the load process using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Open_Module(
+ * errors are reported during the load process using syms->error_report().
+ **************************************************************************** */
+extern int dynamic_open_module(
 				      /* the source for the module image */
-				      struct Dynamic_Loader_Stream *module,
+				      struct dynamic_loader_stream *module,
 				      /* host support for symbols and storage */
-				      struct Dynamic_Loader_Sym *syms,
+				      struct dynamic_loader_sym *syms,
 				      /* the target memory allocator */
-				      struct Dynamic_Loader_Allocate *alloc,
+				      struct dynamic_loader_allocate *alloc,
 				      /* the target memory initializer */
-				      struct Dynamic_Loader_Initialize *init,
-				      unsigned options, /* option flags */
+				      struct dynamic_loader_initialize *init,
+				      unsigned options,	/* option flags */
 				      /* the returned module handle */
-				      DLOAD_mhandle *mhandle
-	);
+				      dload_mhandle * mhandle);
 
 /*****************************************************************************
- * Procedure Dynamic_Unload_Module
+ * Procedure dynamic_unload_module
  *
  * Parameters:
- *  mhandle A module handle from Dynamic_Load_Module
+ *  mhandle A module handle from dynamic_load_module
  *  syms    Host-side symbol table and malloc/free functions
  *  alloc   Target-side memory allocation
  *
@@ -141,25 +139,24 @@
  *
  * Returns:
  *  Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Unload_Module(DLOAD_mhandle mhandle,	/* the module
-								 * handle*/
-					 /* host support for symbols and
-					  * storage */
-					 struct Dynamic_Loader_Sym *syms,
-					 /* the target memory allocator*/
-					 struct Dynamic_Loader_Allocate *alloc,
-					 /* the target memory initializer*/
-					 struct Dynamic_Loader_Initialize *init
-	    );
+ * Individual errors are reported using syms->error_report().
+ **************************************************************************** */
+extern int dynamic_unload_module(dload_mhandle mhandle,	/* the module
+							 * handle */
+				 /* host support for symbols and
+				  * storage */
+				 struct dynamic_loader_sym *syms,
+				 /* the target memory allocator */
+				 struct dynamic_loader_allocate *alloc,
+				 /* the target memory initializer */
+				 struct dynamic_loader_initialize *init);
 
 /*****************************************************************************
  *****************************************************************************
  * A class used by the dynamic loader for input of the module image
  *****************************************************************************
- *****************************************************************************/
-	struct Dynamic_Loader_Stream {
+ **************************************************************************** */
+struct dynamic_loader_stream {
 /* public: */
     /*************************************************************************
      * read_buffer
@@ -176,9 +173,9 @@
      * NOTES:
      *  In release 1 increments the file position by the number of bytes read
      *
-     *************************************************************************/
-		int (*read_buffer) (struct Dynamic_Loader_Stream *thisptr,
-				    void *buffer, unsigned bufsiz);
+     ************************************************************************ */
+	int (*read_buffer) (struct dynamic_loader_stream *thisptr,
+			    void *buffer, unsigned bufsiz);
 
     /*************************************************************************
      * set_file_posn (release 1 only)
@@ -192,33 +189,33 @@
      * the beginning of the input module.  Returns 0 for success, non-zero
      * for failure.
      *
-     *************************************************************************/
-		int (*set_file_posn) (struct Dynamic_Loader_Stream *thisptr,
-					/* to be eliminated in release 2*/
-					unsigned int posn);
+     ************************************************************************ */
+	int (*set_file_posn) (struct dynamic_loader_stream *thisptr,
+			      /* to be eliminated in release 2 */
+			      unsigned int posn);
 
-	};
+};
 
 /*****************************************************************************
  *****************************************************************************
  * A class used by the dynamic loader for symbol table support and
  * miscellaneous host-side functions
  *****************************************************************************
- *****************************************************************************/
+ **************************************************************************** */
 
-	typedef u32 LDR_ADDR;
+typedef u32 ldr_addr;
 
 /*
  * the structure of a symbol known to the dynamic loader
  */
-	struct dynload_symbol {
-		LDR_ADDR value;
-	} ;
+struct dynload_symbol {
+	ldr_addr value;
+};
 
-	struct Dynamic_Loader_Sym {
+struct dynamic_loader_sym {
 /* public: */
     /*************************************************************************
-     * Find_Matching_Symbol
+     * find_matching_symbol
      *
      * PARAMETERS :
      *  name    The name of the desired symbol
@@ -228,14 +225,12 @@
      * symbol is returned if it exists; 0 is returned if no such symbol is
      * found.
      *
-     *************************************************************************/
-		struct dynload_symbol *(*Find_Matching_Symbol)
-			(struct Dynamic_Loader_Sym *
-							 thisptr,
-							 const char *name);
+     ************************************************************************ */
+	struct dynload_symbol *(*find_matching_symbol)
+	 (struct dynamic_loader_sym *thisptr, const char *name);
 
     /*************************************************************************
-     * Add_To_Symbol_Table
+     * add_to_symbol_table
      *
      * PARAMETERS :
      *  nname       Pointer to the name of the new symbol
@@ -250,15 +245,13 @@
      * the named symbol will not be available to resolve references in
      * subsequent loads.  Returning NULL will not cause the current load
      * to fail.
-     *************************************************************************/
-		struct dynload_symbol *(*Add_To_Symbol_Table)
-						(struct Dynamic_Loader_Sym *
-							thisptr,
-							const char *nname,
-							unsigned moduleid);
+     ************************************************************************ */
+	struct dynload_symbol *(*add_to_symbol_table)
+	 (struct dynamic_loader_sym *
+	  thisptr, const char *nname, unsigned moduleid);
 
     /*************************************************************************
-     * Purge_Symbol_Table
+     * purge_symbol_table
      *
      * PARAMETERS :
      *  moduleid    An opaque module id assigned by the dynamic loader
@@ -266,12 +259,12 @@
      * EFFECT :
      *  Each symbol in the symbol table whose moduleid matches the argument
      * is removed from the table.
-     *************************************************************************/
-		void (*Purge_Symbol_Table) (struct Dynamic_Loader_Sym *thisptr,
-					    unsigned moduleid);
+     ************************************************************************ */
+	void (*purge_symbol_table) (struct dynamic_loader_sym *thisptr,
+				    unsigned moduleid);
 
     /*************************************************************************
-     * Allocate
+     * dload_allocate
      *
      * PARAMETERS :
      *  memsiz  size of desired memory in sizeof() units
@@ -281,24 +274,24 @@
      * loader, or NULL for failure.
      * This function is serves as a replaceable form of "malloc" to
      * allow the user to configure the memory usage of the dynamic loader.
-     *************************************************************************/
-		void *(*Allocate) (struct Dynamic_Loader_Sym *thisptr,
-				   unsigned memsiz);
+     ************************************************************************ */
+	void *(*dload_allocate) (struct dynamic_loader_sym *thisptr,
+				 unsigned memsiz);
 
     /*************************************************************************
-     * Deallocate
+     * dload_deallocate
      *
      * PARAMETERS :
      *  memptr  pointer to previously allocated memory
      *
      * EFFECT :
      *  Releases the previously allocated "host" memory.
-     *************************************************************************/
-		void (*Deallocate) (struct Dynamic_Loader_Sym *thisptr,
-				    void *memptr);
+     ************************************************************************ */
+	void (*dload_deallocate) (struct dynamic_loader_sym *thisptr,
+				  void *memptr);
 
     /*************************************************************************
-     * Error_Report
+     * error_report
      *
      * PARAMETERS :
      *  errstr  pointer to an error string
@@ -308,37 +301,37 @@
      *  This function provides an error reporting interface for the dynamic
      * loader.  The error string and arguments are designed as for the
      * library function vprintf.
-     *************************************************************************/
-		void (*Error_Report) (struct Dynamic_Loader_Sym *thisptr,
-				      const char *errstr, va_list args);
+     ************************************************************************ */
+	void (*error_report) (struct dynamic_loader_sym *thisptr,
+			      const char *errstr, va_list args);
 
-	};			/* class Dynamic_Loader_Sym */
+};				/* class dynamic_loader_sym */
 
 /*****************************************************************************
  *****************************************************************************
  * A class used by the dynamic loader to allocate and deallocate target memory.
  *****************************************************************************
- *****************************************************************************/
-
-	struct LDR_SECTION_INFO {
-		/* Name of the memory section assigned at build time */
-		const char *name;
-		LDR_ADDR run_addr;	/* execution address of the section */
-		LDR_ADDR load_addr;	/* load address of the section */
-		LDR_ADDR size;	/* size of the section in addressable units */
+ **************************************************************************** */
+
+struct ldr_section_info {
+	/* Name of the memory section assigned at build time */
+	const char *name;
+	ldr_addr run_addr;	/* execution address of the section */
+	ldr_addr load_addr;	/* load address of the section */
+	ldr_addr size;		/* size of the section in addressable units */
 #ifndef _BIG_ENDIAN
-		u16 page;	/* memory page or view */
-		u16 type;	/* one of the section types below */
+	u16 page;		/* memory page or view */
+	u16 type;		/* one of the section types below */
 #else
-		u16 type;	/* one of the section types below */
-		u16 page;	/* memory page or view */
+	u16 type;		/* one of the section types below */
+	u16 page;		/* memory page or view */
 #endif
-		/* a context field for use by Dynamic_Loader_Allocate;
-		 *   ignored but maintained by the dynamic loader */
-		u32 context;
-	} ;
+	/* a context field for use by dynamic_loader_allocate;
+	 *   ignored but maintained by the dynamic loader */
+	u32 context;
+};
 
-/* use this macro to extract type of section from LDR_SECTION_INFO.type field */
+/* use this macro to extract type of section from ldr_section_info.type field */
 #define DLOAD_SECTION_TYPE(typeinfo) (typeinfo & 0xF)
 
 /* type of section to be allocated */
@@ -348,7 +341,7 @@
 	/* internal use only, run-time cinit will be of type DLOAD_DATA */
 #define DLOAD_CINIT 3
 
-	struct Dynamic_Loader_Allocate {
+struct dynamic_loader_allocate {
 /* public: */
 
     /*************************************************************************
@@ -365,12 +358,12 @@
     *
     * Notes:
     *   Frequently load_addr and run_addr are the same, but if they are not
-    * load_addr is used with Dynamic_Loader_Initialize, and run_addr is
+    * load_addr is used with dynamic_loader_initialize, and run_addr is
     * used for almost all relocations.  This function should always initialize
     * both fields.
-    *************************************************************************/
-		int (*Allocate) (struct Dynamic_Loader_Allocate *thisptr,
-				 struct LDR_SECTION_INFO *info, unsigned align);
+    ************************************************************************ */
+	int (*dload_allocate) (struct dynamic_loader_allocate *thisptr,
+			       struct ldr_section_info *info, unsigned align);
 
     /*************************************************************************
     * Function deallocate
@@ -383,20 +376,20 @@
     *
     * Notes:
     * The content of the info->name field is undefined on call to this function.
-    *************************************************************************/
-		void (*Deallocate) (struct Dynamic_Loader_Allocate *thisptr,
-				    struct LDR_SECTION_INFO *info);
+    ************************************************************************ */
+	void (*dload_deallocate) (struct dynamic_loader_allocate *thisptr,
+				  struct ldr_section_info *info);
 
-	};			/* class Dynamic_Loader_Allocate */
+};				/* class dynamic_loader_allocate */
 
 /*****************************************************************************
  *****************************************************************************
  * A class used by the dynamic loader to load data into a target.  This class
  * provides the interface-specific functions needed to load data.
  *****************************************************************************
- *****************************************************************************/
+ **************************************************************************** */
 
-	struct Dynamic_Loader_Initialize {
+struct dynamic_loader_initialize {
 /* public: */
     /*************************************************************************
     * Function connect
@@ -411,8 +404,8 @@
     * Notes:
     *   This function is called prior to use of any other functions in
     * this interface.
-    *************************************************************************/
-		int (*connect) (struct Dynamic_Loader_Initialize *thisptr);
+    ************************************************************************ */
+	int (*connect) (struct dynamic_loader_initialize *thisptr);
 
     /*************************************************************************
     * Function readmem
@@ -426,12 +419,11 @@
     * Effect:
     *   Fills the specified buffer with data from the target.  Returns TRUE for
     * success, FALSE for failure.
-    *************************************************************************/
-		int (*readmem) (struct Dynamic_Loader_Initialize *thisptr,
-				void *bufr,
-				LDR_ADDR locn,
-				struct LDR_SECTION_INFO *info,
-				unsigned bytsiz);
+    ************************************************************************ */
+	int (*readmem) (struct dynamic_loader_initialize *thisptr,
+			void *bufr,
+			ldr_addr locn,
+			struct ldr_section_info *info, unsigned bytsiz);
 
     /*************************************************************************
     * Function writemem
@@ -445,12 +437,11 @@
     * Effect:
     *   Writes the specified buffer to the target.  Returns TRUE for success,
     * FALSE for failure.
-    *************************************************************************/
-		int (*writemem) (struct Dynamic_Loader_Initialize *thisptr,
-				 void *bufr,
-				 LDR_ADDR locn,
-				 struct LDR_SECTION_INFO *info,
-				 unsigned bytsiz);
+    ************************************************************************ */
+	int (*writemem) (struct dynamic_loader_initialize *thisptr,
+			 void *bufr,
+			 ldr_addr locn,
+			 struct ldr_section_info *info, unsigned bytsiz);
 
     /*************************************************************************
     * Function fillmem
@@ -463,10 +454,10 @@
     * Effect:
     *   Fills the specified area of target memory.  Returns TRUE for success,
     * FALSE for failure.
-    *************************************************************************/
-		int (*fillmem) (struct Dynamic_Loader_Initialize *thisptr,
-				LDR_ADDR locn, struct LDR_SECTION_INFO *info,
-				unsigned bytsiz, unsigned val);
+    ************************************************************************ */
+	int (*fillmem) (struct dynamic_loader_initialize *thisptr,
+			ldr_addr locn, struct ldr_section_info *info,
+			unsigned bytsiz, unsigned val);
 
     /*************************************************************************
     * Function execute
@@ -480,9 +471,9 @@
     * Notes:
     *   This function is called at the end of the dynamic load process
     * if the input module has specified a starting address.
-    *************************************************************************/
-		int (*execute) (struct Dynamic_Loader_Initialize *thisptr,
-				LDR_ADDR start);
+    ************************************************************************ */
+	int (*execute) (struct dynamic_loader_initialize *thisptr,
+			ldr_addr start);
 
     /*************************************************************************
     * Function release
@@ -495,9 +486,9 @@
     *
     * Notes:
     *   This function is called at the end of the dynamic load process.
-    *************************************************************************/
-		void (*release) (struct Dynamic_Loader_Initialize *thisptr);
+    ************************************************************************ */
+	void (*release) (struct dynamic_loader_initialize *thisptr);
 
-	};			/* class Dynamic_Loader_Initialize */
+};				/* class dynamic_loader_initialize */
 
-#endif				/* _DYNAMIC_LOADER_H_ */
+#endif /* _DYNAMIC_LOADER_H_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/errbase.h b/arch/arm/plat-omap/include/dspbridge/errbase.h
index f7706b0..d43ff86 100644
--- a/arch/arm/plat-omap/include/dspbridge/errbase.h
+++ b/arch/arm/plat-omap/include/dspbridge/errbase.h
@@ -26,11 +26,11 @@
 #define ERRBASE_
 
 /* Base of generic errors and component errors */
-#define DSP_SBASE               (DSP_STATUS)0x00008000
-#define DSP_EBASE               (DSP_STATUS)0x80008000
+#define DSP_SBASE               (dsp_status)0x00008000
+#define DSP_EBASE               (dsp_status)0x80008000
 
-#define DSP_COMP_EBASE          (DSP_STATUS)0x80040200
-#define DSP_COMP_ELAST          (DSP_STATUS)0x80047fff
+#define DSP_COMP_EBASE          (dsp_status)0x80040200
+#define DSP_COMP_ELAST          (dsp_status)0x80047fff
 
 /* SUCCESS Codes */
 
@@ -162,7 +162,7 @@
  * found in the COFF file. */
 #define DSP_ESYMBOL                 (DSP_EBASE + 0x1c)
 
-/* UUID not found in registry.  */
+/* UUID not found in registry. */
 #define DSP_EUUID                   (DSP_EBASE + 0x1d)
 
 /* Unable to read content of DCD data section ; this is typically caused by
@@ -200,7 +200,7 @@
 /* Multiple instances are not allowed. */
 #define DSP_EMULINST                (DSP_EBASE + 0x2c)
 
-/* A specified entity was not found.  */
+/* A specified entity was not found. */
 #define DSP_ENOTFOUND               (DSP_EBASE + 0x2d)
 
 /* A DSP I/O resource is not available. */
@@ -270,7 +270,7 @@
 /* The mini-driver expected a newer version of the class driver. */
 #define DEV_E_NEWWMD                (DEV_EBASE + 0x00)
 
-/* WMD_DRV_Entry function returned a NULL function interface table. */
+/* bridge_drv_entry function returned a NULL function interface table. */
 #define DEV_E_NULLWMDINTF           (DEV_EBASE + 0x01)
 
 /* FAILURE Codes : LDR */
@@ -395,7 +395,7 @@
 /* Wait for flush operation on an output channel timed out. */
 #define CHNL_E_WAITTIMEOUT          (CHNL_EBASE + 0x15)
 
-/* User supplied hEvent must be specified with pstrEventName attribute */
+/* User supplied event_obj must be specified with pstr_event_name attribute */
 #define CHNL_E_BADUSEREVENT         (CHNL_EBASE + 0x16)
 
 /* Illegal user event name specified */
@@ -443,4 +443,4 @@
 /* Insufficient space to hold data in registry value. */
 #define REG_E_MOREDATA              (REG_EBASE + 0x03)
 
-#endif				/* ERRBASE_ */
+#endif /* ERRBASE_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/gb.h b/arch/arm/plat-omap/include/dspbridge/gb.h
index 9365072..12cdce8 100644
--- a/arch/arm/plat-omap/include/dspbridge/gb.h
+++ b/arch/arm/plat-omap/include/dspbridge/gb.h
@@ -21,59 +21,59 @@
 
 #define GB_NOBITS (~0)
 #include <dspbridge/host_os.h>
-typedef s32 GB_BitNum;
-struct GB_TMap;
+typedef s32 gb_bit_num;
+struct gb_t_map;
 
 /*
- *  ======== GB_clear ========
+ *  ======== gb_clear ========
  *  Clear the bit in position bitn in the bitmap map.  Bit positions are
  *  zero based.
  */
 
-extern void GB_clear(struct GB_TMap *map, GB_BitNum bitn);
+extern void gb_clear(struct gb_t_map *map, gb_bit_num bitn);
 
 /*
- *  ======== GB_create ========
+ *  ======== gb_create ========
  *  Create a bit map with len bits.  Initially all bits are cleared.
  */
 
-extern struct GB_TMap *GB_create(GB_BitNum len);
+extern struct gb_t_map *gb_create(gb_bit_num len);
 
 /*
- *  ======== GB_delete ========
+ *  ======== gb_delete ========
  *  Delete previously created bit map
  */
 
-extern void GB_delete(struct GB_TMap *map);
+extern void gb_delete(struct gb_t_map *map);
 
 /*
- *  ======== GB_findandset ========
+ *  ======== gb_findandset ========
  *  Finds a clear bit, sets it, and returns the position
  */
 
-extern GB_BitNum GB_findandset(struct GB_TMap *map);
+extern gb_bit_num gb_findandset(struct gb_t_map *map);
 
 /*
- *  ======== GB_minclear ========
- *  GB_minclear returns the minimum clear bit position.  If no bit is
- *  clear, GB_minclear returns -1.
+ *  ======== gb_minclear ========
+ *  gb_minclear returns the minimum clear bit position.  If no bit is
+ *  clear, gb_minclear returns -1.
  */
-extern GB_BitNum GB_minclear(struct GB_TMap *map);
+extern gb_bit_num gb_minclear(struct gb_t_map *map);
 
 /*
- *  ======== GB_set ========
+ *  ======== gb_set ========
  *  Set the bit in position bitn in the bitmap map.  Bit positions are
  *  zero based.
  */
 
-extern void GB_set(struct GB_TMap *map, GB_BitNum bitn);
+extern void gb_set(struct gb_t_map *map, gb_bit_num bitn);
 
 /*
- *  ======== GB_test ========
+ *  ======== gb_test ========
  *  Returns TRUE if the bit in position bitn is set in map; otherwise
- *  GB_test returns FALSE.  Bit positions are zero based.
+ *  gb_test returns FALSE.  Bit positions are zero based.
  */
 
-extern bool GB_test(struct GB_TMap *map, GB_BitNum bitn);
+extern bool gb_test(struct gb_t_map *map, gb_bit_num bitn);
 
-#endif				/*GB_ */
+#endif /*GB_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/getsection.h b/arch/arm/plat-omap/include/dspbridge/getsection.h
index 28c11e8..a0ea786 100644
--- a/arch/arm/plat-omap/include/dspbridge/getsection.h
+++ b/arch/arm/plat-omap/include/dspbridge/getsection.h
@@ -8,7 +8,7 @@
  * modules.
  *
  * Notes:
- *   Functions in this API assume that the supplied Dynamic_Loader_Stream
+ *   Functions in this API assume that the supplied dynamic_loader_stream
  *   object supports the set_file_posn method.
  *
  * Copyright (C) 2008 Texas Instruments, Inc.
@@ -25,14 +25,13 @@
 #ifndef _GETSECTION_H_
 #define _GETSECTION_H_
 
-
 #include "dynamic_loader.h"
 
 	/* opaque handle for module information */
-	typedef void *DLOAD_module_info;
+typedef void *dload_module_info;
 
 /*
- * Procedure DLOAD_module_open
+ * Procedure dload_module_open
  *
  * Parameters:
  *  module  The input stream that supplies the module image
@@ -49,36 +48,35 @@
  *  NULL if an error is encountered, otherwise a module handle for use
  * in subsequent operations.
  */
-	extern DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream
-						   *module,
-						   struct Dynamic_Loader_Sym
-						   *syms);
+extern dload_module_info dload_module_open(struct dynamic_loader_stream
+					   *module, struct dynamic_loader_sym
+					   *syms);
 
 /*
- * Procedure DLOAD_GetSectionInfo
+ * Procedure dload_get_section_info
  *
  * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
+ *  minfo       Handle from dload_module_open for this module
  *  sectionName Pointer to the string name of the section desired
  *  sectionInfo Address of a section info structure pointer to be initialized
  *
  * Effect:
  *  Finds the specified section in the module information, and fills in
- * the provided LDR_SECTION_INFO structure.
+ * the provided ldr_section_info structure.
  *
  * Returns:
  *  TRUE for success, FALSE for section not found
  */
-	extern int DLOAD_GetSectionInfo(DLOAD_module_info minfo,
-					const char *sectionName,
-					const struct LDR_SECTION_INFO
-					** const sectionInfo);
+extern int dload_get_section_info(dload_module_info minfo,
+				  const char *sectionName,
+				  const struct ldr_section_info
+				  **const sectionInfo);
 
 /*
- * Procedure DLOAD_GetSection
+ * Procedure dload_get_section
  *
  * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
+ *  minfo       Handle from dload_module_open for this module
  *  sectionInfo Pointer to a section info structure for the desired section
  *  sectionData Buffer to contain the section initialized data
  *
@@ -89,15 +87,15 @@
  * Returns:
  *  TRUE for success, FALSE for section not found
  */
-	extern int DLOAD_GetSection(DLOAD_module_info minfo,
-				    const struct LDR_SECTION_INFO *sectionInfo,
-				    void *sectionData);
+extern int dload_get_section(dload_module_info minfo,
+			     const struct ldr_section_info *sectionInfo,
+			     void *sectionData);
 
 /*
- * Procedure DLOAD_module_close
+ * Procedure dload_module_close
  *
  * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
+ *  minfo       Handle from dload_module_open for this module
  *
  * Effect:
  *  Releases any storage associated with the module handle.  On return,
@@ -105,9 +103,9 @@
  *
  * Returns:
  *  Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report(), where syms was
- * an argument to DLOAD_module_open
+ * Individual errors are reported using syms->error_report(), where syms was
+ * an argument to dload_module_open
  */
-	extern void DLOAD_module_close(DLOAD_module_info minfo);
+extern void dload_module_close(dload_module_info minfo);
 
-#endif				/* _GETSECTION_H_ */
+#endif /* _GETSECTION_H_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/gh.h b/arch/arm/plat-omap/include/dspbridge/gh.h
index 8bff0b4..e4da0f2 100644
--- a/arch/arm/plat-omap/include/dspbridge/gh.h
+++ b/arch/arm/plat-omap/include/dspbridge/gh.h
@@ -18,12 +18,13 @@
 #define GH_
 #include <dspbridge/host_os.h>
 
-extern struct GH_THashTab *GH_create(u16 maxBucket, u16 valSize,
-		u16(*hash) (void *, u16), bool(*match) (void *, void *),
-		void(*delete) (void *));
-extern void GH_delete(struct GH_THashTab *hashTab);
-extern void GH_exit(void);
-extern void *GH_find(struct GH_THashTab *hashTab, void *key);
-extern void GH_init(void);
-extern void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value);
-#endif				/* GH_ */
+extern struct gh_t_hash_tab *gh_create(u16 max_bucket, u16 val_size,
+				       u16(*hash) (void *, u16),
+				       bool(*match) (void *, void *),
+				       void (*delete) (void *));
+extern void gh_delete(struct gh_t_hash_tab *hash_tab);
+extern void gh_exit(void);
+extern void *gh_find(struct gh_t_hash_tab *hash_tab, void *key);
+extern void gh_init(void);
+extern void *gh_insert(struct gh_t_hash_tab *hash_tab, void *key, void *value);
+#endif /* GH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/gs.h b/arch/arm/plat-omap/include/dspbridge/gs.h
index 5dada9f..f32d8d9 100644
--- a/arch/arm/plat-omap/include/dspbridge/gs.h
+++ b/arch/arm/plat-omap/include/dspbridge/gs.h
@@ -23,37 +23,37 @@
 #define GS_
 
 /*
- *  ======== GS_alloc ========
+ *  ======== gs_alloc ========
  *  Alloc size bytes of space.  Returns pointer to space
  *  allocated, otherwise NULL.
  */
-extern void *GS_alloc(u32 size);
+extern void *gs_alloc(u32 size);
 
 /*
- *  ======== GS_exit ========
- *  Module exit.  Do not change to "#define GS_init()"; in
+ *  ======== gs_exit ========
+ *  Module exit.  Do not change to "#define gs_init()"; in
  *  some environments this operation must actually do some work!
  */
-extern void GS_exit(void);
+extern void gs_exit(void);
 
 /*
- *  ======== GS_free ========
- *  Free space allocated by GS_alloc() or GS_calloc().
+ *  ======== gs_free ========
+ *  Free space allocated by gs_alloc() or GS_calloc().
  */
-extern void GS_free(void *ptr);
+extern void gs_free(void *ptr);
 
 /*
- *  ======== GS_frees ========
- *  Free space allocated by GS_alloc() or GS_calloc() and assert that
+ *  ======== gs_frees ========
+ *  Free space allocated by gs_alloc() or GS_calloc() and assert that
  *  the size of the allocation is size bytes.
  */
-extern void GS_frees(void *ptr, u32 size);
+extern void gs_frees(void *ptr, u32 size);
 
 /*
- *  ======== GS_init ========
- *  Module initialization.  Do not change to "#define GS_init()"; in
+ *  ======== gs_init ========
+ *  Module initialization.  Do not change to "#define gs_init()"; in
  *  some environments this operation must actually do some work!
  */
-extern void GS_init(void);
+extern void gs_init(void);
 
-#endif				/*GS_ */
+#endif /*GS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/host_os.h b/arch/arm/plat-omap/include/dspbridge/host_os.h
index e2f20bc..75dee01 100644
--- a/arch/arm/plat-omap/include/dspbridge/host_os.h
+++ b/arch/arm/plat-omap/include/dspbridge/host_os.h
@@ -61,10 +61,10 @@ struct dsp_shm_freq_table {
 	unsigned long thresh_max_freq;
 };
 struct dspbridge_platform_data {
-	void 	(*dsp_set_min_opp)(u8 opp_id);
-	u8 	(*dsp_get_opp)(void);
-	void 	(*cpu_set_freq)(unsigned long f);
-	unsigned long (*cpu_get_freq)(void);
+	void (*dsp_set_min_opp) (u8 opp_id);
+	 u8(*dsp_get_opp) (void);
+	void (*cpu_set_freq) (unsigned long f);
+	unsigned long (*cpu_get_freq) (void);
 	unsigned long *mpu_speeds;
 	u8 mpu_num_speeds;
 	unsigned long mpu_min_speed;
@@ -84,9 +84,10 @@ extern struct device *bridge;
 #if defined(CONFIG_MPU_BRIDGE) || defined(CONFIG_MPU_BRIDGE_MODULE)
 extern void dspbridge_reserve_sdram(void);
 #else
-static inline void dspbridge_reserve_sdram(void) {}
+static inline void dspbridge_reserve_sdram(void)
+{
+}
 #endif
 
 extern unsigned long dspbridge_get_mempool_base(void);
 #endif
-
diff --git a/arch/arm/plat-omap/include/dspbridge/io.h b/arch/arm/plat-omap/include/dspbridge/io.h
index c42cf52..6b51274 100644
--- a/arch/arm/plat-omap/include/dspbridge/io.h
+++ b/arch/arm/plat-omap/include/dspbridge/io.h
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * The io module manages IO between CHNL and MSG.
+ * The io module manages IO between CHNL and msg_ctrl.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
@@ -25,66 +25,66 @@
 #include <dspbridge/iodefs.h>
 
 /*
- *  ======== IO_Create ========
+ *  ======== io_create ========
  *  Purpose:
  *      Create an IO manager object, responsible for managing IO between
- *      CHNL and MSG.
+ *      CHNL and msg_ctrl.
  *  Parameters:
  *      phChnlMgr:              Location to store a channel manager object on
  *                              output.
- *      hDevObject:             Handle to a device object.
+ *      hdev_obj:             Handle to a device object.
  *      pMgrAttrs:              IO manager attributes.
- *      pMgrAttrs->bIRQ:        I/O IRQ number.
- *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->birq:        I/O IRQ number.
+ *      pMgrAttrs->irq_shared:     TRUE if the IRQ is shareable.
+ *      pMgrAttrs->word_size:   DSP Word size in equivalent PC bytes..
  *  Returns:
  *      DSP_SOK:                Success;
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
  *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
- *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
+ *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= birq <= 15.
  *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
  *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
  *  Requires:
- *      IO_Init(void) called.
+ *      io_init(void) called.
  *      phIOMgr != NULL.
  *      pMgrAttrs != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr,
-				    struct DEV_OBJECT *hDevObject,
-				    IN CONST struct IO_ATTRS *pMgrAttrs);
+extern dsp_status io_create(OUT struct io_mgr **phIOMgr,
+			    struct dev_object *hdev_obj,
+			    IN CONST struct io_attrs *pMgrAttrs);
 
 /*
- *  ======== IO_Destroy ========
+ *  ======== io_destroy ========
  *  Purpose:
  *      Destroy the IO manager.
  *  Parameters:
- *      hIOMgr:         IOmanager object.
+ *      hio_mgr:         IOmanager object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hIOMgr was invalid.
+ *      DSP_EHANDLE:    hio_mgr was invalid.
  *  Requires:
- *      IO_Init(void) called.
+ *      io_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS IO_Destroy(struct IO_MGR *hIOMgr);
+extern dsp_status io_destroy(struct io_mgr *hio_mgr);
 
 /*
- *  ======== IO_Exit ========
+ *  ======== io_exit ========
  *  Purpose:
  *      Discontinue usage of the IO module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      IO_Init(void) previously called.
+ *      io_init(void) previously called.
  *  Ensures:
- *      Resources, if any acquired in IO_Init(void), are freed when the last
- *      client of IO calls IO_Exit(void).
+ *      Resources, if any acquired in io_init(void), are freed when the last
+ *      client of IO calls io_exit(void).
  */
-	extern void IO_Exit(void);
+extern void io_exit(void);
 
 /*
- *  ======== IO_Init ========
+ *  ======== io_init ========
  *  Purpose:
  *      Initialize the IO module's private state.
  *  Parameters:
@@ -94,22 +94,22 @@
  *  Ensures:
  *      A requirement for each of the other public CHNL functions.
  */
-	extern bool IO_Init(void);
+extern bool io_init(void);
 
 /*
- *  ======== IO_OnLoaded ========
+ *  ======== io_on_loaded ========
  *  Purpose:
  *      Called when a program is loaded so IO manager can update its
  *      internal state.
  *  Parameters:
- *      hIOMgr:         IOmanager object.
+ *      hio_mgr:         IOmanager object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hIOMgr was invalid.
+ *      DSP_EHANDLE:    hio_mgr was invalid.
  *  Requires:
- *      IO_Init(void) called.
+ *      io_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS IO_OnLoaded(struct IO_MGR *hIOMgr);
+extern dsp_status io_on_loaded(struct io_mgr *hio_mgr);
 
-#endif				/* CHNL_ */
+#endif /* CHNL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/io_sm.h b/arch/arm/plat-omap/include/dspbridge/io_sm.h
index 4113c30..f21cac6 100644
--- a/arch/arm/plat-omap/include/dspbridge/io_sm.h
+++ b/arch/arm/plat-omap/include/dspbridge/io_sm.h
@@ -4,7 +4,7 @@
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
  * IO dispatcher for a shared memory channel driver.
- * Also, includes macros to simulate SHM via port io calls.
+ * Also, includes macros to simulate shm via port io calls.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
@@ -32,34 +32,33 @@
 
 #define IO_MGRSIGNATURE     0x494f4D43	/* "IOGR" */
 
-#define DSPFieldAddr(type, field, base, wordsize) \
+#define DSP_FIELD_ADDR(type, field, base, wordsize) \
     ((((s32)&(((type *)0)->field)) / wordsize) + (u32)base)
 
 /* Access can be different SM access word size (e.g. 16/32 bit words) */
-#define IO_SetValue(pContext, type, base, field, value) (base->field = value)
-#define IO_GetValue(pContext, type, base, field)	(base->field)
-#define IO_OrValue(pContext, type, base, field, value)  (base->field |= value)
-#define IO_AndValue(pContext, type, base, field, value) (base->field &= value)
-#define IO_SetLong(pContext, type, base, field, value)  (base->field = value)
-#define IO_GetLong(pContext, type, base, field)         (base->field)
-
+#define IO_SET_VALUE(pContext, type, base, field, value) (base->field = value)
+#define IO_GET_VALUE(pContext, type, base, field)	(base->field)
+#define IO_OR_VALUE(pContext, type, base, field, value)  (base->field |= value)
+#define IO_AND_VALUE(pContext, type, base, field, value) (base->field &= value)
+#define IO_SET_LONG(pContext, type, base, field, value)  (base->field = value)
+#define IO_GET_LONG(pContext, type, base, field)         (base->field)
 
 /*
- *  ======== IO_CancelChnl ========
+ *  ======== io_cancel_chnl ========
  *  Purpose:
  *      Cancel IO on a given channel.
  *  Parameters:
- *      hIOMgr:     IO Manager.
+ *      hio_mgr:     IO Manager.
  *      ulChnl:     Index of channel to cancel IO on.
  *  Returns:
  *  Requires:
- *      Valid hIOMgr.
+ *      Valid hio_mgr.
  *  Ensures:
  */
-	extern void IO_CancelChnl(struct IO_MGR *hIOMgr, u32 ulChnl);
+extern void io_cancel_chnl(struct io_mgr *hio_mgr, u32 ulChnl);
 
 /*
- *  ======== IO_DPC ========
+ *  ======== io_dpc ========
  *  Purpose:
  *      Deferred procedure call for shared memory channel driver ISR.  Carries
  *      out the dispatch of I/O.
@@ -74,13 +73,13 @@
  *  Ensures:
  *      Non-preemptible (but interruptible).
  */
-	extern void IO_DPC(IN OUT unsigned long pRefData);
+extern void io_dpc(IN OUT unsigned long pRefData);
 
 /*
  *  ======== io_mbox_msg ========
  *  Purpose:
  *      Main interrupt handler for the shared memory WMD channel manager.
- *      Calls the WMD's CHNLSM_ISR to determine if this interrupt is ours, then
+ *      Calls the WMD's chnlsm_isr to determine if this interrupt is ours, then
  *      schedules a DPC to dispatch I/O..
  *  Parameters:
  *      pRefData:   Pointer to the channel manager object for this board.
@@ -94,64 +93,63 @@
  *      Interrupts are disabled and EOI for this interrupt has been sent.
  *  Ensures:
  */
-       void io_mbox_msg(u32 msg);
+void io_mbox_msg(u32 msg);
 /*
- *  ======== IO_RequestChnl ========
+ *  ======== io_request_chnl ========
  *  Purpose:
  *      Request I/O from the DSP. Sets flags in shared memory, then interrupts
  *      the DSP.
  *  Parameters:
- *      hIOMgr:     IO manager handle.
- *      pChnl:      Ptr to the channel requesting I/O.
+ *      hio_mgr:     IO manager handle.
+ *      pchnl:      Ptr to the channel requesting I/O.
  *      iMode:      Mode of channel: {IO_INPUT | IO_OUTPUT}.
  *  Returns:
  *  Requires:
- *      pChnl != NULL
+ *      pchnl != NULL
  *  Ensures:
  */
 
-
 #ifdef CONFIG_BRIDGE_WDT3
 /*
  *  ========  io_isr_wdt3 ========
  *  Purpose:
  *         Main interrupt handler for the WDT overflow.
  */
-	irqreturn_t io_isr_wdt3(int irq, void *data);
-	void dsp_wdt_enable(bool);
-	void dsp_wdt_set_timeout(unsigned);
-	unsigned dsp_wdt_get_timeout(void);
-	bool dsp_wdt_get_enable(void);
-	void dsp_wdt_set_enable(bool);
+irqreturn_t io_isr_wdt3(int irq, void *data);
+void dsp_wdt_enable(bool);
+void dsp_wdt_set_timeout(unsigned);
+unsigned dsp_wdt_get_timeout(void);
+bool dsp_wdt_get_enable(void);
+void dsp_wdt_set_enable(bool);
 #endif
 
-	extern void IO_RequestChnl(struct IO_MGR *hIOMgr,
-				   struct CHNL_OBJECT *pChnl,
-				   u32 iMode, OUT u16 *pwMbVal);
+extern void io_request_chnl(struct io_mgr *hio_mgr,
+			    struct chnl_object *pchnl,
+			    u32 iMode, OUT u16 *pwMbVal);
 
 /*
- *  ======== IO_Schedule ========
+ *  ======== iosm_schedule ========
  *  Purpose:
  *      Schedule DPC for IO.
  *  Parameters:
- *      pIOMgr:     Ptr to a I/O manager.
+ *      pio_mgr:     Ptr to a I/O manager.
  *  Returns:
  *  Requires:
- *      pChnl != NULL
+ *      pchnl != NULL
  *  Ensures:
  */
-	extern void IO_Schedule(struct IO_MGR *hIOMgr);
+extern void iosm_schedule(struct io_mgr *hio_mgr);
 
 /*
  * DSP-DMA IO functions
  */
 
 /*
- *  ======== IO_DDMAInitChnlDesc ========
+ *  ======== io_ddma_init_chnl_desc ========
  *  Purpose:
  *      Initialize DSP DMA channel descriptor.
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
+ *      hio_mgr:         Handle to a I/O manager.
  *      uDDMAChnlId:    DDMA channel identifier.
  *      uNumDesc:       Number of buffer descriptors(equals # of IOReqs &
  *                      Chirps)
@@ -165,151 +163,148 @@
  *
  *  Ensures:
  */
-	extern void IO_DDMAInitChnlDesc(struct IO_MGR *hIOMgr, u32 uDDMAChnlId,
-					u32 uNumDesc, void *pDsp);
+extern void io_ddma_init_chnl_desc(struct io_mgr *hio_mgr, u32 uDDMAChnlId,
+				   u32 uNumDesc, void *pDsp);
 
 /*
- *  ======== IO_DDMAClearChnlDesc ========
+ *  ======== io_ddma_clear_chnl_desc ========
  *  Purpose:
  *      Clear DSP DMA channel descriptor.
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
+ *      hio_mgr:         Handle to a I/O manager.
  *      uDDMAChnlId:    DDMA channel identifier.
  *  Returns:
  *  Requires:
  *     uDDMAChnlId < DDMA_MAXDDMACHNLS
  *  Ensures:
  */
-	extern void IO_DDMAClearChnlDesc(struct IO_MGR *hIOMgr,
-					 u32 uDDMAChnlId);
+extern void io_ddma_clear_chnl_desc(struct io_mgr *hio_mgr, u32 uDDMAChnlId);
 
 /*
- *  ======== IO_DDMARequestChnl ========
+ *  ======== io_ddma_request_chnl ========
  *  Purpose:
  *      Request channel DSP-DMA from the DSP. Sets up SM descriptors and
  *      control fields in shared memory.
  *  Parameters:
- *      hIOMgr:     Handle to a I/O manager.
- *      pChnl:      Ptr to channel object
- *      pChirp:     Ptr to channel i/o request packet.
+ *      hio_mgr:     Handle to a I/O manager.
+ *      pchnl:      Ptr to channel object
+ *      chnl_packet_obj:     Ptr to channel i/o request packet.
  *  Returns:
  *  Requires:
- *      pChnl != NULL
- *      pChnl->cIOReqs > 0
- *      pChirp != NULL
+ *      pchnl != NULL
+ *      pchnl->cio_reqs > 0
+ *      chnl_packet_obj != NULL
  *  Ensures:
  */
-	extern void IO_DDMARequestChnl(struct IO_MGR *hIOMgr,
-				       struct CHNL_OBJECT *pChnl,
-				       struct CHNL_IRP *pChirp,
-				       OUT u16 *pwMbVal);
+extern void io_ddma_request_chnl(struct io_mgr *hio_mgr,
+				 struct chnl_object *pchnl,
+				 struct chnl_irp *chnl_packet_obj,
+				 OUT u16 *pwMbVal);
 
 /*
  * Zero-copy IO functions
  */
 
 /*
- *  ======== IO_DDZCInitChnlDesc ========
+ *  ======== io_ddzc_init_chnl_desc ========
  *  Purpose:
  *      Initialize ZCPY channel descriptor.
  *  Parameters:
- *      hIOMgr:     Handle to a I/O manager.
+ *      hio_mgr:     Handle to a I/O manager.
  *      uZId:       zero-copy channel identifier.
  *  Returns:
  *  Requires:
  *     uDDMAChnlId < DDMA_MAXZCPYCHNLS
- *     hIOMgr != Null
+ *     hio_mgr != Null
  *  Ensures:
  */
-	extern void IO_DDZCInitChnlDesc(struct IO_MGR *hIOMgr, u32 uZId);
+extern void io_ddzc_init_chnl_desc(struct io_mgr *hio_mgr, u32 uZId);
 
 /*
- *  ======== IO_DDZCClearChnlDesc ========
+ *  ======== io_ddzc_clear_chnl_desc ========
  *  Purpose:
  *      Clear DSP ZC channel descriptor.
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
+ *      hio_mgr:         Handle to a I/O manager.
  *      uChnlId:        ZC channel identifier.
  *  Returns:
  *  Requires:
- *      hIOMgr is valid
+ *      hio_mgr is valid
  *      uChnlId < DDMA_MAXZCPYCHNLS
  *  Ensures:
  */
-	extern void IO_DDZCClearChnlDesc(struct IO_MGR *hIOMgr, u32 uChnlId);
+extern void io_ddzc_clear_chnl_desc(struct io_mgr *hio_mgr, u32 uChnlId);
 
 /*
- *  ======== IO_DDZCRequestChnl ========
+ *  ======== io_ddzc_request_chnl ========
  *  Purpose:
  *      Request zero-copy channel transfer. Sets up SM descriptors and
  *      control fields in shared memory.
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
- *      pChnl:          Ptr to channel object
- *      pChirp:         Ptr to channel i/o request packet.
+ *      hio_mgr:         Handle to a I/O manager.
+ *      pchnl:          Ptr to channel object
+ *      chnl_packet_obj:         Ptr to channel i/o request packet.
  *  Returns:
  *  Requires:
- *      pChnl != NULL
- *      pChnl->cIOReqs > 0
- *      pChirp != NULL
+ *      pchnl != NULL
+ *      pchnl->cio_reqs > 0
+ *      chnl_packet_obj != NULL
  *  Ensures:
  */
-	extern void IO_DDZCRequestChnl(struct IO_MGR *hIOMgr,
-				       struct CHNL_OBJECT *pChnl,
-				       struct CHNL_IRP *pChirp,
-				       OUT u16 *pwMbVal);
+extern void io_ddzc_request_chnl(struct io_mgr *hio_mgr,
+				 struct chnl_object *pchnl,
+				 struct chnl_irp *chnl_packet_obj,
+				 OUT u16 *pwMbVal);
 
 /*
- *  ======== IO_SHMsetting ========
+ *  ======== io_sh_msetting ========
  *  Purpose:
  *      Sets the shared memory setting
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
+ *      hio_mgr:         Handle to a I/O manager.
  *      desc:             Shared memory type
- *      pArgs:          Ptr to SHM setting
+ *      pargs:          Ptr to shm setting
  *  Returns:
  *  Requires:
- *      hIOMgr != NULL
- *      pArgs != NULL
+ *      hio_mgr != NULL
+ *      pargs != NULL
  *  Ensures:
  */
-	extern DSP_STATUS IO_SHMsetting(struct IO_MGR *hIOMgr,
-					u8 desc, void *pArgs);
+extern dsp_status io_sh_msetting(struct io_mgr *hio_mgr, u8 desc, void *pargs);
 
 /*
  *  Misc functions for the CHNL_IO shared memory library:
  */
 
 /* Maximum channel bufsize that can be used. */
-	extern u32 IO_BufSize(struct IO_MGR *hIOMgr);
+extern u32 io_buf_size(struct io_mgr *hio_mgr);
 
-	extern u32 IO_ReadValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr);
+extern u32 io_read_value(struct wmd_dev_context *hDevContext, u32 dwDSPAddr);
 
-	extern void IO_WriteValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr, u32 dwValue);
+extern void io_write_value(struct wmd_dev_context *hDevContext,
+			   u32 dwDSPAddr, u32 dwValue);
 
-	extern u32 IO_ReadValueLong(struct WMD_DEV_CONTEXT *hDevContext,
-				      u32 dwDSPAddr);
+extern u32 io_read_value_long(struct wmd_dev_context *hDevContext,
+			      u32 dwDSPAddr);
 
-	extern void IO_WriteValueLong(struct WMD_DEV_CONTEXT *hDevContext,
-				      u32 dwDSPAddr, u32 dwValue);
+extern void io_write_value_long(struct wmd_dev_context *hDevContext,
+				u32 dwDSPAddr, u32 dwValue);
 
-	extern void IO_OrSetValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr, u32 dwValue);
+extern void io_or_set_value(struct wmd_dev_context *hDevContext,
+			    u32 dwDSPAddr, u32 dwValue);
 
-	extern void IO_AndSetValue(struct WMD_DEV_CONTEXT *hDevContext,
-				   u32 dwDSPAddr, u32 dwValue);
+extern void io_and_set_value(struct wmd_dev_context *hDevContext,
+			     u32 dwDSPAddr, u32 dwValue);
 
-	extern void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal);
+extern void io_intr_dsp2(IN struct io_mgr *pio_mgr, IN u16 mb_val);
 
-	extern void IO_SM_init(void);
+extern void io_sm_init(void);
 
 /*
- *  ========PrintDspTraceBuffer ========
+ *  ========print_dsp_trace_buffer ========
  *      Print DSP tracebuffer.
  */
-	extern DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT
-						*hWmdContext);
+extern dsp_status print_dsp_trace_buffer(struct wmd_dev_context
+					 *hwmd_context);
 
-#endif				/* IOSM_ */
+#endif /* IOSM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/iodefs.h b/arch/arm/plat-omap/include/dspbridge/iodefs.h
index 23f22e9..8bd10a0 100644
--- a/arch/arm/plat-omap/include/dspbridge/iodefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/iodefs.h
@@ -22,15 +22,15 @@
 #define IO_MAXIRQ   0xff	/* Arbitrarily large number. */
 
 /* IO Objects: */
-	struct IO_MGR;
+struct io_mgr;
 
 /* IO manager attributes: */
-	struct IO_ATTRS {
-		u8 bIRQ;	/* Channel's I/O IRQ number. */
-		bool fShared;	/* TRUE if the IRQ is shareable. */
-		u32 uWordSize;	/* DSP Word size. */
-		u32 dwSMBase;	/* Physical base address of shared memory. */
-		u32 uSMLength;	/* Size (in bytes) of shared memory. */
-	} ;
+struct io_attrs {
+	u8 birq;		/* Channel's I/O IRQ number. */
+	bool irq_shared;	/* TRUE if the IRQ is shareable. */
+	u32 word_size;		/* DSP Word size. */
+	u32 shm_base;		/* Physical base address of shared memory. */
+	u32 usm_length;		/* Size (in bytes) of shared memory. */
+};
 
-#endif				/* IODEFS_ */
+#endif /* IODEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/ldr.h b/arch/arm/plat-omap/include/dspbridge/ldr.h
index f13608f..38c616b 100644
--- a/arch/arm/plat-omap/include/dspbridge/ldr.h
+++ b/arch/arm/plat-omap/include/dspbridge/ldr.h
@@ -24,6 +24,6 @@
 #define LDR_
 
 /* Loader objects: */
-	struct LDR_MODULE;
+struct ldr_module;
 
-#endif				/* LDR_ */
+#endif /* LDR_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/list.h b/arch/arm/plat-omap/include/dspbridge/list.h
index 2c2e8a8..dc8ae09 100644
--- a/arch/arm/plat-omap/include/dspbridge/list.h
+++ b/arch/arm/plat-omap/include/dspbridge/list.h
@@ -23,14 +23,14 @@
 #include <dspbridge/host_os.h>
 #include <linux/list.h>
 
-#define LST_IsEmpty(l)      list_empty(&(l)->head)
+#define LST_IS_EMPTY(l)      list_empty(&(l)->head)
 
-struct LST_LIST {
+struct lst_list {
 	struct list_head head;
 };
 
 /*
- *  ======== LST_First ========
+ *  ======== lst_first ========
  *  Purpose:
  *      Returns a pointer to the first element of the list, or NULL if the list
  *      is empty.
@@ -43,7 +43,7 @@ struct LST_LIST {
  *      - pList != NULL.
  *  Ensures:
  */
-static inline struct list_head *LST_First(struct LST_LIST *pList)
+static inline struct list_head *lst_first(struct lst_list *pList)
 {
 	if (pList && !list_empty(&pList->head))
 		return pList->head.next;
@@ -51,7 +51,7 @@ static inline struct list_head *LST_First(struct LST_LIST *pList)
 }
 
 /*
- *  ======== LST_GetHead ========
+ *  ======== lst_get_head ========
  *  Purpose:
  *      Pops the head off the list and returns a pointer to it.
  *  Details:
@@ -78,27 +78,27 @@ static inline struct list_head *LST_First(struct LST_LIST *pList)
  *      the head of the list, and the head of the list points backward (its
  *      "prev" pointer) to the tail of the list, this list is circular.
  */
-static inline struct list_head *LST_GetHead(struct LST_LIST *pList)
+static inline struct list_head *lst_get_head(struct lst_list *pList)
 {
-	struct list_head *pElem;
+	struct list_head *elem_list;
 
 	if (!pList || list_empty(&pList->head))
 		return NULL;
 
-	pElem = pList->head.next;
-	pList->head.next = pElem->next;
-	pElem->next->prev = &pList->head;
+	elem_list = pList->head.next;
+	pList->head.next = elem_list->next;
+	elem_list->next->prev = &pList->head;
 
-	return pElem;
+	return elem_list;
 }
 
 /*
- *  ======== LST_InitElem ========
+ *  ======== lst_init_elem ========
  *  Purpose:
  *      Initializes a list element to default (cleared) values
  *  Details:
  *  Parameters:
- *      pElem:  Pointer to list element to be reset
+ *      elem_list:  Pointer to list element to be reset
  *  Returns:
  *  Requires:
  *      LST initialized.
@@ -108,65 +108,65 @@ static inline struct list_head *LST_GetHead(struct LST_LIST *pList)
  *      of a list chain -- that would break the chain.
  *
  */
-static inline void LST_InitElem(struct list_head *pElem)
+static inline void lst_init_elem(struct list_head *elem_list)
 {
-	if (pElem) {
-		pElem->next = NULL;
-		pElem->prev = NULL;
+	if (elem_list) {
+		elem_list->next = NULL;
+		elem_list->prev = NULL;
 	}
 }
 
 /*
- *  ======== LST_InsertBefore ========
+ *  ======== lst_insert_before ========
  *  Purpose:
  *     Insert the element before the existing element.
  *  Parameters:
  *      pList:          Pointer to list control structure.
- *      pElem:          Pointer to element in list to insert.
+ *      elem_list:          Pointer to element in list to insert.
  *      pElemExisting:  Pointer to existing list element.
  *  Returns:
  *  Requires:
  *      - LST initialized.
  *      - pList != NULL.
- *      - pElem != NULL.
+ *      - elem_list != NULL.
  *      - pElemExisting != NULL.
  *  Ensures:
  */
-static inline void LST_InsertBefore(struct LST_LIST *pList,
-				    struct list_head *pElem,
-				    struct list_head *pElemExisting)
+static inline void lst_insert_before(struct lst_list *pList,
+				     struct list_head *elem_list,
+				     struct list_head *pElemExisting)
 {
-	if (pList && pElem && pElemExisting)
-		list_add_tail(pElem, pElemExisting);
+	if (pList && elem_list && pElemExisting)
+		list_add_tail(elem_list, pElemExisting);
 }
 
 /*
- *  ======== LST_Next ========
+ *  ======== lst_next ========
  *  Purpose:
  *      Returns a pointer to the next element of the list, or NULL if the next
  *      element is the head of the list or the list is empty.
  *  Parameters:
  *      pList:      Pointer to list control structure.
- *      pCurElem:   Pointer to element in list to remove.
+ *      cur_elem:   Pointer to element in list to remove.
  *  Returns:
  *      Pointer to list element, or NULL.
  *  Requires:
  *      - LST initialized.
  *      - pList != NULL.
- *      - pCurElem != NULL.
+ *      - cur_elem != NULL.
  *  Ensures:
  */
-static inline struct list_head *LST_Next(struct LST_LIST *pList,
-					 struct list_head *pCurElem)
+static inline struct list_head *lst_next(struct lst_list *pList,
+					 struct list_head *cur_elem)
 {
-	if (pList && !list_empty(&pList->head) && pCurElem &&
-	   (pCurElem->next != &pList->head))
-		return pCurElem->next;
+	if (pList && !list_empty(&pList->head) && cur_elem &&
+	    (cur_elem->next != &pList->head))
+		return cur_elem->next;
 	return NULL;
 }
 
 /*
- *  ======== LST_PutTail ========
+ *  ======== lst_put_tail ========
  *  Purpose:
  *      Adds the specified element to the tail of the list
  *  Details:
@@ -179,13 +179,13 @@ static inline struct list_head *LST_Next(struct LST_LIST *pList,
  *      Sets new element's next pointer to the address of the head element.
  *      Sets head's prev pointer to the address of the new element.
  *  Parameters:
- *      pList:  Pointer to list control structure to which *pElem will be
+ *      pList:  Pointer to list control structure to which *elem_list will be
  *              added
- *      pElem:  Pointer to list element to be added
+ *      elem_list:  Pointer to list element to be added
  *  Returns:
  *      Void
  *  Requires:
- *      *pElem and *pList must both exist.
+ *      *elem_list and *pList must both exist.
  *      LST initialized.
  *  Ensures:
  *  Notes:
@@ -193,32 +193,33 @@ static inline struct list_head *LST_Next(struct LST_LIST *pList,
  *      tail's "next" pointer points at the head of the list, and the head's
  *      "prev" pointer points at the tail of the list), the list is circular.
  */
-static inline void LST_PutTail(struct LST_LIST *pList, struct list_head *pElem)
+static inline void lst_put_tail(struct lst_list *pList,
+				struct list_head *elem_list)
 {
-	if (pList && pElem)
-		list_add_tail(pElem, &pList->head);
+	if (pList && elem_list)
+		list_add_tail(elem_list, &pList->head);
 }
 
 /*
- *  ======== LST_RemoveElem ========
+ *  ======== lst_remove_elem ========
  *  Purpose:
  *      Removes (unlinks) the given element from the list, if the list is not
  *      empty.  Does not free the list element.
  *  Parameters:
  *      pList:      Pointer to list control structure.
- *      pCurElem:   Pointer to element in list to remove.
+ *      cur_elem:   Pointer to element in list to remove.
  *  Returns:
  *  Requires:
  *      - LST initialized.
  *      - pList != NULL.
- *      - pCurElem != NULL.
+ *      - cur_elem != NULL.
  *  Ensures:
  */
-static inline void LST_RemoveElem(struct LST_LIST *pList,
-				  struct list_head *pCurElem)
+static inline void lst_remove_elem(struct lst_list *pList,
+				   struct list_head *cur_elem)
 {
-	if (pList && !list_empty(&pList->head) && pCurElem)
-		list_del_init(pCurElem);
+	if (pList && !list_empty(&pList->head) && cur_elem)
+		list_del_init(cur_elem);
 }
 
-#endif				/* LIST_ */
+#endif /* LIST_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/mbx_sh.h b/arch/arm/plat-omap/include/dspbridge/mbx_sh.h
index 0e4e655..289f6f3 100644
--- a/arch/arm/plat-omap/include/dspbridge/mbx_sh.h
+++ b/arch/arm/plat-omap/include/dspbridge/mbx_sh.h
@@ -128,7 +128,7 @@
 #define MBX_DEH_USERS_BASE  0x100	/* 256 */
 #define MBX_DEH_LIMIT       0x3FF	/* 1023 */
 #define MBX_DEH_RESET       0x101	/* DSP RESET (DEH) */
-#define MBX_DEH_EMMU        0X103 /*DSP MMU FAULT RECOVERY*/
+#define MBX_DEH_EMMU        0X103	/*DSP MMU FAULT RECOVERY */
 
 /*
  *  Link driver command/status codes.
@@ -173,10 +173,10 @@
 #define MBX_PM_OPP_CHNG(OPP) (MBX_PM_CLASS | MBX_PM_TYPE_OPP_PRECHNG | (OPP))
 #define MBX_PM_RET (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0006)
 #define MBX_PM_HIB (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0002)
-#define MBX_PM_OPP_1 0
-#define MBX_PM_OPP_2 1
-#define MBX_PM_OPP_3 2
-#define MBX_PM_OPP_4 3
+#define MBX_PM_OPP1 0
+#define MBX_PM_OPP2 1
+#define MBX_PM_OPP3 2
+#define MBX_PM_OPP4 3
 #define MBX_OLDOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
 #define MBX_NEWOPP_EXTRACT(OPPMSG) (0x000F & (OPPMSG))
 #define MBX_PREVOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
@@ -195,4 +195,4 @@
 /* Zero-Copy channel */
 #define MBX_SETZCPYVAL(x)  (MBX_ZCPY_CLASS | (x << MBX_ZCPY_CHNLSHIFT))
 
-#endif				/* _MBX_SH_H */
+#endif /* _MBX_SH_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/mem.h b/arch/arm/plat-omap/include/dspbridge/mem.h
index a6215d4..8a9a092 100644
--- a/arch/arm/plat-omap/include/dspbridge/mem.h
+++ b/arch/arm/plat-omap/include/dspbridge/mem.h
@@ -24,17 +24,17 @@
 #include <dspbridge/memdefs.h>
 
 /*
- *  ======== MEM_Alloc ========
+ *  ======== mem_alloc ========
  *  Purpose:
  *      Allocate memory from the paged or non-paged pools.
  *  Parameters:
- *      cBytes: Number of bytes to allocate.
+ *      byte_size: Number of bytes to allocate.
  *      type:   Type of memory to allocate; one of:
  *              MEM_PAGED: Allocate from pageable memory.
  *              MEM_NONPAGED: Allocate from page locked memory.
  *  Returns:
  *      Pointer to a block of memory;
- *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
+ *      NULL if memory couldn't be allocated, if byte_size == 0, or if type is
  *      not one of MEM_PAGED or MEM_NONPAGED.
  *  Requires:
  *      MEM initialized.
@@ -42,10 +42,10 @@
  *      The returned pointer, if not NULL, points to a valid memory block of
  *      the size requested.
  */
-	extern void *MEM_Alloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
+extern void *mem_alloc(IN u32 byte_size, IN enum mem_poolattrs type);
 
 /*
- *  ======== MEM_AllocObject ========
+ *  ======== MEM_ALLOC_OBJECT ========
  *  Purpose:
  *      Allocate an object, and set it's signature.
  *  Parameters:
@@ -54,30 +54,30 @@
  *      Signature:  Magic field value.  Must be non-zero.
  *  Returns:
  *  Requires:
- *      Same requirements as MEM_Calloc(); and
- *      The object structure has a dwSignature field.  The compiler ensures
+ *      Same requirements as mem_calloc(); and
+ *      The object structure has a dw_signature field.  The compiler ensures
  *      this requirement.
  *  Ensures:
- *      A subsequent call to MEM_IsValidHandle() will succeed for this object.
+ *      A subsequent call to MEM_IS_VALID_HANDLE() will succeed for this object.
  */
-#define MEM_AllocObject(pObj, Obj, Signature)		\
+#define MEM_ALLOC_OBJECT(pObj, Obj, Signature)		\
 do {							\
-	pObj = MEM_Calloc(sizeof(Obj), MEM_NONPAGED);	\
+	pObj = mem_calloc(sizeof(Obj), MEM_NONPAGED);	\
 	if (pObj) {					\
-		pObj->dwSignature = Signature;		\
+		pObj->dw_signature = Signature;		\
 	}						\
 } while (0)
 
-/*  ======== MEM_AllocPhysMem ========
+/*  ======== mem_alloc_phys_mem ========
  *  Purpose:
  *      Allocate physically contiguous, uncached memory
  *  Parameters:
- *      cBytes:     Number of bytes to allocate.
+ *      byte_size:     Number of bytes to allocate.
  *      ulAlign:    Alignment Mask.
  *      pPhysicalAddress: Physical address of allocated memory.
  *  Returns:
  *      Pointer to a block of memory;
- *      NULL if memory couldn't be allocated, or if cBytes == 0.
+ *      NULL if memory couldn't be allocated, or if byte_size == 0.
  *  Requires:
  *      MEM initialized.
  *  Ensures:
@@ -85,22 +85,21 @@ do {							\
  *      the size requested.  Returned physical address refers to physical
  *      location of memory.
  */
-	extern void *MEM_AllocPhysMem(IN u32 cBytes,
-				      IN u32 ulAlign,
-				      OUT u32 *pPhysicalAddress);
+extern void *mem_alloc_phys_mem(IN u32 byte_size,
+				IN u32 ulAlign, OUT u32 *pPhysicalAddress);
 
 /*
- *  ======== MEM_Calloc ========
+ *  ======== mem_calloc ========
  *  Purpose:
  *      Allocate zero-initialized memory from the paged or non-paged pools.
  *  Parameters:
- *      cBytes: Number of bytes to allocate.
+ *      byte_size: Number of bytes to allocate.
  *      type:   Type of memory to allocate; one of:
  *              MEM_PAGED:   Allocate from pageable memory.
  *              MEM_NONPAGED: Allocate from page locked memory.
  *  Returns:
  *      Pointer to a block of zeroed memory;
- *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
+ *      NULL if memory couldn't be allocated, if byte_size == 0, or if type is
  *      not one of MEM_PAGED or MEM_NONPAGED.
  *  Requires:
  *      MEM initialized.
@@ -108,10 +107,10 @@ do {							\
  *      The returned pointer, if not NULL, points to a valid memory block
  *      of the size requested.
  */
-	extern void *MEM_Calloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
+extern void *mem_calloc(IN u32 byte_size, IN enum mem_poolattrs type);
 
 /*
- *  ======== MEM_Exit ========
+ *  ======== mem_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -122,10 +121,10 @@ do {							\
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void MEM_Exit(void);
+extern void mem_exit(void);
 
 /*
- *  ======== MEM_FlushCache ========
+ *  ======== mem_flush_cache ========
  *  Purpose:
  *      Performs system cache sync with discard
  *  Parameters:
@@ -137,31 +136,31 @@ do {							\
  *  Ensures:
  *      Cache is synchronized
  */
-	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType);
+extern void mem_flush_cache(void *pMemBuf, u32 byte_size, u32 FlushType);
 
 /*
- *  ======== MEM_FreePhysMem ========
+ *  ======== mem_free_phys_mem ========
  *  Purpose:
  *      Free the given block of physically contiguous memory.
  *  Parameters:
  *      pVirtualAddress:  Pointer to virtual memory region allocated
- *      by MEM_AllocPhysMem().
+ *      by mem_alloc_phys_mem().
  *      pPhysicalAddress:  Pointer to physical memory region  allocated
- *      by MEM_AllocPhysMem().
- *      cBytes:  Size of the memory region allocated by MEM_AllocPhysMem().
+ *      by mem_alloc_phys_mem().
+ *      byte_size:  Size of the memory region allocated by mem_alloc_phys_mem().
  *  Returns:
  *  Requires:
  *      MEM initialized.
  *      pVirtualAddress is a valid memory address returned by
- *          MEM_AllocPhysMem()
+ *          mem_alloc_phys_mem()
  *  Ensures:
  *      pVirtualAddress is no longer a valid pointer to memory.
  */
-	extern void MEM_FreePhysMem(void *pVirtualAddress,
-				    u32 pPhysicalAddress, u32 cBytes);
+extern void mem_free_phys_mem(void *pVirtualAddress,
+			      u32 pPhysicalAddress, u32 byte_size);
 
 /*
- *  ======== MEM_FreeObject ========
+ *  ======== MEM_FREE_OBJECT ========
  *  Purpose:
  *      Utility macro to invalidate an object's signature, and deallocate it.
  *  Parameters:
@@ -170,32 +169,32 @@ do {							\
  *  Requires:
  *      Same requirements as kfree().
  *  Ensures:
- *      A subsequent call to MEM_IsValidHandle() will fail for this object.
+ *      A subsequent call to MEM_IS_VALID_HANDLE() will fail for this object.
  */
-#define MEM_FreeObject(pObj)		\
+#define MEM_FREE_OBJECT(pObj)		\
 do {					\
-	pObj->dwSignature = 0x00;	\
+	pObj->dw_signature = 0x00;	\
 	kfree(pObj);			\
 } while (0)
 
 /*
- *  ======== MEM_GetNumPages ========
+ *  ======== mem_get_num_pages ========
  *  Purpose:
  *      Calculate the number of pages corresponding to the supplied buffer.
  *  Parameters:
- *      pAddr:  Linear (virtual) address of the buffer.
- *      cBytes: Number of bytes in the buffer.
+ *      paddr:  Linear (virtual) address of the buffer.
+ *      byte_size: Number of bytes in the buffer.
  *  Returns:
  *      Number of pages.
  *  Requires:
  *      MEM initialized.
  *  Ensures:
- *      If cBytes > 0, number of pages returned > 0.
+ *      If byte_size > 0, number of pages returned > 0.
  */
-	extern s32 MEM_GetNumPages(IN void *pAddr, IN u32 cBytes);
+extern s32 mem_get_num_pages(IN void *paddr, IN u32 byte_size);
 
 /*
- *  ======== MEM_Init ========
+ *  ======== services_mem_init ========
  *  Purpose:
  *      Initializes private state of MEM module.
  *  Parameters:
@@ -205,31 +204,31 @@ do {					\
  *  Ensures:
  *      MEM initialized.
  */
-	extern bool MEM_Init(void);
+extern bool services_mem_init(void);
 
 /*
- *  ======== MEM_IsValidHandle ========
+ *  ======== MEM_IS_VALID_HANDLE ========
  *  Purpose:
  *      Validate the object handle.
  *  Parameters:
- *      hObj:   Handle to object created with MEM_AllocObject().
+ *      hObj:   Handle to object created with MEM_ALLOC_OBJECT().
  *      Sig:    Expected signature u32.
  *  Returns:
  *      TRUE if handle is valid; FALSE otherwise.
  *  Requires:
- *      The object structure has a dwSignature field. Ensured by compiler.
+ *      The object structure has a dw_signature field. Ensured by compiler.
  *  Ensures:
  */
-#define MEM_IsValidHandle(hObj, Sig)                \
-     ((hObj != NULL) && (hObj->dwSignature == Sig))
+#define MEM_IS_VALID_HANDLE(hObj, Sig)                \
+     ((hObj != NULL) && (hObj->dw_signature == Sig))
 
 /*
- *  ======== MEM_LinearAddress ========
+ *  ======== MEM_LINEAR_ADDRESS ========
  *  Purpose:
  *      Get the linear address corresponding to the given physical address.
  *  Parameters:
  *      pPhysAddr:  Physical address to be mapped.
- *      cBytes:     Number of bytes in physical range to map.
+ *      byte_size:     Number of bytes in physical range to map.
  *  Returns:
  *      The corresponding linear address, or NULL if unsuccessful.
  *  Requires:
@@ -237,27 +236,27 @@ do {					\
  *  Ensures:
  *  Notes:
  *      If valid linear address is returned, be sure to call
- *      MEM_UnmapLinearAddress().
+ *      MEM_UNMAP_LINEAR_ADDRESS().
  */
-#define MEM_LinearAddress(pPhyAddr, cBytes) pPhyAddr
+#define MEM_LINEAR_ADDRESS(pPhyAddr, byte_size) pPhyAddr
 
 /*
- *  ======== MEM_UnmapLinearAddress ========
+ *  ======== MEM_UNMAP_LINEAR_ADDRESS ========
  *  Purpose:
- *      Unmap the linear address mapped in MEM_LinearAddress.
+ *      Unmap the linear address mapped in MEM_LINEAR_ADDRESS.
  *  Parameters:
- *      pBaseAddr: Ptr to mapped memory (as returned by MEM_LinearAddress()).
+ *      pBaseAddr: Ptr to mapped memory (as returned by MEM_LINEAR_ADDRESS()).
  *  Returns:
  *  Requires:
  *      - MEM initialized.
- *      - pBaseAddr is a valid linear address mapped in MEM_LinearAddress.
+ *      - pBaseAddr is a valid linear address mapped in MEM_LINEAR_ADDRESS.
  *  Ensures:
  *      - pBaseAddr no longer points to a valid linear address.
  */
-#define MEM_UnmapLinearAddress(pBaseAddr) {}
+#define MEM_UNMAP_LINEAR_ADDRESS(pBaseAddr) {}
 
 /*
- *  ======== MEM_ExtPhysPoolInit ========
+ *  ======== mem_ext_phys_pool_init ========
  *  Purpose:
  *      Uses the physical memory chunk passed for internal consitent memory
  *      allocations.
@@ -271,12 +270,11 @@ do {					\
  *      - MEM initialized.
  *      - valid physical address for the base and size > 0
  */
-	extern void MEM_ExtPhysPoolInit(IN u32 poolPhysBase,
-					IN u32 poolSize);
+extern void mem_ext_phys_pool_init(IN u32 poolPhysBase, IN u32 poolSize);
 
 /*
- *  ======== MEM_ExtPhysPoolRelease ========
+ *  ======== mem_ext_phys_pool_release ========
  */
-	extern void MEM_ExtPhysPoolRelease(void);
+extern void mem_ext_phys_pool_release(void);
 
-#endif				/* MEM_ */
+#endif /* MEM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/memdefs.h b/arch/arm/plat-omap/include/dspbridge/memdefs.h
index 2e44f5c..23885fd 100644
--- a/arch/arm/plat-omap/include/dspbridge/memdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/memdefs.h
@@ -20,11 +20,11 @@
 #define MEMDEFS_
 
 /* Memory Pool Attributes: */
-	enum MEM_POOLATTRS {
-		MEM_PAGED = 0,
-		MEM_NONPAGED = 1,
-		MEM_LARGEVIRTMEM = 2
-	} ;
+enum mem_poolattrs {
+	MEM_PAGED = 0,
+	MEM_NONPAGED = 1,
+	MEM_LARGEVIRTMEM = 2
+};
 
 /*
  *  MEM_VIRTUALSEGID is used by Node & Strm to access virtual address space in
@@ -34,4 +34,4 @@
 #define MEM_GETVIRTUALSEGID     0x20000000
 #define MEM_MASKVIRTUALSEGID    (MEM_SETVIRTUALSEGID | MEM_GETVIRTUALSEGID)
 
-#endif				/* MEMDEFS_ */
+#endif /* MEMDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/mgr.h b/arch/arm/plat-omap/include/dspbridge/mgr.h
index e645b05..feb1b61 100644
--- a/arch/arm/plat-omap/include/dspbridge/mgr.h
+++ b/arch/arm/plat-omap/include/dspbridge/mgr.h
@@ -24,39 +24,39 @@
 #define MAX_EVENTS 32
 
 /*
- *  ======== MGR_WaitForBridgeEvents ========
+ *  ======== mgr_wait_for_bridge_events ========
  *  Purpose:
  *      Block on any Bridge event(s)
  *  Parameters:
- *      aNotifications  : array of pointers to notification objects.
- *      uCount          : number of elements in above array
- *      puIndex         : index of signaled event object
- *      uTimeout        : timeout interval in milliseocnds
+ *      anotifications  : array of pointers to notification objects.
+ *      count          : number of elements in above array
+ *      pu_index         : index of signaled event object
+ *      utimeout        : timeout interval in milliseocnds
  *  Returns:
  *      DSP_SOK         : Success.
- *      DSP_ETIMEOUT    : Wait timed out. *puIndex is undetermined.
+ *      DSP_ETIMEOUT    : Wait timed out. *pu_index is undetermined.
  *  Details:
  */
 
-	DSP_STATUS MGR_WaitForBridgeEvents(struct DSP_NOTIFICATION
-					   **aNotifications,
-					   u32 uCount, OUT u32 *puIndex,
-					   u32 uTimeout);
+dsp_status mgr_wait_for_bridge_events(struct dsp_notification
+				      **anotifications,
+				      u32 count, OUT u32 *pu_index,
+				      u32 utimeout);
 
 /*
- *  ======== MGR_Create ========
+ *  ======== mgr_create ========
  *  Purpose:
  *      Creates the Manager Object. This is done during the driver loading.
  *      There is only one Manager Object in the DSP/BIOS Bridge.
  *  Parameters:
  *      phMgrObject:    Location to store created MGR Object handle.
- *      hDevNode:       Device object as known to Windows system.
+ *      dev_node_obj:       Device object as known to Windows system.
  *  Returns:
  *      DSP_SOK:        Success
  *      DSP_EMEMORY:    Failed to Create the Object
  *      DSP_EFAIL:      General Failure
  *  Requires:
- *      MGR Initialized (cRefs > 0 )
+ *      MGR Initialized (refs > 0 )
  *      phMgrObject != NULL.
  *  Ensures:
  *      DSP_SOK:        *phMgrObject is a valid MGR interface to the device.
@@ -66,43 +66,43 @@
  *  Details:
  *      DCD Dll is loaded and MGR Object stores the handle of the DLL.
  */
-	extern DSP_STATUS MGR_Create(OUT struct MGR_OBJECT **hMgrObject,
-				     struct CFG_DEVNODE *hDevNode);
+extern dsp_status mgr_create(OUT struct mgr_object **hmgr_obj,
+			     struct cfg_devnode *dev_node_obj);
 
 /*
- *  ======== MGR_Destroy ========
+ *  ======== mgr_destroy ========
  *  Purpose:
  *      Destroys the MGR object. Called upon driver unloading.
  *  Parameters:
- *      hMgrObject:     Handle to Manager object .
+ *      hmgr_obj:     Handle to Manager object .
  *  Returns:
  *      DSP_SOK:        Success.
  *                      DCD Manager freed; MGR Object destroyed;
  *                      MGR Object deleted from the Registry.
  *      DSP_EFAIL:      Failed to destroy MGR Object
  *  Requires:
- *      MGR Initialized (cRefs > 0 )
- *      hMgrObject is a valid MGR handle .
+ *      MGR Initialized (refs > 0 )
+ *      hmgr_obj is a valid MGR handle .
  *  Ensures:
- *      DSP_SOK:        MGR Object destroyed and hMgrObject is Invalid MGR
+ *      DSP_SOK:        MGR Object destroyed and hmgr_obj is Invalid MGR
  *                      Handle.
  */
-	extern DSP_STATUS MGR_Destroy(struct MGR_OBJECT *hMgrObject);
+extern dsp_status mgr_destroy(struct mgr_object *hmgr_obj);
 
 /*
- *  ======== MGR_EnumNodeInfo ========
+ *  ======== mgr_enum_node_info ========
  *  Purpose:
  *      Enumerate and get configuration information about nodes configured
  *      in the node database.
  *  Parameters:
- *      uNode:              The node index (base 0).
- *      pNDBProps:          Ptr to the DSP_NDBPROPS structure for output.
- *      uNDBPropsSize:      Size of the DSP_NDBPROPS structure.
- *      puNumNodes:         Location where the number of nodes configured
+ *      node_id:              The node index (base 0).
+ *      pndb_props:          Ptr to the dsp_ndbprops structure for output.
+ *      undb_props_size:      Size of the dsp_ndbprops structure.
+ *      pu_num_nodes:         Location where the number of nodes configured
  *                          in the database will be returned.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EINVALIDARG:    Parameter uNode is > than the number of nodes.
+ *      DSP_EINVALIDARG:    Parameter node_id is > than the number of nodes.
  *                          configutred in the system
  *      DSP_ECHANGEDURINGENUM:  During Enumeration there has been a change in
  *                              the number of nodes configured or in the
@@ -110,52 +110,52 @@
  *      DSP_EFAIL:          Failed to querry the Node Data Base
  *  Requires:
  *      pNDBPROPS is not null
- *      uNDBPropsSize >= sizeof(DSP_NDBPROPS)
- *      puNumNodes is not null
- *      MGR Initialized (cRefs > 0 )
+ *      undb_props_size >= sizeof(dsp_ndbprops)
+ *      pu_num_nodes is not null
+ *      MGR Initialized (refs > 0 )
  *  Ensures:
- *      SUCCESS on successful retreival of data and *puNumNodes > 0 OR
- *      DSP_FAILED  && *puNumNodes == 0.
+ *      SUCCESS on successful retreival of data and *pu_num_nodes > 0 OR
+ *      DSP_FAILED  && *pu_num_nodes == 0.
  *  Details:
  */
-	extern DSP_STATUS MGR_EnumNodeInfo(u32 uNode,
-					   OUT struct DSP_NDBPROPS *pNDBProps,
-					   u32 uNDBPropsSize,
-					   OUT u32 *puNumNodes);
+extern dsp_status mgr_enum_node_info(u32 node_id,
+				     OUT struct dsp_ndbprops *pndb_props,
+				     u32 undb_props_size,
+				     OUT u32 *pu_num_nodes);
 
 /*
- *  ======== MGR_EnumProcessorInfo ========
+ *  ======== mgr_enum_processor_info ========
  *  Purpose:
  *      Enumerate and get configuration information about available DSP
  *      processors
  *  Parameters:
- *      uProcessor:         The processor index (zero-based).
- *      pProcessorInfo:     Ptr to the DSP_PROCESSORINFO structure .
- *      uProcessorInfoSize: Size of DSP_PROCESSORINFO structure.
- *      puNumProcs:         Location where the number of DSPs configured
+ *      processor_id:         The processor index (zero-based).
+ *      processor_info:     Ptr to the dsp_processorinfo structure .
+ *      processor_info_size: Size of dsp_processorinfo structure.
+ *      pu_num_procs:         Location where the number of DSPs configured
  *                          in the database will be returned
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EINVALIDARG:    Parameter uProcessor is > than the number of
+ *      DSP_EINVALIDARG:    Parameter processor_id is > than the number of
  *                          DSP Processors in the system.
  *      DSP_EFAIL:          Failed to querry the Node Data Base
  *  Requires:
- *      pProcessorInfo is not null
- *      puNumProcs is not null
- *      uProcessorInfoSize >= sizeof(DSP_PROCESSORINFO)
- *      MGR Initialized (cRefs > 0 )
+ *      processor_info is not null
+ *      pu_num_procs is not null
+ *      processor_info_size >= sizeof(dsp_processorinfo)
+ *      MGR Initialized (refs > 0 )
  *  Ensures:
- *      SUCCESS on successful retreival of data and *puNumProcs > 0 OR
- *      DSP_FAILED && *puNumProcs == 0.
+ *      SUCCESS on successful retreival of data and *pu_num_procs > 0 OR
+ *      DSP_FAILED && *pu_num_procs == 0.
  *  Details:
  */
-	extern DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
-						OUT struct DSP_PROCESSORINFO *
-						pProcessorInfo,
-						u32 uProcessorInfoSize,
-						OUT u32 *puNumProcs);
+extern dsp_status mgr_enum_processor_info(u32 processor_id,
+					  OUT struct dsp_processorinfo
+					  *processor_info,
+					  u32 processor_info_size,
+					  OUT u32 *pu_num_procs);
 /*
- *  ======== MGR_Exit ========
+ *  ======== mgr_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
@@ -166,10 +166,10 @@
  *  Ensures:
  *      When reference count == 0, MGR's private resources are freed.
  */
-       extern void MGR_Exit(void);
+extern void mgr_exit(void);
 
 /*
- *  ======== MGR_GetDCDHandle ========
+ *  ======== mgr_get_dcd_handle ========
  *  Purpose:
  *      Retrieves the MGR handle. Accessor Function
  *  Parameters:
@@ -185,12 +185,11 @@
  *      DSP_SOK and *phDCDHandle != NULL ||
  *      DSP_EFAIL and *phDCDHandle == NULL
  */
-       extern DSP_STATUS MGR_GetDCDHandle(IN struct MGR_OBJECT
-						 *hMGRHandle,
-						 OUT u32 *phDCDHandle);
+extern dsp_status mgr_get_dcd_handle(IN struct mgr_object
+				     *hMGRHandle, OUT u32 *phDCDHandle);
 
 /*
- *  ======== MGR_Init ========
+ *  ======== mgr_init ========
  *  Purpose:
  *      Initialize MGR's private state, keeping a reference count on each
  *      call. Intializes the DCD.
@@ -201,6 +200,6 @@
  *  Ensures:
  *      TRUE: A requirement for the other public MGR functions.
  */
-       extern bool MGR_Init(void);
+extern bool mgr_init(void);
 
-#endif				/* MGR_ */
+#endif /* MGR_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/mgrpriv.h b/arch/arm/plat-omap/include/dspbridge/mgrpriv.h
index cb3b0c2..12ac32f 100644
--- a/arch/arm/plat-omap/include/dspbridge/mgrpriv.h
+++ b/arch/arm/plat-omap/include/dspbridge/mgrpriv.h
@@ -25,21 +25,21 @@
 #define MGR_MAXTLBENTRIES  32
 
 /* RM MGR Object */
-	struct MGR_OBJECT;
+struct mgr_object;
 
-	struct MGR_TLBENTRY {
-		u32 ulDspVirt;	/* DSP virtual address */
-		u32 ulGppPhys;	/* GPP physical address */
-	} ;
+struct mgr_tlbentry {
+	u32 ul_dsp_virt;	/* DSP virtual address */
+	u32 ul_gpp_phys;	/* GPP physical address */
+};
 
 /*
  *  The DSP_PROCESSOREXTINFO structure describes additional extended
  *  capabilities of a DSP processor not exposed to user.
  */
-	struct MGR_PROCESSOREXTINFO {
-		struct DSP_PROCESSORINFO tyBasic;    /* user processor info */
-		/* private dsp mmu entries */
-		struct MGR_TLBENTRY tyTlb[MGR_MAXTLBENTRIES];
-	} ;
+struct mgr_processorextinfo {
+	struct dsp_processorinfo ty_basic;	/* user processor info */
+	/* private dsp mmu entries */
+	struct mgr_tlbentry ty_tlb[MGR_MAXTLBENTRIES];
+};
 
-#endif				/* MGRPRIV_ */
+#endif /* MGRPRIV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/msg.h b/arch/arm/plat-omap/include/dspbridge/msg.h
index 2471603..b466afa 100644
--- a/arch/arm/plat-omap/include/dspbridge/msg.h
+++ b/arch/arm/plat-omap/include/dspbridge/msg.h
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * DSP/BIOS Bridge MSG Module.
+ * DSP/BIOS Bridge msg_ctrl Module.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
@@ -23,64 +23,64 @@
 #include <dspbridge/msgdefs.h>
 
 /*
- *  ======== MSG_Create ========
+ *  ======== msg_create ========
  *  Purpose:
  *      Create an object to manage message queues. Only one of these objects
- *      can exist per device object. The MSG manager must be created before
+ *      can exist per device object. The msg_ctrl manager must be created before
  *      the IO Manager.
  *  Parameters:
- *      phMsgMgr:           Location to store MSG manager handle on output.
- *      hDevObject:         The device object.
+ *      phMsgMgr:           Location to store msg_ctrl manager handle on output.
+ *      hdev_obj:         The device object.
  *      msgCallback:        Called whenever an RMS_EXIT message is received.
  *  Returns:
  *  Requires:
- *      MSG_Init(void) called.
+ *      msg_mod_init(void) called.
  *      phMsgMgr != NULL.
- *      hDevObject != NULL.
+ *      hdev_obj != NULL.
  *      msgCallback != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     MSG_ONEXIT msgCallback);
+extern dsp_status msg_create(OUT struct msg_mgr **phMsgMgr,
+			     struct dev_object *hdev_obj,
+			     msg_onexit msgCallback);
 
 /*
- *  ======== MSG_Delete ========
+ *  ======== msg_delete ========
  *  Purpose:
- *      Delete a MSG manager allocated in MSG_Create().
+ *      Delete a msg_ctrl manager allocated in msg_create().
  *  Parameters:
- *      hMsgMgr:            Handle returned from MSG_Create().
+ *      hmsg_mgr:            Handle returned from msg_create().
  *  Returns:
  *  Requires:
- *      MSG_Init(void) called.
- *      Valid hMsgMgr.
+ *      msg_mod_init(void) called.
+ *      Valid hmsg_mgr.
  *  Ensures:
  */
-	extern void MSG_Delete(struct MSG_MGR *hMsgMgr);
+extern void msg_delete(struct msg_mgr *hmsg_mgr);
 
 /*
- *  ======== MSG_Exit ========
+ *  ======== msg_exit ========
  *  Purpose:
- *      Discontinue usage of MSG module.
+ *      Discontinue usage of msg_ctrl module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      MSG_Init(void) successfully called before.
+ *      msg_mod_init(void) successfully called before.
  *  Ensures:
- *      Any resources acquired in MSG_Init(void) will be freed when last MSG
- *      client calls MSG_Exit(void).
+ *      Any resources acquired in msg_mod_init(void) will be freed when last
+ *      msg_ctrl client calls msg_exit(void).
  */
-	extern void MSG_Exit(void);
+extern void msg_exit(void);
 
 /*
- *  ======== MSG_Init ========
+ *  ======== msg_mod_init ========
  *  Purpose:
- *      Initialize the MSG module.
+ *      Initialize the msg_ctrl module.
  *  Parameters:
  *  Returns:
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	extern bool MSG_Init(void);
+extern bool msg_mod_init(void);
 
-#endif				/* MSG_ */
+#endif /* MSG_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/msgdefs.h b/arch/arm/plat-omap/include/dspbridge/msgdefs.h
index 8220bdb..cda4ef4 100644
--- a/arch/arm/plat-omap/include/dspbridge/msgdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/msgdefs.h
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * Global MSG constants and types.
+ * Global msg_ctrl constants and types.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
@@ -21,12 +21,11 @@
 
 #define MSGMGR_SIGNATURE    0x4d47534d	/* "MGSM" */
 
-/* MSG Objects: */
-	struct MSG_MGR;
-	struct MSG_QUEUE;
+/* msg_ctrl Objects: */
+struct msg_mgr;
+struct msg_queue;
 
 /* Function prototype for callback to be called on RMS_EXIT message received */
-       typedef void(*MSG_ONEXIT) (HANDLE h, s32 nStatus);
-
-#endif				/* MSGDEFS_ */
+typedef void (*msg_onexit) (bhandle h, s32 nStatus);
 
+#endif /* MSGDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/nldr.h b/arch/arm/plat-omap/include/dspbridge/nldr.h
index 4f0639a..2ec928a 100644
--- a/arch/arm/plat-omap/include/dspbridge/nldr.h
+++ b/arch/arm/plat-omap/include/dspbridge/nldr.h
@@ -25,31 +25,29 @@
 #ifndef NLDR_
 #define NLDR_
 
-	extern DSP_STATUS NLDR_Allocate(struct NLDR_OBJECT *hNldr,
-					void *pPrivRef,
-					IN CONST struct DCD_NODEPROPS
-					*pNodeProps,
-					OUT struct NLDR_NODEOBJECT **phNldrNode,
-					IN bool *pfPhaseSplit);
-
-	extern DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct NLDR_ATTRS *pAttrs);
-
-	extern void NLDR_Delete(struct NLDR_OBJECT *hNldr);
-	extern void NLDR_Exit(void);
-
-	extern DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode,
-					  char *pstrFxn, u32 *pulAddr);
-
-	extern DSP_STATUS NLDR_GetRmmManager(struct NLDR_OBJECT *hNldrObject,
-					     OUT struct RMM_TargetObj
-					     **phRmmMgr);
-
-	extern bool NLDR_Init(void);
-	extern DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode,
-				    enum NLDR_PHASE phase);
-	extern DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode,
-				    enum NLDR_PHASE phase);
-
-#endif				/* NLDR_ */
+extern dsp_status nldr_allocate(struct nldr_object *nldr_obj,
+				void *priv_ref, IN CONST struct dcd_nodeprops
+				*node_props,
+				OUT struct nldr_nodeobject **phNldrNode,
+				IN bool *pf_phase_split);
+
+extern dsp_status nldr_create(OUT struct nldr_object **phNldr,
+			      struct dev_object *hdev_obj,
+			      IN CONST struct nldr_attrs *pattrs);
+
+extern void nldr_delete(struct nldr_object *nldr_obj);
+extern void nldr_exit(void);
+
+extern dsp_status nldr_get_fxn_addr(struct nldr_nodeobject *nldr_node_obj,
+				    char *pstrFxn, u32 * pulAddr);
+
+extern dsp_status nldr_get_rmm_manager(struct nldr_object *hNldrObject,
+				       OUT struct rmm_target_obj **phRmmMgr);
+
+extern bool nldr_init(void);
+extern dsp_status nldr_load(struct nldr_nodeobject *nldr_node_obj,
+			    enum nldr_phase phase);
+extern dsp_status nldr_unload(struct nldr_nodeobject *nldr_node_obj,
+			      enum nldr_phase phase);
+
+#endif /* NLDR_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/nldrdefs.h b/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
index b0646fa..e55634b 100644
--- a/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
@@ -24,81 +24,80 @@
 
 #define NLDR_MAXPATHLENGTH       255
 /* NLDR Objects: */
-	struct  NLDR_OBJECT;
-	struct NLDR_NODEOBJECT;
+struct nldr_object;
+struct nldr_nodeobject;
 
 /*
- *  ======== NLDR_LOADTYPE ========
+ *  ======== nldr_loadtype ========
  *  Load types for a node. Must match values in node.h55.
  */
-	enum NLDR_LOADTYPE {
-		NLDR_STATICLOAD,	/* Linked in base image, not overlay */
-		NLDR_DYNAMICLOAD,	/* Dynamically loaded node */
-		NLDR_OVLYLOAD	/* Linked in base image, overlay node */
-	} ;
+enum nldr_loadtype {
+	NLDR_STATICLOAD,	/* Linked in base image, not overlay */
+	NLDR_DYNAMICLOAD,	/* Dynamically loaded node */
+	NLDR_OVLYLOAD		/* Linked in base image, overlay node */
+};
 
 /*
- *  ======== NLDR_OVLYFXN ========
+ *  ======== nldr_ovlyfxn ========
  *  Causes code or data to be copied from load address to run address. This
- *  is the "COD_WRITEFXN" that gets passed to the DBLL_Library and is used as
+ *  is the "cod_writefxn" that gets passed to the DBLL_Library and is used as
  *  the ZL write function.
  *
  *  Parameters:
- *      pPrivRef:       Handle to identify the node.
+ *      priv_ref:       Handle to identify the node.
  *      ulDspRunAddr:   Run address of code or data.
  *      ulDspLoadAddr:  Load address of code or data.
- *      ulNumBytes:     Number of (GPP) bytes to copy.
+ *      ul_num_bytes:     Number of (GPP) bytes to copy.
  *      nMemSpace:      RMS_CODE or RMS_DATA.
  *  Returns:
- *      ulNumBytes:     Success.
+ *      ul_num_bytes:     Success.
  *      0:              Failure.
  *  Requires:
  *  Ensures:
  */
-       typedef u32(*NLDR_OVLYFXN) (void *pPrivRef, u32 ulDspRunAddr,
-					     u32 ulDspLoadAddr,
-					     u32 ulNumBytes, u32 nMemSpace);
+typedef u32(*nldr_ovlyfxn) (void *priv_ref, u32 ulDspRunAddr,
+			    u32 ulDspLoadAddr, u32 ul_num_bytes, u32 nMemSpace);
 
 /*
- *  ======== NLDR_WRITEFXN ========
+ *  ======== nldr_writefxn ========
  *  Write memory function. Used for dynamic load writes.
  *  Parameters:
- *      pPrivRef:       Handle to identify the node.
+ *      priv_ref:       Handle to identify the node.
  *      ulDspAddr:      Address of code or data.
- *      pBuf:           Code or data to be written
- *      ulNumBytes:     Number of (GPP) bytes to write.
+ *      pbuf:           Code or data to be written
+ *      ul_num_bytes:     Number of (GPP) bytes to write.
  *      nMemSpace:      DBLL_DATA or DBLL_CODE.
  *  Returns:
- *      ulNumBytes:     Success.
+ *      ul_num_bytes:     Success.
  *      0:              Failure.
  *  Requires:
  *  Ensures:
  */
-       typedef u32(*NLDR_WRITEFXN) (void *pPrivRef,
-					      u32 ulDspAddr, void *pBuf,
-					      u32 ulNumBytes, u32 nMemSpace);
+typedef u32(*nldr_writefxn) (void *priv_ref,
+			     u32 ulDspAddr, void *pbuf,
+			     u32 ul_num_bytes, u32 nMemSpace);
 
 /*
- *  ======== NLDR_ATTRS ========
- *  Attributes passed to NLDR_Create function.
+ *  ======== nldr_attrs ========
+ *  Attributes passed to nldr_create function.
  */
-	struct NLDR_ATTRS {
-		NLDR_OVLYFXN pfnOvly;
-		NLDR_WRITEFXN pfnWrite;
-		u16 usDSPWordSize;
-		u16 usDSPMauSize;
-	} ;
+struct nldr_attrs {
+	nldr_ovlyfxn pfn_ovly;
+	nldr_writefxn pfn_write;
+	u16 us_dsp_word_size;
+	u16 us_dsp_mau_size;
+};
 
 /*
- *  ======== NLDR_PHASE ========
+ *  ======== nldr_phase ========
  *  Indicates node create, delete, or execute phase function.
  */
-	enum NLDR_PHASE {
-		NLDR_CREATE,
-		NLDR_DELETE,
-		NLDR_EXECUTE,
-		NLDR_NOPHASE
-	} ;
+enum nldr_phase {
+	NLDR_CREATE,
+	NLDR_DELETE,
+	NLDR_EXECUTE,
+	NLDR_NOPHASE
+};
 
 /*
  *  Typedefs of loader functions imported from a DLL, or defined in a
@@ -106,130 +105,129 @@
  */
 
 /*
- *  ======== NLDR_Allocate ========
+ *  ======== nldr_allocate ========
  *  Allocate resources to manage the loading of a node on the DSP.
  *
  *  Parameters:
- *      hNldr:          Handle of loader that will load the node.
- *      pPrivRef:       Handle to identify the node.
- *      pNodeProps:     Pointer to a DCD_NODEPROPS for the node.
+ *      nldr_obj:          Handle of loader that will load the node.
+ *      priv_ref:       Handle to identify the node.
+ *      node_props:     Pointer to a dcd_nodeprops for the node.
  *      phNldrNode:     Location to store node handle on output. This handle
- *                      will be passed to NLDR_Load/NLDR_Unload.
- *      pfPhaseSplit:   pointer to boolean variable referenced in node.c
+ *                      will be passed to nldr_load/nldr_unload.
+ *      pf_phase_split:   pointer to boolean variable referenced in node.c
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Insufficient memory on GPP.
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldr.
- *      pNodeProps != NULL.
+ *      nldr_init(void) called.
+ *      Valid nldr_obj.
+ *      node_props != NULL.
  *      phNldrNode != NULL.
  *  Ensures:
  *      DSP_SOK:        IsValidNode(*phNldrNode).
  *      error:          *phNldrNode == NULL.
  */
-	typedef DSP_STATUS(*NLDR_ALLOCATEFXN) (struct NLDR_OBJECT *hNldr,
-					       void *pPrivRef,
-					       IN CONST struct DCD_NODEPROPS
-					       *pNodeProps,
-					       OUT struct NLDR_NODEOBJECT
-					       **phNldrNode,
-					       OUT bool *pfPhaseSplit);
+typedef dsp_status(*nldr_allocatefxn) (struct nldr_object *nldr_obj,
+				       void *priv_ref,
+				       IN CONST struct dcd_nodeprops
+				       * node_props,
+				       OUT struct nldr_nodeobject
+				       **phNldrNode,
+				       OUT bool *pf_phase_split);
 
 /*
- *  ======== NLDR_Create ========
+ *  ======== nldr_create ========
  *  Create a loader object. This object handles the loading and unloading of
  *  create, delete, and execute phase functions of nodes on the DSP target.
  *
  *  Parameters:
  *      phNldr:         Location to store loader handle on output.
- *      hDevObject:     Device for this processor.
- *      pAttrs:         Loader attributes.
+ *      hdev_obj:     Device for this processor.
+ *      pattrs:         Loader attributes.
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
  *  Requires:
- *      NLDR_Init(void) called.
+ *      nldr_init(void) called.
  *      phNldr != NULL.
- *      hDevObject != NULL.
- *	pAttrs != NULL.
+ *      hdev_obj != NULL.
+ *	pattrs != NULL.
  *  Ensures:
  *      DSP_SOK:        Valid *phNldr.
  *      error:          *phNldr == NULL.
  */
-	typedef DSP_STATUS(*NLDR_CREATEFXN) (OUT struct NLDR_OBJECT **phNldr,
-					     struct DEV_OBJECT *hDevObject,
-					     IN CONST struct NLDR_ATTRS
-					     *pAttrs);
+typedef dsp_status(*nldr_createfxn) (OUT struct nldr_object **phNldr,
+				     struct dev_object *hdev_obj,
+				     IN CONST struct nldr_attrs *pattrs);
 
 /*
- *  ======== NLDR_Delete ========
+ *  ======== nldr_delete ========
  *  Delete the NLDR loader.
  *
  *  Parameters:
- *      hNldr:          Node manager object.
+ *      nldr_obj:          Node manager object.
  *  Returns:
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldr.
+ *      nldr_init(void) called.
+ *      Valid nldr_obj.
  *  Ensures:
- *	hNldr invalid
+ *	nldr_obj invalid
  */
-	typedef void(*NLDR_DELETEFXN) (struct NLDR_OBJECT *hNldr);
+typedef void (*nldr_deletefxn) (struct nldr_object *nldr_obj);
 
 /*
- *  ======== NLDR_Exit ========
+ *  ======== nldr_exit ========
  *  Discontinue usage of NLDR module.
  *
  *  Parameters:
  *  Returns:
  *  Requires:
- *      NLDR_Init(void) successfully called before.
+ *      nldr_init(void) successfully called before.
  *  Ensures:
- *      Any resources acquired in NLDR_Init(void) will be freed when last NLDR
- *      client calls NLDR_Exit(void).
+ *      Any resources acquired in nldr_init(void) will be freed when last NLDR
+ *      client calls nldr_exit(void).
  */
-	typedef void(*NLDR_EXITFXN) (void);
+typedef void (*nldr_exitfxn) (void);
 
 /*
  *  ======== NLDR_Free ========
- *  Free resources allocated in NLDR_Allocate.
+ *  Free resources allocated in nldr_allocate.
  *
  *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      nldr_node_obj:      Handle returned from nldr_allocate().
  *  Returns:
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldrNode.
+ *      nldr_init(void) called.
+ *      Valid nldr_node_obj.
  *  Ensures:
  */
-	typedef void(*NLDR_FREEFXN) (struct NLDR_NODEOBJECT *hNldrNode);
+typedef void (*nldr_freefxn) (struct nldr_nodeobject *nldr_node_obj);
 
 /*
- *  ======== NLDR_GetFxnAddr ========
+ *  ======== nldr_get_fxn_addr ========
  *  Get address of create, delete, or execute phase function of a node on
  *  the DSP.
  *
  *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      nldr_node_obj:      Handle returned from nldr_allocate().
  *      pstrFxn:        Name of function.
  *      pulAddr:        Location to store function address.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ESYMBOL:    Address of function not found.
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldrNode.
+ *      nldr_init(void) called.
+ *      Valid nldr_node_obj.
  *      pulAddr != NULL;
  *      pstrFxn != NULL;
  *  Ensures:
  */
-	typedef DSP_STATUS(*NLDR_GETFXNADDRFXN) (struct NLDR_NODEOBJECT
-						 *hNldrNode,
-						 char *pstrFxn, u32 *pulAddr);
+typedef dsp_status(*nldr_getfxnaddrfxn) (struct nldr_nodeobject
+					 * nldr_node_obj,
+					 char *pstrFxn, u32 * pulAddr);
 
 /*
- *  ======== NLDR_Init ========
+ *  ======== nldr_init ========
  *  Initialize the NLDR module.
  *
  *  Parameters:
@@ -237,14 +235,14 @@
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	typedef bool(*NLDR_INITFXN) (void);
+typedef bool(*nldr_initfxn) (void);
 
 /*
- *  ======== NLDR_Load ========
+ *  ======== nldr_load ========
  *  Load create, delete, or execute phase function of a node on the DSP.
  *
  *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      nldr_node_obj:      Handle returned from nldr_allocate().
  *      phase:          Type of function to load (create, delete, or execute).
  *  Returns:
  *      DSP_SOK:                Success.
@@ -254,43 +252,43 @@
  *      DSP_EDYNLOAD:           Failure in dynamic loader library.
  *      DSP_EFWRITE:            Failed to write phase's code or date to target.
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldrNode.
+ *      nldr_init(void) called.
+ *      Valid nldr_node_obj.
  *  Ensures:
  */
-	typedef DSP_STATUS(*NLDR_LOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
-					   enum NLDR_PHASE phase);
+typedef dsp_status(*nldr_loadfxn) (struct nldr_nodeobject *nldr_node_obj,
+				   enum nldr_phase phase);
 
 /*
- *  ======== NLDR_Unload ========
+ *  ======== nldr_unload ========
  *  Unload create, delete, or execute phase function of a node on the DSP.
  *
  *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      nldr_node_obj:      Handle returned from nldr_allocate().
  *      phase:          Node function to unload (create, delete, or execute).
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Insufficient memory on GPP.
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldrNode.
+ *      nldr_init(void) called.
+ *      Valid nldr_node_obj.
  *  Ensures:
  */
-	typedef DSP_STATUS(*NLDR_UNLOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
-					     enum NLDR_PHASE phase);
+typedef dsp_status(*nldr_unloadfxn) (struct nldr_nodeobject *nldr_node_obj,
+				     enum nldr_phase phase);
 
 /*
- *  ======== NLDR_FXNS ========
+ *  ======== node_ldr_fxns ========
  */
-	struct NLDR_FXNS {
-		NLDR_ALLOCATEFXN pfnAllocate;
-		NLDR_CREATEFXN pfnCreate;
-		NLDR_DELETEFXN pfnDelete;
-		NLDR_EXITFXN pfnExit;
-		NLDR_GETFXNADDRFXN pfnGetFxnAddr;
-		NLDR_INITFXN pfnInit;
-		NLDR_LOADFXN pfnLoad;
-		NLDR_UNLOADFXN pfnUnload;
-	} ;
+struct node_ldr_fxns {
+	nldr_allocatefxn pfn_allocate;
+	nldr_createfxn pfn_create;
+	nldr_deletefxn pfn_delete;
+	nldr_exitfxn pfn_exit;
+	nldr_getfxnaddrfxn pfn_get_fxn_addr;
+	nldr_initfxn pfn_init;
+	nldr_loadfxn pfn_load;
+	nldr_unloadfxn pfn_unload;
+};
 
-#endif				/* NLDRDEFS_ */
+#endif /* NLDRDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/node.h b/arch/arm/plat-omap/include/dspbridge/node.h
index 2a45fc0..ec0dcf3 100644
--- a/arch/arm/plat-omap/include/dspbridge/node.h
+++ b/arch/arm/plat-omap/include/dspbridge/node.h
@@ -27,53 +27,52 @@
 #include <dspbridge/drv.h>
 
 /*
- *  ======== NODE_Allocate ========
+ *  ======== node_allocate ========
  *  Purpose:
  *      Allocate GPP resources to manage a node on the DSP.
  *  Parameters:
- *      hProcessor:         Handle of processor that is allocating the node.
- *      pNodeId:            Pointer to a DSP_UUID for the node.
- *      pArgs:              Optional arguments to be passed to the node.
- *      pAttrIn:            Optional pointer to node attributes (priority,
+ *      hprocessor:         Handle of processor that is allocating the node.
+ *      pNodeId:            Pointer to a dsp_uuid for the node.
+ *      pargs:              Optional arguments to be passed to the node.
+ *      attr_in:            Optional pointer to node attributes (priority,
  *                          timeout...)
- *      phNode:             Location to store node handle on output.
+ *      ph_node:             Location to store node handle on output.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EMEMORY:        Insufficient memory on GPP.
  *      DSP_EUUID:          Node UUID has not been registered.
  *      DSP_ESYMBOL:        iAlg functions not found for a DAIS node.
- *      DSP_ERANGE:         pAttrIn != NULL and pAttrIn->iPriority out of
+ *      DSP_ERANGE:         attr_in != NULL and attr_in->prio out of
  *                          range.
  *      DSP_EFAIL:          A failure occured, unable to allocate node.
  *      DSP_EWRONGSTATE:    Proccessor is not in the running state.
  *  Requires:
- *      NODE_Init(void) called.
- *      hProcessor != NULL.
+ *      node_init(void) called.
+ *      hprocessor != NULL.
  *      pNodeId != NULL.
- *      phNode != NULL.
+ *      ph_node != NULL.
  *  Ensures:
- *      DSP_SOK:            IsValidNode(*phNode).
- *      error:              *phNode == NULL.
+ *      DSP_SOK:            IsValidNode(*ph_node).
+ *      error:              *ph_node == NULL.
  */
-	extern DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
-					IN CONST struct DSP_UUID *pNodeId,
-					OPTIONAL IN CONST struct DSP_CBDATA
-					*pArgs,
-					OPTIONAL IN CONST struct DSP_NODEATTRIN
-					*pAttrIn,
-					OUT struct NODE_OBJECT **phNode,
-					struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status node_allocate(struct proc_object *hprocessor,
+				IN CONST struct dsp_uuid *pNodeId,
+				OPTIONAL IN CONST struct dsp_cbdata
+				*pargs, OPTIONAL IN CONST struct dsp_nodeattrin
+				*attr_in,
+				OUT struct node_object **ph_node,
+				struct process_context *pr_ctxt);
 
 /*
- *  ======== NODE_AllocMsgBuf ========
+ *  ======== node_alloc_msg_buf ========
  *  Purpose:
  *      Allocate and Prepare a buffer whose descriptor will be passed to a
- *      Node within a (DSP_MSG)message
+ *      Node within a (dsp_msg)message
  *  Parameters:
- *      hNode:          The node handle.
- *      uSize:          The size of the buffer to be allocated.
- *      pAttr:          Pointer to a DSP_BUFFERATTR structure.
- *      pBuffer:        Location to store the address of the allocated
+ *      hnode:          The node handle.
+ *      usize:          The size of the buffer to be allocated.
+ *      pattr:          Pointer to a dsp_bufferattr structure.
+ *      pbuffer:        Location to store the address of the allocated
  *                      buffer on output.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -82,27 +81,25 @@
  *      DSP_EFAIL:      General Failure.
  *      DSP_ESIZE:      Invalid Size.
  *  Requires:
- *      NODE_Init(void) called.
- *      pBuffer != NULL.
+ *      node_init(void) called.
+ *      pbuffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_AllocMsgBuf(struct NODE_OBJECT *hNode,
-					   u32 uSize,
-					   OPTIONAL struct DSP_BUFFERATTR
-					   *pAttr,
-					   OUT u8 **pBuffer);
+extern dsp_status node_alloc_msg_buf(struct node_object *hnode,
+				     u32 usize, OPTIONAL struct dsp_bufferattr
+				     *pattr, OUT u8 **pbuffer);
 
 /*
- *  ======== NODE_ChangePriority ========
+ *  ======== node_change_priority ========
  *  Purpose:
  *      Change the priority of an allocated node.
  *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate.
- *      nPriority:          New priority level to set node's priority to.
+ *      hnode:              Node handle returned from node_allocate.
+ *      prio:          New priority level to set node's priority to.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ERANGE:         nPriority is out of range.
+ *      DSP_EHANDLE:        Invalid hnode.
+ *      DSP_ERANGE:         prio is out of range.
  *      DSP_ENODETYPE:      The specified node is not a task node.
  *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED, NODE_PAUSED,
  *                          or NODE_RUNNING state.
@@ -111,33 +108,32 @@
  *                          being restarted.
  *      DSP_EFAIL:          Unable to change node's runtime priority level.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
- *      DSP_SOK && (Node's current priority == nPriority)
+ *      DSP_SOK && (Node's current priority == prio)
  */
-	extern DSP_STATUS NODE_ChangePriority(struct NODE_OBJECT *hNode,
-					      s32 nPriority);
+extern dsp_status node_change_priority(struct node_object *hnode, s32 prio);
 
 /*
- *  ======== NODE_CloseOrphans ========
+ *  ======== node_close_orphans ========
  *  Purpose:
  *      Delete all nodes whose owning processor is being destroyed.
  *  Parameters:
- *      hNodeMgr:       Node manager object.
+ *      hnode_mgr:       Node manager object.
  *      hProc:          Handle to processor object being destroyed.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Unable to delete all nodes belonging to hProc.
  *  Requires:
- *      Valid hNodeMgr.
+ *      Valid hnode_mgr.
  *      hProc != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_CloseOrphans(struct NODE_MGR *hNodeMgr,
-					    struct PROC_OBJECT *hProc);
+extern dsp_status node_close_orphans(struct node_mgr *hnode_mgr,
+				     struct proc_object *hProc);
 
 /*
- *  ======== NODE_Connect ========
+ *  ======== node_connect ========
  *  Purpose:
  *      Connect two nodes on the DSP, or a node on the DSP to the GPP. In the
  *      case that the connnection is being made between a node on the DSP and
@@ -152,20 +148,20 @@
  *      hNode2:         Handle of second node. Must be either NODE_HGPPNODE
  *                      if this is a connection from DSP node to GPP, or a
  *                      node handle returned from a successful call to
- *                      NODE_Allocate().
+ *                      node_allocate().
  *      uStream1:       Output stream index on first node, to be connected
  *                      to second node's input stream. Value must range from
  *                      0 <= uStream1 < number of output streams.
  *      uStream2:       Input stream index on second node. Value must range
  *                      from 0 <= uStream2 < number of input streams.
- *      pAttrs:         Stream attributes (NULL ==> use defaults).
- *      pConnParam:     A pointer to a DSP_CBDATA structure that defines
+ *      pattrs:         Stream attributes (NULL ==> use defaults).
+ *      conn_param:     A pointer to a dsp_cbdata structure that defines
  *                      connection parameter for device nodes to pass to DSP
  *                      side.
  *                      If the value of this parameter is NULL, then this API
  *                      behaves like DSPNode_Connect. This parameter will have
  *                      length of the string and the null terminated string in
- *                      DSP_CBDATA struct. This can be extended in future tp
+ *                      dsp_cbdata struct. This can be extended in future tp
  *                      pass binary data.
  *  Returns:
  *      DSP_SOK:                Success.
@@ -181,28 +177,28 @@
  *                              Device node to device node, or device node to
  *                              GPP), the two nodes are on different DSPs.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1,
-				       u32 uStream1,
-				       struct NODE_OBJECT *hNode2,
-				       u32 uStream2,
-				       OPTIONAL IN struct DSP_STRMATTR *pAttrs,
-				       OPTIONAL IN struct DSP_CBDATA
-				       *pConnParam);
+extern dsp_status node_connect(struct node_object *hNode1,
+			       u32 uStream1,
+			       struct node_object *hNode2,
+			       u32 uStream2,
+			       OPTIONAL IN struct dsp_strmattr *pattrs,
+			       OPTIONAL IN struct dsp_cbdata
+			       *conn_param);
 
 /*
- *  ======== NODE_Create ========
+ *  ======== node_create ========
  *  Purpose:
  *      Create a node on the DSP by remotely calling the node's create
  *      function. If necessary, load code that contains the node's create
  *      function.
  *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate().
+ *      hnode:              Node handle returned from node_allocate().
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ESYMBOL:        Create function not found in the COFF file.
  *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED state.
  *      DSP_EMEMORY:        Memory allocation failure on the DSP.
@@ -212,13 +208,13 @@
  *      DSP_EUSER1-16:      A user-defined failure occurred on the DSP.
  *      DSP_EFAIL:          A failure occurred, unable to create node.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode);
+extern dsp_status node_create(struct node_object *hnode);
 
 /*
- *  ======== NODE_CreateMgr ========
+ *  ======== node_create_mgr ========
  *  Purpose:
  *      Create a NODE Manager object. This object handles the creation,
  *      deletion, and execution of nodes on the DSP target. The NODE Manager
@@ -227,195 +223,193 @@
  *
  *  Parameters:
  *      phNodeMgr:      Location to store node manager handle on output.
- *      hDevObject:     Device for this processor.
+ *      hdev_obj:     Device for this processor.
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
  *      DSP_EFAIL:      General failure.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *      phNodeMgr != NULL.
- *      hDevObject != NULL.
+ *      hdev_obj != NULL.
  *  Ensures:
  *      DSP_SOK:        Valide *phNodeMgr.
  *      error:          *phNodeMgr == NULL.
  */
-	extern DSP_STATUS NODE_CreateMgr(OUT struct NODE_MGR **phNodeMgr,
-					 struct DEV_OBJECT *hDevObject);
+extern dsp_status node_create_mgr(OUT struct node_mgr **phNodeMgr,
+				  struct dev_object *hdev_obj);
 
 /*
- *  ======== NODE_Delete ========
+ *  ======== node_delete ========
  *  Purpose:
- *      Delete resources allocated in NODE_Allocate(). If the node was
+ *      Delete resources allocated in node_allocate(). If the node was
  *      created, delete the node on the DSP by remotely calling the node's
  *      delete function. Loads the node's delete function if necessary.
  *      GPP side resources are freed after node's delete function returns.
  *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate().
+ *      hnode:              Node handle returned from node_allocate().
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EDELETE:        A deletion failure occurred.
  *      DSP_EUSER1-16:      Node specific failure occurred on the DSP.
  *      DSP_EFAIL:          A failure occurred in deleting the node.
  *      DSP_ESYMBOL:        Delete function not found in the COFF file.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
- *      DSP_SOK:            hNode is invalid.
+ *      DSP_SOK:            hnode is invalid.
  */
-	extern DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode,
-			struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status node_delete(struct node_object *hnode,
+			      struct process_context *pr_ctxt);
 
 /*
- *  ======== NODE_DeleteMgr ========
+ *  ======== node_delete_mgr ========
  *  Purpose:
  *      Delete the NODE Manager.
  *  Parameters:
- *      hNodeMgr:       Node manager object.
+ *      hnode_mgr:       Node manager object.
  *  Returns:
  *      DSP_SOK:        Success.
  *  Requires:
- *      NODE_Init(void) called.
- *      Valid hNodeMgr.
+ *      node_init(void) called.
+ *      Valid hnode_mgr.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr);
+extern dsp_status node_delete_mgr(struct node_mgr *hnode_mgr);
 
 /*
- *  ======== NODE_EnumNodes ========
+ *  ======== node_enum_nodes ========
  *  Purpose:
  *      Enumerate the nodes currently allocated for the DSP.
  *  Parameters:
- *      hNodeMgr:       Node manager returned from NODE_CreateMgr().
- *      aNodeTab:       Array to copy node handles into.
- *      uNodeTabSize:   Number of handles that can be written to aNodeTab.
- *      puNumNodes:     Location where number of node handles written to
- *                      aNodeTab will be written.
- *      puAllocated:    Location to write total number of allocated nodes.
+ *      hnode_mgr:       Node manager returned from node_create_mgr().
+ *      node_tab:       Array to copy node handles into.
+ *      node_tab_size:   Number of handles that can be written to node_tab.
+ *      pu_num_nodes:     Location where number of node handles written to
+ *                      node_tab will be written.
+ *      pu_allocated:    Location to write total number of allocated nodes.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_ESIZE:      aNodeTab is too small to hold all node handles.
+ *      DSP_ESIZE:      node_tab is too small to hold all node handles.
  *  Requires:
- *      Valid hNodeMgr.
- *      aNodeTab != NULL || uNodeTabSize == 0.
- *      puNumNodes != NULL.
- *      puAllocated != NULL.
+ *      Valid hnode_mgr.
+ *      node_tab != NULL || node_tab_size == 0.
+ *      pu_num_nodes != NULL.
+ *      pu_allocated != NULL.
  *  Ensures:
- *      - (DSP_ESIZE && *puNumNodes == 0)
- *      - || (DSP_SOK && *puNumNodes <= uNodeTabSize)  &&
- *        (*puAllocated == *puNumNodes)
+ *      - (DSP_ESIZE && *pu_num_nodes == 0)
+ *      - || (DSP_SOK && *pu_num_nodes <= node_tab_size)  &&
+ *        (*pu_allocated == *pu_num_nodes)
  */
-	extern DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr,
-					 void **aNodeTab,
-					 u32 uNodeTabSize,
-					 OUT u32 *puNumNodes,
-					 OUT u32 *puAllocated);
+extern dsp_status node_enum_nodes(struct node_mgr *hnode_mgr,
+				  void **node_tab,
+				  u32 node_tab_size,
+				  OUT u32 *pu_num_nodes,
+				  OUT u32 *pu_allocated);
 
 /*
- *  ======== NODE_Exit ========
+ *  ======== node_exit ========
  *  Purpose:
  *      Discontinue usage of NODE module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      NODE_Init(void) successfully called before.
+ *      node_init(void) successfully called before.
  *  Ensures:
- *      Any resources acquired in NODE_Init(void) will be freed when last NODE
- *      client calls NODE_Exit(void).
+ *      Any resources acquired in node_init(void) will be freed when last NODE
+ *      client calls node_exit(void).
  */
-	extern void NODE_Exit(void);
+extern void node_exit(void);
 
 /*
- *  ======== NODE_FreeMsgBuf ========
+ *  ======== node_free_msg_buf ========
  *  Purpose:
- *      Free a message buffer previously allocated with NODE_AllocMsgBuf.
+ *      Free a message buffer previously allocated with node_alloc_msg_buf.
  *  Parameters:
- *      hNode:          The node handle.
- *      pBuffer:        (Address) Buffer allocated by NODE_AllocMsgBuf.
- *      pAttr:          Same buffer attributes passed to NODE_AllocMsgBuf.
+ *      hnode:          The node handle.
+ *      pbuffer:        (Address) Buffer allocated by node_alloc_msg_buf.
+ *      pattr:          Same buffer attributes passed to node_alloc_msg_buf.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid node handle.
  *      DSP_EFAIL:      Failure to free the buffer.
  *  Requires:
- *      NODE_Init(void) called.
- *      pBuffer != NULL.
+ *      node_init(void) called.
+ *      pbuffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_FreeMsgBuf(struct NODE_OBJECT *hNode,
-					  IN u8 *pBuffer,
-					  OPTIONAL struct DSP_BUFFERATTR
-					  *pAttr);
+extern dsp_status node_free_msg_buf(struct node_object *hnode,
+				    IN u8 *pbuffer,
+				    OPTIONAL struct dsp_bufferattr
+				    *pattr);
 
 /*
- *  ======== NODE_GetAttr ========
+ *  ======== node_get_attr ========
  *  Purpose:
- *      Copy the current attributes of the specified node into a DSP_NODEATTR
+ *      Copy the current attributes of the specified node into a dsp_nodeattr
  *      structure.
  *  Parameters:
- *      hNode:          Node object allocated from NODE_Allocate().
- *      pAttr:          Pointer to DSP_NODEATTR structure to copy node's
+ *      hnode:          Node object allocated from node_allocate().
+ *      pattr:          Pointer to dsp_nodeattr structure to copy node's
  *                      attributes.
- *      uAttrSize:      Size of pAttr.
+ *      attr_size:      Size of pattr.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *  Requires:
- *      NODE_Init(void) called.
- *      pAttr != NULL.
+ *      node_init(void) called.
+ *      pattr != NULL.
  *  Ensures:
- *      DSP_SOK:        *pAttrs contains the node's current attributes.
+ *      DSP_SOK:        *pattrs contains the node's current attributes.
  */
-	extern DSP_STATUS NODE_GetAttr(struct NODE_OBJECT *hNode,
-				       OUT struct DSP_NODEATTR *pAttr,
-				       u32 uAttrSize);
+extern dsp_status node_get_attr(struct node_object *hnode,
+				OUT struct dsp_nodeattr *pattr, u32 attr_size);
 
 /*
- *  ======== NODE_GetMessage ========
+ *  ======== node_get_message ========
  *  Purpose:
  *      Retrieve a message from a node on the DSP. The node must be either a
  *      message node, task node, or XDAIS socket node.
  *      If a message is not available, this function will block until a
  *      message is available, or the node's timeout value is reached.
  *  Parameters:
- *      hNode:          Node handle returned from NODE_Allocate().
- *      pMessage:       Pointer to DSP_MSG structure to copy the
+ *      hnode:          Node handle returned from node_allocate().
+ *      message:       Pointer to dsp_msg structure to copy the
  *                      message into.
- *      uTimeout:       Timeout in milliseconds to wait for message.
+ *      utimeout:       Timeout in milliseconds to wait for message.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *      DSP_ENODETYPE:  Cannot retrieve messages from this type of node.
  *      DSP_ETIMEOUT:   Timeout occurred and no message is available.
  *      DSP_EFAIL:      Error occurred while trying to retrieve a message.
  *  Requires:
- *      NODE_Init(void) called.
- *      pMessage != NULL.
+ *      node_init(void) called.
+ *      message != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode,
-					  OUT struct DSP_MSG *pMessage,
-					  u32 uTimeout);
+extern dsp_status node_get_message(struct node_object *hnode,
+				   OUT struct dsp_msg *message, u32 utimeout);
 
 /*
- *  ======== NODE_GetNldrObj ========
+ *  ======== node_get_nldr_obj ========
  *  Purpose:
  *      Retrieve the Nldr manager
  *  Parameters:
- *      hNodeMgr:       Node Manager
+ *      hnode_mgr:       Node Manager
  *      phNldrObj:      Pointer to a Nldr manager handle
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_GetNldrObj(struct NODE_MGR *hNodeMgr,
-					  OUT struct NLDR_OBJECT **phNldrObj);
+extern dsp_status node_get_nldr_obj(struct node_mgr *hnode_mgr,
+				    OUT struct nldr_object **phNldrObj);
 
 /*
- *  ======== NODE_Init ========
+ *  ======== node_init ========
  *  Purpose:
  *      Initialize the NODE module.
  *  Parameters:
@@ -423,156 +417,153 @@
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	extern bool NODE_Init(void);
+extern bool node_init(void);
 
 /*
- *  ======== NODE_OnExit ========
+ *  ======== node_on_exit ========
  *  Purpose:
  *      Gets called when RMS_EXIT is received for a node. PROC needs to pass
- *      this function as a parameter to MSG_Create(). This function then gets
+ *      this function as a parameter to msg_create(). This function then gets
  *      called by the mini-driver when an exit message for a node is received.
  *  Parameters:
- *      hNode:      Handle of the node that the exit message is for.
+ *      hnode:      Handle of the node that the exit message is for.
  *      nStatus:    Return status of the node's execute phase.
  *  Returns:
  *  Ensures:
  */
-	void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus);
+void node_on_exit(struct node_object *hnode, s32 nStatus);
 
 /*
- *  ======== NODE_Pause ========
+ *  ======== node_pause ========
  *  Purpose:
  *      Suspend execution of a node currently running on the DSP.
  *  Parameters:
- *      hNode:              Node object representing a node currently
+ *      hnode:              Node object representing a node currently
  *                          running on the DSP.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ENODETYPE:      Node is not a task or socket node.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EWRONGSTSATE:   Node is not in NODE_RUNNING state.
  *      DSP_EFAIL:          Failed to pause node.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Pause(struct NODE_OBJECT *hNode);
+extern dsp_status node_pause(struct node_object *hnode);
 
 /*
- *  ======== NODE_PutMessage ========
+ *  ======== node_put_message ========
  *  Purpose:
  *      Send a message to a message node, task node, or XDAIS socket node.
  *      This function will block until the message stream can accommodate
  *      the message, or a timeout occurs. The message will be copied, so Msg
  *      can be re-used immediately after return.
  *  Parameters:
- *      hNode:              Node handle returned by NODE_Allocate().
- *      pMsg:               Location of message to be sent to the node.
- *      uTimeout:           Timeout in msecs to wait.
+ *      hnode:              Node handle returned by node_allocate().
+ *      pmsg:               Location of message to be sent to the node.
+ *      utimeout:           Timeout in msecs to wait.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ENODETYPE:      Messages can't be sent to this type of node.
  *      DSP_ETIMEOUT:       Timeout occurred before message could be set.
  *      DSP_EWRONGSTATE:    Node is in invalid state for sending messages.
  *      DSP_EFAIL:          Unable to send message.
  *  Requires:
- *      NODE_Init(void) called.
- *      pMsg != NULL.
+ *      node_init(void) called.
+ *      pmsg != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
-					  IN CONST struct DSP_MSG *pMsg,
-					  u32 uTimeout);
+extern dsp_status node_put_message(struct node_object *hnode,
+				   IN CONST struct dsp_msg *pmsg, u32 utimeout);
 
 /*
- *  ======== NODE_RegisterNotify ========
+ *  ======== node_register_notify ========
  *  Purpose:
  *      Register to be notified on specific events for this node.
  *  Parameters:
- *      hNode:          Node handle returned by NODE_Allocate().
- *      uEventMask:     Mask of types of events to be notified about.
- *      uNotifyType:    Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
+ *      hnode:          Node handle returned by node_allocate().
+ *      event_mask:     Mask of types of events to be notified about.
+ *      notify_type:    Type of notification to be sent.
+ *      hnotification:  Handle to be used for notification.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *      DSP_EMEMORY:    Insufficient memory on GPP.
- *      DSP_EVALUE:     uEventMask is invalid.
- *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
+ *      DSP_EVALUE:     event_mask is invalid.
+ *      DSP_ENOTIMPL:   Notification type specified by notify_type is not
  *                      supported.
  *  Requires:
- *      NODE_Init(void) called.
- *      hNotification != NULL.
+ *      node_init(void) called.
+ *      hnotification != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
+extern dsp_status node_register_notify(struct node_object *hnode,
+				       u32 event_mask, u32 notify_type,
+				       struct dsp_notification
+				       *hnotification);
 
 /*
- *  ======== NODE_Run ========
+ *  ======== node_run ========
  *  Purpose:
  *      Start execution of a node's execute phase, or resume execution of
- *      a node that has been suspended (via NODE_Pause()) on the DSP. Load
+ *      a node that has been suspended (via node_pause()) on the DSP. Load
  *      the node's execute function if necessary.
  *  Parameters:
- *      hNode:              Node object representing a node currently
+ *      hnode:              Node object representing a node currently
  *                          running on the DSP.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ENODETYPE:      hNode doesn't represent a message, task or dais
+ *      DSP_EHANDLE:        Invalid hnode.
+ *      DSP_ENODETYPE:      hnode doesn't represent a message, task or dais
  *                          socket node.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EWRONGSTSATE:   Node is not in NODE_PAUSED or NODE_CREATED state.
  *      DSP_EFAIL:          Unable to start or resume execution.
  *      DSP_ESYMBOL:        Execute function not found in the COFF file.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Run(struct NODE_OBJECT *hNode);
+extern dsp_status node_run(struct node_object *hnode);
 
 /*
- *  ======== NODE_Terminate ========
+ *  ======== node_terminate ========
  *  Purpose:
  *      Signal a node running on the DSP that it should exit its execute
  *      phase function.
  *  Parameters:
- *      hNode:              Node object representing a node currently
+ *      hnode:              Node object representing a node currently
  *                          running on the DSP.
- *      pStatus:            Location to store execute-phase function return
+ *      pstatus:            Location to store execute-phase function return
  *                          value (DSP_EUSER1-16).
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_ENODETYPE:      Type of node specified cannot be terminated.
  *      DSP_EWRONGSTATE:    Operation not valid for the current node state.
  *      DSP_EFAIL:          Unable to terminate the node.
  *  Requires:
- *      NODE_Init(void) called.
- *      pStatus != NULL.
+ *      node_init(void) called.
+ *      pstatus != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Terminate(struct NODE_OBJECT *hNode,
-					 OUT DSP_STATUS *pStatus);
-
-
+extern dsp_status node_terminate(struct node_object *hnode,
+				 OUT dsp_status *pstatus);
 
 /*
- *  ======== NODE_GetUUIDProps ========
+ *  ======== node_get_uuid_props ========
  *  Purpose:
  *      Fetch Node properties given the UUID
  *  Parameters:
  *
  */
-	extern DSP_STATUS NODE_GetUUIDProps(void *hProcessor,
-					    IN CONST struct DSP_UUID *pNodeId,
-					    OUT struct DSP_NDBPROPS
-					    *pNodeProps);
+extern dsp_status node_get_uuid_props(void *hprocessor,
+				      IN CONST struct dsp_uuid *pNodeId,
+				      OUT struct dsp_ndbprops
+				      *node_props);
 
-#endif				/* NODE_ */
+#endif /* NODE_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/nodedefs.h b/arch/arm/plat-omap/include/dspbridge/nodedefs.h
index 6eb7537..fb9623d 100644
--- a/arch/arm/plat-omap/include/dspbridge/nodedefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/nodedefs.h
@@ -22,7 +22,7 @@
 #define NODE_SUSPENDEDPRI -1
 
 /* NODE Objects: */
-	struct NODE_MGR;
-	struct NODE_OBJECT;
+struct node_mgr;
+struct node_object;
 
-#endif				/* NODEDEFS_ */
+#endif /* NODEDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/nodepriv.h b/arch/arm/plat-omap/include/dspbridge/nodepriv.h
index cc74318..ca3c696 100644
--- a/arch/arm/plat-omap/include/dspbridge/nodepriv.h
+++ b/arch/arm/plat-omap/include/dspbridge/nodepriv.h
@@ -24,160 +24,159 @@
 #include <dspbridge/nldrdefs.h>
 
 /* DSP address of node environment structure */
-	typedef u32 NODE_ENV;
+typedef u32 nodeenv;
 
 /*
  *  Node create structures
  */
 
 /* Message node */
-	struct NODE_MSGARGS {
-		u32 uMaxMessages; /* Max # of simultaneous messages for node */
-		u32 uSegid;	/* Segment for allocating message buffers */
-		u32 uNotifyType;  /* Notify type (SEM_post, SWI_post, etc.) */
-		u32 uArgLength;  /* Length in 32-bit words of arg data block */
-		u8 *pData;	/* Argument data for node */
-	} ;
+struct node_msgargs {
+	u32 max_msgs;		/* Max # of simultaneous messages for node */
+	u32 seg_id;		/* Segment for allocating message buffers */
+	u32 notify_type;	/* Notify type (SEM_post, SWI_post, etc.) */
+	u32 arg_length;		/* Length in 32-bit words of arg data block */
+	u8 *pdata;		/* Argument data for node */
+};
 
-	struct NODE_STRMDEF {
-		u32 uBufsize;	/* Size of buffers for SIO stream */
-		u32 uNumBufs;	/* max # of buffers in SIO stream at once */
-		u32 uSegid;	/* Memory segment id to allocate buffers */
-		u32 uTimeout;	/* Timeout for blocking SIO calls */
-		u32 uAlignment;	/* Buffer alignment */
-		char *szDevice;	/* Device name for stream */
-	} ;
+struct node_strmdef {
+	u32 buf_size;		/* Size of buffers for SIO stream */
+	u32 num_bufs;		/* max # of buffers in SIO stream at once */
+	u32 seg_id;		/* Memory segment id to allocate buffers */
+	u32 utimeout;		/* Timeout for blocking SIO calls */
+	u32 buf_alignment;	/* Buffer alignment */
+	char *sz_device;	/* Device name for stream */
+};
 
 /* Task node */
-	struct NODE_TASKARGS {
-		struct NODE_MSGARGS msgArgs;
-		s32 nPriority;
-		u32 uStackSize;
-		u32 uSysStackSize;
-		u32 uStackSeg;
-		u32 uDSPHeapResAddr;	/* DSP virtual heap address */
-		u32 uDSPHeapAddr;	/* DSP virtual heap address */
-		u32 uHeapSize;	/* Heap size */
-		u32 uGPPHeapAddr;	/* GPP virtual heap address */
-		u32 uProfileID;	/* Profile ID */
-		u32 uNumInputs;
-		u32 uNumOutputs;
-		u32 ulDaisArg;	/* Address of iAlg object */
-		struct NODE_STRMDEF *strmInDef;
-		struct NODE_STRMDEF *strmOutDef;
-	} ;
+struct node_taskargs {
+	struct node_msgargs node_msg_args;
+	s32 prio;
+	u32 stack_size;
+	u32 sys_stack_size;
+	u32 stack_seg;
+	u32 udsp_heap_res_addr;	/* DSP virtual heap address */
+	u32 udsp_heap_addr;	/* DSP virtual heap address */
+	u32 heap_size;		/* Heap size */
+	u32 ugpp_heap_addr;	/* GPP virtual heap address */
+	u32 profile_id;		/* Profile ID */
+	u32 num_inputs;
+	u32 num_outputs;
+	u32 ul_dais_arg;	/* Address of iAlg object */
+	struct node_strmdef *strm_in_def;
+	struct node_strmdef *strm_out_def;
+};
 
 /*
- *  ======== NODE_CREATEARGS ========
+ *  ======== node_createargs ========
  */
-	struct NODE_CREATEARGS {
-		union {
-			struct NODE_MSGARGS msgArgs;
-			struct NODE_TASKARGS taskArgs;
-		} asa;
-	} ;
+struct node_createargs {
+	union {
+		struct node_msgargs node_msg_args;
+		struct node_taskargs task_arg_obj;
+	} asa;
+};
 
 /*
- *  ======== NODE_GetChannelId ========
+ *  ======== node_get_channel_id ========
  *  Purpose:
  *      Get the channel index reserved for a stream connection between the
- *      host and a node. This index is reserved when NODE_Connect() is called
+ *      host and a node. This index is reserved when node_connect() is called
  *      to connect the node with the host. This index should be passed to
  *      the CHNL_Open function when the stream is actually opened.
  *  Parameters:
- *      hNode:          Node object allocated from NODE_Allocate().
- *      uDir:           Input (DSP_TONODE) or output (DSP_FROMNODE).
- *      uIndex:         Stream index.
+ *      hnode:          Node object allocated from node_allocate().
+ *      dir:           Input (DSP_TONODE) or output (DSP_FROMNODE).
+ *      index:         Stream index.
  *      pulId:          Location to store channel index.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *      DSP_ENODETYPE:  Not a task or DAIS socket node.
- *      DSP_EVALUE:     The node's stream corresponding to uIndex and uDir
+ *      DSP_EVALUE:     The node's stream corresponding to index and dir
  *                      is not a stream to or from the host.
  *  Requires:
- *      NODE_Init(void) called.
- *      Valid uDir.
+ *      node_init(void) called.
+ *      Valid dir.
  *      pulId != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode,
-					    u32 uDir,
-					    u32 uIndex, OUT u32 *pulId);
+extern dsp_status node_get_channel_id(struct node_object *hnode,
+				      u32 dir, u32 index, OUT u32 *pulId);
 
 /*
- *  ======== NODE_GetStrmMgr ========
+ *  ======== node_get_strm_mgr ========
  *  Purpose:
  *      Get the STRM manager for a node.
  *  Parameters:
- *      hNode:          Node allocated with NODE_Allocate().
+ *      hnode:          Node allocated with node_allocate().
  *      phStrmMgr:      Location to store STRM manager on output.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *  Requires:
  *      phStrmMgr != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_GetStrmMgr(struct NODE_OBJECT *hNode,
-					  struct STRM_MGR **phStrmMgr);
+extern dsp_status node_get_strm_mgr(struct node_object *hnode,
+				    struct strm_mgr **phStrmMgr);
 
 /*
- *  ======== NODE_GetTimeout ========
+ *  ======== node_get_timeout ========
  *  Purpose:
  *      Get the timeout value of a node.
  *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *      hnode:      Node allocated with node_allocate(), or DSP_HGPPNODE.
  *  Returns:
  *      Node's timeout value.
  *  Requires:
- *      Valid hNode.
+ *      Valid hnode.
  *  Ensures:
  */
-	extern u32 NODE_GetTimeout(struct NODE_OBJECT *hNode);
+extern u32 node_get_timeout(struct node_object *hnode);
 
 /*
- *  ======== NODE_GetType ========
+ *  ======== node_get_type ========
  *  Purpose:
  *      Get the type (device, message, task, or XDAIS socket) of a node.
  *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *      hnode:      Node allocated with node_allocate(), or DSP_HGPPNODE.
  *  Returns:
  *      Node type:  NODE_DEVICE, NODE_TASK, NODE_XDAIS, or NODE_GPP.
  *  Requires:
- *      Valid hNode.
+ *      Valid hnode.
  *  Ensures:
  */
-	extern enum NODE_TYPE NODE_GetType(struct NODE_OBJECT *hNode);
+extern enum node_type node_get_type(struct node_object *hnode);
 
 /*
- *  ======== GetNodeInfo ========
+ *  ======== get_node_info ========
  *  Purpose:
  *      Get node information without holding semaphore.
  *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *      hnode:      Node allocated with node_allocate(), or DSP_HGPPNODE.
  *  Returns:
  *      Node info:  priority, device owner, no. of streams, execution state
  *                  NDB properties.
  *  Requires:
- *      Valid hNode.
+ *      Valid hnode.
  *  Ensures:
  */
-	extern void GetNodeInfo(struct NODE_OBJECT *hNode,
-				struct DSP_NODEINFO *pNodeInfo);
+extern void get_node_info(struct node_object *hnode,
+			  struct dsp_nodeinfo *pNodeInfo);
 
 /*
- *  ======== NODE_GetLoadType ========
+ *  ======== node_get_load_type ========
  *  Purpose:
  *      Get the load type (dynamic, overlay, static) of a node.
  *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *      hnode:      Node allocated with node_allocate(), or DSP_HGPPNODE.
  *  Returns:
  *      Node type:  NLDR_DYNAMICLOAD, NLDR_OVLYLOAD, NLDR_STATICLOAD
  *  Requires:
- *      Valid hNode.
+ *      Valid hnode.
  *  Ensures:
  */
-	extern enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode);
+extern enum nldr_loadtype node_get_load_type(struct node_object *hnode);
 
-#endif				/* NODEPRIV_ */
+#endif /* NODEPRIV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/ntfy.h b/arch/arm/plat-omap/include/dspbridge/ntfy.h
index 3448a69..dfda615 100644
--- a/arch/arm/plat-omap/include/dspbridge/ntfy.h
+++ b/arch/arm/plat-omap/include/dspbridge/ntfy.h
@@ -19,110 +19,200 @@
 #ifndef NTFY_
 #define NTFY_
 
-	struct NTFY_OBJECT;
+#include <dspbridge/host_os.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+#include <dspbridge/sync.h>
 
-/*
- *  ======== NTFY_Create ========
- *  Purpose:
- *      Create an empty list of notifications.
- *  Parameters:
- *      phNtfy:         Location to store handle on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failure.
- *  Requires:
- *      NTFY_Init(void) called.
- *      phNtfy != NULL.
- *  Ensures:
- *      DSP_SUCCEEDED(status) <==>  IsValid(*phNtfy).
+/**
+ * ntfy_object - head structure to nofify dspbridge events
+ * @head:	List of notify objects
+ * @ntfy_lock:	lock for list access.
+ *
  */
-	extern DSP_STATUS NTFY_Create(OUT struct NTFY_OBJECT **phNtfy);
+struct ntfy_object {
+	struct raw_notifier_head head;/* List of notifier objects */
+	spinlock_t ntfy_lock;	/* For critical sections */
+};
 
-/*
- *  ======== NTFY_Delete ========
- *  Purpose:
- *      Free resources allocated in NTFY_Create.
- *  Parameters:
- *      hNtfy:  Handle returned from NTFY_Create().
- *  Returns:
- *  Requires:
- *      NTFY_Init(void) called.
- *      IsValid(hNtfy).
- *  Ensures:
+/**
+ * ntfy_event - structure store specify event to be notified
+ * @noti_block:	List of notify objects
+ * @event:	event that it respond
+ * @type: 	event type (only DSP_SIGNALEVENT supported)
+ * @sync_obj:	sync_event used to set the event
+ *
  */
-	extern void NTFY_Delete(IN struct NTFY_OBJECT *hNtfy);
+struct ntfy_event {
+	struct notifier_block noti_block;
+	u32 event;	/* Events to be notified about */
+	u32 type;	/* Type of notification to be sent */
+	struct sync_object sync_obj;
+};
 
-/*
- *  ======== NTFY_Exit ========
- *  Purpose:
- *      Discontinue usage of NTFY module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      NTFY_Init(void) successfully called before.
- *  Ensures:
+
+/**
+ * dsp_notifier_event() - callback function to nofity events
+ * @this:		pointer to itself struct notifier_block
+ * @event:	event to be notified.
+ * @data:		Currently not used.
+ *
  */
-	extern void NTFY_Exit(void);
+int dsp_notifier_event(struct notifier_block *this, unsigned long event,
+			   void *data);
 
-/*
- *  ======== NTFY_Init ========
- *  Purpose:
- *      Initialize the NTFY module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialization succeeded, FALSE otherwise.
- *  Ensures:
+/**
+ * ntfy_init() - Set the initial state of the ntfy_object structure.
+ * @no:		pointer to ntfy_object structure.
+ *
+ * This function sets the initial state of the ntfy_object in order it
+ * can be used by the other ntfy functions.
  */
-	extern bool NTFY_Init(void);
 
-/*
- *  ======== NTFY_Notify ========
- *  Purpose:
- *      Execute notify function (signal event or post message) for every
- *      element in the notification list that is to be notified about the
- *      event specified in uEventMask.
- *  Parameters:
- *      hNtfy:      Handle returned from NTFY_Create().
- *      uEventMask: The type of event that has occurred.
- *  Returns:
- *  Requires:
- *      NTFY_Init(void) called.
- *      IsValid(hNtfy).
- *  Ensures:
+static inline void ntfy_init(struct ntfy_object *no)
+{
+	spin_lock_init(&no->ntfy_lock);
+	RAW_INIT_NOTIFIER_HEAD(&no->head);
+}
+
+/**
+ * ntfy_delete() - delete list of nofy events registered.
+ * @ntfy_obj:	Pointer to the ntfy object structure.
+ *
+ * This function is used to remove all the notify events  registered.
+ * unregister function is not needed in this function, to unregister
+ * a ntfy_event please look at ntfy_register function.
+ *
  */
-	extern void NTFY_Notify(IN struct NTFY_OBJECT *hNtfy,
-				IN u32 uEventMask);
+static inline void ntfy_delete(struct ntfy_object *ntfy_obj)
+{
+	struct ntfy_event *ne;
+	struct notifier_block *nb;
 
-/*
- *  ======== NTFY_Register ========
- *  Purpose:
- *      Add a notification element to the list. If the notification is already
- *      registered, and uEventMask != 0, the notification will get posted for
- *      events specified in the new event mask. If the notification is already
- *      registered and uEventMask == 0, the notification will be unregistered.
- *  Parameters:
- *      hNtfy:              Handle returned from NTFY_Create().
- *      hNotification:      Handle to a DSP_NOTIFICATION object.
- *      uEventMask:         Events to be notified about.
- *      uNotifyType:        Type of notification: DSP_SIGNALEVENT.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Insufficient memory.
- *      DSP_EVALUE:         uEventMask is 0 and hNotification was not
- *                          previously registered.
- *      DSP_EHANDLE:        NULL hNotification, hNotification event name
- *                          too long, or hNotification event name NULL.
- *  Requires:
- *      NTFY_Init(void) called.
- *      IsValid(hNtfy).
- *      hNotification != NULL.
- *      uNotifyType is DSP_SIGNALEVENT
- *  Ensures:
+	spin_lock_bh(&ntfy_obj->ntfy_lock);
+	nb = ntfy_obj->head.head;
+	while (nb) {
+		ne = container_of(nb, struct ntfy_event, noti_block);
+		nb = nb->next;
+		kfree(ne);
+	}
+	spin_unlock_bh(&ntfy_obj->ntfy_lock);
+}
+
+/**
+ * ntfy_notify() - nofity all event register for an specific event.
+ * @ntfy_obj:	Pointer to the ntfy_object structure.
+ * @event:	event to be notified.
+ *
+ * This function traverses all the ntfy events registers and
+ * set the event with mach with @event.
  */
-	extern DSP_STATUS NTFY_Register(IN struct NTFY_OBJECT *hNtfy,
-					IN struct DSP_NOTIFICATION
-					*hNotification,
-					IN u32 uEventMask,
-					IN u32 uNotifyType);
+static inline void ntfy_notify(struct ntfy_object *ntfy_obj, u32 event)
+{
+	spin_lock_bh(&ntfy_obj->ntfy_lock);
+	raw_notifier_call_chain(&ntfy_obj->head, event, NULL);
+	spin_unlock_bh(&ntfy_obj->ntfy_lock);
+}
+
+
+
+/**
+ * ntfy_init() - Create and initialize a ntfy_event structure.
+ * @event:	event that the ntfy event will respond
+ * @type		event type (only DSP_SIGNALEVENT supported)
+ *
+ * This function create a ntfy_event element and sets the event it will
+ * respond the ntfy_event in order it can be used by the other ntfy functions.
+ * In case of success it will return a pointer to the ntfy_event struct
+ * created. Otherwise it will return NULL;
+ */
+
+static inline struct ntfy_event *ntfy_event_create(u32 event, u32 type)
+{
+	struct ntfy_event *ne;
+	ne = kmalloc(sizeof(struct ntfy_event), GFP_KERNEL);
+	if (ne) {
+		sync_init_event(&ne->sync_obj);
+		ne->noti_block.notifier_call = dsp_notifier_event;
+		ne->event = event;
+		ne->type = type;
+	}
+	return ne;
+}
+
+/**
+ * ntfy_register() - register new ntfy_event into a given ntfy_object
+ * @ntfy_obj:	Pointer to the ntfy_object structure.
+ * @noti:		Pointer to the handle to be returned to the user space.
+ * @event	event that the ntfy event will respond
+ * @type		event type (only DSP_SIGNALEVENT supported)
+ *
+ * This function register a new ntfy_event into the ntfy_object list,
+ * which will respond to the @event passed.
+ * This function will return DSP_SOK in case of error.
+ * DSP_EHANDLE in case of bad pointers and
+ * DSP_EMemory in case of no memory to create ntfy_event.
+ */
+static  inline dsp_status ntfy_register(struct ntfy_object *ntfy_obj,
+			 struct dsp_notification *noti,
+			 u32 event, u32 type)
+{
+	struct ntfy_event *ne;
+	dsp_status status = DSP_SOK;
+
+	if (!noti || !ntfy_obj) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	if (!event) {
+		status = DSP_EINVALIDARG;
+		goto func_end;
+	}
+	ne = ntfy_event_create(event, type);
+	if (!ne) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	noti->handle = &ne->sync_obj;
+
+	spin_lock_bh(&ntfy_obj->ntfy_lock);
+	raw_notifier_chain_register(&ntfy_obj->head, &ne->noti_block);
+	spin_unlock_bh(&ntfy_obj->ntfy_lock);
+func_end:
+	return status;
+}
+
+/**
+ * ntfy_unregister() - unregister a ntfy_event from a given ntfy_object
+ * @ntfy_obj:	Pointer to the ntfy_object structure.
+ * @noti:		Pointer to the event that will be removed.
+ *
+ * This function unregister a ntfy_event from the ntfy_object list,
+ * @noti contains the event which is wanted to be removed.
+ * This function will return DSP_SOK in case of error.
+ * DSP_EHANDLE in case of bad pointers and
+ * DSP_EMemory in case of no memory to create ntfy_event.
+ */
+static  inline dsp_status ntfy_unregister(struct ntfy_object *ntfy_obj,
+			 struct dsp_notification *noti)
+{
+	dsp_status status = DSP_SOK;
+	struct ntfy_event *ne;
+
+	if (!noti || !ntfy_obj) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	ne = container_of((struct sync_object *)noti, struct ntfy_event,
+								sync_obj);
+	spin_lock_bh(&ntfy_obj->ntfy_lock);
+	raw_notifier_chain_unregister(&ntfy_obj->head,
+						&ne->noti_block);
+	kfree(ne);
+	spin_unlock_bh(&ntfy_obj->ntfy_lock);
+func_end:
+	return status;
+}
 
 #endif				/* NTFY_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/proc.h b/arch/arm/plat-omap/include/dspbridge/proc.h
index ccafba6..0707739 100644
--- a/arch/arm/plat-omap/include/dspbridge/proc.h
+++ b/arch/arm/plat-omap/include/dspbridge/proc.h
@@ -24,66 +24,66 @@
 #include <dspbridge/drv.h>
 
 /*
- *  ======== PROC_Attach ========
+ *  ======== proc_attach ========
  *  Purpose:
  *      Prepare for communication with a particular DSP processor, and return
  *      a handle to the processor object. The PROC Object gets created
  *  Parameters:
- *      uProcessor  :	   The processor index (zero-based).
- *      hMgrObject  :	   Handle to the Manager Object
- *      pAttrIn     :	   Ptr to the DSP_PROCESSORATTRIN structure.
+ *      processor_id  :	   The processor index (zero-based).
+ *      hmgr_obj  :	   Handle to the Manager Object
+ *      attr_in     :	   Ptr to the dsp_processorattrin structure.
  *			      A NULL value means use default values.
- *      phProcessor :	   Ptr to location to store processor handle.
+ *      ph_processor :	   Ptr to location to store processor handle.
  *  Returns:
  *      DSP_SOK     :	   Success.
  *      DSP_EFAIL   :	   General failure.
  *      DSP_EHANDLE :	   Invalid processor handle.
  *      DSP_SALREADYATTACHED:   Success; Processor already attached.
  *  Requires:
- *      phProcessor != NULL.
+ *      ph_processor != NULL.
  *      PROC Initialized.
  *  Ensures:
- *      DSP_EFAIL, and *phProcessor == NULL, OR
- *      Success and *phProcessor is a Valid Processor handle OR
- *      DSP_SALREADYATTACHED and *phProcessor is a Valid Processor.
+ *      DSP_EFAIL, and *ph_processor == NULL, OR
+ *      Success and *ph_processor is a Valid Processor handle OR
+ *      DSP_SALREADYATTACHED and *ph_processor is a Valid Processor.
  *  Details:
- *      When pAttrIn is NULL, the default timeout value is 10 seconds.
+ *      When attr_in is NULL, the default timeout value is 10 seconds.
  */
-	extern DSP_STATUS PROC_Attach(u32 uProcessor,
-				      OPTIONAL CONST struct DSP_PROCESSORATTRIN
-				      *pAttrIn, void **phProcessor,
-				      struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_attach(u32 processor_id,
+			      OPTIONAL CONST struct dsp_processorattrin
+			      *attr_in, void **ph_processor,
+			      struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_AutoStart =========
+ *  ======== proc_auto_start =========
  *  Purpose:
  *      A Particular device gets loaded with the default image
  *      if the AutoStart flag is set.
  *  Parameters:
- *      hDevObject  :   Handle to the Device
+ *      hdev_obj  :   Handle to the Device
  *  Returns:
  *      DSP_SOK     :   On Successful Loading
  *      DSP_EFILE   :   No DSP exec file found.
  *      DSP_EFAIL   :   General Failure
  *  Requires:
- *      hDevObject != NULL.
- *      hDevNode != NULL.
+ *      hdev_obj != NULL.
+ *      dev_node_obj != NULL.
  *      PROC Initialized.
  *  Ensures:
  */
-	extern DSP_STATUS PROC_AutoStart(struct CFG_DEVNODE *hDevNode,
-					 struct DEV_OBJECT *hDevObject);
+extern dsp_status proc_auto_start(struct cfg_devnode *dev_node_obj,
+				  struct dev_object *hdev_obj);
 
 /*
- *  ======== PROC_Ctrl ========
+ *  ======== proc_ctrl ========
  *  Purpose:
  *      Pass control information to the GPP device driver managing the DSP
  *      processor. This will be an OEM-only function, and not part of the
  *      'Bridge application developer's API.
  *  Parameters:
- *      hProcessor  :       The processor handle.
- *      dwCmd       :       Private driver IOCTL cmd ID.
- *      pArgs       :       Ptr to an driver defined argument structure.
+ *      hprocessor  :       The processor handle.
+ *      dw_cmd       :       Private driver IOCTL cmd ID.
+ *      pargs       :       Ptr to an driver defined argument structure.
  *  Returns:
  *      DSP_SOK     :       SUCCESS
  *      DSP_EHANDLE :       Invalid processor handle.
@@ -100,11 +100,11 @@
  *  Details:
  *      This function Calls WMD_BRD_Ioctl.
  */
-	extern DSP_STATUS PROC_Ctrl(void *hProcessor,
-				    u32 dwCmd, IN struct DSP_CBDATA *pArgs);
+extern dsp_status proc_ctrl(void *hprocessor,
+			    u32 dw_cmd, IN struct dsp_cbdata *pargs);
 
 /*
- *  ======== PROC_Detach ========
+ *  ======== proc_detach ========
  *  Purpose:
  *      Close a DSP processor and de-allocate all (GPP) resources reserved
  *      for it. The Processor Object is deleted.
@@ -119,54 +119,54 @@
  *  Ensures:
  *      PROC Object is destroyed.
  */
-	extern DSP_STATUS PROC_Detach(struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_detach(struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_EnumNodes ========
+ *  ======== proc_enum_nodes ========
  *  Purpose:
  *      Enumerate the nodes currently allocated on a processor.
  *  Parameters:
- *      hProcessor  :   The processor handle.
- *      aNodeTab    :   The first Location of an array allocated for node
+ *      hprocessor  :   The processor handle.
+ *      node_tab    :   The first Location of an array allocated for node
  *		      handles.
- *      uNodeTabSize:   The number of (DSP_HNODE) handles that can be held
- *		      to the memory the client has allocated for aNodeTab
- *      puNumNodes  :   Location where DSPProcessor_EnumNodes will return
- *		      the number of valid handles written to aNodeTab
- *      puAllocated :   Location where DSPProcessor_EnumNodes will return
+ *      node_tab_size:   The number of (DSP_HNODE) handles that can be held
+ *		      to the memory the client has allocated for node_tab
+ *      pu_num_nodes  :   Location where DSPProcessor_EnumNodes will return
+ *		      the number of valid handles written to node_tab
+ *      pu_allocated :   Location where DSPProcessor_EnumNodes will return
  *		      the number of nodes that are allocated on the DSP.
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_ESIZE   :   The amount of memory allocated for aNodeTab is
+ *      DSP_ESIZE   :   The amount of memory allocated for node_tab is
  *		      insufficent. That is the number of nodes actually
  *		      allocated on the DSP is greater than the value
- *		      specified for uNodeTabSize.
+ *		      specified for node_tab_size.
  *      DSP_EFAIL   :   Unable to get Resource Information.
  *  Details:
  *  Requires
- *      puNumNodes is not NULL.
- *      puAllocated is not NULL.
- *      aNodeTab is not NULL.
+ *      pu_num_nodes is not NULL.
+ *      pu_allocated is not NULL.
+ *      node_tab is not NULL.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_EnumNodes(void *hProcessor,
-					 void **aNodeTab,
-					 IN u32 uNodeTabSize,
-					 OUT u32 *puNumNodes,
-					 OUT u32 *puAllocated);
+extern dsp_status proc_enum_nodes(void *hprocessor,
+				  void **node_tab,
+				  IN u32 node_tab_size,
+				  OUT u32 *pu_num_nodes,
+				  OUT u32 *pu_allocated);
 
 /*
- *  ======== PROC_GetResourceInfo ========
+ *  ======== proc_get_resource_info ========
  *  Purpose:
  *      Enumerate the resources currently available on a processor.
  *  Parameters:
- *      hProcessor  :       The processor handle.
- *      uResourceType:      Type of resource .
- *      pResourceInfo:      Ptr to the DSP_RESOURCEINFO structure.
- *      uResourceInfoSize:  Size of the structure.
+ *      hprocessor  :       The processor handle.
+ *      resource_type:      Type of resource .
+ *      resource_info:      Ptr to the dsp_resourceinfo structure.
+ *      resource_info_size:  Size of the structure.
  *  Returns:
  *      DSP_SOK     :       Success.
  *      DSP_EHANDLE :       Invalid processor handle.
@@ -177,23 +177,23 @@
  *			  restarted.
  *      DSP_EFAIL   :       Unable to get Resource Information
  *  Requires:
- *      pResourceInfo is not NULL.
- *      Parameter uResourceType is Valid.[TBD]
- *      uResourceInfoSize is >= sizeof DSP_RESOURCEINFO struct.
+ *      resource_info is not NULL.
+ *      Parameter resource_type is Valid.[TBD]
+ *      resource_info_size is >= sizeof dsp_resourceinfo struct.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  *      This function currently returns
- *      DSP_ENOTIMPL, and does not write any data to the pResourceInfo struct.
+ *      DSP_ENOTIMPL, and does not write any data to the resource_info struct.
  */
-	extern DSP_STATUS PROC_GetResourceInfo(void *hProcessor,
-					       u32 uResourceType,
-					       OUT struct DSP_RESOURCEINFO *
-					       pResourceInfo,
-					       u32 uResourceInfoSize);
+extern dsp_status proc_get_resource_info(void *hprocessor,
+					 u32 resource_type,
+					 OUT struct dsp_resourceinfo
+					 *resource_info,
+					 u32 resource_info_size);
 
 /*
- *  ======== PROC_Exit ========
+ *  ======== proc_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
@@ -204,14 +204,14 @@
  *  Ensures:
  *      When reference count == 0, PROC's private resources are freed.
  */
-       extern void PROC_Exit(void);
+extern void proc_exit(void);
 
 /*
- * ======== PROC_GetDevObject =========
+ * ======== proc_get_dev_object =========
  *  Purpose:
  *      Returns the DEV Hanlde for a given Processor handle
  *  Parameters:
- *      hProcessor  :   Processor Handle
+ *      hprocessor  :   Processor Handle
  *      phDevObject :   Location to store the DEV Handle.
  *  Returns:
  *      DSP_SOK     :   Success; *phDevObject has Dev handle
@@ -223,11 +223,11 @@
  *      DSP_SOK     :   *phDevObject is not NULL
  *      DSP_EFAIL   :   *phDevObject is NULL.
  */
-	extern DSP_STATUS PROC_GetDevObject(void *hProcessor,
-					    struct DEV_OBJECT **phDevObject);
+extern dsp_status proc_get_dev_object(void *hprocessor,
+				      struct dev_object **phDevObject);
 
 /*
- *  ======== PROC_Init ========
+ *  ======== proc_init ========
  *  Purpose:
  *      Initialize PROC's private state, keeping a reference count on each
  *      call.
@@ -238,39 +238,37 @@
  *  Ensures:
  *      TRUE: A requirement for the other public PROC functions.
  */
-       extern bool PROC_Init(void);
+extern bool proc_init(void);
 
 /*
- *  ======== PROC_GetState ========
+ *  ======== proc_get_state ========
  *  Purpose:
  *      Report the state of the specified DSP processor.
  *  Parameters:
- *      hProcessor  :   The processor handle.
- *      pProcStatus :   Ptr to location to store the DSP_PROCESSORSTATE
+ *      hprocessor  :   The processor handle.
+ *      proc_state_obj :   Ptr to location to store the dsp_processorstate
  *		      structure.
- *      uStateInfoSize: Size of DSP_PROCESSORSTATE.
+ *      state_info_size: Size of dsp_processorstate.
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
  *      DSP_EFAIL   :   General failure while querying processor state.
  *  Requires:
- *      pProcStatus is not NULL
- *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
+ *      proc_state_obj is not NULL
+ *      state_info_size is >= than the size of dsp_processorstate structure.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetState(void *hProcessor,
-					OUT struct DSP_PROCESSORSTATE
-					*pProcStatus,
-					u32 uStateInfoSize);
+extern dsp_status proc_get_state(void *hprocessor, OUT struct dsp_processorstate
+				 *proc_state_obj, u32 state_info_size);
 
 /*
  *  ======== PROC_GetProcessorID ========
  *  Purpose:
  *      Report the state of the specified DSP processor.
  *  Parameters:
- *      hProcessor  :   The processor handle.
+ *      hprocessor  :   The processor handle.
  *      procID      :   Processor ID
  *
  *  Returns:
@@ -278,52 +276,50 @@
  *      DSP_EHANDLE :   Invalid processor handle.
  *      DSP_EFAIL   :   General failure while querying processor state.
  *  Requires:
- *      pProcStatus is not NULL
- *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
+ *      proc_state_obj is not NULL
+ *      state_info_size is >= than the size of dsp_processorstate structure.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetProcessorId(void *hProcessor,
-					      u32 *procID);
+extern dsp_status proc_get_processor_id(void *hprocessor, u32 * procID);
 
 /*
- *  ======== PROC_GetTrace ========
+ *  ======== proc_get_trace ========
  *  Purpose:
  *      Retrieve the trace buffer from the specified DSP processor.
  *  Parameters:
- *      hProcessor  :   The processor handle.
- *      pBuf	:   Ptr to buffer to hold trace output.
- *      uMaxSize    :   Maximum size of the output buffer.
+ *      hprocessor  :   The processor handle.
+ *      pbuf	:   Ptr to buffer to hold trace output.
+ *      max_size    :   Maximum size of the output buffer.
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
  *      DSP_EFAIL   :   General failure while retireving processor trace
  *		      Buffer.
  *  Requires:
- *      pBuf is not NULL
- *      uMaxSize is > 0.
+ *      pbuf is not NULL
+ *      max_size is > 0.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetTrace(void *hProcessor, u8 *pBuf,
-					u32 uMaxSize);
+extern dsp_status proc_get_trace(void *hprocessor, u8 * pbuf, u32 max_size);
 
 /*
- *  ======== PROC_Load ========
+ *  ======== proc_load ========
  *  Purpose:
  *      Reset a processor and load a new base program image.
  *      This will be an OEM-only function.
  *  Parameters:
- *      hProcessor  :       The processor handle.
- *      iArgc       :       The number of Arguments(strings)in the aArgV[]
- *      aArgv       :       An Array of Arguments(Unicode Strings)
- *      aEnvp       :       An Array of Environment settings(Unicode Strings)
+ *      hprocessor:       The processor handle.
+ *      argc_index:       The number of Arguments(strings)in the aArgV[]
+ *      user_args:       An Array of Arguments(Unicode Strings)
+ *      user_envp:       An Array of Environment settings(Unicode Strings)
  *  Returns:
- *      DSP_SOK     :       Success.
- *      DSP_EFILE   :       The DSP Execuetable was not found.
- *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_SOK:       Success.
+ *      DSP_EFILE:       The DSP Execuetable was not found.
+ *      DSP_EHANDLE:       Invalid processor handle.
  *      DSP_ECORRUTFILE:    Unable to Parse the DSP Execuetable
  *      DSP_EATTACHED:      Abort because a GPP Client is attached to the
  *			  specified Processor
@@ -331,8 +327,8 @@
  *			  to reset and load the Processor
  *      DSP_EFAIL   :       Unable to Load the Processor
  *  Requires:
- *      aArgv is not NULL
- *      iArgc is > 0
+ *      user_args is not NULL
+ *      argc_index is > 0
  *      PROC Initialized.
  *  Ensures:
  *      Success and ProcState == PROC_LOADED
@@ -341,39 +337,39 @@
  *      Does not implement access rights to control which GPP application
  *      can load the processor.
  */
-	extern DSP_STATUS PROC_Load(void *hProcessor,
-				    IN CONST s32 iArgc, IN CONST char **aArgv,
-				    IN CONST char **aEnvp);
+extern dsp_status proc_load(void *hprocessor,
+			    IN CONST s32 argc_index, IN CONST char **user_args,
+			    IN CONST char **user_envp);
 
 /*
- *  ======== PROC_RegisterNotify ========
+ *  ======== proc_register_notify ========
  *  Purpose:
  *      Register to be notified of specific processor events
  *  Parameters:
- *      hProcessor  :   The processor handle.
- *      uEventMask  :   Mask of types of events to be notified about.
- *      uNotifyType :   Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
+ *      hprocessor  :   The processor handle.
+ *      event_mask  :   Mask of types of events to be notified about.
+ *      notify_type :   Type of notification to be sent.
+ *      hnotification:  Handle to be used for notification.
  *  Returns:
  *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle or hNotification.
- *      DSP_EVALUE  :   Parameter uEventMask is Invalid
+ *      DSP_EHANDLE :   Invalid processor handle or hnotification.
+ *      DSP_EVALUE  :   Parameter event_mask is Invalid
  *      DSP_ENOTIMP :   The notification type specified in uNotifyMask
  *		      is not supported.
  *      DSP_EFAIL   :   Unable to register for notification.
  *  Requires:
- *      hNotification is not NULL
+ *      hnotification is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_RegisterNotify(void *hProcessor,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
+extern dsp_status proc_register_notify(void *hprocessor,
+				       u32 event_mask, u32 notify_type,
+				       struct dsp_notification
+				       *hnotification);
 
 /*
- *  ======== PROC_NotifyClients ========
+ *  ======== proc_notify_clients ========
  *  Purpose:
  *      Notify the Processor Clients
  *  Parameters:
@@ -389,11 +385,10 @@
  *      PROC Initialized.
  *  Ensures:
  */
-	extern DSP_STATUS PROC_NotifyClients(void *hProc,
-					     u32 uEvents);
+extern dsp_status proc_notify_clients(void *hProc, u32 uEvents);
 
 /*
- *  ======== PROC_NotifyAllClients ========
+ *  ======== proc_notify_all_clients ========
  *  Purpose:
  *      Notify the Processor Clients
  *  Parameters:
@@ -412,18 +407,17 @@
  *      NODE And STRM would use this function to notify their clients
  *      about the state changes in NODE or STRM.
  */
-	extern DSP_STATUS PROC_NotifyAllClients(void *hProc,
-						u32 uEvents);
+extern dsp_status proc_notify_all_clients(void *hProc, u32 uEvents);
 
 /*
- *  ======== PROC_Start ========
+ *  ======== proc_start ========
  *  Purpose:
  *      Start a processor running.
  *      Processor must be in PROC_LOADED state.
  *      This will be an OEM-only function, and not part of the 'Bridge
  *      application developer's API.
  *  Parameters:
- *      hProcessor  :       The processor handle.
+ *      hprocessor  :       The processor handle.
  *  Returns:
  *      DSP_SOK     :       Success.
  *      DSP_EHANDLE :       Invalid processor handle.
@@ -435,17 +429,17 @@
  *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
  *  Details:
  */
-	extern DSP_STATUS PROC_Start(void *hProcessor);
+extern dsp_status proc_start(void *hprocessor);
 
 /*
- *  ======== PROC_Stop ========
+ *  ======== proc_stop ========
  *  Purpose:
  *      Start a processor running.
  *      Processor must be in PROC_LOADED state.
  *      This will be an OEM-only function, and not part of the 'Bridge
  *      application developer's API.
  *  Parameters:
- *      hProcessor  :       The processor handle.
+ *      hprocessor  :       The processor handle.
  *  Returns:
  *      DSP_SOK     :       Success.
  *      DSP_EHANDLE :       Invalid processor handle.
@@ -457,17 +451,17 @@
  *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
  *  Details:
  */
-	extern DSP_STATUS PROC_Stop(void *hProcessor);
+extern dsp_status proc_stop(void *hprocessor);
 
 /*
- *  ======== PROC_FlushMemory ========
+ *  ======== proc_flush_memory ========
  *  Purpose:
  *      Flushes a buffer from the MPU data cache.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Buffer start address
- *      ulSize	  :   Buffer size
- *      ulFlags	 :   Reserved.
+ *      hprocessor      :   The processor handle.
+ *      pmpu_addr	:   Buffer start address
+ *      ul_size	  :   Buffer size
+ *      ul_flags	 :   Reserved.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -478,19 +472,17 @@
  *  Details:
  *      All the arguments are currently ignored.
  */
-	extern DSP_STATUS PROC_FlushMemory(void *hProcessor,
-					   void *pMpuAddr,
-					   u32 ulSize, u32 ulFlags);
-
+extern dsp_status proc_flush_memory(void *hprocessor,
+				    void *pmpu_addr, u32 ul_size, u32 ul_flags);
 
 /*
- *  ======== PROC_InvalidateMemory ========
+ *  ======== proc_invalidate_memory ========
  *  Purpose:
  *      Invalidates a buffer from the MPU data cache.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Buffer start address
- *      ulSize	  :   Buffer size
+ *      hprocessor      :   The processor handle.
+ *      pmpu_addr	:   Buffer start address
+ *      ul_size	  :   Buffer size
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -501,22 +493,21 @@
  *  Details:
  *      All the arguments are currently ignored.
  */
-	extern DSP_STATUS PROC_InvalidateMemory(void *hProcessor,
-					   void *pMpuAddr,
-					   u32 ulSize);
+extern dsp_status proc_invalidate_memory(void *hprocessor,
+					 void *pmpu_addr, u32 ul_size);
 
 /*
- *  ======== PROC_Map ========
+ *  ======== proc_map ========
  *  Purpose:
  *      Maps a MPU buffer to DSP address space.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Starting address of the memory region to map.
- *      ulSize	  :   Size of the memory region to map.
- *      pReqAddr	:   Requested DSP start address. Offset-adjusted actual
+ *      hprocessor      :   The processor handle.
+ *      pmpu_addr	:   Starting address of the memory region to map.
+ *      ul_size	  :   Size of the memory region to map.
+ *      req_addr	:   Requested DSP start address. Offset-adjusted actual
  *			  mapped address is in the last argument.
- *      ppMapAddr       :   Ptr to DSP side mapped u8 address.
- *      ulMapAttr       :   Optional endianness attributes, virt to phys flag.
+ *      pp_map_addr       :   Ptr to DSP side mapped u8 address.
+ *      ul_map_attr       :   Optional endianness attributes, virt to phys flag.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -525,49 +516,50 @@
  *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
  *		      :   address.
  *  Requires:
- *      pMpuAddr is not NULL
- *      ulSize is not zero
- *      ppMapAddr is not NULL
+ *      pmpu_addr is not NULL
+ *      ul_size is not zero
+ *      pp_map_addr is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_Map(void *hProcessor,
-				   void *pMpuAddr,
-				   u32 ulSize,
-				   void *pReqAddr,
-				   void **ppMapAddr, u32 ulMapAttr,
-				   struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_map(void *hprocessor,
+			   void *pmpu_addr,
+			   u32 ul_size,
+			   void *req_addr,
+			   void **pp_map_addr, u32 ul_map_attr,
+			   struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_ReserveMemory ========
+ *  ======== proc_reserve_memory ========
  *  Purpose:
  *      Reserve a virtually contiguous region of DSP address space.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      ulSize	  :   Size of the address space to reserve.
- *      ppRsvAddr       :   Ptr to DSP side reserved u8 address.
+ *      hprocessor      :   The processor handle.
+ *      ul_size	  :   Size of the address space to reserve.
+ *      pp_rsv_addr       :   Ptr to DSP side reserved u8 address.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
  *      DSP_EFAIL       :   General failure.
  *      DSP_EMEMORY     :   Cannot reserve chunk of this size.
  *  Requires:
- *      ppRsvAddr is not NULL
+ *      pp_rsv_addr is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_ReserveMemory(void *hProcessor,
-		u32 ulSize, void **ppRsvAddr, struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_reserve_memory(void *hprocessor,
+				      u32 ul_size, void **pp_rsv_addr,
+				      struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_UnMap ========
+ *  ======== proc_un_map ========
  *  Purpose:
  *      Removes a MPU buffer mapping from the DSP address space.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMapAddr	:   Starting address of the mapped memory region.
+ *      hprocessor      :   The processor handle.
+ *      map_addr	:   Starting address of the mapped memory region.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -575,21 +567,21 @@
  *      DSP_ENOTFOUND   :   Cannot find a mapped region starting with this
  *		      :   address.
  *  Requires:
- *      pMapAddr is not NULL
+ *      map_addr is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_UnMap(void *hProcessor, void *pMapAddr,
-			struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_un_map(void *hprocessor, void *map_addr,
+			      struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_UnReserveMemory ========
+ *  ======== proc_un_reserve_memory ========
  *  Purpose:
  *      Frees a previously reserved region of DSP address space.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pRsvAddr	:   Ptr to DSP side reservedBYTE address.
+ *      hprocessor      :   The processor handle.
+ *      prsv_addr	:   Ptr to DSP side reservedBYTE address.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -597,12 +589,13 @@
  *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
  *		      :   address.
  *  Requires:
- *      pRsvAddr is not NULL
+ *      prsv_addr is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_UnReserveMemory(void *hProcessor,
-			void *pRsvAddr, struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_un_reserve_memory(void *hprocessor,
+					 void *prsv_addr,
+					 struct process_context *pr_ctxt);
 
-#endif				/* PROC_ */
+#endif /* PROC_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/procpriv.h b/arch/arm/plat-omap/include/dspbridge/procpriv.h
index 4a24949..1cd38ba 100644
--- a/arch/arm/plat-omap/include/dspbridge/procpriv.h
+++ b/arch/arm/plat-omap/include/dspbridge/procpriv.h
@@ -20,7 +20,6 @@
 #define PROCPRIV_
 
 /* RM PROC Object */
-	struct PROC_OBJECT;
-
-#endif				/* PROCPRIV_ */
+struct proc_object;
 
+#endif /* PROCPRIV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/pwr.h b/arch/arm/plat-omap/include/dspbridge/pwr.h
index d1433fa..1ce54a1 100644
--- a/arch/arm/plat-omap/include/dspbridge/pwr.h
+++ b/arch/arm/plat-omap/include/dspbridge/pwr.h
@@ -22,7 +22,7 @@
 #include <dspbridge/pwr_sh.h>
 
 /*
- *  ======== PWR_SleepDSP ========
+ *  ======== pwr_sleep_dsp ========
  *      Signal the DSP to go to sleep.
  *
  *  Parameters:
@@ -46,11 +46,10 @@
  *      DSP_EFAIL:          General failure, unable to send sleep command to
  *                          the DSP.
  */
-	extern DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode,
-				       IN CONST u32 timeout);
+extern dsp_status pwr_sleep_dsp(IN CONST u32 sleepCode, IN CONST u32 timeout);
 
 /*
- *  ======== PWR_WakeDSP ========
+ *  ======== pwr_wake_dsp ========
  *    Signal the DSP to wake from sleep.
  *
  *  Parameters:
@@ -68,10 +67,10 @@
  *      DSP_EFAIL:          General failure, unable to send wake command to
  *                          the DSP.
  */
-	extern DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout);
+extern dsp_status pwr_wake_dsp(IN CONST u32 timeout);
 
 /*
- *  ======== PWR_PM_PreScale ========
+ *  ======== pwr_pm_pre_scale ========
  *    Prescale notification to DSP.
  *
  *  Parameters:
@@ -86,10 +85,10 @@
  *      DSP_EFAIL:          General failure, unable to send wake command to
  *                          the DSP.
  */
-	extern DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level);
+extern dsp_status pwr_pm_pre_scale(IN u16 voltage_domain, u32 level);
 
 /*
- *  ======== PWR_PM_PostScale ========
+ *  ======== pwr_pm_post_scale ========
  *    PostScale notification to DSP.
  *
  *  Parameters:
@@ -104,7 +103,6 @@
  *      DSP_EFAIL:          General failure, unable to send wake command to
  *                          the DSP.
  */
-	extern DSP_STATUS PWR_PM_PostScale(IN u16 voltage_domain,
-					   u32 level);
+extern dsp_status pwr_pm_post_scale(IN u16 voltage_domain, u32 level);
 
-#endif				/* PWR_ */
+#endif /* PWR_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/pwr_sh.h b/arch/arm/plat-omap/include/dspbridge/pwr_sh.h
index 202b225..1b4a090 100644
--- a/arch/arm/plat-omap/include/dspbridge/pwr_sh.h
+++ b/arch/arm/plat-omap/include/dspbridge/pwr_sh.h
@@ -30,4 +30,4 @@
 #define PWR_AUTODISABLE         MBX_PM_PWRDISABLE
 #define PWR_RETENTION             MBX_PM_DSPRETN
 
-#endif				/* PWR_SH_ */
+#endif /* PWR_SH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/reg.h b/arch/arm/plat-omap/include/dspbridge/reg.h
index 4801578..8f32157 100644
--- a/arch/arm/plat-omap/include/dspbridge/reg.h
+++ b/arch/arm/plat-omap/include/dspbridge/reg.h
@@ -24,7 +24,7 @@
 #define REG_MAXREGPATHLENGTH    255
 
 /*
- *  ======== REG_DeleteValue ========
+ *  ======== reg_delete_value ========
  *  Purpose:
  *      Deletes a registry entry. NOTE: A registry entry is not the same as
  *      a registry key.
@@ -40,15 +40,15 @@
  *  Ensures:
  *  Details:
  */
-extern DSP_STATUS REG_DeleteValue(IN CONST char *pstrValue);
+extern dsp_status reg_delete_value(IN CONST char *pstrValue);
 
 /*
- *  ======== REG_EnumValue ========
+ *  ======== reg_enum_value ========
  *  Purpose:
  *      Enumerates values of a specified key. Retrieves each value name and
  *      the data associated with the value.
  *  Parameters:
- *      dwIndex:        Specifies the index of the value to retrieve.
+ *      dw_index:        Specifies the index of the value to retrieve.
  *      pstrKey:        The name of the registry key to be enumerated.
  *      pstrValue:      Pointer to buffer that receives the name of the value.
  *      pdwValueSize:   Specifies bytes of memory pstrValue points to on input,
@@ -68,14 +68,14 @@ extern DSP_STATUS REG_DeleteValue(IN CONST char *pstrValue);
  *      Length of pstrKey is less than REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-extern DSP_STATUS REG_EnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
-				IN OUT char *pstrValue,
-				IN OUT u32 *pdwValueSize,
-				IN OUT char *pstrData,
-				IN OUT u32 *pdwDataSize);
+extern dsp_status reg_enum_value(IN u32 dw_index, IN CONST char *pstrKey,
+				 IN OUT char *pstrValue,
+				 IN OUT u32 *pdwValueSize,
+				 IN OUT char *pstrData,
+				 IN OUT u32 *pdwDataSize);
 
 /*
- *  ======== REG_Exit ========
+ *  ======== reg_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -86,10 +86,10 @@ extern DSP_STATUS REG_EnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void REG_Exit(void);
+extern void reg_exit(void);
 
 /*
- *  ======== REG_GetValue ========
+ *  ======== reg_get_value ========
  *  Purpose:
  *      Retrieve a value from the registry.
  *  Parameters:
@@ -109,11 +109,11 @@ extern DSP_STATUS REG_EnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
  *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-extern DSP_STATUS REG_GetValue(IN CONST char *pstrEntry, OUT u8 *pbValue,
-			       IN OUT u32 *pdwValueSize);
+extern dsp_status reg_get_value(IN CONST char *pstrEntry, OUT u8 * pbValue,
+				IN OUT u32 *pdwValueSize);
 
 /*
- *  ======== REG_Init ========
+ *  ======== reg_init ========
  *  Purpose:
  *      Initializes private state of REG module.
  *  Parameters:
@@ -123,16 +123,16 @@ extern DSP_STATUS REG_GetValue(IN CONST char *pstrEntry, OUT u8 *pbValue,
  *  Ensures:
  *      REG initialized.
  */
-	extern bool REG_Init(void);
+extern bool reg_init(void);
 
 /*
- *  ======== REG_SetValue ========
+ *  ======== reg_set_value ========
  *  Purpose:
  *      Set a value in the registry.
  *  Parameters:
  *      pstrEntry:      Name of entry to set.
  *      pbValue:        Points to buffer containing new data.
- *      dwValueSize:    Specifies bytes of memory bValue points to.
+ *      dw_value_size:    Specifies bytes of memory bValue points to.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      General failure.
@@ -144,7 +144,7 @@ extern DSP_STATUS REG_GetValue(IN CONST char *pstrEntry, OUT u8 *pbValue,
  *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-extern DSP_STATUS REG_SetValue(IN CONST char *pstrEntry, IN u8 *pbValue,
-			       IN u32 dwValueSize);
+extern dsp_status reg_set_value(IN CONST char *pstrEntry, IN u8 * pbValue,
+				IN u32 dw_value_size);
 
-#endif				/* _REG_H */
+#endif /* _REG_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h b/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
index 2bb756a..ef18477 100644
--- a/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
+++ b/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
@@ -14,51 +14,50 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 #include <dspbridge/nodepriv.h>
 #include <dspbridge/drv.h>
 
+extern dsp_status drv_get_proc_ctxt_list(struct process_context **pPctxt,
+					 struct drv_object *hdrv_obj);
 
-extern DSP_STATUS DRV_GetProcCtxtList(struct PROCESS_CONTEXT **pPctxt,
-				struct DRV_OBJECT *hDrvObject);
-
-extern DSP_STATUS DRV_InsertProcContext(struct DRV_OBJECT *hDrVObject,
-					HANDLE hPCtxt);
-
-extern DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE pCtxt);
+extern dsp_status drv_insert_proc_context(struct drv_object *hDrVObject,
+					  bhandle hPCtxt);
 
-extern DSP_STATUS DRV_RemoveAllNodeResElements(HANDLE pCtxt);
+extern dsp_status drv_remove_all_dmm_res_elements(bhandle ctxt);
 
-extern DSP_STATUS DRV_ProcSetPID(HANDLE pCtxt, s32 hProcess);
+extern dsp_status drv_remove_all_node_res_elements(bhandle ctxt);
 
-extern DSP_STATUS DRV_RemoveAllResources(HANDLE pPctxt);
+extern dsp_status drv_proc_set_pid(bhandle ctxt, s32 process);
 
-extern DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
-				     HANDLE pr_ctxt);
+extern dsp_status drv_remove_all_resources(bhandle pPctxt);
 
-extern DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE nodeRes,
-					HANDLE pCtxt);
+extern dsp_status drv_remove_proc_context(struct drv_object *hDRVObject,
+					  bhandle pr_ctxt);
 
-extern DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE nodeRes,
-					    HANDLE pCtxt);
+extern dsp_status drv_get_node_res_element(bhandle hnode, bhandle node_res,
+					   bhandle ctxt);
 
-extern void DRV_ProcNodeUpdateHeapStatus(HANDLE hNodeRes, s32 status);
+extern dsp_status drv_insert_node_res_element(bhandle hnode, bhandle node_res,
+					      bhandle ctxt);
 
-extern DSP_STATUS DRV_RemoveNodeResElement(HANDLE nodeRes, HANDLE status);
+extern void drv_proc_node_update_heap_status(bhandle hNodeRes, s32 status);
 
-extern void DRV_ProcNodeUpdateStatus(HANDLE hNodeRes, s32 status);
+extern dsp_status drv_remove_node_res_element(bhandle node_res, bhandle status);
 
-extern DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE STRMRes);
+extern void drv_proc_node_update_status(bhandle hNodeRes, s32 status);
 
-extern DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
-						HANDLE pPctxt);
+extern dsp_status drv_proc_update_strm_res(u32 num_bufs, bhandle strm_res);
 
-extern DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
-					HANDLE pCtxt);
+extern dsp_status drv_proc_insert_strm_res_element(bhandle hStrm,
+						   bhandle strm_res,
+						   bhandle pPctxt);
 
-extern DSP_STATUS DRV_ProcRemoveSTRMResElement(HANDLE STRMRes, HANDLE pCtxt);
+extern dsp_status drv_get_strm_res_element(bhandle hStrm, bhandle strm_res,
+					   bhandle ctxt);
 
-extern DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE pCtxt);
+extern dsp_status drv_proc_remove_strm_res_element(bhandle strm_res,
+						   bhandle ctxt);
 
-extern enum NODE_STATE NODE_GetState(HANDLE hNode);
+extern dsp_status drv_remove_all_strm_res_elements(bhandle ctxt);
 
+extern enum node_state node_get_state(bhandle hnode);
diff --git a/arch/arm/plat-omap/include/dspbridge/rmm.h b/arch/arm/plat-omap/include/dspbridge/rmm.h
index 389cf57..b22b5c5 100644
--- a/arch/arm/plat-omap/include/dspbridge/rmm.h
+++ b/arch/arm/plat-omap/include/dspbridge/rmm.h
@@ -22,37 +22,37 @@
 #define RMM_
 
 /*
- *  ======== RMM_Addr ========
+ *  ======== rmm_addr ========
  *  DSP address + segid
  */
-struct RMM_Addr {
+struct rmm_addr {
 	u32 addr;
 	s32 segid;
-} ;
+};
 
 /*
- *  ======== RMM_Segment ========
+ *  ======== rmm_segment ========
  *  Memory segment on the DSP available for remote allocations.
  */
-struct RMM_Segment {
+struct rmm_segment {
 	u32 base;		/* Base of the segment */
 	u32 length;		/* Size of the segment (target MAUs) */
 	s32 space;		/* Code or data */
 	u32 number;		/* Number of Allocated Blocks */
-} ;
+};
 
 /*
  *  ======== RMM_Target ========
  */
-struct RMM_TargetObj;
+struct rmm_target_obj;
 
 /*
- *  ======== RMM_alloc ========
+ *  ======== rmm_alloc ========
  *
- *  RMM_alloc is used to remotely allocate or reserve memory on the DSP.
+ *  rmm_alloc is used to remotely allocate or reserve memory on the DSP.
  *
  *  Parameters:
- *      target          - Target returned from RMM_create().
+ *      target          - Target returned from rmm_create().
  *      segid           - Memory segment to allocate from.
  *      size            - Size (target MAUS) to allocate.
  *      align           - alignment.
@@ -70,68 +70,68 @@ struct RMM_TargetObj;
  *      Valid target.
  *      dspAddr != NULL.
  *      size > 0
- *      reserve || target->numSegs > 0.
+ *      reserve || target->num_segs > 0.
  *  Ensures:
  */
-extern DSP_STATUS RMM_alloc(struct RMM_TargetObj *target, u32 segid, u32 size,
+extern dsp_status rmm_alloc(struct rmm_target_obj *target, u32 segid, u32 size,
 			    u32 align, u32 *dspAdr, bool reserve);
 
 /*
- *  ======== RMM_create ========
+ *  ======== rmm_create ========
  *  Create a target object with memory segments for remote allocation. If
- *  segTab == NULL or numSegs == 0, memory can only be reserved through
- *  RMM_alloc().
+ *  seg_tab == NULL or num_segs == 0, memory can only be reserved through
+ *  rmm_alloc().
  *
  *  Parameters:
- *      pTarget:        - Location to store target on output.
- *      segTab:         - Table of memory segments.
- *      numSegs:        - Number of memory segments.
+ *      target_obj:        - Location to store target on output.
+ *      seg_tab:         - Table of memory segments.
+ *      num_segs:        - Number of memory segments.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failed.
  *  Requires:
  *      RMM initialized.
- *      pTarget != NULL.
- *      numSegs == 0 || segTab != NULL.
+ *      target_obj != NULL.
+ *      num_segs == 0 || seg_tab != NULL.
  *  Ensures:
- *      Success:        Valid *pTarget.
- *      Failure:        *pTarget == NULL.
+ *      Success:        Valid *target_obj.
+ *      Failure:        *target_obj == NULL.
  */
-extern DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
-			     struct RMM_Segment segTab[], u32 numSegs);
+extern dsp_status rmm_create(struct rmm_target_obj **target_obj,
+			     struct rmm_segment seg_tab[], u32 num_segs);
 
 /*
- *  ======== RMM_delete ========
- *  Delete target allocated in RMM_create().
+ *  ======== rmm_delete ========
+ *  Delete target allocated in rmm_create().
  *
  *  Parameters:
- *      target          - Target returned from RMM_create().
+ *      target          - Target returned from rmm_create().
  *  Returns:
  *  Requires:
  *      RMM initialized.
  *      Valid target.
  *  Ensures:
  */
-extern void RMM_delete(struct RMM_TargetObj *target);
+extern void rmm_delete(struct rmm_target_obj *target);
 
 /*
- *  ======== RMM_exit ========
+ *  ======== rmm_exit ========
  *  Exit the RMM module
  *
  *  Parameters:
  *  Returns:
  *  Requires:
- *      RMM_init successfully called.
+ *      rmm_init successfully called.
  *  Ensures:
  */
-extern void RMM_exit(void);
+extern void rmm_exit(void);
 
 /*
- *  ======== RMM_free ========
- *  Free or unreserve memory allocated through RMM_alloc().
+ *  ======== rmm_free ========
+ *  Free or unreserve memory allocated through rmm_alloc().
  *
  *  Parameters:
- *      target:         - Target returned from RMM_create().
+ *      target:         - Target returned from rmm_create().
  *      segid:          - Segment of memory to free.
  *      dspAddr:        - Address to free or unreserve.
  *      size:           - Size of memory to free or unreserve.
@@ -140,15 +140,15 @@ extern void RMM_exit(void);
  *  Requires:
  *      RMM initialized.
  *      Valid target.
- *      reserved || segid < target->numSegs.
+ *      reserved || segid < target->num_segs.
  *      reserve || [dspAddr, dspAddr + size] is a valid memory range.
  *  Ensures:
  */
-extern bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 dspAddr,
+extern bool rmm_free(struct rmm_target_obj *target, u32 segid, u32 dspAddr,
 		     u32 size, bool reserved);
 
 /*
- *  ======== RMM_init ========
+ *  ======== rmm_init ========
  *  Initialize the RMM module
  *
  *  Parameters:
@@ -158,10 +158,10 @@ extern bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 dspAddr,
  *  Requires:
  *  Ensures:
  */
-extern bool RMM_init(void);
+extern bool rmm_init(void);
 
 /*
- *  ======== RMM_stat ========
+ *  ======== rmm_stat ========
  *  Obtain  memory segment status
  *
  *  Parameters:
@@ -172,10 +172,10 @@ extern bool RMM_init(void);
  *      TRUE:   Success.
  *      FALSE:  Failure.
  *  Requires:
- *      segid < target->numSegs
+ *      segid < target->num_segs
  *  Ensures:
  */
-extern bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
-		     struct DSP_MEMSTAT *pMemStatBuf);
+extern bool rmm_stat(struct rmm_target_obj *target, enum dsp_memtype segid,
+		     struct dsp_memstat *pMemStatBuf);
 
-#endif				/* RMM_ */
+#endif /* RMM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/rms_sh.h b/arch/arm/plat-omap/include/dspbridge/rms_sh.h
index 59c00d1..d70b17d 100644
--- a/arch/arm/plat-omap/include/dspbridge/rms_sh.h
+++ b/arch/arm/plat-omap/include/dspbridge/rms_sh.h
@@ -37,61 +37,59 @@
 #define RMS_RESPONSEBUFSIZE    16	/* Size of response buffer */
 
 /* Pre-Defined Command/Response Codes: */
-#define RMS_EXIT                0x80000000   /* GPP->Node: shutdown */
-#define RMS_EXITACK             0x40000000   /* Node->GPP: ack shutdown */
-#define RMS_BUFDESC             0x20000000   /* Arg1 SM buf, Arg2 is SM size */
-#define RMS_KILLTASK            0x10000000  /* GPP->Node: Kill Task */
+#define RMS_EXIT                0x80000000	/* GPP->Node: shutdown */
+#define RMS_EXITACK             0x40000000	/* Node->GPP: ack shutdown */
+#define RMS_BUFDESC             0x20000000	/* Arg1 SM buf, Arg2 SM size */
+#define RMS_KILLTASK            0x10000000	/* GPP->Node: Kill Task */
 #define RMS_USER                0x0	/* Start of user-defined msg codes */
 #define RMS_MAXUSERCODES        0xfff	/* Maximum user defined C/R Codes */
 
-
 /* RM Server RPC Command Structure: */
-	struct RMS_Command {
-		RMS_WORD fxn;	/* Server function address */
-		RMS_WORD arg1;	/* First argument */
-		RMS_WORD arg2;	/* Second argument */
-		RMS_WORD data;	/* Function-specific data array */
-	} ;
+struct rms_command {
+	rms_word fxn;		/* Server function address */
+	rms_word arg1;		/* First argument */
+	rms_word arg2;		/* Second argument */
+	rms_word data;		/* Function-specific data array */
+};
 
 /*
- *  The RMS_StrmDef structure defines the parameters for both input and output
+ *  The rms_strm_def structure defines the parameters for both input and output
  *  streams, and is passed to a node's create function.
  */
-	struct RMS_StrmDef {
-		RMS_WORD bufsize;	/* Buffer size (in DSP words) */
-		RMS_WORD nbufs;	/* Max number of bufs in stream */
-		RMS_WORD segid;	/* Segment to allocate buffers */
-		RMS_WORD align;	/* Alignment for allocated buffers */
-		RMS_WORD timeout;	/* Timeout (msec) for blocking calls */
-		RMS_CHAR name[1];	/* Device Name (terminated by '\0') */
-	} ;
+struct rms_strm_def {
+	rms_word bufsize;	/* Buffer size (in DSP words) */
+	rms_word nbufs;		/* Max number of bufs in stream */
+	rms_word segid;		/* Segment to allocate buffers */
+	rms_word align;		/* Alignment for allocated buffers */
+	rms_word timeout;	/* Timeout (msec) for blocking calls */
+	rms_char name[1];	/* Device Name (terminated by '\0') */
+};
 
 /* Message node create args structure: */
-	struct RMS_MsgArgs {
-		RMS_WORD maxMessages;	/* Max # simultaneous msgs to node */
-		RMS_WORD segid;	/* Mem segment for NODE_allocMsgBuf */
-		RMS_WORD notifyType;	/* Type of message notification */
-		RMS_WORD argLength;	/* Length (in DSP chars) of arg data */
-		RMS_WORD argData;	/* Arg data for node */
-	} ;
+struct rms_msg_args {
+	rms_word max_msgs;	/* Max # simultaneous msgs to node */
+	rms_word segid;		/* Mem segment for NODE_allocMsgBuf */
+	rms_word notify_type;	/* Type of message notification */
+	rms_word arg_length;	/* Length (in DSP chars) of arg data */
+	rms_word arg_data;	/* Arg data for node */
+};
 
 /* Partial task create args structure */
-	struct RMS_MoreTaskArgs {
-		RMS_WORD priority;	/* Task's runtime priority level */
-		RMS_WORD stackSize;	/* Task's stack size */
-		RMS_WORD sysstackSize;	/* Task's system stack size (55x) */
-		RMS_WORD stackSeg;	/* Memory segment for task's stack */
-		RMS_WORD heapAddr;   /* base address of the node memory heap in
-				      * external memory (DSP virtual address) */
-		RMS_WORD heapSize;   /* size in MAUs of the node memory heap in
-				      * external memory */
-		RMS_WORD misc;	/* Misc field.  Not used for 'normal'
+struct rms_more_task_args {
+	rms_word priority;	/* Task's runtime priority level */
+	rms_word stack_size;	/* Task's stack size */
+	rms_word sysstack_size;	/* Task's system stack size (55x) */
+	rms_word stack_seg;	/* Memory segment for task's stack */
+	rms_word heap_addr;	/* base address of the node memory heap in
+				 * external memory (DSP virtual address) */
+	rms_word heap_size;	/* size in MAUs of the node memory heap in
+				 * external memory */
+	rms_word misc;		/* Misc field.  Not used for 'normal'
 				 * task nodes; for xDAIS socket nodes
 				 * specifies the IALG_Fxn pointer.
 				 */
-		/* # input STRM definition structures */
-		RMS_WORD numInputStreams;
-	} ;
-
-#endif				/* RMS_SH_ */
+	/* # input STRM definition structures */
+	rms_word num_input_streams;
+};
 
+#endif /* RMS_SH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/rmstypes.h b/arch/arm/plat-omap/include/dspbridge/rmstypes.h
index 484f539..b096cf1 100644
--- a/arch/arm/plat-omap/include/dspbridge/rmstypes.h
+++ b/arch/arm/plat-omap/include/dspbridge/rmstypes.h
@@ -23,7 +23,7 @@
  *  DSP-side definitions.
  */
 #include <dspbridge/std.h>
-typedef u32 RMS_WORD;
-typedef char RMS_CHAR;
+typedef u32 rms_word;
+typedef char rms_char;
 
-#endif				/* RMSTYPES_ */
+#endif /* RMSTYPES_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/services.h b/arch/arm/plat-omap/include/dspbridge/services.h
index f44e458..eb26c86 100644
--- a/arch/arm/plat-omap/include/dspbridge/services.h
+++ b/arch/arm/plat-omap/include/dspbridge/services.h
@@ -21,7 +21,7 @@
 
 #include <dspbridge/host_os.h>
 /*
- *  ======== SERVICES_Exit ========
+ *  ======== services_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -32,10 +32,10 @@
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void SERVICES_Exit(void);
+extern void services_exit(void);
 
 /*
- *  ======== SERVICES_Init ========
+ *  ======== services_init ========
  *  Purpose:
  *      Initializes SERVICES modules.
  *  Parameters:
@@ -45,6 +45,6 @@
  *  Ensures:
  *      SERVICES modules initialized.
  */
-	extern bool SERVICES_Init(void);
+extern bool services_init(void);
 
-#endif				/* SERVICES_ */
+#endif /* SERVICES_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/std.h b/arch/arm/plat-omap/include/dspbridge/std.h
index 19289b9..7e09fec 100644
--- a/arch/arm/plat-omap/include/dspbridge/std.h
+++ b/arch/arm/plat-omap/include/dspbridge/std.h
@@ -72,24 +72,23 @@
  *  Aliases for standard C types
  */
 
-typedef s32(*Fxn) (void);		/* generic function type */
+typedef s32(*fxn) (void);	/* generic function type */
 
 #ifndef NULL
 #define NULL 0
 #endif
 
-
 /*
  * These macros are used to cast 'Arg' types to 's32' or 'Ptr'.
  * These macros were added for the 55x since Arg is not the same
  * size as s32 and Ptr in 55x large model.
  */
 #if defined(_28l_) || defined(_55l_)
-#define ArgToInt(A)	((s32)((long)(A) & 0xffff))
-#define ArgToPtr(A)	((Ptr)(A))
+#define ARG_TO_INT(A)	((s32)((long)(A) & 0xffff))
+#define ARG_TO_PTR(A)	((Ptr)(A))
 #else
-#define ArgToInt(A)	((s32)(A))
-#define ArgToPtr(A)	((Ptr)(A))
+#define ARG_TO_INT(A)	((s32)(A))
+#define ARG_TO_PTR(A)	((Ptr)(A))
 #endif
 
-#endif				/* STD_ */
+#endif /* STD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/strm.h b/arch/arm/plat-omap/include/dspbridge/strm.h
index a26abc3..51a897f 100644
--- a/arch/arm/plat-omap/include/dspbridge/strm.h
+++ b/arch/arm/plat-omap/include/dspbridge/strm.h
@@ -25,37 +25,37 @@
 #include <dspbridge/proc.h>
 
 /*
- *  ======== STRM_AllocateBuffer ========
+ *  ======== strm_allocate_buffer ========
  *  Purpose:
  *      Allocate data buffer(s) for use with a stream.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer(s).
- *      uNumBufs:       Number of buffers to allocate.
- *      apBuffer:       Array to hold buffer addresses.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      usize:          Size (GPP bytes) of the buffer(s).
+ *      num_bufs:       Number of buffers to allocate.
+ *      ap_buffer:       Array to hold buffer addresses.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EMEMORY:    Insufficient memory.
  *      DSP_EFAIL:      Failure occurred, unable to allocate buffers.
- *      DSP_ESIZE:      uSize must be > 0 bytes.
+ *      DSP_ESIZE:      usize must be > 0 bytes.
  *  Requires:
- *      STRM_Init(void) called.
- *      apBuffer != NULL.
+ *      strm_init(void) called.
+ *      ap_buffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm,
-					      u32 uSize,
-					      OUT u8 **apBuffer,
-					      u32 uNumBufs,
-					      struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status strm_allocate_buffer(struct strm_object *hStrm,
+				       u32 usize,
+				       OUT u8 **ap_buffer,
+				       u32 num_bufs,
+				       struct process_context *pr_ctxt);
 
 /*
- *  ======== STRM_Close ========
+ *  ======== strm_close ========
  *  Purpose:
- *      Close a stream opened with STRM_Open().
+ *      Close a stream opened with strm_open().
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
+ *      hStrm:          Stream handle returned from strm_open().
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
@@ -63,128 +63,128 @@
  *                      been reclaimed.
  *      DSP_EFAIL:      Failure to close stream.
  *  Requires:
- *      STRM_Init(void) called.
+ *      strm_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
-				struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status strm_close(struct strm_object *hStrm,
+			     struct process_context *pr_ctxt);
 
 /*
- *  ======== STRM_Create ========
+ *  ======== strm_create ========
  *  Purpose:
  *      Create a STRM manager object. This object holds information about the
  *      device needed to open streams.
  *  Parameters:
  *      phStrmMgr:      Location to store handle to STRM manager object on
  *                      output.
- *      hDev:           Device for this processor.
+ *      dev_obj:           Device for this processor.
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
  *      DSP_EFAIL:      General failure.
  *  Requires:
- *      STRM_Init(void) called.
+ *      strm_init(void) called.
  *      phStrmMgr != NULL.
- *      hDev != NULL.
+ *      dev_obj != NULL.
  *  Ensures:
  *      DSP_SOK:        Valid *phStrmMgr.
  *      error:          *phStrmMgr == NULL.
  */
-	extern DSP_STATUS STRM_Create(OUT struct STRM_MGR **phStrmMgr,
-				      struct DEV_OBJECT *hDev);
+extern dsp_status strm_create(OUT struct strm_mgr **phStrmMgr,
+			      struct dev_object *dev_obj);
 
 /*
- *  ======== STRM_Delete ========
+ *  ======== strm_delete ========
  *  Purpose:
  *      Delete the STRM Object.
  *  Parameters:
- *      hStrmMgr:       Handle to STRM manager object from STRM_Create.
+ *      strm_mgr_obj:       Handle to STRM manager object from strm_create.
  *  Returns:
  *  Requires:
- *      STRM_Init(void) called.
- *      Valid hStrmMgr.
+ *      strm_init(void) called.
+ *      Valid strm_mgr_obj.
  *  Ensures:
- *      hStrmMgr is not valid.
+ *      strm_mgr_obj is not valid.
  */
-	extern void STRM_Delete(struct STRM_MGR *hStrmMgr);
+extern void strm_delete(struct strm_mgr *strm_mgr_obj);
 
 /*
- *  ======== STRM_Exit ========
+ *  ======== strm_exit ========
  *  Purpose:
  *      Discontinue usage of STRM module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      STRM_Init(void) successfully called before.
+ *      strm_init(void) successfully called before.
  *  Ensures:
  */
-	extern void STRM_Exit(void);
+extern void strm_exit(void);
 
 /*
- *  ======== STRM_FreeBuffer ========
+ *  ======== strm_free_buffer ========
  *  Purpose:
- *      Free buffer(s) allocated with STRM_AllocateBuffer.
+ *      Free buffer(s) allocated with strm_allocate_buffer.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      apBuffer:       Array containing buffer addresses.
- *      uNumBufs:       Number of buffers to be freed.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      ap_buffer:       Array containing buffer addresses.
+ *      num_bufs:       Number of buffers to be freed.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid stream handle.
  *      DSP_EFAIL:      Failure occurred, unable to free buffers.
  *  Requires:
- *      STRM_Init(void) called.
- *      apBuffer != NULL.
+ *      strm_init(void) called.
+ *      ap_buffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm,
-					  u8 **apBuffer, u32 uNumBufs,
-					  struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status strm_free_buffer(struct strm_object *hStrm,
+				   u8 **ap_buffer, u32 num_bufs,
+				   struct process_context *pr_ctxt);
 
 /*
- *  ======== STRM_GetEventHandle ========
+ *  ======== strm_get_event_handle ========
  *  Purpose:
  *      Get stream's user event handle. This function is used when closing
  *      a stream, so the event can be closed.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      phEvent:        Location to store event handle on output.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      ph_event:        Location to store event handle on output.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *  Requires:
- *      STRM_Init(void) called.
- *      phEvent != NULL.
+ *      strm_init(void) called.
+ *      ph_event != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_GetEventHandle(struct STRM_OBJECT *hStrm,
-					      OUT HANDLE *phEvent);
+extern dsp_status strm_get_event_handle(struct strm_object *hStrm,
+					OUT bhandle *ph_event);
 
 /*
- *  ======== STRM_GetInfo ========
+ *  ======== strm_get_info ========
  *  Purpose:
- *      Get information about a stream. User's DSP_STREAMINFO is contained
- *      in STRM_INFO struct. STRM_INFO also contains Bridge private info.
+ *      Get information about a stream. User's dsp_streaminfo is contained
+ *      in stream_info struct. stream_info also contains Bridge private info.
  *  Parameters:
- *      hStrm:              Stream handle returned from STRM_Open().
- *      pStreamInfo:        Location to store stream info on output.
- *      uSteamInfoSize:     Size of user's DSP_STREAMINFO structure.
+ *      hStrm:              Stream handle returned from strm_open().
+ *      stream_info:        Location to store stream info on output.
+ *      uSteamInfoSize:     Size of user's dsp_streaminfo structure.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EHANDLE:        Invalid hStrm.
- *      DSP_ESIZE:          uStreamInfoSize < sizeof(DSP_STREAMINFO).
+ *      DSP_ESIZE:          stream_info_size < sizeof(dsp_streaminfo).
  *      DSP_EFAIL:          Unable to get stream info.
  *  Requires:
- *      STRM_Init(void) called.
- *      pStreamInfo != NULL.
+ *      strm_init(void) called.
+ *      stream_info != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
-				       OUT struct STRM_INFO *pStreamInfo,
-				       u32 uStreamInfoSize);
+extern dsp_status strm_get_info(struct strm_object *hStrm,
+				OUT struct stream_info *stream_info,
+				u32 stream_info_size);
 
 /*
- *  ======== STRM_Idle ========
+ *  ======== strm_idle ========
  *  Purpose:
  *      Idle a stream and optionally flush output data buffers.
  *      If this is an output stream and fFlush is TRUE, all data currently
@@ -192,10 +192,10 @@
  *      If this is an output stream and fFlush is FALSE, this function
  *      will block until all currently buffered data is output, or the timeout
  *      specified has been reached.
- *      After a successful call to STRM_Idle(), all buffers can immediately
+ *      After a successful call to strm_idle(), all buffers can immediately
  *      be reclaimed.
  *  Parameters:
- *      hStrm:          Stream handle returned from STRM_Open().
+ *      hStrm:          Stream handle returned from strm_open().
  *      fFlush:         If TRUE, discard output buffers.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -204,13 +204,13 @@
  *      DSP_ERESTART:   A critical error occurred, DSP is being restarted.
  *      DSP_EFAIL:      Unable to idle stream.
  *  Requires:
- *      STRM_Init(void) called.
+ *      strm_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Idle(struct STRM_OBJECT *hStrm, bool fFlush);
+extern dsp_status strm_idle(struct strm_object *hStrm, bool fFlush);
 
 /*
- *  ======== STRM_Init ========
+ *  ======== strm_init ========
  *  Purpose:
  *      Initialize the STRM module.
  *  Parameters:
@@ -219,97 +219,95 @@
  *  Requires:
  *  Ensures:
  */
-	extern bool STRM_Init(void);
+extern bool strm_init(void);
 
 /*
- *  ======== STRM_Issue ========
+ *  ======== strm_issue ========
  *  Purpose:
  *      Send a buffer of data to a stream.
  *  Parameters:
- *      hStrm:              Stream handle returned from STRM_Open().
- *      pBuf:               Pointer to buffer of data to be sent to the stream.
- *      ulBytes:            Number of bytes of data in the buffer.
- *      ulBufSize:          Actual buffer size in bytes.
- *      dwArg:              A user argument that travels with the buffer.
+ *      hStrm:              Stream handle returned from strm_open().
+ *      pbuf:               Pointer to buffer of data to be sent to the stream.
+ *      ul_bytes:            Number of bytes of data in the buffer.
+ *      ul_buf_size:          Actual buffer size in bytes.
+ *      dw_arg:              A user argument that travels with the buffer.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EHANDLE:        Invalid hStrm.
  *      DSP_ESTREAMFULL:    The stream is full.
  *      DSP_EFAIL:          Failure occurred, unable to issue buffer.
  *  Requires:
- *      STRM_Init(void) called.
- *      pBuf != NULL.
+ *      strm_init(void) called.
+ *      pbuf != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Issue(struct STRM_OBJECT *hStrm, IN u8 *pBuf,
-				     u32 ulBytes, u32 ulBufSize,
-				     IN u32 dwArg);
+extern dsp_status strm_issue(struct strm_object *hStrm, IN u8 * pbuf,
+			     u32 ul_bytes, u32 ul_buf_size, IN u32 dw_arg);
 
 /*
- *  ======== STRM_Open ========
+ *  ======== strm_open ========
  *  Purpose:
  *      Open a stream for sending/receiving data buffers to/from a task of
  *      DAIS socket node on the DSP.
  *  Parameters:
- *      hNode:          Node handle returned from NODE_Allocate().
- *      uDir:           DSP_TONODE or DSP_FROMNODE.
- *      uIndex:         Stream index.
- *      pAttr:          Pointer to structure containing attributes to be
+ *      hnode:          Node handle returned from node_allocate().
+ *      dir:           DSP_TONODE or DSP_FROMNODE.
+ *      index:         Stream index.
+ *      pattr:          Pointer to structure containing attributes to be
  *                      applied to stream. Cannot be NULL.
  *      phStrm:         Location to store stream handle on output.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *      DSP_EDIRECTION: Invalid uDir.
- *      DSP_EVALUE:     Invalid uIndex.
- *      DSP_ENODETYPE:  hNode is not a task or DAIS socket node.
+ *      DSP_EHANDLE:    Invalid hnode.
+ *      DSP_EDIRECTION: Invalid dir.
+ *      DSP_EVALUE:     Invalid index.
+ *      DSP_ENODETYPE:  hnode is not a task or DAIS socket node.
  *      DSP_EFAIL:      Unable to open stream.
  *  Requires:
- *      STRM_Init(void) called.
+ *      strm_init(void) called.
  *      phStrm != NULL.
- *      pAttr != NULL.
+ *      pattr != NULL.
  *  Ensures:
  *      DSP_SOK:        *phStrm is valid.
  *      error:          *phStrm == NULL.
  */
-	extern DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir,
-				    u32 uIndex, IN struct STRM_ATTR *pAttr,
-				    OUT struct STRM_OBJECT **phStrm,
-				    struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status strm_open(struct node_object *hnode, u32 dir,
+			    u32 index, IN struct strm_attr *pattr,
+			    OUT struct strm_object **phStrm,
+			    struct process_context *pr_ctxt);
 
 /*
- *  ======== STRM_PrepareBuffer ========
+ *  ======== strm_prepare_buffer ========
  *  Purpose:
  *      Prepare a data buffer not allocated by DSPStream_AllocateBuffers()
  *      for use with a stream.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer.
- *      pBuffer:        Buffer address.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      usize:          Size (GPP bytes) of the buffer.
+ *      pbuffer:        Buffer address.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EFAIL:      Failure occurred, unable to prepare buffer.
  *  Requires:
- *      STRM_Init(void) called.
- *      pBuffer != NULL.
+ *      strm_init(void) called.
+ *      pbuffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_PrepareBuffer(struct STRM_OBJECT *hStrm,
-					     u32 uSize,
-					     u8 *pBuffer);
+extern dsp_status strm_prepare_buffer(struct strm_object *hStrm,
+				      u32 usize, u8 *pbuffer);
 
 /*
- *  ======== STRM_Reclaim ========
+ *  ======== strm_reclaim ========
  *  Purpose:
  *      Request a buffer back from a stream.
  *  Parameters:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      pBufPtr:        Location to store pointer to reclaimed buffer.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      buf_ptr:        Location to store pointer to reclaimed buffer.
  *      pulBytes:       Location where number of bytes of data in the
  *                      buffer will be written.
  *      pulBufSize:     Location where actual buffer size will be written.
- *      pdwArg:         Location where user argument that travels with
+ *      pdw_arg:         Location where user argument that travels with
  *                      the buffer will be written.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -318,51 +316,51 @@
  *                      retrieved.
  *      DSP_EFAIL:      Failure occurred, unable to reclaim buffer.
  *  Requires:
- *      STRM_Init(void) called.
- *      pBufPtr != NULL.
+ *      strm_init(void) called.
+ *      buf_ptr != NULL.
  *      pulBytes != NULL.
- *      pdwArg != NULL.
+ *      pdw_arg != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Reclaim(struct STRM_OBJECT *hStrm,
-				       OUT u8 **pBufPtr, u32 *pulBytes,
-				       u32 *pulBufSize, u32 *pdwArg);
+extern dsp_status strm_reclaim(struct strm_object *hStrm,
+			       OUT u8 **buf_ptr, u32 * pulBytes,
+			       u32 *pulBufSize, u32 *pdw_arg);
 
 /*
- *  ======== STRM_RegisterNotify ========
+ *  ======== strm_register_notify ========
  *  Purpose:
  *      Register to be notified on specific events for this stream.
  *  Parameters:
- *      hStrm:          Stream handle returned by STRM_Open().
- *      uEventMask:     Mask of types of events to be notified about.
- *      uNotifyType:    Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
+ *      hStrm:          Stream handle returned by strm_open().
+ *      event_mask:     Mask of types of events to be notified about.
+ *      notify_type:    Type of notification to be sent.
+ *      hnotification:  Handle to be used for notification.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EMEMORY:    Insufficient memory on GPP.
- *      DSP_EVALUE:     uEventMask is invalid.
- *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
+ *      DSP_EVALUE:     event_mask is invalid.
+ *      DSP_ENOTIMPL:   Notification type specified by notify_type is not
  *                      supported.
  *  Requires:
- *      STRM_Init(void) called.
- *      hNotification != NULL.
+ *      strm_init(void) called.
+ *      hnotification != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_RegisterNotify(struct STRM_OBJECT *hStrm,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
+extern dsp_status strm_register_notify(struct strm_object *hStrm,
+				       u32 event_mask, u32 notify_type,
+				       struct dsp_notification
+				       *hnotification);
 
 /*
- *  ======== STRM_Select ========
+ *  ======== strm_select ========
  *  Purpose:
  *      Select a ready stream.
  *  Parameters:
- *      aStrmTab:       Array of stream handles returned from STRM_Open().
+ *      strm_tab:       Array of stream handles returned from strm_open().
  *      nStrms:         Number of stream handles in array.
- *      pMask:          Location to store mask of ready streams on output.
- *      uTimeout:       Timeout value (milliseconds).
+ *      pmask:          Location to store mask of ready streams on output.
+ *      utimeout:       Timeout value (milliseconds).
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ERANGE:     nStrms out of range.
@@ -371,39 +369,37 @@
  *      DSP_ETIMEOUT:   A timeout occurred before a stream became ready.
  *      DSP_EFAIL:      Failure occurred, unable to select a stream.
  *  Requires:
- *      STRM_Init(void) called.
- *      aStrmTab != NULL.
+ *      strm_init(void) called.
+ *      strm_tab != NULL.
  *      nStrms > 0.
- *      pMask != NULL.
+ *      pmask != NULL.
  *  Ensures:
- *      DSP_SOK:        *pMask != 0 || uTimeout == 0.
- *      Error:          *pMask == 0.
+ *      DSP_SOK:        *pmask != 0 || utimeout == 0.
+ *      Error:          *pmask == 0.
  */
-	extern DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab,
-				      u32 nStrms,
-				      OUT u32 *pMask, u32 uTimeout);
+extern dsp_status strm_select(IN struct strm_object **strm_tab,
+			      u32 nStrms, OUT u32 *pmask, u32 utimeout);
 
 /*
- *  ======== STRM_UnprepareBuffer ========
+ *  ======== strm_unprepare_buffer ========
  *  Purpose:
  *      Unprepare a data buffer that was previously prepared for a stream
  *      with DSPStream_PrepareBuffer(), and that will no longer be used with
  *      the stream.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer.
- *      pBuffer:        Buffer address.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      usize:          Size (GPP bytes) of the buffer.
+ *      pbuffer:        Buffer address.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EFAIL:      Failure occurred, unable to unprepare buffer.
  *  Requires:
- *      STRM_Init(void) called.
- *      pBuffer != NULL.
+ *      strm_init(void) called.
+ *      pbuffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_UnprepareBuffer(struct STRM_OBJECT *hStrm,
-					       u32 uSize,
-					       u8 *pBuffer);
+extern dsp_status strm_unprepare_buffer(struct strm_object *hStrm,
+					u32 usize, u8 *pbuffer);
 
-#endif				/* STRM_ */
+#endif /* STRM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/strmdefs.h b/arch/arm/plat-omap/include/dspbridge/strmdefs.h
index 6530de9..1742544 100644
--- a/arch/arm/plat-omap/include/dspbridge/strmdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/strmdefs.h
@@ -21,27 +21,26 @@
 
 #define STRM_MAXEVTNAMELEN      32
 
-	struct STRM_MGR;
+struct strm_mgr;
 
-	struct STRM_OBJECT;
+struct strm_object;
 
-	struct STRM_ATTR {
-		HANDLE hUserEvent;
-		char *pstrEventName;
-		void *pVirtBase;	/* Process virtual base address of
-					 * mapped SM */
-		u32 ulVirtSize;	/* Size of virtual space in bytes */
-		struct DSP_STREAMATTRIN *pStreamAttrIn;
-	} ;
+struct strm_attr {
+	bhandle user_event;
+	char *pstr_event_name;
+	void *virt_base;	/* Process virtual base address of
+				 * mapped SM */
+	u32 ul_virt_size;	/* Size of virtual space in bytes */
+	struct dsp_streamattrin *stream_attr_in;
+};
 
-	struct STRM_INFO {
-		enum DSP_STRMMODE lMode;	/* transport mode of
+struct stream_info {
+	enum dsp_strmmode strm_mode;	/* transport mode of
 					 * stream(DMA, ZEROCOPY..) */
-		u32 uSegment;	/* Segment strm allocs from. 0 is local mem */
-		void *pVirtBase;	/* "      " Stream'process virt base */
-		struct DSP_STREAMINFO *pUser;	/* User's stream information
+	u32 segment_id;		/* Segment strm allocs from. 0 is local mem */
+	void *virt_base;	/* "      " Stream'process virt base */
+	struct dsp_streaminfo *user_strm;	/* User's stream information
 						 * returned */
-	} ;
-
-#endif				/* STRMDEFS_ */
+};
 
+#endif /* STRMDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/sync.h b/arch/arm/plat-omap/include/dspbridge/sync.h
index a82389e..9f8786e 100644
--- a/arch/arm/plat-omap/include/dspbridge/sync.h
+++ b/arch/arm/plat-omap/include/dspbridge/sync.h
@@ -19,286 +19,92 @@
 #ifndef _SYNC_H
 #define _SYNC_H
 
-#define SIGNATURECS     0x53435953	/* "SYCS" (in reverse) */
-#define SIGNATUREDPCCS  0x53445953	/* "SYDS" (in reverse) */
+#include <dspbridge/errbase.h>
+#include <dspbridge/dbdefs.h>
+
 
 /* Special timeout value indicating an infinite wait: */
 #define SYNC_INFINITE  0xffffffff
 
-/* Maximum string length of a named event */
-#define SYNC_MAXNAMELENGTH 32
-
-/* Generic SYNC object: */
-	struct SYNC_OBJECT;
-
-/* Generic SYNC CS object: */
-struct SYNC_CSOBJECT {
-	u32 dwSignature;	/* used for object validation */
-	struct semaphore sem;
-} ;
-
-/* SYNC object attributes: */
-	struct SYNC_ATTRS {
-		HANDLE hUserEvent;    /* Platform's User Mode synch. object. */
-		HANDLE hKernelEvent;  /* Platform's Kernel Mode sync. object. */
-		u32 dwReserved1;	/* For future expansion.   */
-		u32 dwReserved2;	/* For future expansion.   */
-	} ;
-
-/*
- *  ======== SYNC_CloseEvent ========
- *  Purpose:
- *      Close this event handle, freeing resources allocated in SYNC_OpenEvent
- *      if necessary.
- *  Parameters:
- *      hEvent: Handle to a synchronization event, created/opened in
- *              SYNC_OpenEvent.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EFAIL:      Failed to close event handle.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *      SYNC initialized.
- *  Ensures:
- *      Any subsequent usage of hEvent would be invalid.
- */
-	extern DSP_STATUS SYNC_CloseEvent(IN struct SYNC_OBJECT *hEvent);
-
-/*
- *  ======== SYNC_DeleteCS ========
- *  Purpose:
- *      Delete a critical section.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_DeleteCS(IN struct SYNC_CSOBJECT *hCSObj);
-
-/*
- *  ======== SYNC_EnterCS ========
- *  Purpose:
- *      Enter the critical section.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_EnterCS(IN struct SYNC_CSOBJECT *hCSObj);
-
-/*
- *  ======== SYNC_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      SYNC initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
+/**
+ * struct sync_object - the basic sync_object structure
+ * @comp:	use to signal events
+ * @multi_comp:	use to signal multiple events.
+ *
  */
-	extern void SYNC_Exit(void);
-
-/*
- *  ======== SYNC_Init ========
- *  Purpose:
- *      Initializes private state of SYNC module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      SYNC initialized.
+struct sync_object{
+	struct completion comp;
+	struct completion *multi_comp;
+};
+
+/**
+ * sync_init_event() - set initial state for a sync_event element
+ * @event:	event to be initialized.
+ *
+ * Set the initial state for a sync_event element.
  */
-	extern bool SYNC_Init(void);
 
-/*
- *  ======== SYNC_InitializeCS ========
- *  Purpose:
- *      Initialize the critical section.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Out of memory.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_InitializeCS(OUT struct SYNC_CSOBJECT **phCSObj);
+static inline void sync_init_event(struct sync_object *event)
+{
+	init_completion(&event->comp);
+	event->multi_comp = NULL;
+}
 
-/*
- *  ======== SYNC_InitializeDPCCS ========
- *  Purpose:
- *      Initialize the critical section between process context and DPC.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Out of memory.
- *  Requires:
- *  Ensures:
+/**
+ * sync_reset_event() - reset a sync_event element
+ * @event:	event to be reset.
+ *
+ * This function reset to the initial state to @event.
  */
-	extern DSP_STATUS SYNC_InitializeDPCCS(OUT struct SYNC_CSOBJECT
-					       **phCSObj);
 
-/*
- *  ======== SYNC_LeaveCS ========
- *  Purpose:
- *      Leave the critical section.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_LeaveCS(IN struct SYNC_CSOBJECT *hCSObj);
+static inline void sync_reset_event(struct sync_object *event)
+{
+	INIT_COMPLETION(event->comp);
+	event->multi_comp = NULL;
+}
 
-/*
- *  ======== SYNC_OpenEvent ========
- *  Purpose:
- *      Create/open and initialize an event object for thread synchronization,
- *      which is initially in the non-signalled state.
- *  Parameters:
- *      phEvent:    Pointer to location to receive the event object handle.
- *      pAttrs:     Pointer to SYNC_ATTRS object containing initial SYNC
- *                  SYNC_OBJECT attributes.  If this pointer is NULL, then
- *                  SYNC_OpenEvent will create and manage an OS specific
- *                  syncronization object.
- *          pAttrs->hUserEvent:  Platform's User Mode synchronization object.
- *
- *      The behaviour of the SYNC methods depend on the value of
- *      the hUserEvent attr:
+/**
+ * sync_set_event() - set or signal and specified event
+ * @event:	Event to be set..
  *
- *      1. (hUserEvent == NULL):
- *          A user mode event is created.
- *      2. (hUserEvent != NULL):
- *          A user mode event is supplied by the caller of SYNC_OpenEvent().
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Unable to create user mode event.
- *      DSP_EMEMORY:    Insufficient memory.
- *      DSP_EINVALIDARG SYNC_ATTRS values are invalid.
- *  Requires:
- *      - SYNC initialized.
- *      - phEvent != NULL.
- *  Ensures:
- *      If function succeeded, pEvent->hEvent must be a valid event handle.
+ * set the @event, if there is an thread waiting for the event
+ * it will be waken up, this function only wakes one thread.
  */
-	extern DSP_STATUS SYNC_OpenEvent(OUT struct SYNC_OBJECT **phEvent,
-					 IN OPTIONAL struct SYNC_ATTRS
-					 *pAttrs);
 
-/*
- * ========= SYNC_PostMessage ========
- *  Purpose:
- *      To post a windows message
- *  Parameters:
- *      hWindow:    Handle to the window
- *      uMsg:       Message to be posted
- *  Returns:
- *      DSP_SOK:        Success
- *      DSP_EFAIL:      Post message failed
- *      DSP_EHANDLE:    Invalid Window handle
- *  Requires:
- *      SYNC initialized
- *  Ensures
- */
-	extern DSP_STATUS SYNC_PostMessage(IN HANDLE hWindow, IN u32 uMsg);
+void sync_set_event(struct sync_object *event);
 
-/*
- *  ======== SYNC_ResetEvent ========
- *  Purpose:
- *      Reset a syncronization event object state to non-signalled.
- *  Parameters:
- *      hEvent:         Handle to a sync event.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EFAIL:      Failed to reset event.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *      SYNC initialized.
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_ResetEvent(IN struct SYNC_OBJECT *hEvent);
-
-/*
- *  ======== SYNC_SetEvent ========
- *  Purpose:
- *      Signal the event.  Will unblock one waiting thread.
- *  Parameters:
- *      hEvent:         Handle to an event object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Failed to signal event.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *      SYNC initialized.
- *  Ensures:
+/**
+ * sync_wait_on_event() - waits for a event to be set.
+ * @event:	events to wait for it.
+ * @timeout	timeout on waiting for the evetn.
+ *
+ * This functios will wait until @event is set or until timeout. In case of
+ * success the function will return DSP_SOK and
+ * in case of timeout the function will return DSP_ETIMEOUT
  */
-	extern DSP_STATUS SYNC_SetEvent(IN struct SYNC_OBJECT *hEvent);
 
-/*
- *  ======== SYNC_WaitOnEvent ========
- *  Purpose:
- *      Wait for an event to be signalled, up to the specified timeout.
- *  Parameters:
- *      hEvent:         Handle to an event object.
- *      dwTimeOut:      The time-out interval, in milliseconds.
- *                      The function returns if the interval elapses, even if
- *                      the object's state is nonsignaled.
- *                      If zero, the function tests the object's state and
- *                      returns immediately.
- *                      If SYNC_INFINITE, the function's time-out interval
- *                      never elapses.
- *  Returns:
- *      DSP_SOK:        The object was signalled.
- *      DSP_EHANDLE:    Invalid handle.
- *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
- *      SYNC_E_TIMEOUT: Timeout expired while waiting for event to be signalled.
- *  Requires:
- *  Ensures:
+static inline dsp_status sync_wait_on_event(struct sync_object *event,
+							unsigned timeout)
+{
+	return wait_for_completion_timeout(&event->comp,
+		msecs_to_jiffies(timeout)) ? DSP_SOK : DSP_ETIMEOUT;
+}
+
+/**
+ * sync_wait_on_multiple_events() - waits for multiple events to be set.
+ * @events:	Array of events to wait for them.
+ * @count:	number of elements of the array.
+ * @timeout	timeout on waiting for the evetns.
+ * @pu_index	index of the event set.
+ *
+ * This functios will wait until any of the array element is set or until
+ * timeout. In case of success the function will return DSP_SOK and
+ * @pu_index will store the index of the array element set and in case
+ * of timeout the function will return DSP_ETIMEOUT.
  */
-	extern DSP_STATUS SYNC_WaitOnEvent(IN struct SYNC_OBJECT *hEvent,
-					   IN u32 dwTimeOut);
 
-/*
- *  ======== SYNC_WaitOnMultipleEvents ========
- *  Purpose:
- *      Wait for any of an array of events to be signalled, up to the
- *      specified timeout.
- *      Note: dwTimeOut must be SYNC_INFINITE to signal infinite wait.
- *  Parameters:
- *      hSyncEvents:    Array of handles to event objects.
- *      uCount:         Number of event handles.
- *      dwTimeOut:      The time-out interval, in milliseconds.
- *                      The function returns if the interval elapses, even if
- *                      no event is signalled.
- *                      If zero, the function tests the object's state and
- *                      returns immediately.
- *                      If SYNC_INFINITE, the function's time-out interval
- *                      never elapses.
- *      puIndex:        Location to store index of event that was signalled.
- *  Returns:
- *      DSP_SOK:        The object was signalled.
- *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
- *      SYNC_E_TIMEOUT: Timeout expired before event was signalled.
- *      DSP_EMEMORY:    Memory allocation failed.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_WaitOnMultipleEvents(IN struct SYNC_OBJECT
-						    **hSyncEvents,
-						    IN u32 uCount,
-						    IN u32 dwTimeout,
-						    OUT u32 *puIndex);
+dsp_status sync_wait_on_multiple_events(struct sync_object **events,
+				     unsigned count, unsigned timeout,
+				     unsigned *index);
 
-#endif				/* _SYNC_H */
+#endif /* _SYNC_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/utildefs.h b/arch/arm/plat-omap/include/dspbridge/utildefs.h
index 68c9a54..5c67b04 100644
--- a/arch/arm/plat-omap/include/dspbridge/utildefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/utildefs.h
@@ -29,11 +29,11 @@
 #define UTIL_MAXARGVS       10
 
 /* Platform specific important info */
-	struct UTIL_SYSINFO {
-		/* Granularity of page protection; usually 1k or 4k */
-		u32 dwPageSize;
-		u32 dwAllocationGranularity; /* VM granularity, usually 64K */
-		u32 dwNumberOfProcessors;	/* Used as sanity check */
-	} ;
+struct util_sysinfo {
+	/* Granularity of page protection; usually 1k or 4k */
+	u32 dw_page_size;
+	u32 dw_allocation_granularity;	/* VM granularity, usually 64K */
+	u32 dw_number_of_processors;	/* Used as sanity check */
+};
 
-#endif				/* UTILDEFS_ */
+#endif /* UTILDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/uuidutil.h b/arch/arm/plat-omap/include/dspbridge/uuidutil.h
index 2f5ad0e..d7d0962 100644
--- a/arch/arm/plat-omap/include/dspbridge/uuidutil.h
+++ b/arch/arm/plat-omap/include/dspbridge/uuidutil.h
@@ -22,41 +22,41 @@
 #define MAXUUIDLEN  37
 
 /*
- *  ======== UUID_UuidToString ========
+ *  ======== uuid_uuid_to_string ========
  *  Purpose:
- *      Converts a DSP_UUID to an ANSI string.
+ *      Converts a dsp_uuid to an ANSI string.
  *  Parameters:
- *      pUuid:      Pointer to a DSP_UUID object.
+ *      uuid_obj:      Pointer to a dsp_uuid object.
  *      pszUuid:    Pointer to a buffer to receive a NULL-terminated UUID
  *                  string.
  *      size:	    Maximum size of the pszUuid string.
  *  Returns:
  *  Requires:
- *      pUuid & pszUuid are non-NULL values.
+ *      uuid_obj & pszUuid are non-NULL values.
  *  Ensures:
  *      Lenghth of pszUuid is less than MAXUUIDLEN.
  *  Details:
  *      UUID string limit currently set at MAXUUIDLEN.
  */
-	void UUID_UuidToString(IN struct DSP_UUID *pUuid, OUT char *pszUuid,
-			       s32 size);
+void uuid_uuid_to_string(IN struct dsp_uuid *uuid_obj, OUT char *pszUuid,
+			 s32 size);
 
 /*
- *  ======== UUID_UuidFromString ========
+ *  ======== uuid_uuid_from_string ========
  *  Purpose:
- *      Converts an ANSI string to a DSP_UUID.
+ *      Converts an ANSI string to a dsp_uuid.
  *  Parameters:
- *      pszUuid:    Pointer to a string that represents a DSP_UUID object.
- *      pUuid:      Pointer to a DSP_UUID object.
+ *      pszUuid:    Pointer to a string that represents a dsp_uuid object.
+ *      uuid_obj:      Pointer to a dsp_uuid object.
  *  Returns:
  *  Requires:
- *      pUuid & pszUuid are non-NULL values.
+ *      uuid_obj & pszUuid are non-NULL values.
  *  Ensures:
  *  Details:
  *      We assume the string representation of a UUID has the following format:
  *      "12345678_1234_1234_1234_123456789abc".
  */
-	extern void UUID_UuidFromString(IN char *pszUuid,
-					OUT struct DSP_UUID *pUuid);
+extern void uuid_uuid_from_string(IN char *pszUuid,
+				  OUT struct dsp_uuid *uuid_obj);
 
-#endif				/* UUIDUTIL_ */
+#endif /* UUIDUTIL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wcd.h b/arch/arm/plat-omap/include/dspbridge/wcd.h
index 35be14e..f609627 100644
--- a/arch/arm/plat-omap/include/dspbridge/wcd.h
+++ b/arch/arm/plat-omap/include/dspbridge/wcd.h
@@ -29,8 +29,8 @@
 #ifndef WCD_
 #define WCD_
 
-/* This WCD Library Version:  */
+/* This WCD Library Version: */
 #define WCD_MAJOR_VERSION   (u32)8	/* .8x - Alpha, .9x - Beta, 1.x FCS */
 #define WCD_MINOR_VERSION   (u32)0
 
-#endif				/* WCD_ */
+#endif /* WCD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wcdioctl.h b/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
index 5817009..b6a4dda 100644
--- a/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
+++ b/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
@@ -29,364 +29,363 @@ union Trapped_Args {
 
 	/* MGR Module */
 	struct {
-		u32 uNode;
-		struct DSP_NDBPROPS __user *pNDBProps;
-		u32 uNDBPropsSize;
-		u32 __user *puNumNodes;
-	} ARGS_MGR_ENUMNODE_INFO;
+		u32 node_id;
+		struct dsp_ndbprops __user *pndb_props;
+		u32 undb_props_size;
+		u32 __user *pu_num_nodes;
+	} args_mgr_enumnode_info;
 
 	struct {
-		u32 uProcessor;
-		struct DSP_PROCESSORINFO __user *pProcessorInfo;
-		u32 uProcessorInfoSize;
-		u32 __user *puNumProcs;
-	} ARGS_MGR_ENUMPROC_INFO;
+		u32 processor_id;
+		struct dsp_processorinfo __user *processor_info;
+		u32 processor_info_size;
+		u32 __user *pu_num_procs;
+	} args_mgr_enumproc_info;
 
 	struct {
-		struct DSP_UUID *pUuid;
-		enum DSP_DCDOBJTYPE objType;
-		char *pszPathName;
-	} ARGS_MGR_REGISTEROBJECT;
+		struct dsp_uuid *uuid_obj;
+		enum dsp_dcdobjtype obj_type;
+		char *psz_path_name;
+	} args_mgr_registerobject;
 
 	struct {
-		struct DSP_UUID *pUuid;
-		enum DSP_DCDOBJTYPE objType;
-	} ARGS_MGR_UNREGISTEROBJECT;
+		struct dsp_uuid *uuid_obj;
+		enum dsp_dcdobjtype obj_type;
+	} args_mgr_unregisterobject;
 
 	struct {
-		struct DSP_NOTIFICATION  __user *__user *aNotifications;
-		u32 uCount;
-		u32 __user *puIndex;
-		u32 uTimeout;
-	} ARGS_MGR_WAIT;
+		struct dsp_notification __user *__user *anotifications;
+		u32 count;
+		u32 __user *pu_index;
+		u32 utimeout;
+	} args_mgr_wait;
 
 	/* PROC Module */
 	struct {
-		u32 uProcessor;
-		struct DSP_PROCESSORATTRIN __user *pAttrIn;
-		void *__user *phProcessor;
-	} ARGS_PROC_ATTACH;
+		u32 processor_id;
+		struct dsp_processorattrin __user *attr_in;
+		void *__user *ph_processor;
+	} args_proc_attach;
 
 	struct {
-		void *hProcessor;
-		u32 dwCmd;
-		struct DSP_CBDATA __user *pArgs;
-	} ARGS_PROC_CTRL;
+		void *hprocessor;
+		u32 dw_cmd;
+		struct dsp_cbdata __user *pargs;
+	} args_proc_ctrl;
 
 	struct {
-		void *hProcessor;
-	} ARGS_PROC_DETACH;
+		void *hprocessor;
+	} args_proc_detach;
 
 	struct {
-		void *hProcessor;
-		void *__user *aNodeTab;
-		u32 uNodeTabSize;
-		u32 __user *puNumNodes;
-		u32 __user *puAllocated;
-	} ARGS_PROC_ENUMNODE_INFO;
+		void *hprocessor;
+		void *__user *node_tab;
+		u32 node_tab_size;
+		u32 __user *pu_num_nodes;
+		u32 __user *pu_allocated;
+	} args_proc_enumnode_info;
 
 	struct {
-		void *hProcessor;
-		u32 uResourceType;
-		struct DSP_RESOURCEINFO *pResourceInfo;
-		u32 uResourceInfoSize;
-	} ARGS_PROC_ENUMRESOURCES;
+		void *hprocessor;
+		u32 resource_type;
+		struct dsp_resourceinfo *resource_info;
+		u32 resource_info_size;
+	} args_proc_enumresources;
 
 	struct {
-		void *hProcessor;
-		struct DSP_PROCESSORSTATE __user *pProcStatus;
-		u32 uStateInfoSize;
-	} ARGS_PROC_GETSTATE;
+		void *hprocessor;
+		struct dsp_processorstate __user *proc_state_obj;
+		u32 state_info_size;
+	} args_proc_getstate;
 
 	struct {
-		void *hProcessor;
-		u8 __user *pBuf;
-		u8 __user *pSize;
-		u32 uMaxSize;
-	} ARGS_PROC_GETTRACE;
+		void *hprocessor;
+		u8 __user *pbuf;
+		u8 __user *psize;
+		u32 max_size;
+	} args_proc_gettrace;
 
 	struct {
-		void *hProcessor;
-		s32 iArgc;
-		char __user *__user *aArgv;
-		char *__user *aEnvp;
-	} ARGS_PROC_LOAD;
+		void *hprocessor;
+		s32 argc_index;
+		char __user *__user *user_args;
+		char *__user *user_envp;
+	} args_proc_load;
 
 	struct {
-		void *hProcessor;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_PROC_REGISTER_NOTIFY;
+		void *hprocessor;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_proc_register_notify;
 
 	struct {
-		void *hProcessor;
-	} ARGS_PROC_START;
+		void *hprocessor;
+	} args_proc_start;
 
 	struct {
-		void *hProcessor;
-		u32 ulSize;
-		void *__user *ppRsvAddr;
-	} ARGS_PROC_RSVMEM;
+		void *hprocessor;
+		u32 ul_size;
+		void *__user *pp_rsv_addr;
+	} args_proc_rsvmem;
 
 	struct {
-		void *hProcessor;
-		u32 ulSize;
-		void *pRsvAddr;
-	} ARGS_PROC_UNRSVMEM;
+		void *hprocessor;
+		u32 ul_size;
+		void *prsv_addr;
+	} args_proc_unrsvmem;
 
 	struct {
-		void *hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-		void *pReqAddr;
-		void *__user *ppMapAddr;
-		u32 ulMapAttr;
-	} ARGS_PROC_MAPMEM;
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+		void *req_addr;
+		void *__user *pp_map_addr;
+		u32 ul_map_attr;
+	} args_proc_mapmem;
 
 	struct {
-		void *hProcessor;
-		u32 ulSize;
-		void *pMapAddr;
-	} ARGS_PROC_UNMAPMEM;
+		void *hprocessor;
+		u32 ul_size;
+		void *map_addr;
+	} args_proc_unmapmem;
 
 	struct {
-		void *hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-		u32 ulFlags;
-	} ARGS_PROC_FLUSHMEMORY;
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+		u32 ul_flags;
+	} args_proc_flushmemory;
 
 	struct {
-		void *hProcessor;
-	} ARGS_PROC_STOP;
+		void *hprocessor;
+	} args_proc_stop;
 
 	struct {
-		void *hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-	} ARGS_PROC_INVALIDATEMEMORY;
-
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+	} args_proc_invalidatememory;
 
 	/* NODE Module */
 	struct {
-		void *hProcessor;
-		struct DSP_UUID __user *pNodeID;
-		struct DSP_CBDATA __user *pArgs;
-		struct DSP_NODEATTRIN __user *pAttrIn;
-		void *__user *phNode;
-	} ARGS_NODE_ALLOCATE;
+		void *hprocessor;
+		struct dsp_uuid __user *node_id_ptr;
+		struct dsp_cbdata __user *pargs;
+		struct dsp_nodeattrin __user *attr_in;
+		void *__user *ph_node;
+	} args_node_allocate;
 
 	struct {
-		void *hNode;
-		u32 uSize;
-		struct DSP_BUFFERATTR __user *pAttr;
-		u8 *__user *pBuffer;
-	} ARGS_NODE_ALLOCMSGBUF;
+		void *hnode;
+		u32 usize;
+		struct dsp_bufferattr __user *pattr;
+		u8 *__user *pbuffer;
+	} args_node_allocmsgbuf;
 
 	struct {
-		void *hNode;
-		s32 iPriority;
-	} ARGS_NODE_CHANGEPRIORITY;
+		void *hnode;
+		s32 prio;
+	} args_node_changepriority;
 
 	struct {
-		void *hNode;
-		u32 uStream;
-		void *hOtherNode;
-		u32 uOtherStream;
-		struct DSP_STRMATTR __user *pAttrs;
-		struct DSP_CBDATA __user *pConnParam;
-	} ARGS_NODE_CONNECT;
+		void *hnode;
+		u32 stream_id;
+		void *other_node;
+		u32 other_stream;
+		struct dsp_strmattr __user *pattrs;
+		struct dsp_cbdata __user *conn_param;
+	} args_node_connect;
 
 	struct {
-		void *hNode;
-	} ARGS_NODE_CREATE;
+		void *hnode;
+	} args_node_create;
 
 	struct {
-		void *hNode;
-	} ARGS_NODE_DELETE;
+		void *hnode;
+	} args_node_delete;
 
 	struct {
-		void *hNode;
-		struct DSP_BUFFERATTR __user *pAttr;
-		u8 *pBuffer;
-	} ARGS_NODE_FREEMSGBUF;
+		void *hnode;
+		struct dsp_bufferattr __user *pattr;
+		u8 *pbuffer;
+	} args_node_freemsgbuf;
 
 	struct {
-		void *hNode;
-		struct DSP_NODEATTR __user *pAttr;
-		u32 uAttrSize;
-	} ARGS_NODE_GETATTR;
+		void *hnode;
+		struct dsp_nodeattr __user *pattr;
+		u32 attr_size;
+	} args_node_getattr;
 
 	struct {
-		void *hNode;
-		struct DSP_MSG __user *pMessage;
-		u32 uTimeout;
-	} ARGS_NODE_GETMESSAGE;
+		void *hnode;
+		struct dsp_msg __user *message;
+		u32 utimeout;
+	} args_node_getmessage;
 
 	struct {
-		void *hNode;
-	} ARGS_NODE_PAUSE;
+		void *hnode;
+	} args_node_pause;
 
 	struct {
-		void *hNode;
-		struct DSP_MSG __user *pMessage;
-		u32 uTimeout;
-	} ARGS_NODE_PUTMESSAGE;
+		void *hnode;
+		struct dsp_msg __user *message;
+		u32 utimeout;
+	} args_node_putmessage;
 
 	struct {
-		void *hNode;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_NODE_REGISTERNOTIFY;
+		void *hnode;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_node_registernotify;
 
 	struct {
-		void *hNode;
-	} ARGS_NODE_RUN;
+		void *hnode;
+	} args_node_run;
 
 	struct {
-		void *hNode;
-		DSP_STATUS __user *pStatus;
-	} ARGS_NODE_TERMINATE;
+		void *hnode;
+		dsp_status __user *pstatus;
+	} args_node_terminate;
 
 	struct {
-		void *hProcessor;
-		struct DSP_UUID __user *pNodeID;
-		struct DSP_NDBPROPS __user *pNodeProps;
-	} ARGS_NODE_GETUUIDPROPS;
+		void *hprocessor;
+		struct dsp_uuid __user *node_id_ptr;
+		struct dsp_ndbprops __user *node_props;
+	} args_node_getuuidprops;
 
 	/* STRM module */
 
 	struct {
-		void *hStream;
-		u32 uSize;
-		u8 *__user *apBuffer;
-		u32 uNumBufs;
-	} ARGS_STRM_ALLOCATEBUFFER;
+		void *hstream;
+		u32 usize;
+		u8 *__user *ap_buffer;
+		u32 num_bufs;
+	} args_strm_allocatebuffer;
 
 	struct {
-		void *hStream;
-	} ARGS_STRM_CLOSE;
+		void *hstream;
+	} args_strm_close;
 
 	struct {
-		void *hStream;
-		u8 *__user *apBuffer;
-		u32 uNumBufs;
-	} ARGS_STRM_FREEBUFFER;
+		void *hstream;
+		u8 *__user *ap_buffer;
+		u32 num_bufs;
+	} args_strm_freebuffer;
 
 	struct {
-		void *hStream;
-		HANDLE *phEvent;
-	} ARGS_STRM_GETEVENTHANDLE;
+		void *hstream;
+		bhandle *ph_event;
+	} args_strm_geteventhandle;
 
 	struct {
-		void *hStream;
-		struct STRM_INFO __user *pStreamInfo;
-		u32 uStreamInfoSize;
-	} ARGS_STRM_GETINFO;
+		void *hstream;
+		struct stream_info __user *stream_info;
+		u32 stream_info_size;
+	} args_strm_getinfo;
 
 	struct {
-		void *hStream;
-		bool bFlush;
-	} ARGS_STRM_IDLE;
+		void *hstream;
+		bool flush_flag;
+	} args_strm_idle;
 
 	struct {
-		void *hStream;
-		u8 *pBuffer;
-		u32 dwBytes;
-		u32 dwBufSize;
-		u32 dwArg;
-	} ARGS_STRM_ISSUE;
+		void *hstream;
+		u8 *pbuffer;
+		u32 dw_bytes;
+		u32 dw_buf_size;
+		u32 dw_arg;
+	} args_strm_issue;
 
 	struct {
-		void *hNode;
-		u32 uDirection;
-		u32 uIndex;
-		struct STRM_ATTR __user *pAttrIn;
-		void *__user *phStream;
-	} ARGS_STRM_OPEN;
+		void *hnode;
+		u32 direction;
+		u32 index;
+		struct strm_attr __user *attr_in;
+		void *__user *ph_stream;
+	} args_strm_open;
 
 	struct {
-		void *hStream;
-		u8 *__user *pBufPtr;
-		u32 __user *pBytes;
-		u32 __user *pBufSize;
-		u32 __user *pdwArg;
-	} ARGS_STRM_RECLAIM;
+		void *hstream;
+		u8 *__user *buf_ptr;
+		u32 __user *bytes;
+		u32 __user *buf_size_ptr;
+		u32 __user *pdw_arg;
+	} args_strm_reclaim;
 
 	struct {
-		void *hStream;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_STRM_REGISTERNOTIFY;
+		void *hstream;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_strm_registernotify;
 
 	struct {
-		void *__user *aStreamTab;
-		u32 nStreams;
-		u32 __user *pMask;
-		u32 uTimeout;
-	} ARGS_STRM_SELECT;
+		void *__user *stream_tab;
+		u32 strm_num;
+		u32 __user *pmask;
+		u32 utimeout;
+	} args_strm_select;
 
 	/* CMM Module */
 	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		u32 uSize;
-		struct CMM_ATTRS *pAttrs;
-		OUT void **ppBufVA;
-	} ARGS_CMM_ALLOCBUF;
+		struct cmm_object *hcmm_mgr;
+		u32 usize;
+		struct cmm_attrs *pattrs;
+		OUT void **pp_buf_va;
+	} args_cmm_allocbuf;
 
 	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		void *pBufPA;
-		u32 ulSegId;
-	} ARGS_CMM_FREEBUF;
+		struct cmm_object *hcmm_mgr;
+		void *buf_pa;
+		u32 ul_seg_id;
+	} args_cmm_freebuf;
 
 	struct {
-		void *hProcessor;
-		struct CMM_OBJECT *__user *phCmmMgr;
-	} ARGS_CMM_GETHANDLE;
+		void *hprocessor;
+		struct cmm_object *__user *ph_cmm_mgr;
+	} args_cmm_gethandle;
 
 	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		struct CMM_INFO __user *pCmmInfo;
-	} ARGS_CMM_GETINFO;
+		struct cmm_object *hcmm_mgr;
+		struct cmm_info __user *cmm_info_obj;
+	} args_cmm_getinfo;
 
 	/* MEM Module */
 	struct {
-		u32 cBytes;
-		enum MEM_POOLATTRS type;
-		void *pMem;
-	} ARGS_MEM_ALLOC;
+		u32 byte_size;
+		enum mem_poolattrs type;
+		void *mem;
+	} args_mem_alloc;
 
 	struct {
-		u32 cBytes;
-		enum MEM_POOLATTRS type;
-		void *pMem;
-	} ARGS_MEM_CALLOC;
+		u32 byte_size;
+		enum mem_poolattrs type;
+		void *mem;
+	} args_mem_calloc;
 
 	struct {
-		void *pMem;
-	} ARGS_MEM_FREE;
+		void *mem;
+	} args_mem_free;
 
 	struct {
-		void *pBuffer;
-		u32 cSize;
-		void *pLockedBuffer;
-	} ARGS_MEM_PAGELOCK;
+		void *pbuffer;
+		u32 size;
+		void *locked_buffer;
+	} args_mem_pagelock;
 
 	struct {
-		void *pBuffer;
-		u32 cSize;
-	} ARGS_MEM_PAGEUNLOCK;
+		void *pbuffer;
+		u32 size;
+	} args_mem_pageunlock;
 
 	/* UTIL module */
 	struct {
-		s32 cArgc;
-		char **ppArgv;
-	} ARGS_UTIL_TESTDLL;
-} ;
+		s32 util_argc;
+		char **pp_argv;
+	} args_util_testdll;
+};
 
 /*
  * Dspbridge Ioctl numbering scheme
@@ -493,4 +492,4 @@ union Trapped_Args {
 #define CMM_GETHANDLE		_IOR(DB, DB_IOC(DB_CMM, 2), unsigned long)
 #define CMM_GETINFO		_IOR(DB, DB_IOC(DB_CMM, 3), unsigned long)
 
-#endif				/* WCDIOCTL_ */
+#endif /* WCDIOCTL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmd.h b/arch/arm/plat-omap/include/dspbridge/wmd.h
index 3305eab..f9883db 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmd.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmd.h
@@ -7,7 +7,7 @@
  *
  * Notes:
  *   The Bridge class driver obtains it's function interface to
- *   the Bridge mini driver via a call to WMD_DRV_Entry().
+ *   the Bridge mini driver via a call to bridge_drv_entry().
  *
  *   Bridge Class Driver services exported to WMD's are initialized by the
  *   WCD on behalf of the WMD.
@@ -43,15 +43,15 @@
  */
 #define WMD_RESERVEDIOCTLBASE   0x8000
 
-/* Handle to mini-driver's private device context.  */
-	struct WMD_DEV_CONTEXT;
+/* Handle to mini-driver's private device context. */
+struct wmd_dev_context;
 
-/*---------------------------------------------------------------------------*/
-/* 'Bridge MINI DRIVER FUNCTION TYPES                                        */
-/*---------------------------------------------------------------------------*/
+/*--------------------------------------------------------------------------- */
+/* 'Bridge MINI DRIVER FUNCTION TYPES */
+/*--------------------------------------------------------------------------- */
 
 /*
- *  ======== WMD_BRD_Monitor ========
+ *  ======== bridge_brd_monitor ========
  *  Purpose:
  *      Bring the board to the BRD_IDLE (monitor) state.
  *  Parameters:
@@ -67,12 +67,10 @@
  *      DSP_SOK:        Board is in BRD_IDLE state;
  *      else:           Board state is indeterminate.
  */
-       typedef DSP_STATUS(
-			   *WMD_BRD_MONITOR) (struct WMD_DEV_CONTEXT
-			   *hDevContext);
+typedef dsp_status(*fxn_brd_monitor) (struct wmd_dev_context *hDevContext);
 
 /*
- *  ======== WMD_BRD_SETSTATE ========
+ *  ======== fxn_brd_setstate ========
  *  Purpose:
  *      Sets the Mini driver state
  *  Parameters:
@@ -88,12 +86,11 @@
  *      ulBrdState  <= BRD_LASTSTATE.
  *  Update the Board state to the specified state.
  */
-       typedef DSP_STATUS(
-			   *WMD_BRD_SETSTATE) (struct WMD_DEV_CONTEXT
-			   *hDevContext, u32 ulBrdState);
+typedef dsp_status(*fxn_brd_setstate) (struct wmd_dev_context
+				       * hDevContext, u32 ulBrdState);
 
 /*
- *  ======== WMD_BRD_Start ========
+ *  ======== bridge_brd_start ========
  *  Purpose:
  *      Bring board to the BRD_RUNNING (start) state.
  *  Parameters:
@@ -111,44 +108,44 @@
  *                      Interrupts to the PC are enabled.
  *      else:           Board state is indeterminate.
  */
-       typedef DSP_STATUS(*WMD_BRD_START) (struct WMD_DEV_CONTEXT
-						*hDevContext, u32 dwDSPAddr);
+typedef dsp_status(*fxn_brd_start) (struct wmd_dev_context
+				    * hDevContext, u32 dwDSPAddr);
 
 /*
- *  ======== WMD_BRD_MemCopy ========
+ *  ======== bridge_brd_mem_copy ========
  *  Purpose:
  *  Copy memory from one DSP address to another
  *  Parameters:
- *      pDevContext:    Pointer to context handle
+ *      dev_context:    Pointer to context handle
  *  ulDspDestAddr:  DSP address to copy to
  *  ulDspSrcAddr:   DSP address to copy from
- *  ulNumBytes: Number of bytes to copy
+ *  ul_num_bytes: Number of bytes to copy
  *  ulMemType:  What section of memory to copy to
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Other, unspecified error.
  *  Requires:
- *      pDevContext != NULL
+ *      dev_context != NULL
  *  Ensures:
  *      DSP_SOK:        Board is in BRD_RUNNING state.
  *                      Interrupts to the PC are enabled.
  *      else:           Board state is indeterminate.
  */
-       typedef DSP_STATUS(*WMD_BRD_MEMCOPY) (struct WMD_DEV_CONTEXT
-					     *hDevContext,
-					     u32 ulDspDestAddr,
-					     u32 ulDspSrcAddr,
-					     u32 ulNumBytes, u32 ulMemType);
+typedef dsp_status(*fxn_brd_memcopy) (struct wmd_dev_context
+				      * hDevContext,
+				      u32 ulDspDestAddr,
+				      u32 ulDspSrcAddr,
+				      u32 ul_num_bytes, u32 ulMemType);
 /*
- *  ======== WMD_BRD_MemWrite ========
+ *  ======== bridge_brd_mem_write ========
  *  Purpose:
  *      Write a block of host memory into a DSP address, into a given memory
- *      space.  Unlike WMD_BRD_Write, this API does reset the DSP
+ *      space.  Unlike bridge_brd_write, this API does reset the DSP
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
  *      dwDSPAddr:      Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
+ *      ul_num_bytes:     Number of bytes to transfer.
  *      ulMemType:      Memory space on DSP to which to transfer.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -159,22 +156,22 @@
  *      pHostBuf != NULL.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_BRD_MEMWRITE) (struct WMD_DEV_CONTEXT
-					*hDevContext,
-					IN u8 *pHostBuf,
-					u32 dwDSPAddr, u32 ulNumBytes,
-					u32 ulMemType);
+typedef dsp_status(*fxn_brd_memwrite) (struct wmd_dev_context
+				       * hDevContext,
+				       IN u8 *pHostBuf,
+				       u32 dwDSPAddr, u32 ul_num_bytes,
+				       u32 ulMemType);
 
 /*
- *  ======== WMD_BRD_MemMap ========
+ *  ======== bridge_brd_mem_map ========
  *  Purpose:
  *      Map a MPU memory region to a DSP/IVA memory space
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
- *      ulMpuAddr:      MPU memory region start address.
+ *      ul_mpu_addr:      MPU memory region start address.
  *      ulVirtAddr:     DSP/IVA memory region u8 address.
- *      ulNumBytes:     Number of bytes to map.
- *      mapAttrs:       Mapping attributes (e.g. endianness).
+ *      ul_num_bytes:     Number of bytes to map.
+ *      map_attrs:       Mapping attributes (e.g. endianness).
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Other, unspecified error.
@@ -182,19 +179,19 @@
  *      hDevContext != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_BRD_MEMMAP) (struct WMD_DEV_CONTEXT
-					*hDevContext, u32 ulMpuAddr,
-					u32 ulVirtAddr, u32 ulNumBytes,
-					u32 ulMapAttrs);
+typedef dsp_status(*fxn_brd_memmap) (struct wmd_dev_context
+				     * hDevContext, u32 ul_mpu_addr,
+				     u32 ulVirtAddr, u32 ul_num_bytes,
+				     u32 ulMapAttrs);
 
 /*
- *  ======== WMD_BRD_MemUnMap ========
+ *  ======== bridge_brd_mem_un_map ========
  *  Purpose:
  *      UnMap an MPU memory region from DSP/IVA memory space
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
  *      ulVirtAddr:     DSP/IVA memory region u8 address.
- *      ulNumBytes:     Number of bytes to unmap.
+ *      ul_num_bytes:     Number of bytes to unmap.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Other, unspecified error.
@@ -202,13 +199,12 @@
  *      hDevContext != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_BRD_MEMUNMAP) (struct WMD_DEV_CONTEXT
-					*hDevContext,
-					u32 ulVirtAddr,
-					u32 ulNumBytes);
+typedef dsp_status(*fxn_brd_memunmap) (struct wmd_dev_context
+				       * hDevContext,
+				       u32 ulVirtAddr, u32 ul_num_bytes);
 
 /*
- *  ======== WMD_BRD_Stop ========
+ *  ======== bridge_brd_stop ========
  *  Purpose:
  *      Bring board to the BRD_STOPPED state.
  *  Parameters:
@@ -224,11 +220,10 @@
  *                      Interrupts to the PC are disabled.
  *      else:           Board state is indeterminate.
  */
-       typedef DSP_STATUS(*WMD_BRD_STOP) (struct WMD_DEV_CONTEXT
-					*hDevContext);
+typedef dsp_status(*fxn_brd_stop) (struct wmd_dev_context *hDevContext);
 
 /*
- *  ======== WMD_BRD_Status ========
+ *  ======== bridge_brd_status ========
  *  Purpose:
  *      Report the current state of the board.
  *  Parameters:
@@ -242,12 +237,11 @@
  *  Ensures:
  *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
  */
-       typedef DSP_STATUS(*
-			   WMD_BRD_STATUS) (struct WMD_DEV_CONTEXT *hDevContext,
-					    int *pdwState);
+typedef dsp_status(*fxn_brd_status) (struct wmd_dev_context *hDevContext,
+				     int *pdwState);
 
 /*
- *  ======== WMD_BRD_Read ========
+ *  ======== bridge_brd_read ========
  *  Purpose:
  *      Read a block of DSP memory, from a given memory space, into a host
  *      buffer.
@@ -255,7 +249,7 @@
  *      hDevContext:    Handle to mini-driver defined device info.
  *      pHostBuf:       Pointer to host buffer (Destination).
  *      dwDSPAddr:      Address on DSP board (Source).
- *      ulNumBytes:     Number of bytes to transfer.
+ *      ul_num_bytes:     Number of bytes to transfer.
  *      ulMemType:      Memory space on DSP from which to transfer.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -265,16 +259,15 @@
  *      hDevContext != NULL;
  *      pHostBuf != NULL.
  *  Ensures:
- *  Will not write more than ulNumBytes bytes into pHostBuf.
+ *  Will not write more than ul_num_bytes bytes into pHostBuf.
  */
-typedef DSP_STATUS(*WMD_BRD_READ) (struct WMD_DEV_CONTEXT *hDevContext,
-						  OUT u8 *pHostBuf,
-						  u32 dwDSPAddr,
-						  u32 ulNumBytes,
-						  u32 ulMemType);
+typedef dsp_status(*fxn_brd_read) (struct wmd_dev_context *hDevContext,
+				   OUT u8 *pHostBuf,
+				   u32 dwDSPAddr,
+				   u32 ul_num_bytes, u32 ulMemType);
 
 /*
- *  ======== WMD_BRD_Write ========
+ *  ======== bridge_brd_write ========
  *  Purpose:
  *      Write a block of host memory into a DSP address, into a given memory
  *      space.
@@ -282,7 +275,7 @@ typedef DSP_STATUS(*WMD_BRD_READ) (struct WMD_DEV_CONTEXT *hDevContext,
  *      hDevContext:    Handle to mini-driver defined device info.
  *      dwDSPAddr:      Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
+ *      ul_num_bytes:     Number of bytes to transfer.
  *      ulMemType:      Memory space on DSP to which to transfer.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -293,27 +286,26 @@ typedef DSP_STATUS(*WMD_BRD_READ) (struct WMD_DEV_CONTEXT *hDevContext,
  *      pHostBuf != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
-						   IN u8 *pHostBuf,
-						   u32 dwDSPAddr,
-						   u32 ulNumBytes,
-						   u32 ulMemType);
+typedef dsp_status(*fxn_brd_write) (struct wmd_dev_context *hDevContext,
+				    IN u8 *pHostBuf,
+				    u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType);
 
 /*
- *  ======== WMD_CHNL_Create ========
+ *  ======== bridge_chnl_create ========
  *  Purpose:
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given 'Bridge board.
  *  Parameters:
  *      phChnlMgr:      Location to store a channel manager object on output.
- *      hDevObject:     Handle to a device object.
+ *      hdev_obj:     Handle to a device object.
  *      pMgrAttrs:      Channel manager attributes.
- *      pMgrAttrs->cChannels: Max channels
- *      pMgrAttrs->bIRQ:      Channel's I/O IRQ number.
- *      pMgrAttrs->fShared:   TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize: DSP Word size in equivalent PC bytes..
- *      pMgrAttrs->dwSMBase:  Base physical address of shared memory, if any.
- *      pMgrAttrs->uSMLength: Bytes of shared memory block.
+ *      pMgrAttrs->max_channels: Max channels
+ *      pMgrAttrs->birq:      Channel's I/O IRQ number.
+ *      pMgrAttrs->irq_shared:   TRUE if the IRQ is shareable.
+ *      pMgrAttrs->word_size: DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->shm_base:  Base physical address of shared memory, if any.
+ *      pMgrAttrs->usm_length: Bytes of shared memory block.
  *  Returns:
  *      DSP_SOK:            Success;
  *      DSP_EMEMORY:        Insufficient memory for requested resources.
@@ -323,82 +315,81 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *      phChnlMgr != NULL.
  *      pMgrAttrs != NULL
  *      pMgrAttrs field are all valid:
- *          0 < cChannels <= CHNL_MAXCHANNELS.
- *          bIRQ <= 15.
- *          uWordSize > 0.
- *      IsValidHandle(hDevObject)
+ *          0 < max_channels <= CHNL_MAXCHANNELS.
+ *          birq <= 15.
+ *          word_size > 0.
+ *      IS_VALID_HANDLE(hdev_obj)
  *      No channel manager exists for this board.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_CHNL_CREATE)(OUT struct CHNL_MGR
-						    **phChnlMgr,
-						    struct DEV_OBJECT
-						    *hDevObject,
-						    IN CONST struct
-						    CHNL_MGRATTRS *pMgrAttrs);
+typedef dsp_status(*fxn_chnl_create) (OUT struct chnl_mgr
+				      **phChnlMgr,
+				      struct dev_object
+				      * hdev_obj,
+				      IN CONST struct
+				      chnl_mgrattrs * pMgrAttrs);
 
 /*
- *  ======== WMD_CHNL_Destroy ========
+ *  ======== bridge_chnl_destroy ========
  *  Purpose:
  *      Close all open channels, and destroy the channel manager.
  *  Parameters:
- *      hChnlMgr:       Channel manager object.
+ *      hchnl_mgr:       Channel manager object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hChnlMgr was invalid.
+ *      DSP_EHANDLE:    hchnl_mgr was invalid.
  *  Requires:
  *  Ensures:
  *      DSP_SOK: Cancels I/O on each open channel. Closes each open channel.
- *          CHNL_Create may subsequently be called for the same device.
+ *          chnl_create may subsequently be called for the same device.
  */
-       typedef DSP_STATUS(*WMD_CHNL_DESTROY) (struct CHNL_MGR
-						      *hChnlMgr);
+typedef dsp_status(*fxn_chnl_destroy) (struct chnl_mgr *hchnl_mgr);
 /*
- *  ======== WMD_DEH_Notify ========
+ *  ======== bridge_deh_notify ========
  *  Purpose:
  *      When notified of DSP error, take appropriate action.
  *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
+ *      hdeh_mgr:        Handle to DEH manager object.
  *      ulEventMask:  Indicate the type of exception
  *      dwErrInfo:     Error information
  *  Returns:
  *
  *  Requires:
- *      hDehMgr != NULL;
+ *      hdeh_mgr != NULL;
  *     ulEventMask with a valid exception
  *  Ensures:
  */
-       typedef void (*WMD_DEH_NOTIFY)(struct DEH_MGR *hDehMgr,
-					u32 ulEventMask, u32 dwErrInfo);
-
+typedef void (*fxn_deh_notify) (struct deh_mgr *hdeh_mgr,
+				u32 ulEventMask, u32 dwErrInfo);
 
 /*
- *  ======== WMD_CHNL_Open ========
+ *  ======== bridge_chnl_open ========
  *  Purpose:
  *      Open a new half-duplex channel to the DSP board.
  *  Parameters:
  *      phChnl:         Location to store a channel object handle.
- *      hChnlMgr:       Handle to channel manager, as returned by CHNL_GetMgr().
- *      uMode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
+ *      hchnl_mgr:	Handle to channel manager, as returned by
+ *      		CHNL_GetMgr().
+ *      chnl_mode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
  *                      direction of data transfer.
  *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
  *                      select a free channel id (default);
  *                      otherwise this field specifies the id of the channel.
- *      pAttrs:         Channel attributes.  Attribute fields are as follows:
- *      pAttrs->uIOReqs: Specifies the maximum number of I/O requests which can
+ *      pattrs:         Channel attributes.  Attribute fields are as follows:
+ *      pattrs->uio_reqs: Specifies the maximum number of I/O requests which can
  *                      be pending at any given time. All request packets are
  *                      preallocated when the channel is opened.
- *      pAttrs->hEvent: This field allows the user to supply an auto reset
+ *      pattrs->event_obj: This field allows the user to supply an auto reset
  *                      event object for channel I/O completion notifications.
  *                      It is the responsibility of the user to destroy this
  *                      object AFTER closing the channel.
  *                      This channel event object can be retrieved using
  *                      CHNL_GetEventHandle().
- *      pAttrs->hReserved: The kernel mode handle of this event object.
+ *      pattrs->hReserved: The kernel mode handle of this event object.
  *
  *  Returns:
  *      DSP_SOK:                Success.
- *      DSP_EHANDLE:            hChnlMgr is invalid.
+ *      DSP_EHANDLE:            hchnl_mgr is invalid.
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
  *      DSP_EINVALIDARG:        Invalid number of IOReqs.
  *      CHNL_E_OUTOFSTREAMS:    No free channels available.
@@ -408,58 +399,58 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *                              queuing.
  *  Requires:
  *      phChnl != NULL.
- *      pAttrs != NULL.
- *      pAttrs->hEvent is a valid event handle.
- *      pAttrs->hReserved is the kernel mode handle for pAttrs->hEvent.
+ *      pattrs != NULL.
+ *      pattrs->event_obj is a valid event handle.
+ *      pattrs->hReserved is the kernel mode handle for pattrs->event_obj.
  *  Ensures:
  *      DSP_SOK:                *phChnl is a valid channel.
  *      else:                   *phChnl is set to NULL if (phChnl != NULL);
  */
-       typedef DSP_STATUS(*WMD_CHNL_OPEN) (OUT struct CHNL_OBJECT
-						   **phChnl,
-						   struct CHNL_MGR *hChnlMgr,
-						   short int uMode,
-						   u32 uChnlId,
-						   CONST IN OPTIONAL struct
-						   CHNL_ATTRS *pAttrs);
+typedef dsp_status(*fxn_chnl_open) (OUT struct chnl_object
+				    **phChnl,
+				    struct chnl_mgr *hchnl_mgr,
+				    short int chnl_mode,
+				    u32 uChnlId,
+				    CONST IN OPTIONAL struct
+				    chnl_attr * pattrs);
 
 /*
- *  ======== WMD_CHNL_Close ========
+ *  ======== bridge_chnl_close ========
  *  Purpose:
  *      Ensures all pending I/O on this channel is cancelled, discards all
  *      queued I/O completion notifications, then frees the resources allocated
  *      for this channel, and makes the corresponding logical channel id
  *      available for subsequent use.
  *  Parameters:
- *      hChnl:          Handle to a channel object.
+ *      chnl_obj:          Handle to a channel object.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *  Requires:
  *      No thread must be blocked on this channel's I/O completion event.
  *  Ensures:
- *      DSP_SOK:        hChnl is no longer valid.
+ *      DSP_SOK:        chnl_obj is no longer valid.
  */
-       typedef DSP_STATUS(*WMD_CHNL_CLOSE) (struct CHNL_OBJECT *hChnl);
+typedef dsp_status(*fxn_chnl_close) (struct chnl_object *chnl_obj);
 
 /*
- *  ======== WMD_CHNL_AddIOReq ========
+ *  ======== bridge_chnl_add_io_req ========
  *  Purpose:
  *      Enqueue an I/O request for data transfer on a channel to the DSP.
  *      The direction (mode) is specified in the channel object. Note the DSP
  *      address is specified for channels opened in direct I/O mode.
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *      pHostBuf:       Host buffer address source.
- *      cBytes:         Number of PC bytes to transfer. A zero value indicates
+ *      byte_size:	Number of PC bytes to transfer. A zero value indicates
  *                      that this buffer is the last in the output channel.
  *                      A zero value is invalid for an input channel.
- *!     cBufSize:       Actual buffer size in host bytes.
- *      dwDspAddr:      DSP address for transfer.  (Currently ignored).
- *      dwArg:          A user argument that travels with the buffer.
+ *!     buf_size:       Actual buffer size in host bytes.
+ *      dw_dsp_addr:      DSP address for transfer.  (Currently ignored).
+ *      dw_arg:          A user argument that travels with the buffer.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *      DSP_EPOINTER:   pHostBuf is invalid.
  *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
  *      CHNL_E_CANCELLED: I/O has been cancelled on this channel.  No further
@@ -474,26 +465,25 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *          otherwise, will be queued for transfer when the channel becomes
  *          ready.  In any case, notifications of I/O completion are
  *          asynchronous.
- *          If cBytes is 0 for an output channel, subsequent CHNL_AddIOReq's
+ *          If byte_size is 0 for an output channel, subsequent CHNL_AddIOReq's
  *          on this channel will fail with error code CHNL_E_EOS.  The
  *          corresponding IOC for this I/O request will have its status flag
  *          set to CHNL_IOCSTATEOS.
  */
-       typedef DSP_STATUS(*WMD_CHNL_ADDIOREQ) (struct CHNL_OBJECT
-						       *hChnl,
-						       void *pHostBuf,
-						       u32 cBytes,
-						       u32 cBufSize,
-						       OPTIONAL u32 dwDspAddr,
-						       u32 dwArg);
+typedef dsp_status(*fxn_chnl_addioreq) (struct chnl_object
+					* chnl_obj,
+					void *pHostBuf,
+					u32 byte_size,
+					u32 buf_size,
+					OPTIONAL u32 dw_dsp_addr, u32 dw_arg);
 
 /*
- *  ======== WMD_CHNL_GetIOC ========
+ *  ======== bridge_chnl_get_ioc ========
  *  Purpose:
  *      Dequeue an I/O completion record, which contains information about the
  *      completed I/O request.
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *      dwTimeOut:      A value of CHNL_IOCNOWAIT will simply dequeue the
  *                      first available IOC.
  *      pIOC:           On output, contains host buffer address, bytes
@@ -501,7 +491,7 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *      pIOC->status:   See chnldefs.h.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *      DSP_EPOINTER:   pIOC is invalid.
  *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
  *                      yet no I/O completions were queued.
@@ -512,97 +502,94 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *          returns, the channel event object will be left in a signalled
  *          state.
  */
-       typedef DSP_STATUS(*WMD_CHNL_GETIOC) (struct CHNL_OBJECT *hChnl,
-						     u32 dwTimeOut,
-						     OUT struct CHNL_IOC *pIOC);
+typedef dsp_status(*fxn_chnl_getioc) (struct chnl_object *chnl_obj,
+				      u32 dwTimeOut,
+				      OUT struct chnl_ioc *pIOC);
 
 /*
- *  ======== WMD_CHNL_CancelIO ========
+ *  ======== bridge_chnl_cancel_io ========
  *  Purpose:
  *      Return all I/O requests to the client which have not yet been
  *      transferred.  The channel's I/O completion object is
  *      signalled, and all the I/O requests are queued as IOC's, with the
  *      status field set to CHNL_IOCSTATCANCEL.
  *      This call is typically used in abort situations, and is a prelude to
- *      CHNL_Close();
+ *      chnl_close();
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *  Requires:
  *  Ensures:
  *      Subsequent I/O requests to this channel will not be accepted.
  */
-       typedef DSP_STATUS(*WMD_CHNL_CANCELIO) (struct CHNL_OBJECT
-						       *hChnl);
+typedef dsp_status(*fxn_chnl_cancelio) (struct chnl_object *chnl_obj);
 
 /*
- *  ======== WMD_CHNL_FlushIO ========
+ *  ======== bridge_chnl_flush_io ========
  *  Purpose:
  *      For an output stream (to the DSP), indicates if any IO requests are in
  *      the output request queue.  For input streams (from the DSP), will
  *      cancel all pending IO requests.
  *  Parameters:
- *      hChnl:              Channel object handle.
+ *      chnl_obj:              Channel object handle.
  *      dwTimeOut:          Timeout value for flush operation.
  *  Returns:
  *      DSP_SOK:            Success;
  *      S_CHNLIOREQUEST:    Returned if any IORequests are in the output queue.
- *      DSP_EHANDLE:        Invalid hChnl.
+ *      DSP_EHANDLE:        Invalid chnl_obj.
  *  Requires:
  *  Ensures:
  *      DSP_SOK:            No I/O requests will be pending on this channel.
  */
-       typedef DSP_STATUS(*WMD_CHNL_FLUSHIO) (struct CHNL_OBJECT *hChnl,
-						      u32 dwTimeOut);
+typedef dsp_status(*fxn_chnl_flushio) (struct chnl_object *chnl_obj,
+				       u32 dwTimeOut);
 
 /*
- *  ======== WMD_CHNL_GetInfo ========
+ *  ======== bridge_chnl_get_info ========
  *  Purpose:
  *      Retrieve information related to a channel.
  *  Parameters:
- *      hChnl:          Handle to a valid channel object, or NULL.
+ *      chnl_obj:          Handle to a valid channel object, or NULL.
  *      pInfo:          Location to store channel info.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *      DSP_EPOINTER:   pInfo == NULL.
  *  Requires:
  *  Ensures:
- *      DSP_SOK:        pInfo points to a filled in CHNL_INFO struct,
+ *      DSP_SOK:        pInfo points to a filled in chnl_info struct,
  *                      if (pInfo != NULL).
  */
-       typedef DSP_STATUS(*WMD_CHNL_GETINFO) (struct CHNL_OBJECT *hChnl,
-						      OUT struct CHNL_INFO
-						      *pChnlInfo);
+typedef dsp_status(*fxn_chnl_getinfo) (struct chnl_object *chnl_obj,
+				       OUT struct chnl_info *pChnlInfo);
 
 /*
- *  ======== WMD_CHNL_GetMgrInfo ========
+ *  ======== bridge_chnl_get_mgr_info ========
  *  Purpose:
  *      Retrieve information related to the channel manager.
  *  Parameters:
- *      hChnlMgr:           Handle to a valid channel manager, or NULL.
+ *      hchnl_mgr:           Handle to a valid channel manager, or NULL.
  *      uChnlID:            Channel ID.
  *      pMgrInfo:           Location to store channel manager info.
  *  Returns:
  *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnlMgr.
+ *      DSP_EHANDLE:        Invalid hchnl_mgr.
  *      DSP_EPOINTER:       pMgrInfo == NULL.
  *      CHNL_E_BADCHANID:   Invalid channel ID.
  *  Requires:
  *  Ensures:
- *      DSP_SOK:            pMgrInfo points to a filled in CHNL_MGRINFO
+ *      DSP_SOK:            pMgrInfo points to a filled in chnl_mgrinfo
  *                          struct, if (pMgrInfo != NULL).
  */
-       typedef DSP_STATUS(*WMD_CHNL_GETMGRINFO) (struct CHNL_MGR
-							 *hChnlMgr,
-							 u32 uChnlID,
-							 OUT struct CHNL_MGRINFO
-							 *pMgrInfo);
+typedef dsp_status(*fxn_chnl_getmgrinfo) (struct chnl_mgr
+					  * hchnl_mgr,
+					  u32 uChnlID,
+					  OUT struct chnl_mgrinfo *pMgrInfo);
 
 /*
- *  ======== WMD_CHNL_Idle ========
+ *  ======== bridge_chnl_idle ========
  *  Purpose:
  *      Idle a channel. If this is an input channel, or if this is an output
  *      channel and fFlush is TRUE, all currently enqueued buffers will be
@@ -612,7 +599,7 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *      specified has been reached.
  *
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *      dwTimeOut:      If output channel and fFlush is FALSE, timeout value
  *                      to wait for buffers to be output. (Not used for
  *                      input channel).
@@ -622,53 +609,50 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *                      occurs first. fFlush is ignored for input channel.
  *  Returns:
  *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
+ *      DSP_EHANDLE:        Invalid chnl_obj.
  *      CHNL_E_WAITTIMEOUT: Timeout occured before channel could be idled.
  *  Requires:
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_CHNL_IDLE) (struct CHNL_OBJECT *hChnl,
-						   u32 dwTimeOut,
-						   bool fFlush);
+typedef dsp_status(*fxn_chnl_idle) (struct chnl_object *chnl_obj,
+				    u32 dwTimeOut, bool fFlush);
 
 /*
- *  ======== WMD_CHNL_RegisterNotify ========
+ *  ======== bridge_chnl_register_notify ========
  *  Purpose:
  *      Register for notification of events on a channel.
  *  Parameters:
- *      hChnl:          Channel object handle.
- *      uEventMask:     Type of events to be notified about: IO completion
+ *      chnl_obj:          Channel object handle.
+ *      event_mask:     Type of events to be notified about: IO completion
  *                      (DSP_STREAMIOCOMPLETION) or end of stream
  *                      (DSP_STREAMDONE).
- *      uNotifyType:    DSP_SIGNALEVENT.
- *      hNotification:  Handle of a DSP_NOTIFICATION object.
+ *      notify_type:    DSP_SIGNALEVENT.
+ *      hnotification:  Handle of a dsp_notification object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Insufficient memory.
- *      DSP_EVALUE:     uEventMask is 0 and hNotification was not
+ *      DSP_EVALUE:     event_mask is 0 and hnotification was not
  *                      previously registered.
- *      DSP_EHANDLE:    NULL hNotification, hNotification event name
- *                      too long, or hNotification event name NULL.
+ *      DSP_EHANDLE:    NULL hnotification, hnotification event name
+ *                      too long, or hnotification event name NULL.
  *  Requires:
- *      Valid hChnl.
- *      hNotification != NULL.
- *      (uEventMask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
- *      uNotifyType == DSP_SIGNALEVENT.
+ *      Valid chnl_obj.
+ *      hnotification != NULL.
+ *      (event_mask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
+ *      notify_type == DSP_SIGNALEVENT.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_CHNL_REGISTERNOTIFY)
-				(struct CHNL_OBJECT *hChnl,
-				u32 uEventMask,
-				u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
+typedef dsp_status(*fxn_chnl_registernotify)
+ (struct chnl_object *chnl_obj,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
 
 /*
- *  ======== WMD_DEV_Create ========
+ *  ======== bridge_dev_create ========
  *  Purpose:
  *      Complete creation of the device object for this board.
  *  Parameters:
  *      phDevContext:   Ptr to location to store a WMD device context.
- *      hDevObject:     Handle to a Device Object, created and managed by WCD.
+ *      hdev_obj:     Handle to a Device Object, created and managed by WCD.
  *      pConfig:        Ptr to configuration parameters provided by the Windows
  *                      Configuration Manager during device loading.
  *      pDspConfig:     DSP resources, as specified in the registry key for this
@@ -681,7 +665,7 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *                          made by this WMD.
  *  Requires:
  *      phDevContext != NULL;
- *      hDevObject != NULL;
+ *      hdev_obj != NULL;
  *      pConfig != NULL;
  *      pDspConfig != NULL;
  *      Fields in pConfig and pDspConfig contain valid values.
@@ -690,7 +674,8 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *                      board context has been allocated.
  *      DSP_EMEMORY:    WMD failed to allocate resources.
  *                      Any acquired resources have been freed.  The WCD will
- *                      not call WMD_DEV_Destroy() if WMD_DEV_Create() fails.
+ *                      not call bridge_dev_destroy() if bridge_dev_create()
+ *                      fails.
  *  Details:
  *      Called during the CONFIGMG's Device_Init phase. Based on host and
  *      DSP configuration information, create a board context, a handle to
@@ -700,42 +685,40 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
  *      function returns, they must not be stored into the device context
  *      structure.
  */
-       typedef DSP_STATUS(*WMD_DEV_CREATE) (OUT struct WMD_DEV_CONTEXT
-						    **phDevContext,
-						    struct DEV_OBJECT
-						    *hDevObject,
-						    IN CONST struct CFG_HOSTRES
-						    *pConfig,
-						    IN CONST struct CFG_DSPRES
-						    *pDspConfig);
+typedef dsp_status(*fxn_dev_create) (OUT struct wmd_dev_context
+				     **phDevContext,
+				     struct dev_object
+				     * hdev_obj,
+				     IN CONST struct cfg_hostres
+				     * pConfig,
+				     IN CONST struct cfg_dspres *pDspConfig);
 
 /*
- *  ======== WMD_DEV_Ctrl ========
+ *  ======== bridge_dev_ctrl ========
  *  Purpose:
  *      Mini-driver specific interface.
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
- *      dwCmd:          WMD defined command code.
- *      pArgs:          Pointer to an arbitrary argument structure.
+ *      dw_cmd:          WMD defined command code.
+ *      pargs:          Pointer to an arbitrary argument structure.
  *  Returns:
  *      DSP_SOK or DSP_EFAIL. Actual command error codes should be passed back
- *      in the pArgs structure, and are defined by the WMD implementor.
+ *      in the pargs structure, and are defined by the WMD implementor.
  *  Requires:
  *      All calls are currently assumed to be synchronous.  There are no
  *      IOCTL completion routines provided.
  *  Ensures:
  */
-typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
-					u32 dwCmd,
-					IN OUT void *pArgs);
+typedef dsp_status(*fxn_dev_ctrl) (struct wmd_dev_context *hDevContext,
+				   u32 dw_cmd, IN OUT void *pargs);
 
 /*
- *  ======== WMD_DEV_Destroy ========
+ *  ======== bridge_dev_destroy ========
  *  Purpose:
  *      Deallocate WMD device extension structures and all other resources
  *      acquired by the mini-driver.
  *      No calls to other mini driver functions may subsequently
- *      occur, except for WMD_DEV_Create().
+ *      occur, except for bridge_dev_create().
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device information.
  *  Returns:
@@ -746,65 +729,61 @@ typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
  *  Ensures:
  *      DSP_SOK: Device context is freed.
  */
-       typedef DSP_STATUS(*WMD_DEV_DESTROY) (struct WMD_DEV_CONTEXT
-					     *hDevContext);
+typedef dsp_status(*fxn_dev_destroy) (struct wmd_dev_context *hDevContext);
 
 /*
- *  ======== WMD_DEH_Create ========
+ *  ======== bridge_deh_create ========
  *  Purpose:
  *      Create an object that manages DSP exceptions from the GPP.
  *  Parameters:
  *      phDehMgr:       Location to store DEH manager on output.
- *      hDevObject:     Handle to DEV object.
+ *      hdev_obj:     Handle to DEV object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
  *      DSP_EFAIL:      Creation failed.
  *  Requires:
- *      hDevObject != NULL;
+ *      hdev_obj != NULL;
  *      phDehMgr != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_DEH_CREATE) (OUT struct DEH_MGR
-						    **phDehMgr,
-						    struct DEV_OBJECT
-						    *hDevObject);
+typedef dsp_status(*fxn_deh_create) (OUT struct deh_mgr
+				     **phDehMgr, struct dev_object *hdev_obj);
 
 /*
- *  ======== WMD_DEH_Destroy ========
+ *  ======== bridge_deh_destroy ========
  *  Purpose:
  *      Destroy the DEH object.
  *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
+ *      hdeh_mgr:        Handle to DEH manager object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Destroy failed.
  *  Requires:
- *      hDehMgr != NULL;
+ *      hdeh_mgr != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_DEH_DESTROY) (struct DEH_MGR *hDehMgr);
+typedef dsp_status(*fxn_deh_destroy) (struct deh_mgr *hdeh_mgr);
 
 /*
- *  ======== WMD_DEH_RegisterNotify ========
+ *  ======== bridge_deh_register_notify ========
  *  Purpose:
  *      Register for DEH event notification.
  *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
+ *      hdeh_mgr:        Handle to DEH manager object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Destroy failed.
  *  Requires:
- *      hDehMgr != NULL;
+ *      hdeh_mgr != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_DEH_REGISTERNOTIFY)
-				(struct DEH_MGR *hDehMgr,
-				u32 uEventMask, u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
+typedef dsp_status(*fxn_deh_registernotify)
+ (struct deh_mgr *hdeh_mgr,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
 
 /*
- *  ======== WMD_DEH_GetInfo ========
+ *  ======== bridge_deh_get_info ========
  *  Purpose:
  *      Get DSP exception info.
  *  Parameters:
@@ -818,91 +797,92 @@ typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
  *      pErrorInfo != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_DEH_GETINFO) (struct DEH_MGR *phDehMgr,
-					struct DSP_ERRORINFO *pErrInfo);
+typedef dsp_status(*fxn_deh_getinfo) (struct deh_mgr *phDehMgr,
+				      struct dsp_errorinfo *pErrInfo);
 
 /*
- *  ======== WMD_IO_Create ========
+ *  ======== bridge_io_create ========
  *  Purpose:
- *      Create an object that manages I/O between CHNL and MSG.
+ *      Create an object that manages I/O between CHNL and msg_ctrl.
  *  Parameters:
  *      phIOMgr:        Location to store IO manager on output.
- *      hChnlMgr:       Handle to channel manager.
- *      hMsgMgr:        Handle to message manager.
+ *      hchnl_mgr:       Handle to channel manager.
+ *      hmsg_mgr:        Handle to message manager.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
  *      DSP_EFAIL:      Creation failed.
  *  Requires:
- *      hDevObject != NULL;
+ *      hdev_obj != NULL;
  *      Channel manager already created;
  *      Message manager already created;
  *      pMgrAttrs != NULL;
  *      phIOMgr != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_IO_CREATE) (OUT struct IO_MGR **phIOMgr,
-					struct DEV_OBJECT *hDevObject,
-					IN CONST struct IO_ATTRS *pMgrAttrs);
+typedef dsp_status(*fxn_io_create) (OUT struct io_mgr **phIOMgr,
+				    struct dev_object *hdev_obj,
+				    IN CONST struct io_attrs *pMgrAttrs);
 
 /*
- *  ======== WMD_IO_Destroy ========
+ *  ======== bridge_io_destroy ========
  *  Purpose:
- *      Destroy object created in WMD_IO_Create.
+ *      Destroy object created in bridge_io_create.
  *  Parameters:
- *      hIOMgr:         IO Manager.
+ *      hio_mgr:         IO Manager.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
  *      DSP_EFAIL:      Creation failed.
  *  Requires:
- *      Valid hIOMgr;
+ *      Valid hio_mgr;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_IO_DESTROY) (struct IO_MGR *hIOMgr);
+typedef dsp_status(*fxn_io_destroy) (struct io_mgr *hio_mgr);
 
 /*
- *  ======== WMD_IO_OnLoaded ========
+ *  ======== bridge_io_on_loaded ========
  *  Purpose:
  *      Called whenever a program is loaded to update internal data. For
  *      example, if shared memory is used, this function would update the
  *      shared memory location and address.
  *  Parameters:
- *      hIOMgr:     IO Manager.
+ *      hio_mgr:     IO Manager.
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  Internal failure occurred.
  *  Requires:
- *      Valid hIOMgr;
+ *      Valid hio_mgr;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_IO_ONLOADED) (struct IO_MGR *hIOMgr);
+typedef dsp_status(*fxn_io_onloaded) (struct io_mgr *hio_mgr);
 
 /*
- *  ======== WMD_IO_GETPROCLOAD ========
+ *  ======== fxn_io_getprocload ========
  *  Purpose:
  *      Called to get the Processor's current and predicted load
  *  Parameters:
- *      hIOMgr:     IO Manager.
+ *      hio_mgr:     IO Manager.
  *      pProcLoadStat   Processor Load statistics
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  Internal failure occurred.
  *  Requires:
- *      Valid hIOMgr;
+ *      Valid hio_mgr;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_IO_GETPROCLOAD)(struct IO_MGR *hIOMgr,
-			   struct DSP_PROCLOADSTAT *pProcLoadStat);
+typedef dsp_status(*fxn_io_getprocload) (struct io_mgr *hio_mgr,
+					 struct dsp_procloadstat *
+					 pProcLoadStat);
 
 /*
- *  ======== WMD_MSG_Create ========
+ *  ======== bridge_msg_create ========
  *  Purpose:
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  *  Parameters:
- *      phMsgMgr:           Location to store MSG manager on output.
- *      hDevObject:         Handle to a device object.
+ *      phMsgMgr:           Location to store msg_ctrl manager on output.
+ *      hdev_obj:         Handle to a device object.
  *      msgCallback:        Called whenever an RMS_EXIT message is received.
  *  Returns:
  *      DSP_SOK:            Success.
@@ -910,157 +890,152 @@ typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
  *  Requires:
  *      phMsgMgr != NULL.
  *      msgCallback != NULL.
- *      hDevObject != NULL.
+ *      hdev_obj != NULL.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_MSG_CREATE)
-				(OUT struct MSG_MGR **phMsgMgr,
-				struct DEV_OBJECT *hDevObject,
-				MSG_ONEXIT msgCallback);
+typedef dsp_status(*fxn_msg_create)
+ (OUT struct msg_mgr **phMsgMgr,
+  struct dev_object *hdev_obj, msg_onexit msgCallback);
 
 /*
- *  ======== WMD_MSG_CreateQueue ========
+ *  ======== bridge_msg_create_queue ========
  *  Purpose:
- *      Create a MSG queue for sending or receiving messages from a Message
+ *      Create a msg_ctrl queue for sending or receiving messages from a Message
  *      node on the DSP.
  *  Parameters:
- *      hMsgMgr:            MSG queue manager handle returned from
- *                          WMD_MSG_Create.
- *      phMsgQueue:         Location to store MSG queue on output.
- *      dwId:               Identifier for messages (node environment pointer).
- *      uMaxMsgs:           Max number of simultaneous messages for the node.
- *      h:                  Handle passed to hMsgMgr->msgCallback().
+ *      hmsg_mgr:            msg_ctrl queue manager handle returned from
+ *                          bridge_msg_create.
+ *      phMsgQueue:         Location to store msg_ctrl queue on output.
+ *      msgq_id:	    Identifier for messages (node environment pointer).
+ *      max_msgs:           Max number of simultaneous messages for the node.
+ *      h:                  Handle passed to hmsg_mgr->msgCallback().
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EMEMORY:        Insufficient memory.
  *  Requires:
  *      phMsgQueue != NULL.
  *      h != NULL.
- *      uMaxMsgs > 0.
+ *      max_msgs > 0.
  *  Ensures:
  *      phMsgQueue !=NULL <==> DSP_SOK.
  */
-       typedef DSP_STATUS(*WMD_MSG_CREATEQUEUE)
-				(struct MSG_MGR *hMsgMgr,
-				OUT struct MSG_QUEUE **phMsgQueue,
-				u32 dwId, u32 uMaxMsgs, HANDLE h);
+typedef dsp_status(*fxn_msg_createqueue)
+ (struct msg_mgr *hmsg_mgr,
+  OUT struct msg_queue **phMsgQueue, u32 msgq_id, u32 max_msgs, bhandle h);
 
 /*
- *  ======== WMD_MSG_Delete ========
+ *  ======== bridge_msg_delete ========
  *  Purpose:
- *      Delete a MSG manager allocated in WMD_MSG_Create().
+ *      Delete a msg_ctrl manager allocated in bridge_msg_create().
  *  Parameters:
- *      hMsgMgr:    Handle returned from WMD_MSG_Create().
+ *      hmsg_mgr:    Handle returned from bridge_msg_create().
  *  Returns:
  *  Requires:
- *      Valid hMsgMgr.
+ *      Valid hmsg_mgr.
  *  Ensures:
  */
-       typedef void(*WMD_MSG_DELETE) (struct MSG_MGR *hMsgMgr);
+typedef void (*fxn_msg_delete) (struct msg_mgr *hmsg_mgr);
 
 /*
- *  ======== WMD_MSG_DeleteQueue ========
+ *  ======== bridge_msg_delete_queue ========
  *  Purpose:
- *      Delete a MSG queue allocated in WMD_MSG_CreateQueue.
+ *      Delete a msg_ctrl queue allocated in bridge_msg_create_queue.
  *  Parameters:
- *      hMsgQueue:  Handle to MSG queue returned from
- *                  WMD_MSG_CreateQueue.
+ *      msg_queue_obj:  Handle to msg_ctrl queue returned from
+ *                  bridge_msg_create_queue.
  *  Returns:
  *  Requires:
- *      Valid hMsgQueue.
+ *      Valid msg_queue_obj.
  *  Ensures:
  */
-       typedef void(*WMD_MSG_DELETEQUEUE) (struct MSG_QUEUE *hMsgQueue);
+typedef void (*fxn_msg_deletequeue) (struct msg_queue *msg_queue_obj);
 
 /*
- *  ======== WMD_MSG_Get ========
+ *  ======== bridge_msg_get ========
  *  Purpose:
- *      Get a message from a MSG queue.
+ *      Get a message from a msg_ctrl queue.
  *  Parameters:
- *      hMsgQueue:     Handle to MSG queue returned from
- *                     WMD_MSG_CreateQueue.
- *      pMsg:          Location to copy message into.
- *      uTimeout:      Timeout to wait for a message.
+ *      msg_queue_obj:     Handle to msg_ctrl queue returned from
+ *                     bridge_msg_create_queue.
+ *      pmsg:          Location to copy message into.
+ *      utimeout:      Timeout to wait for a message.
  *  Returns:
  *      DSP_SOK:       Success.
  *      DSP_ETIMEOUT:  Timeout occurred.
- *      DSP_EFAIL:     No frames available for message (uMaxMessages too
+ *      DSP_EFAIL:     No frames available for message (max_msgs too
  *                     small).
  *  Requires:
- *      Valid hMsgQueue.
- *      pMsg != NULL.
+ *      Valid msg_queue_obj.
+ *      pmsg != NULL.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_MSG_GET) (struct MSG_QUEUE *hMsgQueue,
-						 struct DSP_MSG *pMsg,
-						 u32 uTimeout);
+typedef dsp_status(*fxn_msg_get) (struct msg_queue *msg_queue_obj,
+				  struct dsp_msg *pmsg, u32 utimeout);
 
 /*
- *  ======== WMD_MSG_Put ========
+ *  ======== bridge_msg_put ========
  *  Purpose:
- *      Put a message onto a MSG queue.
+ *      Put a message onto a msg_ctrl queue.
  *  Parameters:
- *      hMsgQueue:      Handle to MSG queue returned from
- *                      WMD_MSG_CreateQueue.
- *      pMsg:           Pointer to message.
- *      uTimeout:       Timeout to wait for a message.
+ *      msg_queue_obj:      Handle to msg_ctrl queue returned from
+ *                      bridge_msg_create_queue.
+ *      pmsg:           Pointer to message.
+ *      utimeout:       Timeout to wait for a message.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ETIMEOUT:   Timeout occurred.
- *      DSP_EFAIL:      No frames available for message (uMaxMessages too
+ *      DSP_EFAIL:      No frames available for message (max_msgs too
  *                      small).
  *  Requires:
- *      Valid hMsgQueue.
- *      pMsg != NULL.
+ *      Valid msg_queue_obj.
+ *      pmsg != NULL.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_MSG_PUT) (struct MSG_QUEUE *hMsgQueue,
-						 IN CONST struct DSP_MSG *pMsg,
-						 u32 uTimeout);
+typedef dsp_status(*fxn_msg_put) (struct msg_queue *msg_queue_obj,
+				  IN CONST struct dsp_msg *pmsg, u32 utimeout);
 
 /*
- *  ======== WMD_MSG_RegisterNotify ========
+ *  ======== bridge_msg_register_notify ========
  *  Purpose:
  *      Register notification for when a message is ready.
  *  Parameters:
- *      hMsgQueue:      Handle to MSG queue returned from
- *                      WMD_MSG_CreateQueue.
- *      uEventMask:     Type of events to be notified about: Must be
+ *      msg_queue_obj:      Handle to msg_ctrl queue returned from
+ *                      bridge_msg_create_queue.
+ *      event_mask:     Type of events to be notified about: Must be
  *                      DSP_NODEMESSAGEREADY, or 0 to unregister.
- *      uNotifyType:    DSP_SIGNALEVENT.
- *      hNotification:  Handle of notification object.
+ *      notify_type:    DSP_SIGNALEVENT.
+ *      hnotification:  Handle of notification object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Insufficient memory.
  *  Requires:
- *      Valid hMsgQueue.
- *      hNotification != NULL.
- *      uNotifyType == DSP_SIGNALEVENT.
- *      uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0.
+ *      Valid msg_queue_obj.
+ *      hnotification != NULL.
+ *      notify_type == DSP_SIGNALEVENT.
+ *      event_mask == DSP_NODEMESSAGEREADY || event_mask == 0.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_MSG_REGISTERNOTIFY)
-				(struct MSG_QUEUE *hMsgQueue,
-				u32 uEventMask, u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
+typedef dsp_status(*fxn_msg_registernotify)
+ (struct msg_queue *msg_queue_obj,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
 
 /*
- *  ======== WMD_MSG_SetQueueId ========
+ *  ======== bridge_msg_set_queue_id ========
  *  Purpose:
- *      Set message queue id to node environment. Allows WMD_MSG_CreateQueue
- *      to be called in NODE_Allocate, before the node environment is known.
+ *      Set message queue id to node environment. Allows bridge_msg_create_queue
+ *      to be called in node_allocate, before the node environment is known.
  *  Parameters:
- *      hMsgQueue:  Handle to MSG queue returned from
- *                  WMD_MSG_CreateQueue.
- *      dwId:       Node environment pointer.
+ *      msg_queue_obj:  Handle to msg_ctrl queue returned from
+ *                  bridge_msg_create_queue.
+ *      msgq_id:       Node environment pointer.
  *  Returns:
  *  Requires:
- *      Valid hMsgQueue.
- *      dwId != 0.
+ *      Valid msg_queue_obj.
+ *      msgq_id != 0.
  *  Ensures:
  */
-       typedef void(*WMD_MSG_SETQUEUEID) (struct MSG_QUEUE *hMsgQueue,
-						  u32 dwId);
+typedef void (*fxn_msg_setqueueid) (struct msg_queue *msg_queue_obj,
+				    u32 msgq_id);
 
 /*
  *  'Bridge Mini Driver (WMD) interface function table.
@@ -1079,64 +1054,64 @@ typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
  *  A mini-driver need not export a CHNL interface.  In this case, *all* of
  *  the WMD_CHNL_* entries must be set to NULL.
  */
-	struct WMD_DRV_INTERFACE {
-		u32 dwWCDMajorVersion;	/* Set to WCD_MAJOR_VERSION. */
-		u32 dwWCDMinorVersion;	/* Set to WCD_MINOR_VERSION. */
-		WMD_DEV_CREATE pfnDevCreate;	/* Create device context     */
-		WMD_DEV_DESTROY pfnDevDestroy;	/* Destroy device context    */
-		WMD_DEV_CTRL pfnDevCntrl;	/* Optional vendor interface */
-		WMD_BRD_MONITOR pfnBrdMonitor;	/* Load and/or start monitor */
-		WMD_BRD_START pfnBrdStart;	/* Start DSP program.        */
-		WMD_BRD_STOP pfnBrdStop;	/* Stop/reset board.         */
-		WMD_BRD_STATUS pfnBrdStatus;	/* Get current board status. */
-		WMD_BRD_READ pfnBrdRead;	/* Read board memory         */
-		WMD_BRD_WRITE pfnBrdWrite;	/* Write board memory.       */
-		WMD_BRD_SETSTATE pfnBrdSetState;  /* Sets the Board State */
-		WMD_BRD_MEMCOPY pfnBrdMemCopy;	 /* Copies DSP Memory         */
-		WMD_BRD_MEMWRITE pfnBrdMemWrite; /* Write DSP Memory w/o halt */
-		WMD_BRD_MEMMAP pfnBrdMemMap;	 /* Maps MPU mem to DSP mem   */
-		WMD_BRD_MEMUNMAP pfnBrdMemUnMap; /* Unmaps MPU mem to DSP mem */
-		WMD_CHNL_CREATE pfnChnlCreate;	 /* Create channel manager.   */
-		WMD_CHNL_DESTROY pfnChnlDestroy; /* Destroy channel manager.  */
-		WMD_CHNL_OPEN pfnChnlOpen;	 /* Create a new channel.     */
-		WMD_CHNL_CLOSE pfnChnlClose;	 /* Close a channel.          */
-		WMD_CHNL_ADDIOREQ pfnChnlAddIOReq; /* Req I/O on a channel. */
-		WMD_CHNL_GETIOC pfnChnlGetIOC;	 /* Wait for I/O completion.  */
-		WMD_CHNL_CANCELIO pfnChnlCancelIO; /* Cancl I/O on a channel. */
-		WMD_CHNL_FLUSHIO pfnChnlFlushIO;	/* Flush I/O.         */
-		WMD_CHNL_GETINFO pfnChnlGetInfo; /* Get channel specific info */
-		/* Get channel manager info. */
-		WMD_CHNL_GETMGRINFO pfnChnlGetMgrInfo;
-		WMD_CHNL_IDLE pfnChnlIdle;	/* Idle the channel */
-		/* Register for notif. */
-		WMD_CHNL_REGISTERNOTIFY pfnChnlRegisterNotify;
-		WMD_DEH_CREATE pfnDehCreate;	/* Create DEH manager */
-		WMD_DEH_DESTROY pfnDehDestroy;	/* Destroy DEH manager */
-		WMD_DEH_NOTIFY pfnDehNotify;    /* Notify of DSP error */
-		/* register for deh notif. */
-		WMD_DEH_REGISTERNOTIFY pfnDehRegisterNotify;
-		WMD_DEH_GETINFO pfnDehGetInfo;	/* register for deh notif. */
-		WMD_IO_CREATE pfnIOCreate;	/* Create IO manager */
-		WMD_IO_DESTROY pfnIODestroy;	/* Destroy IO manager */
-		WMD_IO_ONLOADED pfnIOOnLoaded;	/* Notify of program loaded */
-		/* Get Processor's current and predicted load */
-		WMD_IO_GETPROCLOAD pfnIOGetProcLoad;
-		WMD_MSG_CREATE pfnMsgCreate;	/* Create message manager */
-		/* Create message queue */
-		WMD_MSG_CREATEQUEUE pfnMsgCreateQueue;
-		WMD_MSG_DELETE pfnMsgDelete;	/* Delete message manager */
-		/* Delete message queue */
-		WMD_MSG_DELETEQUEUE pfnMsgDeleteQueue;
-		WMD_MSG_GET pfnMsgGet;	/* Get a message */
-		WMD_MSG_PUT pfnMsgPut;	/* Send a message */
-		/* Register for notif. */
-		WMD_MSG_REGISTERNOTIFY pfnMsgRegisterNotify;
-		/* Set message queue id */
-		WMD_MSG_SETQUEUEID pfnMsgSetQueueId;
-	} ;
+struct bridge_drv_interface {
+	u32 dw_wcd_major_version;	/* Set to WCD_MAJOR_VERSION. */
+	u32 dw_wcd_minor_version;	/* Set to WCD_MINOR_VERSION. */
+	fxn_dev_create pfn_dev_create;	/* Create device context */
+	fxn_dev_destroy pfn_dev_destroy;	/* Destroy device context */
+	fxn_dev_ctrl pfn_dev_cntrl;	/* Optional vendor interface */
+	fxn_brd_monitor pfn_brd_monitor;	/* Load and/or start monitor */
+	fxn_brd_start pfn_brd_start;	/* Start DSP program. */
+	fxn_brd_stop pfn_brd_stop;	/* Stop/reset board. */
+	fxn_brd_status pfn_brd_status;	/* Get current board status. */
+	fxn_brd_read pfn_brd_read;	/* Read board memory */
+	fxn_brd_write pfn_brd_write;	/* Write board memory. */
+	fxn_brd_setstate pfn_brd_set_state;	/* Sets the Board State */
+	fxn_brd_memcopy pfn_brd_mem_copy;	/* Copies DSP Memory */
+	fxn_brd_memwrite pfn_brd_mem_write;	/* Write DSP Memory w/o halt */
+	fxn_brd_memmap pfn_brd_mem_map;	/* Maps MPU mem to DSP mem */
+	fxn_brd_memunmap pfn_brd_mem_un_map;	/* Unmaps MPU mem to DSP mem */
+	fxn_chnl_create pfn_chnl_create;	/* Create channel manager. */
+	fxn_chnl_destroy pfn_chnl_destroy;	/* Destroy channel manager. */
+	fxn_chnl_open pfn_chnl_open;	/* Create a new channel. */
+	fxn_chnl_close pfn_chnl_close;	/* Close a channel. */
+	fxn_chnl_addioreq pfn_chnl_add_io_req;	/* Req I/O on a channel. */
+	fxn_chnl_getioc pfn_chnl_get_ioc;	/* Wait for I/O completion. */
+	fxn_chnl_cancelio pfn_chnl_cancel_io;	/* Cancl I/O on a channel. */
+	fxn_chnl_flushio pfn_chnl_flush_io;	/* Flush I/O. */
+	fxn_chnl_getinfo pfn_chnl_get_info;	/* Get channel specific info */
+	/* Get channel manager info. */
+	fxn_chnl_getmgrinfo pfn_chnl_get_mgr_info;
+	fxn_chnl_idle pfn_chnl_idle;	/* Idle the channel */
+	/* Register for notif. */
+	fxn_chnl_registernotify pfn_chnl_register_notify;
+	fxn_deh_create pfn_deh_create;	/* Create DEH manager */
+	fxn_deh_destroy pfn_deh_destroy;	/* Destroy DEH manager */
+	fxn_deh_notify pfn_deh_notify;	/* Notify of DSP error */
+	/* register for deh notif. */
+	fxn_deh_registernotify pfn_deh_register_notify;
+	fxn_deh_getinfo pfn_deh_get_info;	/* register for deh notif. */
+	fxn_io_create pfn_io_create;	/* Create IO manager */
+	fxn_io_destroy pfn_io_destroy;	/* Destroy IO manager */
+	fxn_io_onloaded pfn_io_on_loaded;	/* Notify of program loaded */
+	/* Get Processor's current and predicted load */
+	fxn_io_getprocload pfn_io_get_proc_load;
+	fxn_msg_create pfn_msg_create;	/* Create message manager */
+	/* Create message queue */
+	fxn_msg_createqueue pfn_msg_create_queue;
+	fxn_msg_delete pfn_msg_delete;	/* Delete message manager */
+	/* Delete message queue */
+	fxn_msg_deletequeue pfn_msg_delete_queue;
+	fxn_msg_get pfn_msg_get;	/* Get a message */
+	fxn_msg_put pfn_msg_put;	/* Send a message */
+	/* Register for notif. */
+	fxn_msg_registernotify pfn_msg_register_notify;
+	/* Set message queue id */
+	fxn_msg_setqueueid pfn_msg_set_queue_id;
+};
 
 /*
- *  ======== WMD_DRV_Entry ========
+ *  ======== bridge_drv_entry ========
  *  Purpose:
  *      Registers WMD functions with the class driver. Called only once
  *      by the WCD.  The caller will first check WCD version compatibility, and
@@ -1154,7 +1129,7 @@ typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
  *  Details:
  *      Win95: Called during the Device_Init phase.
  */
-       void WMD_DRV_Entry(OUT struct WMD_DRV_INTERFACE **ppDrvInterface,
-				 IN CONST char *pstrWMDFileName);
+void bridge_drv_entry(OUT struct bridge_drv_interface **ppDrvInterface,
+		   IN CONST char *pstrWMDFileName);
 
-#endif				/* WMD_ */
+#endif /* WMD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdchnl.h b/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
index f2608e0..0d874ab 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
@@ -24,52 +24,49 @@
 #ifndef WMDCHNL_
 #define WMDCHNL_
 
-	extern DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-					  struct DEV_OBJECT *hDevObject,
-					  IN CONST struct CHNL_MGRATTRS
-					  *pMgrAttrs);
+extern dsp_status bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
+				     struct dev_object *hdev_obj,
+				     IN CONST struct chnl_mgrattrs
+				     *pMgrAttrs);
 
-	extern DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
+extern dsp_status bridge_chnl_destroy(struct chnl_mgr *hchnl_mgr);
 
-	extern DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
-					struct CHNL_MGR *hChnlMgr,
-					short int uMode,
-					u32 uChnlId,
-					CONST IN OPTIONAL struct CHNL_ATTRS
-					*pAttrs);
+extern dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
+				   struct chnl_mgr *hchnl_mgr,
+				   short int chnl_mode,
+				   u32 uChnlId,
+				   CONST IN OPTIONAL struct chnl_attr
+				   *pattrs);
 
-	extern DSP_STATUS WMD_CHNL_Close(struct CHNL_OBJECT *hChnl);
+extern dsp_status bridge_chnl_close(struct chnl_object *chnl_obj);
 
-	extern DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl,
-					    void *pHostBuf,
-					    u32 cBytes, u32 cBufSize,
-					    OPTIONAL u32 dwDspAddr,
-					    u32 dwArg);
+extern dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj,
+				      void *pHostBuf,
+				      u32 byte_size, u32 buf_size,
+				      OPTIONAL u32 dw_dsp_addr, u32 dw_arg);
 
-	extern DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl,
-					  u32 dwTimeOut,
-					  OUT struct CHNL_IOC *pIOC);
+extern dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj,
+				   u32 dwTimeOut, OUT struct chnl_ioc *pIOC);
 
-	extern DSP_STATUS WMD_CHNL_CancelIO(struct CHNL_OBJECT *hChnl);
+extern dsp_status bridge_chnl_cancel_io(struct chnl_object *chnl_obj);
 
-	extern DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl,
-					   u32 dwTimeOut);
+extern dsp_status bridge_chnl_flush_io(struct chnl_object *chnl_obj,
+				    u32 dwTimeOut);
 
-	extern DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
-					   OUT struct CHNL_INFO *pInfo);
+extern dsp_status bridge_chnl_get_info(struct chnl_object *chnl_obj,
+				    OUT struct chnl_info *pInfo);
 
-	extern DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr,
-					      u32 uChnlID,
-					      OUT struct CHNL_MGRINFO
-					      *pMgrInfo);
+extern dsp_status bridge_chnl_get_mgr_info(struct chnl_mgr *hchnl_mgr,
+					u32 uChnlID, OUT struct chnl_mgrinfo
+					*pMgrInfo);
 
-	extern DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl,
-					u32 dwTimeOut, bool fFlush);
+extern dsp_status bridge_chnl_idle(struct chnl_object *chnl_obj,
+				   u32 dwTimeOut, bool fFlush);
 
-	extern DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl,
-						  u32 uEventMask,
-						  u32 uNotifyType,
-						  struct DSP_NOTIFICATION
-						  *hNotification);
+extern dsp_status bridge_chnl_register_notify(struct chnl_object *chnl_obj,
+					   u32 event_mask,
+					   u32 notify_type,
+					   struct dsp_notification
+					   *hnotification);
 
-#endif				/* WMDCHNL_ */
+#endif /* WMDCHNL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmddeh.h b/arch/arm/plat-omap/include/dspbridge/wmddeh.h
index 92c4452..0152c43 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmddeh.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmddeh.h
@@ -27,22 +27,22 @@
 
 #include <dspbridge/dehdefs.h>
 
-	extern DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
-					 struct DEV_OBJECT *hDevObject);
+extern dsp_status bridge_deh_create(OUT struct deh_mgr **phDehMgr,
+				    struct dev_object *hdev_obj);
 
-	extern DSP_STATUS WMD_DEH_Destroy(struct DEH_MGR *hDehMgr);
+extern dsp_status bridge_deh_destroy(struct deh_mgr *hdeh_mgr);
 
-	extern DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
-					  struct DSP_ERRORINFO *pErrInfo);
+extern dsp_status bridge_deh_get_info(struct deh_mgr *hdeh_mgr,
+				   struct dsp_errorinfo *pErrInfo);
 
-	extern DSP_STATUS WMD_DEH_RegisterNotify(struct DEH_MGR *hDehMgr,
-						 u32 uEventMask,
-						 u32 uNotifyType,
-						 struct DSP_NOTIFICATION
-						 *hNotification);
+extern dsp_status bridge_deh_register_notify(struct deh_mgr *hdeh_mgr,
+					  u32 event_mask,
+					  u32 notify_type,
+					  struct dsp_notification
+					  *hnotification);
 
-	extern void WMD_DEH_Notify(struct DEH_MGR *hDehMgr,
-				   u32 ulEventMask, u32 dwErrInfo);
+extern void bridge_deh_notify(struct deh_mgr *hdeh_mgr,
+			      u32 ulEventMask, u32 dwErrInfo);
 
-	extern void WMD_DEH_ReleaseDummyMem(void);
-#endif				/* WMDDEH_ */
+extern void bridge_deh_release_dummy_mem(void);
+#endif /* WMDDEH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdio.h b/arch/arm/plat-omap/include/dspbridge/wmdio.h
index 95af696..c566350 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmdio.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmdio.h
@@ -26,16 +26,16 @@
 #include <dspbridge/devdefs.h>
 #include <dspbridge/iodefs.h>
 
-	extern DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
-					struct DEV_OBJECT *hDevObject,
-					IN CONST struct IO_ATTRS *pMgrAttrs);
+extern dsp_status bridge_io_create(OUT struct io_mgr **phIOMgr,
+				   struct dev_object *hdev_obj,
+				   IN CONST struct io_attrs *pMgrAttrs);
 
-	extern DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr);
+extern dsp_status bridge_io_destroy(struct io_mgr *hio_mgr);
 
-	extern DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr);
+extern dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr);
 
-	extern DSP_STATUS IVA_IO_OnLoaded(struct IO_MGR *hIOMgr);
-	extern DSP_STATUS WMD_IO_GetProcLoad(IN struct IO_MGR *hIOMgr,
-				OUT struct DSP_PROCLOADSTAT *pProcStat);
+extern dsp_status iva_io_on_loaded(struct io_mgr *hio_mgr);
+extern dsp_status bridge_io_get_proc_load(IN struct io_mgr *hio_mgr,
+				       OUT struct dsp_procloadstat *pProcStat);
 
-#endif				/* WMDIO_ */
+#endif /* WMDIO_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdioctl.h b/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
index 3a9d65c..6547e38 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
@@ -23,7 +23,10 @@
 #include <hw_defs.h>
 #include <hw_mmu.h>
 
-/* Any IOCTLS at or above this value are reserved for standard WMD interfaces.*/
+/*
+ * Any IOCTLS at or above this value are reserved for standard WMD
+ * interfaces.
+ */
 #define WMDIOCTL_RESERVEDBASE       0x8000
 
 #define WMDIOCTL_CHNLREAD           (WMDIOCTL_RESERVEDBASE + 0x10)
@@ -31,8 +34,10 @@
 #define WMDIOCTL_GETINTRCOUNT       (WMDIOCTL_RESERVEDBASE + 0x30)
 #define WMDIOCTL_RESETINTRCOUNT     (WMDIOCTL_RESERVEDBASE + 0x40)
 #define WMDIOCTL_INTERRUPTDSP       (WMDIOCTL_RESERVEDBASE + 0x50)
-#define WMDIOCTL_SETMMUCONFIG       (WMDIOCTL_RESERVEDBASE + 0x60)   /* DMMU */
-#define WMDIOCTL_PWRCONTROL         (WMDIOCTL_RESERVEDBASE + 0x70)   /* PWR */
+/* DMMU */
+#define WMDIOCTL_SETMMUCONFIG       (WMDIOCTL_RESERVEDBASE + 0x60)
+/* PWR */
+#define WMDIOCTL_PWRCONTROL         (WMDIOCTL_RESERVEDBASE + 0x70)
 
 /* attention, modifiers:
  * Some of these control enumerations are made visible to user for power
@@ -45,8 +50,8 @@
 #define WMDIOCTL_PWRENABLE          (WMDIOCTL_PWRCONTROL + 0x3)
 #define WMDIOCTL_PWRDISABLE         (WMDIOCTL_PWRCONTROL + 0x4)
 #define WMDIOCTL_CLK_CTRL		    (WMDIOCTL_PWRCONTROL + 0x7)
-#define WMDIOCTL_PWR_HIBERNATE (WMDIOCTL_PWRCONTROL + 0x8) /*DSP Initiated
-							    * Hibernate*/
+/* DSP Initiated Hibernate */
+#define WMDIOCTL_PWR_HIBERNATE	(WMDIOCTL_PWRCONTROL + 0x8)
 #define WMDIOCTL_PRESCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0x9)
 #define WMDIOCTL_POSTSCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0xA)
 #define WMDIOCTL_CONSTRAINT_REQUEST (WMDIOCTL_PWRCONTROL + 0xB)
@@ -54,16 +59,15 @@
 /* Number of actual DSP-MMU TLB entrries */
 #define WMDIOCTL_NUMOFMMUTLB        32
 
-struct WMDIOCTL_EXTPROC {
-	u32 ulDspVa;		/* DSP virtual address */
-	u32 ulGppPa;		/* GPP physical address */
+struct wmdioctl_extproc {
+	u32 ul_dsp_va;		/* DSP virtual address */
+	u32 ul_gpp_pa;		/* GPP physical address */
 	/* GPP virtual address. __va does not work for ioremapped addresses */
-	u32 ulGppVa;
-	u32 ulSize;		/* Size of the mapped memory in bytes */
-	enum HW_Endianism_t endianism;
-	enum HW_MMUMixedSize_t mixedMode;
-	enum HW_ElementSize_t elemSize;
+	u32 ul_gpp_va;
+	u32 ul_size;		/* Size of the mapped memory in bytes */
+	enum hw_endianism_t endianism;
+	enum hw_mmu_mixed_size_t mixed_mode;
+	enum hw_element_size_t elem_size;
 };
 
-#endif				/* WMDIOCTL_ */
-
+#endif /* WMDIOCTL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdmsg.h b/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
index 3b50e38..f8005ea 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
@@ -26,32 +26,30 @@
 
 #include <dspbridge/msgdefs.h>
 
-	extern DSP_STATUS WMD_MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-					 struct DEV_OBJECT *hDevObject,
-					 MSG_ONEXIT msgCallback);
+extern dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
+				    struct dev_object *hdev_obj,
+				    msg_onexit msgCallback);
 
-	extern DSP_STATUS WMD_MSG_CreateQueue(struct MSG_MGR *hMsgMgr,
-					      OUT struct MSG_QUEUE **phMsgQueue,
-					      u32 dwId, u32 uMaxMsgs,
-					      HANDLE h);
+extern dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
+				       OUT struct msg_queue **phMsgQueue,
+				       u32 msgq_id, u32 max_msgs, bhandle h);
 
-	extern void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr);
+extern void bridge_msg_delete(struct msg_mgr *hmsg_mgr);
 
-	extern void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue);
+extern void bridge_msg_delete_queue(struct msg_queue *msg_queue_obj);
 
-	extern DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE *hMsgQueue,
-				      struct DSP_MSG *pMsg, u32 uTimeout);
+extern dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
+				 struct dsp_msg *pmsg, u32 utimeout);
 
-	extern DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE *hMsgQueue,
-				      IN CONST struct DSP_MSG *pMsg,
-				      u32 uTimeout);
+extern dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
+				 IN CONST struct dsp_msg *pmsg, u32 utimeout);
 
-	extern DSP_STATUS WMD_MSG_RegisterNotify(struct MSG_QUEUE *hMsgQueue,
-						 u32 uEventMask,
-						 u32 uNotifyType,
-						 struct DSP_NOTIFICATION
-						 *hNotification);
+extern dsp_status bridge_msg_register_notify(struct msg_queue *msg_queue_obj,
+					  u32 event_mask,
+					  u32 notify_type,
+					  struct dsp_notification
+					  *hnotification);
 
-	extern void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId);
+extern void bridge_msg_set_queue_id(struct msg_queue *msg_queue_obj, u32 msgq_id);
 
-#endif				/* WMDMSG_ */
+#endif /* WMDMSG_ */
diff --git a/drivers/dsp/bridge/dynload/cload.c b/drivers/dsp/bridge/dynload/cload.c
index 505fcdf..c77f561 100644
--- a/drivers/dsp/bridge/dynload/cload.c
+++ b/drivers/dsp/bridge/dynload/cload.c
@@ -21,10 +21,10 @@
 
 /*
  * we use the fact that DOFF section records are shaped just like
- * LDR_SECTION_INFO to reduce our section storage usage.  This macro marks
+ * ldr_section_info to reduce our section storage usage.  This macro marks
  * the places where that assumption is made
  */
-#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct LDR_SECTION_INFO *)(pdoffsec))
+#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct ldr_section_info *)(pdoffsec))
 
 /*
  * forward references
@@ -40,20 +40,20 @@ static void init_module_handle(struct dload_state *dlthis);
 static char *unpack_name(struct dload_state *dlthis, u32 soffset);
 #endif
 
-static const char CINITNAME[] = { ".cinit" };
-static const char LOADER_DLLVIEW_ROOT[] = { "?DLModules?" };
+static const char cinitname[] = { ".cinit" };
+static const char loader_dllview_root[] = { "?DLModules?" };
 
 /*
  * Error strings
  */
-static const char E_READSTRM[] = { "Error reading %s from input stream" };
-static const char E_ALLOC[] = { "Syms->Allocate( %d ) failed" };
-static const char E_TGTALLOC[] =
+static const char readstrm[] = { "Error reading %s from input stream" };
+static const char err_alloc[] = { "Syms->dload_allocate( %d ) failed" };
+static const char tgtalloc[] =
     { "Target memory allocate failed, section %s size " FMT_UI32 };
-static const char E_INITFAIL[] = { "%s to target address " FMT_UI32 " failed" };
-static const char E_DLVWRITE[] = { "Write to DLLview list failed" };
-static const char E_ICONNECT[] = { "Connect call to init interface failed" };
-static const char E_CHECKSUM[] = { "Checksum failed on %s" };
+static const char initfail[] = { "%s to target address " FMT_UI32 " failed" };
+static const char dlvwrite[] = { "Write to DLLview list failed" };
+static const char iconnect[] = { "Connect call to init interface failed" };
+static const char err_checksum[] = { "Checksum failed on %s" };
 
 /*************************************************************************
  * Procedure dload_error
@@ -64,13 +64,13 @@ static const char E_CHECKSUM[] = { "Checksum failed on %s" };
  *
  * Effect:
  *	Reports or records the error as appropriate.
- ************************************************************************/
+ *********************************************************************** */
 void dload_error(struct dload_state *dlthis, const char *errtxt, ...)
 {
 	va_list args;
 
 	va_start(args, errtxt);
-	dlthis->mysym->Error_Report(dlthis->mysym, errtxt, args);
+	dlthis->mysym->error_report(dlthis->mysym, errtxt, args);
 	va_end(args);
 	dlthis->dload_errcount += 1;
 
@@ -87,18 +87,18 @@ void dload_error(struct dload_state *dlthis, const char *errtxt, ...)
  *
  * Effect:
  *	Reports or records the error as appropriate.
- ************************************************************************/
-void dload_syms_error(struct Dynamic_Loader_Sym *syms, const char *errtxt, ...)
+ *********************************************************************** */
+void dload_syms_error(struct dynamic_loader_sym *syms, const char *errtxt, ...)
 {
 	va_list args;
 
 	va_start(args, errtxt);
-	syms->Error_Report(syms, errtxt, args);
+	syms->error_report(syms, errtxt, args);
 	va_end(args);
 }
 
 /*************************************************************************
- * Procedure Dynamic_Load_Module
+ * Procedure dynamic_load_module
  *
  * Parameters:
  *	module	The input stream that supplies the module image
@@ -120,13 +120,13 @@ void dload_syms_error(struct Dynamic_Loader_Sym *syms, const char *errtxt, ...)
  *	On a successful load, a module handle is placed in *mhandle,
  *	and zero is returned.  On error, the number of errors detected is
  *	returned.  Individual errors are reported during the load process
- *	using syms->Error_Report().
- ***********************************************************************/
-int Dynamic_Load_Module(struct Dynamic_Loader_Stream *module,
-			struct Dynamic_Loader_Sym *syms ,
-			struct Dynamic_Loader_Allocate *alloc,
-			struct Dynamic_Loader_Initialize *init,
-			unsigned options, DLOAD_mhandle *mhandle)
+ *	using syms->error_report().
+ ********************************************************************** */
+int dynamic_load_module(struct dynamic_loader_stream *module,
+			struct dynamic_loader_sym *syms,
+			struct dynamic_loader_allocate *alloc,
+			struct dynamic_loader_initialize *init,
+			unsigned options, dload_mhandle *mhandle)
 {
 	register unsigned *dp, sz;
 	struct dload_state dl_state;	/* internal state for this call */
@@ -159,7 +159,7 @@ int Dynamic_Load_Module(struct Dynamic_Loader_Stream *module,
 				/* do now, before reducing symbols */
 				allocate_sections(&dl_state);
 			} else
-				dload_error(&dl_state, E_ICONNECT);
+				dload_error(&dl_state, iconnect);
 		}
 
 		if (!dl_state.dload_errcount) {
@@ -183,8 +183,7 @@ int Dynamic_Load_Module(struct Dynamic_Loader_Stream *module,
 			    (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&
 			    (!init->execute(init,
 					    dl_state.dfile_hdr.df_entrypt)))
-				dload_error(&dl_state,
-					    "Init->Execute Failed");
+				dload_error(&dl_state, "Init->Execute Failed");
 			init->release(init);
 		}
 
@@ -193,10 +192,9 @@ int Dynamic_Load_Module(struct Dynamic_Loader_Stream *module,
 		string_table_free(&dl_state);
 		dload_tramp_cleanup(&dl_state);
 
-
 		if (dl_state.dload_errcount) {
-			Dynamic_Unload_Module(dl_state.myhandle, syms, alloc,
-					     init);
+			dynamic_unload_module(dl_state.myhandle, syms, alloc,
+					      init);
 			dl_state.myhandle = NULL;
 		}
 	}
@@ -208,7 +206,7 @@ int Dynamic_Load_Module(struct Dynamic_Loader_Stream *module,
 }				/* DLOAD_File */
 
 /*************************************************************************
- * Procedure Dynamic_Open_Module
+ * Procedure dynamic_open_module
  *
  * Parameters:
  *      module  The input stream that supplies the module image
@@ -230,17 +228,17 @@ int Dynamic_Load_Module(struct Dynamic_Loader_Stream *module,
  *      On a successful load, a module handle is placed in *mhandle,
  *      and zero is returned.  On error, the number of errors detected is
  *      returned.  Individual errors are reported during the load process
- *      using syms->Error_Report().
- ***********************************************************************/
+ *      using syms->error_report().
+ ********************************************************************** */
 int
-Dynamic_Open_Module(struct Dynamic_Loader_Stream *module,
-		    struct Dynamic_Loader_Sym *syms,
-		    struct Dynamic_Loader_Allocate *alloc,
-		    struct Dynamic_Loader_Initialize *init,
-		    unsigned options, DLOAD_mhandle *mhandle)
+dynamic_open_module(struct dynamic_loader_stream *module,
+		    struct dynamic_loader_sym *syms,
+		    struct dynamic_loader_allocate *alloc,
+		    struct dynamic_loader_initialize *init,
+		    unsigned options, dload_mhandle *mhandle)
 {
 	register unsigned *dp, sz;
-	struct dload_state dl_state;   /* internal state for this call */
+	struct dload_state dl_state;	/* internal state for this call */
 
 	/* blast our internal state */
 	dp = (unsigned *)&dl_state;
@@ -270,7 +268,7 @@ Dynamic_Open_Module(struct Dynamic_Loader_Stream *module,
 				/* do now, before reducing symbols */
 				allocate_sections(&dl_state);
 			} else
-				dload_error(&dl_state, E_ICONNECT);
+				dload_error(&dl_state, iconnect);
 		}
 
 		if (!dl_state.dload_errcount) {
@@ -291,8 +289,7 @@ Dynamic_Open_Module(struct Dynamic_Loader_Stream *module,
 			    (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&
 			    (!init->execute(init,
 					    dl_state.dfile_hdr.df_entrypt)))
-				dload_error(&dl_state,
-					    "Init->Execute Failed");
+				dload_error(&dl_state, "Init->Execute Failed");
 			init->release(init);
 		}
 
@@ -301,17 +298,17 @@ Dynamic_Open_Module(struct Dynamic_Loader_Stream *module,
 		string_table_free(&dl_state);
 
 		if (dl_state.dload_errcount) {
-			Dynamic_Unload_Module(dl_state.myhandle, syms, alloc,
+			dynamic_unload_module(dl_state.myhandle, syms, alloc,
 					      init);
 			dl_state.myhandle = NULL;
 		}
 	}
 
 	if (mhandle)
-		*mhandle = dl_state.myhandle;   /* give back the handle */
+		*mhandle = dl_state.myhandle;	/* give back the handle */
 
 	return dl_state.dload_errcount;
-}			       /* DLOAD_File */
+}				/* DLOAD_File */
 
 /*************************************************************************
  * Procedure dload_headers
@@ -322,7 +319,7 @@ Dynamic_Open_Module(struct Dynamic_Loader_Stream *module,
  * Effect:
  *	Loads the DOFF header and verify record.  Deals with any byte-order
  * issues and checks them for validity.
- ************************************************************************/
+ *********************************************************************** */
 #define COMBINED_HEADER_SIZE (sizeof(struct doff_filehdr_t)+ \
 			     sizeof(struct doff_verify_rec_t))
 
@@ -333,8 +330,9 @@ void dload_headers(struct dload_state *dlthis)
 	/* Read the header and the verify record as one.  If we don't get it
 	   all, we're done */
 	if (dlthis->strm->read_buffer(dlthis->strm, &dlthis->dfile_hdr,
-	    COMBINED_HEADER_SIZE) != COMBINED_HEADER_SIZE) {
-		DL_ERROR(E_READSTRM, "File Headers");
+				      COMBINED_HEADER_SIZE) !=
+	    COMBINED_HEADER_SIZE) {
+		DL_ERROR(readstrm, "File Headers");
 		return;
 	}
 	/*
@@ -363,10 +361,10 @@ void dload_headers(struct dload_state *dlthis)
 	 * Verify checksum of header and verify record
 	 */
 	if (~dload_checksum(&dlthis->dfile_hdr,
-	    sizeof(struct doff_filehdr_t)) ||
+			    sizeof(struct doff_filehdr_t)) ||
 	    ~dload_checksum(&dlthis->verify,
-	    sizeof(struct doff_verify_rec_t))) {
-		DL_ERROR(E_CHECKSUM, "header or verify record");
+			    sizeof(struct doff_verify_rec_t))) {
+		DL_ERROR(err_checksum, "header or verify record");
 		return;
 	}
 #if HOST_ENDIANNESS
@@ -375,7 +373,7 @@ void dload_headers(struct dload_state *dlthis)
 
 	/* Check for valid target ID */
 	if ((dlthis->dfile_hdr.df_target_id != TARGET_ID) &&
-	  -(dlthis->dfile_hdr.df_target_id != TMS470_ID)) {
+	    -(dlthis->dfile_hdr.df_target_id != TMS470_ID)) {
 		dload_error(dlthis, "Bad target ID 0x%x and TARGET_ID 0x%x",
 			    dlthis->dfile_hdr.df_target_id, TARGET_ID);
 		return;
@@ -419,9 +417,9 @@ void dload_headers(struct dload_state *dlthis)
  *
  *	COFF sections are read in and retained intact.  Each record is embedded
  * 	in a new structure that records the updated load and
- * 	run addresses of the section  */
+ * 	run addresses of the section */
 
-static const char SECN_ERRID[] = { "section" };
+static const char secn_errid[] = { "section" };
 
 /*************************************************************************
  * Procedure dload_sections
@@ -431,9 +429,8 @@ static const char SECN_ERRID[] = { "section" };
  *
  * Effect:
  *	Loads the section records into an internal table.
- ************************************************************************/
-void
-dload_sections(struct dload_state *dlthis)
+ *********************************************************************** */
+void dload_sections(struct dload_state *dlthis)
 {
 	s16 siz;
 	struct doff_scnhdr_t *shp;
@@ -441,17 +438,18 @@ dload_sections(struct dload_state *dlthis)
 
 	/* allocate space for the DOFF section records */
 	siz = nsecs * sizeof(struct doff_scnhdr_t);
-	shp = (struct doff_scnhdr_t *)dlthis->mysym->Allocate(dlthis->mysym,
-	       siz);
+	shp =
+	    (struct doff_scnhdr_t *)dlthis->mysym->dload_allocate(dlthis->mysym,
+								  siz);
 	if (!shp) {		/* not enough storage */
-		DL_ERROR(E_ALLOC, siz);
+		DL_ERROR(err_alloc, siz);
 		return;
 	}
 	dlthis->sect_hdrs = shp;
 
 	/* read in the section records */
 	if (dlthis->strm->read_buffer(dlthis->strm, shp, siz) != siz) {
-		DL_ERROR(E_READSTRM, SECN_ERRID);
+		DL_ERROR(readstrm, secn_errid);
 		return;
 	}
 
@@ -462,7 +460,7 @@ dload_sections(struct dload_state *dlthis)
 	/* check for validity */
 	if (~dload_checksum(dlthis->sect_hdrs, siz) !=
 	    dlthis->verify.dv_scn_rec_checksum) {
-		DL_ERROR(E_CHECKSUM, SECN_ERRID);
+		DL_ERROR(err_checksum, secn_errid);
 		return;
 	}
 
@@ -476,18 +474,18 @@ dload_sections(struct dload_state *dlthis)
  *
  * Effect:
  *	Assigns new (target) addresses for sections
- *****************************************************************************/
+ **************************************************************************** */
 static void allocate_sections(struct dload_state *dlthis)
 {
 	u16 curr_sect, nsecs, siz;
 	struct doff_scnhdr_t *shp;
-	struct LDR_SECTION_INFO *asecs;
+	struct ldr_section_info *asecs;
 	struct my_handle *hndl;
 	nsecs = dlthis->dfile_hdr.df_no_scns;
 	if (!nsecs)
 		return;
 	if ((dlthis->myalloc == NULL) &&
-	   (dlthis->dfile_hdr.df_target_scns > 0)) {
+	    (dlthis->dfile_hdr.df_target_scns > 0)) {
 		DL_ERROR("Arg 3 (alloc) required but NULL", 0);
 		return;
 	}
@@ -497,11 +495,13 @@ static void allocate_sections(struct dload_state *dlthis)
 	 * trampoline section in case we need it.
 	 */
 	siz = (dlthis->dfile_hdr.df_target_scns + 1) *
-		sizeof(struct LDR_SECTION_INFO) + MY_HANDLE_SIZE;
+	    sizeof(struct ldr_section_info) + MY_HANDLE_SIZE;
 
-	hndl = (struct my_handle *)dlthis->mysym->Allocate(dlthis->mysym, siz);
+	hndl =
+	    (struct my_handle *)dlthis->mysym->dload_allocate(dlthis->mysym,
+							      siz);
 	if (!hndl) {		/* not enough storage */
-		DL_ERROR(E_ALLOC, siz);
+		DL_ERROR(err_alloc, siz);
 		return;
 	}
 	/* initialize the handle header */
@@ -520,7 +520,7 @@ static void allocate_sections(struct dload_state *dlthis)
 		/* attempt to insert the name of this section */
 		if (soffset < dlthis->dfile_hdr.df_strtab_size)
 			DOFFSEC_IS_LDRSEC(shp)->name = dlthis->str_head +
-							       soffset;
+			    soffset;
 		else {
 			dload_error(dlthis, "Bad name offset in section %d",
 				    curr_sect);
@@ -537,13 +537,14 @@ static void allocate_sections(struct dload_state *dlthis)
 #else
 			dlthis->debug_string_size = soffset;
 #endif
-		if (dlthis->myalloc != NULL) {
-			if (!dlthis->myalloc->Allocate(dlthis->myalloc, asecs,
-				     DS_ALIGNMENT(asecs->type))) {
-				dload_error(dlthis, E_TGTALLOC, asecs->name,
-					    asecs->size);
-				return;
-			}
+			if (dlthis->myalloc != NULL) {
+				if (!dlthis->myalloc->
+				    dload_allocate(dlthis->myalloc, asecs,
+						   DS_ALIGNMENT(asecs->type))) {
+					dload_error(dlthis, tgtalloc,
+						    asecs->name, asecs->size);
+					return;
+				}
 			}
 			/* keep address deltas in original section table */
 			shp->ds_vaddr = asecs->load_addr - shp->ds_vaddr;
@@ -570,14 +571,14 @@ static void allocate_sections(struct dload_state *dlthis)
  *
  * WARNING:
  *	This routine is not allowed to declare errors!
- ************************************************************************/
+ *********************************************************************** */
 static void section_table_free(struct dload_state *dlthis)
 {
 	struct doff_scnhdr_t *shp;
 
 	shp = dlthis->sect_hdrs;
 	if (shp)
-		dlthis->mysym->Deallocate(dlthis->mysym, shp);
+		dlthis->mysym->dload_deallocate(dlthis->mysym, shp);
 
 }				/* section_table_free */
 
@@ -591,8 +592,9 @@ static void section_table_free(struct dload_state *dlthis)
  * Effect:
  *	Loads the DOFF string table into memory. DOFF keeps all strings in a
  * big unsorted array.  We just read that array into memory in bulk.
- ************************************************************************/
-static const char S_STRINGTBL[] = { "string table" };
+ *********************************************************************** */
+static const char stringtbl[] = { "string table" };
+
 void dload_strings(struct dload_state *dlthis, bool sec_names_only)
 {
 	u32 ssiz;
@@ -600,23 +602,24 @@ void dload_strings(struct dload_state *dlthis, bool sec_names_only)
 
 	if (sec_names_only) {
 		ssiz = BYTE_TO_HOST(DOFF_ALIGN
-				   (dlthis->dfile_hdr.df_scn_name_size));
+				    (dlthis->dfile_hdr.df_scn_name_size));
 	} else {
 		ssiz = BYTE_TO_HOST(DOFF_ALIGN
-				   (dlthis->dfile_hdr.df_strtab_size));
+				    (dlthis->dfile_hdr.df_strtab_size));
 	}
 	if (ssiz == 0)
 		return;
 
 	/* get some memory for the string table */
 #if BITS_PER_AU > BITS_PER_BYTE
-	strbuf = (char *)dlthis->mysym->Allocate(dlthis->mysym, ssiz +
-					     dlthis->dfile_hdr.df_max_str_len);
+	strbuf = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, ssiz +
+						       dlthis->dfile_hdr.
+						       df_max_str_len);
 #else
-	strbuf = (char *)dlthis->mysym->Allocate(dlthis->mysym, ssiz);
+	strbuf = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, ssiz);
 #endif
 	if (strbuf == NULL) {
-		DL_ERROR(E_ALLOC, ssiz);
+		DL_ERROR(err_alloc, ssiz);
 		return;
 	}
 	dlthis->str_head = strbuf;
@@ -625,8 +628,8 @@ void dload_strings(struct dload_state *dlthis, bool sec_names_only)
 #endif
 	/* read in the strings and verify them */
 	if ((unsigned)(dlthis->strm->read_buffer(dlthis->strm, strbuf,
-	    ssiz)) != ssiz) {
-		DL_ERROR(E_READSTRM, S_STRINGTBL);
+						 ssiz)) != ssiz) {
+		DL_ERROR(readstrm, stringtbl);
 	}
 	/* if we need to fix up byte order, do it now */
 #ifndef _BIG_ENDIAN
@@ -634,19 +637,20 @@ void dload_strings(struct dload_state *dlthis, bool sec_names_only)
 		dload_reorder(strbuf, ssiz, dlthis->reorder_map);
 
 	if ((!sec_names_only) && (~dload_checksum(strbuf, ssiz) !=
-	     dlthis->verify.dv_str_tab_checksum)) {
-		DL_ERROR(E_CHECKSUM, S_STRINGTBL);
+				  dlthis->verify.dv_str_tab_checksum)) {
+		DL_ERROR(err_checksum, stringtbl);
 	}
 #else
 	if (dlthis->dfile_hdr.df_byte_reshuffle !=
 	    HOST_BYTE_ORDER(REORDER_MAP(BYTE_RESHUFFLE_VALUE))) {
 		/* put strings in big-endian order, not in PC order */
-		dload_reorder(strbuf, ssiz, HOST_BYTE_ORDER(dlthis->dfile_hdr.
-					      df_byte_reshuffle));
+		dload_reorder(strbuf, ssiz,
+			      HOST_BYTE_ORDER(dlthis->
+					      dfile_hdr.df_byte_reshuffle));
 	}
 	if ((!sec_names_only) && (~dload_reverse_checksum(strbuf, ssiz) !=
-	     dlthis->verify.dv_str_tab_checksum)) {
-		DL_ERROR(E_CHECKSUM, S_STRINGTBL);
+				  dlthis->verify.dv_str_tab_checksum)) {
+		DL_ERROR(err_checksum, stringtbl);
 	}
 #endif
 }				/* dload_strings */
@@ -662,11 +666,12 @@ void dload_strings(struct dload_state *dlthis, bool sec_names_only)
  *
  * WARNING:
  *	This routine is not allowed to declare errors!
- *************************************************************************/
+ ************************************************************************ */
 static void string_table_free(struct dload_state *dlthis)
 {
 	if (dlthis->str_head)
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->str_head);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->str_head);
 
 }				/* string_table_free */
 
@@ -676,7 +681,7 @@ static void string_table_free(struct dload_state *dlthis)
  * COFF symbols are read by dload_symbols(), which is called after
  * sections have been allocated.  Symbols which might be used in
  * relocation (ie, not debug info) are retained in an internal temporary
- * compressed table (type Local_Symbol). A particular symbol is recovered
+ * compressed table (type local_symbol). A particular symbol is recovered
  * by index by calling dload_find_symbol().  dload_find_symbol
  * reconstructs a more explicit representation (type SLOTVEC) which is
  * used by reloc.c
@@ -684,7 +689,7 @@ static void string_table_free(struct dload_state *dlthis)
 /* real size of debug header */
 #define DBG_HDR_SIZE (sizeof(struct dll_module) - sizeof(struct dll_sect))
 
-static const char SYM_ERRID[] = { "symbol" };
+static const char sym_errid[] = { "symbol" };
 
 /**************************************************************************
  * Procedure dload_symbols
@@ -695,22 +700,22 @@ static const char SYM_ERRID[] = { "symbol" };
  * Effect:
  *	Reads in symbols and retains ones that might be needed for relocation
  * purposes.
- ************************************************************************/
+ *********************************************************************** */
 /* size of symbol buffer no bigger than target data buffer, to limit stack
- * usage*/
+ * usage */
 #define MY_SYM_BUF_SIZ (BYTE_TO_HOST(IMAGE_PACKET_SIZE)/\
 			sizeof(struct doff_syment_t))
 
 static void dload_symbols(struct dload_state *dlthis)
 {
-	u32 s_count, siz, dsiz, symbols_left;
+	u32 sym_count, siz, dsiz, symbols_left;
 	u32 checks;
-	struct Local_Symbol *sp;
+	struct local_symbol *sp;
 	struct dynload_symbol *symp;
 	struct dynload_symbol *newsym;
 
-	s_count = dlthis->dfile_hdr.df_no_syms;
-	if (s_count == 0)
+	sym_count = dlthis->dfile_hdr.df_no_syms;
+	if (sym_count == 0)
 		return;
 
 	/*
@@ -723,23 +728,24 @@ static void dload_symbols(struct dload_state *dlthis)
 	 * size of the trampoline section name so DLLView doens't get lost.
 	 */
 
-	siz = s_count * sizeof(struct Local_Symbol);
+	siz = sym_count * sizeof(struct local_symbol);
 	dsiz = DBG_HDR_SIZE +
-		(sizeof(struct dll_sect) * dlthis->allocated_secn_count) +
+	    (sizeof(struct dll_sect) * dlthis->allocated_secn_count) +
 	    BYTE_TO_HOST_ROUND(dlthis->debug_string_size + 1);
 	if (dsiz > siz)
 		siz = dsiz;	/* larger of symbols and .dllview temp */
-	sp = (struct Local_Symbol *)dlthis->mysym->Allocate(dlthis->mysym, siz);
+	sp = (struct local_symbol *)dlthis->mysym->dload_allocate(dlthis->mysym,
+								  siz);
 	if (!sp) {
-		DL_ERROR(E_ALLOC, siz);
+		DL_ERROR(err_alloc, siz);
 		return;
 	}
 	dlthis->local_symtab = sp;
 	/* Read the symbols in the input, store them in the table, and post any
 	 * globals to the global symbol table.  In the process, externals
-	   become defined from the global symbol table */
+	 become defined from the global symbol table */
 	checks = dlthis->verify.dv_sym_tab_checksum;
-	symbols_left = s_count;
+	symbols_left = sym_count;
 	do {			/* read all symbols */
 		char *sname;
 		u32 val;
@@ -749,11 +755,11 @@ static void dload_symbols(struct dload_state *dlthis)
 		struct doff_syment_t my_sym_buf[MY_SYM_BUF_SIZ];
 		input_sym = my_sym_buf;
 		syms_in_buf = symbols_left > MY_SYM_BUF_SIZ ?
-					     MY_SYM_BUF_SIZ : symbols_left;
+		    MY_SYM_BUF_SIZ : symbols_left;
 		siz = syms_in_buf * sizeof(struct doff_syment_t);
 		if (dlthis->strm->read_buffer(dlthis->strm, input_sym, siz) !=
-					      siz) {
-			DL_ERROR(E_READSTRM, SYM_ERRID);
+		    siz) {
+			DL_ERROR(readstrm, sym_errid);
 			return;
 		}
 		if (dlthis->reorder_map)
@@ -769,14 +775,14 @@ static void dload_symbols(struct dload_state *dlthis)
 				if ((u32) input_sym->dn_offset <
 				    dlthis->dfile_hdr.df_strtab_size)
 					sname = dlthis->str_head +
-					     BYTE_TO_HOST(input_sym->dn_offset);
+					    BYTE_TO_HOST(input_sym->dn_offset);
 				else
 					dload_error(dlthis,
-						 "Bad name offset in symbol %d",
-						 symbols_left);
+						    "Bad name offset in symbol "
+						    " %d", symbols_left);
 #else
 				sname = unpack_name(dlthis,
-						   input_sym->dn_offset);
+						    input_sym->dn_offset);
 #endif
 			}
 			val = input_sym->dn_value;
@@ -784,43 +790,43 @@ static void dload_symbols(struct dload_state *dlthis)
 			sp->sclass = input_sym->dn_sclass;
 			sp->secnn = input_sym->dn_scnum;
 			/* if this is an undefined symbol,
-			 * define it (or fail) now	  */
+			 * define it (or fail) now */
 			if (sp->secnn == DN_UNDEF) {
-					/* pointless for static undefined */
+				/* pointless for static undefined */
 				if (input_sym->dn_sclass != DN_EXT)
 					goto loop_cont;
 
 				/* try to define symbol from previously
-				 * loaded images			  */
-				symp = dlthis->mysym->Find_Matching_Symbol
-						      (dlthis->mysym, sname);
+				 * loaded images */
+				symp = dlthis->mysym->find_matching_symbol
+				    (dlthis->mysym, sname);
 				if (!symp) {
 					DL_ERROR
-						("Undefined external symbol %s",
-						 sname);
+					    ("Undefined external symbol %s",
+					     sname);
 					goto loop_cont;
 				}
 				val = delta = symp->value;
 #ifdef ENABLE_TRAMP_DEBUG
 				dload_syms_error(dlthis->mysym,
-						"===> ext sym [%s] at %x",
-						sname, val);
+						 "===> ext sym [%s] at %x",
+						 sname, val);
 #endif
 
 				goto loop_cont;
 			}
 			/* symbol defined by this module */
-			if (sp->secnn > 0) {   /* symbol references a section */
+			if (sp->secnn > 0) {
+				/* symbol references a section */
 				if ((unsigned)sp->secnn <=
 				    dlthis->allocated_secn_count) {
 					/* section was allocated */
 					struct doff_scnhdr_t *srefp =
-							     &dlthis->sect_hdrs
-							     [sp->secnn - 1];
+					    &dlthis->sect_hdrs[sp->secnn - 1];
 
 					if (input_sym->dn_sclass ==
 					    DN_STATLAB ||
-					    input_sym->dn_sclass == DN_EXTLAB){
+					    input_sym->dn_sclass == DN_EXTLAB) {
 						/* load */
 						delta = srefp->ds_vaddr;
 					} else {
@@ -833,16 +839,19 @@ static void dload_symbols(struct dload_state *dlthis)
 			}
 			/* This symbol is an absolute symbol */
 			if (sp->secnn == DN_ABS && ((sp->sclass == DN_EXT) ||
-						   (sp->sclass == DN_EXTLAB))) {
-				symp = dlthis->mysym->Find_Matching_Symbol
-						      (dlthis->mysym, sname);
+						    (sp->sclass ==
+						     DN_EXTLAB))) {
+				symp =
+				    dlthis->mysym->find_matching_symbol(dlthis->
+									mysym,
+									sname);
 				if (!symp)
 					goto loop_itr;
-				/* This absolute symbol is already defined.  */
+				/* This absolute symbol is already defined. */
 				if (symp->value == input_sym->dn_value) {
 					/* If symbol values are equal, continue
 					 * but don't add to the global symbol
-					 * table			     */
+					 * table */
 					sp->value = val;
 					sp->delta = delta;
 					sp += 1;
@@ -852,14 +861,14 @@ static void dload_symbols(struct dload_state *dlthis)
 					/* If symbol values are not equal,
 					 * return with redefinition error */
 					DL_ERROR("Absolute symbol %s is "
-					   "defined multiple times with "
-					   "different values", sname);
+						 "defined multiple times with "
+						 "different values", sname);
 					return;
 				}
 			}
 loop_itr:
 			/* if this is a global symbol, post it to the
-			 * global table			       */
+			 * global table */
 			if (input_sym->dn_sclass == DN_EXT ||
 			    input_sym->dn_sclass == DN_EXTLAB) {
 				/* Keep this global symbol for subsequent
@@ -868,9 +877,9 @@ loop_itr:
 				if (!sname)
 					goto loop_cont;
 
-				newsym = dlthis->mysym->Add_To_Symbol_Table
-						    (dlthis->mysym, sname,
-						    (unsigned)dlthis->myhandle);
+				newsym = dlthis->mysym->add_to_symbol_table
+				    (dlthis->mysym, sname,
+				     (unsigned)dlthis->myhandle);
 				if (newsym)
 					newsym->value = val;
 
@@ -880,7 +889,7 @@ loop_cont:
 			sp->delta = delta;
 			sp += 1;
 			input_sym += 1;
-		} while ((syms_in_buf -= 1) > 0); /* process sym in buffer */
+		} while ((syms_in_buf -= 1) > 0);	/* process sym in buf */
 	} while (symbols_left > 0);	/* read all symbols */
 	if (~checks)
 		dload_error(dlthis, "Checksum of symbols failed");
@@ -898,15 +907,17 @@ loop_cont:
  *
  * WARNING:
  *	This routine is not allowed to declare errors!
- *****************************************************************************/
+ **************************************************************************** */
 static void symbol_table_free(struct dload_state *dlthis)
 {
 	if (dlthis->local_symtab) {
 		if (dlthis->dload_errcount) {	/* blow off our symbols */
-			dlthis->mysym->Purge_Symbol_Table(dlthis->mysym,
-						   (unsigned)dlthis->myhandle);
+			dlthis->mysym->purge_symbol_table(dlthis->mysym,
+							  (unsigned)
+							  dlthis->myhandle);
 		}
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->local_symtab);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->local_symtab);
 	}
 }				/* symbol_table_free */
 
@@ -922,8 +933,9 @@ static void symbol_table_free(struct dload_state *dlthis)
  */
 
 /* The following are only for use by reloc.c and things it calls */
-static const struct LDR_SECTION_INFO CINIT_INFO_INIT = { CINITNAME, 0, 0,
-					(LDR_ADDR) -1, 0, DLOAD_BSS, 0 };
+static const struct ldr_section_info cinit_info_init = { cinitname, 0, 0,
+	(ldr_addr) - 1, 0, DLOAD_BSS, 0
+};
 
 /*************************************************************************
  * Procedure cload_cinit
@@ -934,7 +946,7 @@ static const struct LDR_SECTION_INFO CINIT_INFO_INIT = { CINITNAME, 0, 0,
  * Effect:
  *	Interprets the data in the buffer as .cinit data, and performs the
  * appropriate initializations.
- ************************************************************************/
+ *********************************************************************** */
 static void cload_cinit(struct dload_state *dlthis,
 			struct image_packet_t *ipacket)
 {
@@ -943,92 +955,93 @@ static void cload_cinit(struct dload_state *dlthis,
 #else
 	s16 init_count, left;
 #endif
-	unsigned char *pktp = ipacket->i_bits;
-	unsigned char *pktend =	pktp +
-				BYTE_TO_HOST_ROUND(ipacket->i_packet_size);
+	unsigned char *pktp = ipacket->img_data;
+	unsigned char *pktend = pktp + BYTE_TO_HOST_ROUND(ipacket->packet_size);
 	int temp;
-	LDR_ADDR atmp;
-	struct LDR_SECTION_INFO cinit_info;
+	ldr_addr atmp;
+	struct ldr_section_info cinit_info;
 
-	/*  PROCESS ALL THE INITIALIZATION RECORDS IN THE BUFFER.  */
+	/*  PROCESS ALL THE INITIALIZATION RECORDS IN THE BUFFER. */
 	while (true) {
 		left = pktend - pktp;
 		switch (dlthis->cinit_state) {
-		case CI_count:	/* count field */
+		case CI_COUNT:	/* count field */
 			if (left < TDATA_TO_HOST(CINIT_COUNT))
 				goto loopexit;
-			temp = dload_unpack(dlthis, (TgtAU_t *)pktp,
-					CINIT_COUNT * TDATA_AU_BITS, 0,
-					ROP_SGN);
+			temp = dload_unpack(dlthis, (tgt_au_t *) pktp,
+					    CINIT_COUNT * TDATA_AU_BITS, 0,
+					    ROP_SGN);
 			pktp += TDATA_TO_HOST(CINIT_COUNT);
 			/* negative signifies BSS table, zero means done */
 			if (temp <= 0) {
-				dlthis->cinit_state = CI_done;
+				dlthis->cinit_state = CI_DONE;
 				break;
 			}
 			dlthis->cinit_count = temp;
-			dlthis->cinit_state = CI_address;
+			dlthis->cinit_state = CI_ADDRESS;
 			break;
 #if CINIT_ALIGN < CINIT_ADDRESS
-		case CI_partaddress:
+		case CI_PARTADDRESS:
 			pktp -= TDATA_TO_HOST(CINIT_ALIGN);
 			/* back up pointer into space courtesy of caller */
-			*(uint16_t *)pktp = dlthis->cinit_addr;
+			*(uint16_t *) pktp = dlthis->cinit_addr;
 			/* stuff in saved bits  !! FALL THRU !! */
 #endif
-		case CI_address:	/* Address field for a copy packet */
+		case CI_ADDRESS:	/* Address field for a copy packet */
 			if (left < TDATA_TO_HOST(CINIT_ADDRESS)) {
 #if CINIT_ALIGN < CINIT_ADDRESS
 				if (left == TDATA_TO_HOST(CINIT_ALIGN)) {
 					/* address broken into halves */
-					dlthis->cinit_addr = *(uint16_t *)pktp;
+					dlthis->cinit_addr = *(uint16_t *) pktp;
 					/* remember 1st half */
-					dlthis->cinit_state = CI_partaddress;
+					dlthis->cinit_state = CI_PARTADDRESS;
 					left = 0;
 				}
 #endif
 				goto loopexit;
 			}
-			atmp = dload_unpack(dlthis, (TgtAU_t *)pktp,
-					CINIT_ADDRESS * TDATA_AU_BITS, 0,
-					ROP_UNS);
+			atmp = dload_unpack(dlthis, (tgt_au_t *) pktp,
+					    CINIT_ADDRESS * TDATA_AU_BITS, 0,
+					    ROP_UNS);
 			pktp += TDATA_TO_HOST(CINIT_ADDRESS);
 #if CINIT_PAGE_BITS > 0
 			dlthis->cinit_page = atmp &
-					     ((1 << CINIT_PAGE_BITS) - 1);
+			    ((1 << CINIT_PAGE_BITS) - 1);
 			atmp >>= CINIT_PAGE_BITS;
 #else
 			dlthis->cinit_page = CINIT_DEFAULT_PAGE;
 #endif
 			dlthis->cinit_addr = atmp;
-			dlthis->cinit_state = CI_copy;
+			dlthis->cinit_state = CI_COPY;
 			break;
-		case CI_copy:	/* copy bits to the target */
+		case CI_COPY:	/* copy bits to the target */
 			init_count = HOST_TO_TDATA(left);
 			if (init_count > dlthis->cinit_count)
 				init_count = dlthis->cinit_count;
 			if (init_count == 0)
 				goto loopexit;	/* get more bits */
-			cinit_info = CINIT_INFO_INIT;
+			cinit_info = cinit_info_init;
 			cinit_info.page = dlthis->cinit_page;
 			if (!dlthis->myio->writemem(dlthis->myio, pktp,
-					TDATA_TO_TADDR(dlthis->cinit_addr),
-					&cinit_info,
-					TDATA_TO_HOST(init_count))) {
-				dload_error(dlthis, E_INITFAIL, "write",
+						    TDATA_TO_TADDR
+						    (dlthis->cinit_addr),
+						    &cinit_info,
+						    TDATA_TO_HOST(init_count)))
+			{
+				dload_error(dlthis, initfail, "write",
 					    dlthis->cinit_addr);
 			}
 			dlthis->cinit_count -= init_count;
-			if (dlthis->cinit_count  <= 0) {
-				dlthis->cinit_state = CI_count;
+			if (dlthis->cinit_count <= 0) {
+				dlthis->cinit_state = CI_COUNT;
 				init_count = (init_count + CINIT_ALIGN - 1) &
-					     -CINIT_ALIGN;
+				    -CINIT_ALIGN;
 				/* align to next init */
 			}
 			pktp += TDATA_TO_HOST(init_count);
 			dlthis->cinit_addr += init_count;
 			break;
-		case CI_done:	/* no more .cinit to do */
+		case CI_DONE:	/* no more .cinit to do */
 			return;
 		}		/* switch (cinit_state) */
 	}			/* while */
@@ -1036,7 +1049,7 @@ static void cload_cinit(struct dload_state *dlthis,
 loopexit:
 	if (left > 0) {
 		dload_error(dlthis, "%d bytes left over in cinit packet", left);
-		dlthis->cinit_state = CI_done;	/* left over bytes are bad */
+		dlthis->cinit_state = CI_DONE;	/* left over bytes are bad */
 	}
 }				/* cload_cinit */
 
@@ -1058,17 +1071,17 @@ loopexit:
  * Effect:
  *	Performs the required relocations on the packet.  Returns a checksum
  * of the relocation operations.
- ************************************************************************/
+ *********************************************************************** */
 #define MY_RELOC_BUF_SIZ 8
-/* careful! exists at the same time as the image buffer*/
+/* careful! exists at the same time as the image buffer */
 static int relocate_packet(struct dload_state *dlthis,
-				struct image_packet_t *ipacket,
-				u32 *checks, bool *tramps_generated)
+			   struct image_packet_t *ipacket,
+			   u32 *checks, bool *tramps_generated)
 {
 	u32 rnum;
 	*tramps_generated = false;
 
-	rnum = ipacket->i_num_relocs;
+	rnum = ipacket->num_relocs;
 	do {			/* all relocs */
 		unsigned rinbuf;
 		int siz;
@@ -1077,7 +1090,7 @@ static int relocate_packet(struct dload_state *dlthis,
 		rinbuf = rnum > MY_RELOC_BUF_SIZ ? MY_RELOC_BUF_SIZ : rnum;
 		siz = rinbuf * sizeof(struct reloc_record_t);
 		if (dlthis->strm->read_buffer(dlthis->strm, rp, siz) != siz) {
-			DL_ERROR(E_READSTRM, "relocation");
+			DL_ERROR(readstrm, "relocation");
 			return 0;
 		}
 		/* reorder the bytes if need be */
@@ -1087,19 +1100,20 @@ static int relocate_packet(struct dload_state *dlthis,
 		*checks += dload_checksum(rp, siz);
 		do {
 			/* perform the relocation operation */
-			dload_relocate(dlthis, (TgtAU_t *) ipacket->i_bits, rp,
-					tramps_generated, false);
+			dload_relocate(dlthis, (tgt_au_t *) ipacket->img_data,
+				       rp, tramps_generated, false);
 			rp += 1;
 			rnum -= 1;
 		} while ((rinbuf -= 1) > 0);
 	} while (rnum > 0);	/* all relocs */
 	/* If trampoline(s) were generated, we need to do an update of the
 	 * trampoline copy of the packet since a 2nd phase relo will be done
-	 * later.  */
+	 * later. */
 	if (*tramps_generated == true) {
 		dload_tramp_pkt_udpate(dlthis,
-				(dlthis->image_secn - dlthis->ldr_sections),
-				dlthis->image_offset, ipacket);
+				       (dlthis->image_secn -
+					dlthis->ldr_sections),
+				       dlthis->image_offset, ipacket);
 	}
 
 	return 1;
@@ -1108,7 +1122,7 @@ static int relocate_packet(struct dload_state *dlthis,
 #define IPH_SIZE (sizeof(struct image_packet_t) - sizeof(u32))
 
 /* VERY dangerous */
-static const char IMAGEPAK[] = { "image packet" };
+static const char imagepak[] = { "image packet" };
 
 /*************************************************************************
  * Procedure dload_data
@@ -1119,16 +1133,16 @@ static const char IMAGEPAK[] = { "image packet" };
  * Effect:
  *	Read image data from input file, relocate it, and download it to the
  *	target.
- ************************************************************************/
+ *********************************************************************** */
 static void dload_data(struct dload_state *dlthis)
 {
 	u16 curr_sect;
 	struct doff_scnhdr_t *sptr = dlthis->sect_hdrs;
-	struct LDR_SECTION_INFO *lptr = dlthis->ldr_sections;
+	struct ldr_section_info *lptr = dlthis->ldr_sections;
 #ifdef OPT_ZERO_COPY_LOADER
-	bool bZeroCopy = false;
+	bool zero_copy = false;
 #endif
-	u8 *pDest;
+	u8 *dest;
 
 	struct {
 		struct image_packet_t ipacket;
@@ -1144,7 +1158,7 @@ static void dload_data(struct dload_state *dlthis)
 	     curr_sect += 1) {
 		if (DS_NEEDS_DOWNLOAD(sptr)) {
 			s32 nip;
-			LDR_ADDR image_offset = 0;
+			ldr_addr image_offset = 0;
 			/* set relocation info for this section */
 			if (curr_sect < dlthis->allocated_secn_count)
 				dlthis->delta_runaddr = sptr->ds_paddr;
@@ -1161,12 +1175,14 @@ static void dload_data(struct dload_state *dlthis)
 
 				s32 ipsize;
 				u32 checks;
-				bool  tramp_generated = false;
+				bool tramp_generated = false;
 
 				/* get the fixed header bits */
 				if (dlthis->strm->read_buffer(dlthis->strm,
-				    &ibuf.ipacket, IPH_SIZE) != IPH_SIZE) {
-					DL_ERROR(E_READSTRM, IMAGEPAK);
+							      &ibuf.ipacket,
+							      IPH_SIZE) !=
+				    IPH_SIZE) {
+					DL_ERROR(readstrm, imagepak);
 					return;
 				}
 				/* reorder the header if need be */
@@ -1177,72 +1193,76 @@ static void dload_data(struct dload_state *dlthis)
 				/* now read the rest of the packet */
 				ipsize =
 				    BYTE_TO_HOST(DOFF_ALIGN
-						(ibuf.ipacket.i_packet_size));
+						 (ibuf.ipacket.packet_size));
 				if (ipsize > BYTE_TO_HOST(IMAGE_PACKET_SIZE)) {
 					DL_ERROR("Bad image packet size %d",
-						ipsize);
+						 ipsize);
 					return;
 				}
-				pDest = ibuf.bufr;
+				dest = ibuf.bufr;
 #ifdef OPT_ZERO_COPY_LOADER
-				bZeroCopy = false;
+				zero_copy = false;
 				if (DLOAD_SECT_TYPE(sptr) != DLOAD_CINIT) {
 					dlthis->myio->writemem(dlthis->myio,
-						&pDest, lptr->load_addr +
-						image_offset, lptr, 0);
-				bZeroCopy = (pDest != ibuf.bufr);
+							       &dest,
+							       lptr->load_addr +
+							       image_offset,
+							       lptr, 0);
+					zero_copy = (dest != ibuf.bufr);
 				}
 #endif
-		/* End of determination */
+				/* End of determination */
 
 				if (dlthis->strm->read_buffer(dlthis->strm,
-				    ibuf.bufr, ipsize) != ipsize) {
-					DL_ERROR(E_READSTRM, IMAGEPAK);
+							      ibuf.bufr,
+							      ipsize) !=
+				    ipsize) {
+					DL_ERROR(readstrm, imagepak);
 					return;
 				}
-				ibuf.ipacket.i_bits = pDest;
+				ibuf.ipacket.img_data = dest;
 
 				/* reorder the bytes if need be */
 #if !defined(_BIG_ENDIAN) || (TARGET_AU_BITS > 16)
 				if (dlthis->reorder_map) {
-					dload_reorder(pDest, ipsize,
-						     dlthis->reorder_map);
+					dload_reorder(dest, ipsize,
+						      dlthis->reorder_map);
 				}
-				checks = dload_checksum(pDest, ipsize);
+				checks = dload_checksum(dest, ipsize);
 #else
 				if (dlthis->dfile_hdr.df_byte_reshuffle !=
 				    TARGET_ORDER(REORDER_MAP
-				    (BYTE_RESHUFFLE_VALUE))) {
+						 (BYTE_RESHUFFLE_VALUE))) {
 					/* put image bytes in big-endian order,
 					 * not PC order */
-					dload_reorder(pDest, ipsize,
-					TARGET_ORDER
-					(dlthis->dfile_hdr.df_byte_reshuffle));
+					dload_reorder(dest, ipsize,
+						      TARGET_ORDER
+						      (dlthis->dfile_hdr.
+						       df_byte_reshuffle));
 				}
 #if TARGET_AU_BITS > 8
-				checks = dload_reverse_checksum_16(pDest,
-								   ipsize);
+				checks = dload_reverse_checksum16(dest, ipsize);
 #else
-				checks = dload_reverse_checksum(pDest,
-								ipsize);
+				checks = dload_reverse_checksum(dest, ipsize);
 #endif
 #endif
 
 				checks += dload_checksum(&ibuf.ipacket,
-							IPH_SIZE);
+							 IPH_SIZE);
 				/* relocate the image bits as needed */
-				if (ibuf.ipacket.i_num_relocs) {
+				if (ibuf.ipacket.num_relocs) {
 					dlthis->image_offset = image_offset;
 					if (!relocate_packet(dlthis,
-					    &ibuf.ipacket, &checks,
-					    &tramp_generated))
+							     &ibuf.ipacket,
+							     &checks,
+							     &tramp_generated))
 						return;	/* serious error */
 				}
 				if (~checks)
-					DL_ERROR(E_CHECKSUM, IMAGEPAK);
+					DL_ERROR(err_checksum, imagepak);
 				/* Only write the result to the target if no
-				  * trampoline was generated.  Otherwise it
-				  *will be done during trampoline finalize.  */
+				 * trampoline was generated.  Otherwise it
+				 *will be done during trampoline finalize. */
 
 				if (tramp_generated == false) {
 
@@ -1251,30 +1271,40 @@ static void dload_data(struct dload_state *dlthis)
 					if (DLOAD_SECT_TYPE(sptr) ==
 					    DLOAD_CINIT) {
 						cload_cinit(dlthis,
-							&ibuf.ipacket);
+							    &ibuf.ipacket);
 						cinit_processed = true;
 					} else {
 #ifdef OPT_ZERO_COPY_LOADER
-						if (!bZeroCopy) {
+						if (!zero_copy) {
 #endif
-						if (!dlthis->myio->writemem
-						(dlthis->myio, ibuf.bufr,
-						lptr->load_addr + image_offset,
-						lptr, BYTE_TO_HOST
-						(ibuf.ipacket.i_packet_size))) {
-							DL_ERROR(
-							"Write to " FMT_UI32
-							" failed",
-							lptr->load_addr +
-							image_offset);
-						}
+							/* FIXME */
+							if (!dlthis->myio->
+							    writemem(dlthis->
+								myio,
+								ibuf.bufr,
+								lptr->
+								load_addr +
+								image_offset,
+								lptr,
+								BYTE_TO_HOST
+								(ibuf.
+								ipacket.
+								packet_size))) {
+								DL_ERROR
+								  ("Write to "
+								  FMT_UI32
+								  " failed",
+								  lptr->
+								  load_addr +
+								  image_offset);
+							}
 #ifdef OPT_ZERO_COPY_LOADER
-					}
+						}
 #endif
 					}
 				}
 				image_offset +=
-				      BYTE_TO_TADDR(ibuf.ipacket.i_packet_size);
+				    BYTE_TO_TADDR(ibuf.ipacket.packet_size);
 			}	/* process packets */
 			/* if this is a BSS section, we may want to fill it */
 			if (DLOAD_SECT_TYPE(sptr) != DLOAD_BSS)
@@ -1287,17 +1317,19 @@ static void dload_data(struct dload_state *dlthis)
 				/* Don't clear BSS after load-time
 				 * initialization */
 				DL_ERROR
-				  ("Zero-initialization at " FMT_UI32 " after "
-				  "load-time initialization!", lptr->load_addr);
+				    ("Zero-initialization at " FMT_UI32
+				     " after " "load-time initialization!",
+				     lptr->load_addr);
 				goto loop_cont;
 			}
 			/* fill the .bss area */
 			dlthis->myio->fillmem(dlthis->myio,
 					      TADDR_TO_HOST(lptr->load_addr),
 					      lptr, TADDR_TO_HOST(lptr->size),
-					      dload_fill_bss);
+					      DLOAD_FILL_BSS);
 			goto loop_cont;
-		} /* if DS_DOWNLOAD_MASK */
+		}
+		/* if DS_DOWNLOAD_MASK */
 		/* If not loading, but BSS, zero initialize */
 		if (DLOAD_SECT_TYPE(sptr) != DLOAD_BSS)
 			goto loop_cont;
@@ -1310,25 +1342,26 @@ static void dload_data(struct dload_state *dlthis)
 
 		if (cinit_processed) {
 			/*Don't clear BSS after load-time initialization */
-			DL_ERROR(
-			 "Zero-initialization at " FMT_UI32 " attempted after "
-			 "load-time initialization!", lptr->load_addr);
+			DL_ERROR("Zero-initialization at " FMT_UI32
+				 " attempted after "
+				 "load-time initialization!", lptr->load_addr);
 			goto loop_cont;
 		}
 		/* fill the .bss area */
 		dlthis->myio->fillmem(dlthis->myio,
-				     TADDR_TO_HOST(lptr->load_addr), lptr,
-				     TADDR_TO_HOST(lptr->size), dload_fill_bss);
+				      TADDR_TO_HOST(lptr->load_addr), lptr,
+				      TADDR_TO_HOST(lptr->size),
+				      DLOAD_FILL_BSS);
 loop_cont:
 		sptr += 1;
 		lptr += 1;
 	}			/* load sections */
 
-	/*  Finalize any trampolines that were created during the load  */
+	/*  Finalize any trampolines that were created during the load */
 	if (dload_tramp_finalize(dlthis) == 0) {
 		DL_ERROR("Finalization of auto-trampolines (size = " FMT_UI32
-			") failed", dlthis->tramp.tramp_sect_next_addr);
-    }
+			 ") failed", dlthis->tramp.tramp_sect_next_addr);
+	}
 }				/* dload_data */
 
 /*************************************************************************
@@ -1344,14 +1377,14 @@ loop_cont:
  * Effect:
  *	Re-arranges the bytes in each word according to the map specified.
  *
- ************************************************************************/
+ *********************************************************************** */
 /* mask for byte shift count */
 #define SHIFT_COUNT_MASK (3 << LOG_BITS_PER_BYTE)
 
 void dload_reorder(void *data, int dsiz, unsigned int map)
 {
 	register u32 tmp, tmap, datv;
-	u32 *dp = (u32 *)data;
+	u32 *dp = (u32 *) data;
 
 	map <<= LOG_BITS_PER_BYTE;	/* align map with SHIFT_COUNT_MASK */
 	do {
@@ -1376,7 +1409,7 @@ void dload_reorder(void *data, int dsiz, unsigned int map)
  * Effect:
  *	Returns a checksum of the specified block
  *
- ************************************************************************/
+ *********************************************************************** */
 u32 dload_checksum(void *data, unsigned siz)
 {
 	u32 sum;
@@ -1384,7 +1417,7 @@ u32 dload_checksum(void *data, unsigned siz)
 	int left;
 
 	sum = 0;
-	dp = (u32 *)data;
+	dp = (u32 *) data;
 	for (left = siz; left > 0; left -= sizeof(u32))
 		sum += *dp++;
 	return sum;
@@ -1407,7 +1440,7 @@ u32 dload_checksum(void *data, unsigned siz)
  * in host order. But dllcreate always checksums in little-endian order.
  * It is most efficient to just handle the difference a word at a time.
  *
- ***********************************************************************/
+ ********************************************************************** */
 u32 dload_reverse_checksum(void *data, unsigned siz)
 {
 	u32 sum, temp;
@@ -1415,7 +1448,7 @@ u32 dload_reverse_checksum(void *data, unsigned siz)
 	int left;
 
 	sum = 0;
-	dp = (u32 *)data;
+	dp = (u32 *) data;
 
 	for (left = siz; left > 0; left -= sizeof(u32)) {
 		temp = *dp++;
@@ -1429,14 +1462,14 @@ u32 dload_reverse_checksum(void *data, unsigned siz)
 }				/* dload_reverse_checksum */
 
 #if (TARGET_AU_BITS > 8) && (TARGET_AU_BITS < 32)
-u32 dload_reverse_checksum_16(void *data, unsigned siz)
+u32 dload_reverse_checksum16(void *data, unsigned siz)
 {
 	uint_fast32_t sum, temp;
 	u32 *dp;
 	int left;
 
 	sum = 0;
-	dp = (u32 *)data;
+	dp = (u32 *) data;
 
 	for (left = siz; left > 0; left -= sizeof(u32)) {
 		temp = *dp++;
@@ -1445,7 +1478,7 @@ u32 dload_reverse_checksum_16(void *data, unsigned siz)
 	}
 
 	return sum;
-}				/* dload_reverse_checksum_16 */
+}				/* dload_reverse_checksum16 */
 #endif
 #endif
 
@@ -1461,7 +1494,7 @@ u32 dload_reverse_checksum_16(void *data, unsigned siz)
  * Effect:
  *	Swaps the specified data according to the specified map
  *
- ************************************************************************/
+ *********************************************************************** */
 static void swap_words(void *data, unsigned siz, unsigned bitmap)
 {
 	register int i;
@@ -1513,11 +1546,11 @@ static void swap_words(void *data, unsigned siz, unsigned bitmap)
  * target addressable unit order).  Makes sure the last string in the
  * buffer is NULL terminated (for safety).
  * Returns the first unused destination address.
- ************************************************************************/
+ *********************************************************************** */
 static char *copy_tgt_strings(void *dstp, void *srcp, unsigned charcount)
 {
-	register TgtAU_t *src = (TgtAU_t *)srcp;
-	register TgtAU_t *dst = (TgtAU_t *)dstp;
+	register tgt_au_t *src = (tgt_au_t *) srcp;
+	register tgt_au_t *dst = (tgt_au_t *) dstp;
 	register int cnt = charcount;
 	do {
 #if TARGET_AU_BITS <= BITS_PER_AU
@@ -1526,12 +1559,13 @@ static char *copy_tgt_strings(void *dstp, void *srcp, unsigned charcount)
 #else
 		*dst++ = *src++;
 #endif
-	} while ((cnt -= (sizeof(TgtAU_t) * BITS_PER_AU / BITS_PER_BYTE)) > 0);
+	} while ((cnt -= (sizeof(tgt_au_t) * BITS_PER_AU / BITS_PER_BYTE)) > 0);
 	/*apply force to make sure that the string table has null terminator */
 #if (BITS_PER_AU == BITS_PER_BYTE) && (TARGET_AU_BITS == BITS_PER_BYTE)
 	dst[-1] = 0;
 #else
-	dst[-1] &= (1 << (BITS_PER_AU - BITS_PER_BYTE)) - 1; /* little endian */
+	/* little endian */
+	dst[-1] &= (1 << (BITS_PER_AU - BITS_PER_BYTE)) - 1;
 #endif
 	return (char *)dst;
 }				/* copy_tgt_strings */
@@ -1547,38 +1581,40 @@ static char *copy_tgt_strings(void *dstp, void *srcp, unsigned charcount)
  * the debug information required by the target.
  *
  * Notes:
- * The handle returned from Dynamic_Load_Module needs to encapsulate all the
+ * The handle returned from dynamic_load_module needs to encapsulate all the
  * allocations done for the module, and enable them plus the modules symbols to
  * be deallocated.
  *
- ************************************************************************/
+ *********************************************************************** */
 #ifndef _BIG_ENDIAN
-static const struct LDR_SECTION_INFO DLLVIEW_INFO_INIT = { ".dllview", 0, 0,
-				(LDR_ADDR) -1, DBG_LIST_PAGE, DLOAD_DATA, 0 };
+static const struct ldr_section_info dllview_info_init = { ".dllview", 0, 0,
+	(ldr_addr) - 1, DBG_LIST_PAGE, DLOAD_DATA, 0
+};
 #else
-static const struct LDR_SECTION_INFO DLLVIEW_INFO_INIT = { ".dllview", 0, 0,
-				(LDR_ADDR) -1, DLOAD_DATA, DBG_LIST_PAGE, 0 };
+static const struct ldr_section_info dllview_info_init = { ".dllview", 0, 0,
+	(ldr_addr) - 1, DLOAD_DATA, DBG_LIST_PAGE, 0
+};
 #endif
 static void init_module_handle(struct dload_state *dlthis)
 {
 	struct my_handle *hndl;
 	u16 curr_sect;
-	struct LDR_SECTION_INFO *asecs;
+	struct ldr_section_info *asecs;
 	struct dll_module *dbmod;
 	struct dll_sect *dbsec;
 	struct dbg_mirror_root *mlist;
 	register char *cp;
 	struct modules_header mhdr;
-	struct LDR_SECTION_INFO dllview_info;
+	struct ldr_section_info dllview_info;
 	struct dynload_symbol *debug_mirror_sym;
 	hndl = dlthis->myhandle;
 	if (!hndl)
 		return;		/* must be errors detected, so forget it */
 
-	/*  Store the section count  */
+	/*  Store the section count */
 	hndl->secn_count = dlthis->allocated_secn_count;
 
-	/*  If a trampoline section was created, add it in  */
+	/*  If a trampoline section was created, add it in */
 	if (dlthis->tramp.tramp_sect_next_addr != 0)
 		hndl->secn_count += 1;
 
@@ -1591,30 +1627,31 @@ static void init_module_handle(struct dload_state *dlthis)
 #endif
 	if (dlthis->dload_errcount)
 		return;		/* abandon if errors detected */
-	 /* Locate the symbol that names the header for the CCS debug list
-	 of modules. If not found, we just don't generate the debug record.
-	 If found, we create our modules list.  We make sure to create the
-	 LOADER_DLLVIEW_ROOT even if there is no relocation info to record,
-	 just to try to put both symbols in the same symbol table and
-	 module.*/
-	debug_mirror_sym = dlthis->mysym->Find_Matching_Symbol(dlthis->mysym,
-						LOADER_DLLVIEW_ROOT);
+	/* Locate the symbol that names the header for the CCS debug list
+	   of modules. If not found, we just don't generate the debug record.
+	   If found, we create our modules list.  We make sure to create the
+	   loader_dllview_root even if there is no relocation info to record,
+	   just to try to put both symbols in the same symbol table and
+	   module. */
+	debug_mirror_sym = dlthis->mysym->find_matching_symbol(dlthis->mysym,
+							loader_dllview_root);
 	if (!debug_mirror_sym) {
 		struct dynload_symbol *dlmodsym;
 		struct dbg_mirror_root *mlst;
 
 		/* our root symbol is not yet present;
 		   check if we have DLModules defined */
-		dlmodsym = dlthis->mysym->Find_Matching_Symbol(dlthis->mysym,
+		dlmodsym = dlthis->mysym->find_matching_symbol(dlthis->mysym,
 							LINKER_MODULES_HEADER);
 		if (!dlmodsym)
 			return;	/* no DLModules list so no debug info */
 		/* if we have DLModules defined, construct our header */
 		mlst = (struct dbg_mirror_root *)
-			dlthis->mysym->Allocate(dlthis->mysym,
-			sizeof(struct dbg_mirror_root));
+		    dlthis->mysym->dload_allocate(dlthis->mysym,
+						  sizeof(struct
+							 dbg_mirror_root));
 		if (!mlst) {
-			DL_ERROR(E_ALLOC, sizeof(struct dbg_mirror_root));
+			DL_ERROR(err_alloc, sizeof(struct dbg_mirror_root));
 			return;
 		}
 		mlst->hnext = NULL;
@@ -1622,19 +1659,19 @@ static void init_module_handle(struct dload_state *dlthis)
 		mlst->refcount = 0;
 		mlst->dbthis = TDATA_TO_TADDR(dlmodsym->value);
 		/* add our root symbol */
-		debug_mirror_sym = dlthis->mysym->Add_To_Symbol_Table
-			(dlthis->mysym, LOADER_DLLVIEW_ROOT,
-			(unsigned)dlthis->myhandle);
+		debug_mirror_sym = dlthis->mysym->add_to_symbol_table
+		    (dlthis->mysym, loader_dllview_root,
+		     (unsigned)dlthis->myhandle);
 		if (!debug_mirror_sym) {
 			/* failed, recover memory */
-			dlthis->mysym->Deallocate(dlthis->mysym, mlst);
+			dlthis->mysym->dload_deallocate(dlthis->mysym, mlst);
 			return;
 		}
-		debug_mirror_sym->value = (u32)mlst;
+		debug_mirror_sym->value = (u32) mlst;
 	}
-	 /* First create the DLLview record and stuff it into the buffer.
-	 Then write it to the DSP.  Record pertinent locations in our hndl,
-	  and add it to the per-processor list of handles with debug info.*/
+	/* First create the DLLview record and stuff it into the buffer.
+	   Then write it to the DSP.  Record pertinent locations in our hndl,
+	   and add it to the per-processor list of handles with debug info. */
 #ifndef DEBUG_HEADER_IN_LOADER
 	mlist = (struct dbg_mirror_root *)debug_mirror_sym->value;
 	if (!mlist)
@@ -1646,8 +1683,8 @@ static void init_module_handle(struct dload_state *dlthis)
 	if (!dlthis->allocated_secn_count)
 		return;		/* no load addresses to be recorded */
 	/* reuse temporary symbol storage */
-	dbmod = (struct dll_module *) dlthis->local_symtab;
-	 /* Create the DLLview record in the memory we retain for our handle*/
+	dbmod = (struct dll_module *)dlthis->local_symtab;
+	/* Create the DLLview record in the memory we retain for our handle */
 	dbmod->num_sects = dlthis->allocated_secn_count;
 	dbmod->timestamp = dlthis->verify.dv_timdat;
 	dbmod->version = INIT_VERSION;
@@ -1662,7 +1699,7 @@ static void init_module_handle(struct dload_state *dlthis)
 		asecs += 1;
 	}
 
-	/*  If a trampoline section was created go ahead and add its info  */
+	/*  If a trampoline section was created go ahead and add its info */
 	if (dlthis->tramp.tramp_sect_next_addr != 0) {
 		dbmod->num_sects++;
 		dbsec->sect_load_adr = asecs->load_addr;
@@ -1675,20 +1712,19 @@ static void init_module_handle(struct dload_state *dlthis)
 	cp = copy_tgt_strings(dbsec, dlthis->str_head,
 			      dlthis->debug_string_size);
 
-
 	/* If a trampoline section was created, add its name so DLLView
-	 * can show the user the section info.  */
+	 * can show the user the section info. */
 	if (dlthis->tramp.tramp_sect_next_addr != 0) {
 		cp = copy_tgt_strings(cp,
-			dlthis->tramp.final_string_table,
-			strlen(dlthis->tramp.final_string_table) + 1);
+				      dlthis->tramp.final_string_table,
+				      strlen(dlthis->tramp.final_string_table) +
+				      1);
 	}
 
-
 	/* round off the size of the debug record, and remember same */
 	hndl->dm.dbsiz = HOST_TO_TDATA_ROUND(cp - (char *)dbmod);
 	*cp = 0;		/* strictly to make our test harness happy */
-	dllview_info = DLLVIEW_INFO_INIT;
+	dllview_info = dllview_info_init;
 	dllview_info.size = TDATA_TO_TADDR(hndl->dm.dbsiz);
 	/* Initialize memory context to default heap */
 	dllview_info.context = 0;
@@ -1704,8 +1740,8 @@ static void init_module_handle(struct dload_state *dlthis)
 	/* allocate memory for on-DSP DLLview debug record */
 	if (!dlthis->myalloc)
 		return;
-	if (!dlthis->myalloc->Allocate(dlthis->myalloc, &dllview_info,
-		     HOST_TO_TADDR(sizeof(u32)))) {
+	if (!dlthis->myalloc->dload_allocate(dlthis->myalloc, &dllview_info,
+					     HOST_TO_TADDR(sizeof(u32)))) {
 		return;
 	}
 	/* Store load address of .dllview section */
@@ -1719,10 +1755,10 @@ static void init_module_handle(struct dload_state *dlthis)
 		swap_words(dbmod, (char *)dbsec - (char *)dbmod,
 			   DLL_MODULE_BITMAP);
 	}
-	 /* Update the DLLview list on the DSP write new record */
+	/* Update the DLLview list on the DSP write new record */
 	if (!dlthis->myio->writemem(dlthis->myio, dbmod,
-		dllview_info.load_addr, &dllview_info,
-		TADDR_TO_HOST(dllview_info.size))) {
+				    dllview_info.load_addr, &dllview_info,
+				    TADDR_TO_HOST(dllview_info.size))) {
 		return;
 	}
 	/* write new header */
@@ -1733,26 +1769,27 @@ static void init_module_handle(struct dload_state *dlthis)
 		swap_words(&mhdr, sizeof(struct modules_header) - sizeof(u16),
 			   MODULES_HEADER_BITMAP);
 	}
-	dllview_info = DLLVIEW_INFO_INIT;
+	dllview_info = dllview_info_init;
 	if (!dlthis->myio->writemem(dlthis->myio, &mhdr, mlist->dbthis,
-			&dllview_info, sizeof(struct modules_header) -
-				       sizeof(u16))) {
+				    &dllview_info,
+				    sizeof(struct modules_header) -
+				    sizeof(u16))) {
 		return;
 	}
-	 /* Add the module handle to this processor's list
-		of handles with debug info */
+	/* Add the module handle to this processor's list
+	   of handles with debug info */
 	hndl->dm.hnext = mlist->hnext;
 	if (hndl->dm.hnext)
 		hndl->dm.hnext->dm.hprev = hndl;
-	hndl->dm.hprev = (struct my_handle *) mlist;
-	mlist->hnext = hndl;	/* insert after root*/
+	hndl->dm.hprev = (struct my_handle *)mlist;
+	mlist->hnext = hndl;	/* insert after root */
 }				/* init_module_handle */
 
 /*************************************************************************
- * Procedure Dynamic_Unload_Module
+ * Procedure dynamic_unload_module
  *
  * Parameters:
- *	mhandle	A module handle from Dynamic_Load_Module
+ *	mhandle	A module handle from dynamic_load_module
  *	syms	Host-side symbol table and malloc/free functions
  *	alloc	Target-side memory allocation
  *
@@ -1764,42 +1801,42 @@ static void init_module_handle(struct dload_state *dlthis)
  *
  * Returns:
  *	Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report().
- ************************************************************************/
-int Dynamic_Unload_Module(DLOAD_mhandle mhandle,
-		struct Dynamic_Loader_Sym *syms,
-		struct Dynamic_Loader_Allocate *alloc,
-		struct Dynamic_Loader_Initialize *init)
+ * Individual errors are reported using syms->error_report().
+ *********************************************************************** */
+int dynamic_unload_module(dload_mhandle mhandle,
+			  struct dynamic_loader_sym *syms,
+			  struct dynamic_loader_allocate *alloc,
+			  struct dynamic_loader_initialize *init)
 {
 	s16 curr_sect;
-	struct LDR_SECTION_INFO *asecs;
+	struct ldr_section_info *asecs;
 	struct my_handle *hndl;
 	struct dbg_mirror_root *root;
 	unsigned errcount = 0;
-	struct LDR_SECTION_INFO dllview_info = DLLVIEW_INFO_INIT;
+	struct ldr_section_info dllview_info = dllview_info_init;
 	struct modules_header mhdr;
 
 	hndl = (struct my_handle *)mhandle;
 	if (!hndl)
 		return 0;	/* if handle is null, nothing to do */
-	 /* Clear out the module symbols
+	/* Clear out the module symbols
 	 * Note that if this is the module that defined MODULES_HEADER
-	  (the head of the target debug list)
+	 (the head of the target debug list)
 	 * then this operation will blow away that symbol.
 	 It will therefore be impossible for subsequent
-	 * operations to add entries to this un-referenceable list.*/
+	 * operations to add entries to this un-referenceable list. */
 	if (!syms)
 		return 1;
-	syms->Purge_Symbol_Table(syms, (unsigned) hndl);
-	 /* Deallocate target memory for sections
-	  * NOTE: The trampoline section, if created, gets deleted here, too */
+	syms->purge_symbol_table(syms, (unsigned)hndl);
+	/* Deallocate target memory for sections
+	 * NOTE: The trampoline section, if created, gets deleted here, too */
 
 	asecs = hndl->secns;
 	if (alloc)
 		for (curr_sect = (hndl->secn_count >> 1); curr_sect > 0;
 		     curr_sect -= 1) {
 			asecs->name = NULL;
-			alloc->Deallocate(alloc, asecs++);
+			alloc->dload_deallocate(alloc, asecs++);
 		}
 	root = hndl->dm.hroot;
 	if (!root) {
@@ -1819,9 +1856,9 @@ int Dynamic_Unload_Module(DLOAD_mhandle mhandle,
 	hndl->dm.hprev->dm.hnext = hndl->dm.hnext;
 	if (hndl->dm.hnext)
 		hndl->dm.hnext->dm.hprev = hndl->dm.hprev;
-	 /* Update next_module of previous entry in target list
+	/* Update next_module of previous entry in target list
 	 * We are using mhdr here as a surrogate for either a
-	 struct modules_header or a dll_module	 */
+	 struct modules_header or a dll_module */
 	if (hndl->dm.hnext) {
 		mhdr.first_module = TADDR_TO_TDATA(hndl->dm.hnext->dm.dbthis);
 		mhdr.first_module_size = hndl->dm.hnext->dm.dbsiz;
@@ -1833,7 +1870,7 @@ int Dynamic_Unload_Module(DLOAD_mhandle mhandle,
 		goto exitunltgt;
 
 	if (!init->connect(init)) {
-		dload_syms_error(syms, E_ICONNECT);
+		dload_syms_error(syms, iconnect);
 		errcount += 1;
 		goto exitunltgt;
 	}
@@ -1845,18 +1882,17 @@ int Dynamic_Unload_Module(DLOAD_mhandle mhandle,
 	if (!init->writemem(init, &mhdr, hndl->dm.hprev->dm.dbthis,
 			    &dllview_info, sizeof(struct modules_header) -
 			    sizeof(mhdr.update_flag))) {
-		dload_syms_error(syms, E_DLVWRITE);
+		dload_syms_error(syms, dlvwrite);
 		errcount += 1;
 	}
 	/* update change counter */
 	root->changes += 1;
 	if (!init->writemem(init, &(root->changes),
-				root->dbthis + HOST_TO_TADDR
-				      (sizeof(mhdr.first_module) +
-				      sizeof(mhdr.first_module_size)),
-				      &dllview_info,
-				      sizeof(mhdr.update_flag))) {
-		dload_syms_error(syms, E_DLVWRITE);
+			    root->dbthis + HOST_TO_TADDR
+			    (sizeof(mhdr.first_module) +
+			     sizeof(mhdr.first_module_size)),
+			    &dllview_info, sizeof(mhdr.update_flag))) {
+		dload_syms_error(syms, dlvwrite);
 		errcount += 1;
 	}
 	init->release(init);
@@ -1865,7 +1901,7 @@ exitunltgt:
 	dllview_info.size = TDATA_TO_TADDR(hndl->dm.dbsiz);
 	dllview_info.load_addr = hndl->dm.dbthis;
 	if (alloc)
-		alloc->Deallocate(alloc, &dllview_info);
+		alloc->dload_deallocate(alloc, &dllview_info);
 	root->refcount -= 1;
 	/* target-side dllview record exists */
 loop_end:
@@ -1874,16 +1910,16 @@ loop_end:
 		/* if all references gone, blow off the header */
 		/* our root symbol may be gone due to the Purge above,
 		   but if not, do not destroy the root */
-		if (syms->Find_Matching_Symbol
-			(syms, LOADER_DLLVIEW_ROOT) == NULL)
-			syms->Deallocate(syms, root);
+		if (syms->find_matching_symbol
+		    (syms, loader_dllview_root) == NULL)
+			syms->dload_deallocate(syms, root);
 	}
 #endif
 func_end:
 	/* there is a debug list containing this module */
-	syms->Deallocate(syms, mhandle);	/* release our storage */
+	syms->dload_deallocate(syms, mhandle);	/* release our storage */
 	return errcount;
-}				/* Dynamic_Unload_Module */
+}				/* dynamic_unload_module */
 
 #if BITS_PER_AU > BITS_PER_BYTE
 /*************************************************************************
@@ -1896,7 +1932,7 @@ func_end:
  *	Returns a pointer to the string specified by the offset supplied, or
  * NULL for error.
  *
- ************************************************************************/
+ *********************************************************************** */
 static char *unpack_name(struct dload_state *dlthis, u32 soffset)
 {
 	u8 tmp, *src;
@@ -1907,7 +1943,7 @@ static char *unpack_name(struct dload_state *dlthis, u32 soffset)
 			    soffset);
 		return NULL;
 	}
-	src = (uint_least8_t *)dlthis->str_head +
+	src = (uint_least8_t *) dlthis->str_head +
 	    (soffset >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE));
 	dst = dlthis->str_temp;
 	if (soffset & 1)
diff --git a/drivers/dsp/bridge/dynload/dload_internal.h b/drivers/dsp/bridge/dynload/dload_internal.h
index 8595d7a..12ac6c1 100644
--- a/drivers/dsp/bridge/dynload/dload_internal.h
+++ b/drivers/dsp/bridge/dynload/dload_internal.h
@@ -14,8 +14,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __DLOAD_INTERNAL__
-#define __DLOAD_INTERNAL__
+#ifndef _DLOAD_INTERNAL_
+#define _DLOAD_INTERNAL_
 
 #include <linux/types.h>
 
@@ -27,12 +27,11 @@
 #define FALSE 0
 typedef int boolean;
 
-
 /* type used for relocation intermediate results */
-typedef s32 RVALUE;
+typedef s32 rvalue;
 
 /* unsigned version of same; must have at least as many bits */
-typedef u32 URVALUE;
+typedef u32 urvalue;
 
 /*
  * Dynamic loader configuration constants
@@ -41,7 +40,7 @@ typedef u32 URVALUE;
 #define REASONABLE_SECTION_LIMIT 100
 
 /* (Addressable unit) value used to clear BSS section */
-#define dload_fill_bss 0
+#define DLOAD_FILL_BSS 0
 
 /*
  * Reorder maps explained (?)
@@ -84,9 +83,9 @@ struct dbg_mirror_root {
 	/* must be same as dbg_mirror_list; __DLModules address on target */
 	u32 dbthis;
 	struct my_handle *hnext;	/* must be same as dbg_mirror_list */
-	u16 changes;	/* change counter */
-	u16 refcount;	/* number of modules referencing this root */
-} ;
+	u16 changes;		/* change counter */
+	u16 refcount;		/* number of modules referencing this root */
+};
 
 struct dbg_mirror_list {
 	u32 dbthis;
@@ -94,7 +93,7 @@ struct dbg_mirror_list {
 	struct dbg_mirror_root *hroot;
 	u16 dbsiz;
 	u32 context;	/* Save context for .dllview memory allocation */
-} ;
+};
 
 #define VARIABLE_SIZE 1
 /*
@@ -104,31 +103,32 @@ struct my_handle {
 	struct dbg_mirror_list dm;	/* !!! must be first !!! */
 	/* sections following << 1, LSB is set for big-endian target */
 	u16 secn_count;
-	struct LDR_SECTION_INFO secns[VARIABLE_SIZE];
-} ;
+	struct ldr_section_info secns[VARIABLE_SIZE];
+};
 #define MY_HANDLE_SIZE (sizeof(struct my_handle) -\
-			sizeof(struct LDR_SECTION_INFO))
+			sizeof(struct ldr_section_info))
 /* real size of my_handle */
 
 /*
  * reduced symbol structure used for symbols during relocation
  */
-struct Local_Symbol {
-	s32 value;	/* Relocated symbol value */
-	s32 delta;	/* Original value in input file */
+struct local_symbol {
+	s32 value;		/* Relocated symbol value */
+	s32 delta;		/* Original value in input file */
 	s16 secnn;		/* section number */
 	s16 sclass;		/* symbol class */
 };
 
-
 /*
  * Trampoline data structures
  */
 #define TRAMP_NO_GEN_AVAIL              65535
 #define TRAMP_SYM_PREFIX                "__$dbTR__"
 #define TRAMP_SECT_NAME                 ".dbTR"
-#define TRAMP_SYM_PREFIX_LEN            9  /*  MUST MATCH THE LENGTH ABOVE!! */
-#define TRAMP_SYM_HEX_ASCII_LEN         9  /*  Includes NULL termination  */
+/* MUST MATCH THE LENGTH ABOVE!! */
+#define TRAMP_SYM_PREFIX_LEN            9
+/* Includes NULL termination */
+#define TRAMP_SYM_HEX_ASCII_LEN         9
 
 #define GET_CONTAINER(ptr, type, field) ((type *)((unsigned long)ptr -\
 				(unsigned long)(&((type *)0)->field)))
@@ -136,7 +136,6 @@ struct Local_Symbol {
 #define FIELD_OFFSET(type, field)       ((unsigned long)(&((type *)0)->field))
 #endif
 
-
 /*
     The trampoline code for the target is located in a table called
     "tramp_gen_info" with is indexed by looking up the index in the table
@@ -155,78 +154,78 @@ struct Local_Symbol {
 
     This is very similar to how image data is laid out in the DOFF file
     itself.
-*/
+ */
 struct tramp_gen_code_hdr {
-	u32		tramp_code_size;    /*  in BYTES  */
-	u32		num_relos;
-	u32		relo_offset;   /*  in BYTES  */
+	u32 tramp_code_size;	/*  in BYTES */
+	u32 num_relos;
+	u32 relo_offset;	/*  in BYTES */
 };
 
 struct tramp_img_pkt {
-	struct tramp_img_pkt	*next;    /*  MUST BE FIRST  */
-	u32		base;
-	struct tramp_gen_code_hdr	hdr;
-	u8		payload[VARIABLE_SIZE];
+	struct tramp_img_pkt *next;	/*  MUST BE FIRST */
+	u32 base;
+	struct tramp_gen_code_hdr hdr;
+	u8 payload[VARIABLE_SIZE];
 };
 
 struct tramp_img_dup_relo {
-	struct tramp_img_dup_relo	*next;
-	struct reloc_record_t	relo;
+	struct tramp_img_dup_relo *next;
+	struct reloc_record_t relo;
 };
 
 struct tramp_img_dup_pkt {
-	struct tramp_img_dup_pkt  *next;    /*  MUST BE FIRST  */
-	s16		secnn;
-	u32		offset;
-	struct image_packet_t                img_pkt;
-	struct tramp_img_dup_relo            *relo_chain;
+	struct tramp_img_dup_pkt *next;	/*  MUST BE FIRST */
+	s16 secnn;
+	u32 offset;
+	struct image_packet_t img_pkt;
+	struct tramp_img_dup_relo *relo_chain;
 
-	/*  PAYLOAD OF IMG PKT FOLLOWS  */
+	/*  PAYLOAD OF IMG PKT FOLLOWS */
 };
 
 struct tramp_sym {
-	struct tramp_sym	*next;    /*  MUST BE FIRST  */
-	u32		index;
-	u32		str_index;
-	struct Local_Symbol sym_info;
+	struct tramp_sym *next;	/*  MUST BE FIRST */
+	u32 index;
+	u32 str_index;
+	struct local_symbol sym_info;
 };
 
 struct tramp_string {
-	struct tramp_string	*next;    /*  MUST BE FIRST  */
-	u32	index;
-	char    str[VARIABLE_SIZE];    /*  NULL terminated  */
+	struct tramp_string *next;	/*  MUST BE FIRST */
+	u32 index;
+	char str[VARIABLE_SIZE];	/*  NULL terminated */
 };
 
 struct tramp_info {
-	u32		tramp_sect_next_addr;
-	struct LDR_SECTION_INFO	sect_info;
-
-	struct tramp_sym		*symbol_head;
-	struct tramp_sym		*symbol_tail;
-	u32		tramp_sym_next_index;
-	struct	Local_Symbol		*final_sym_table;
-
-	struct tramp_string                *string_head;
-	struct tramp_string                *string_tail;
-	u32		tramp_string_next_index;
-	u32		tramp_string_size;
-	char		*final_string_table;
-
-	struct tramp_img_pkt		*tramp_pkts;
-	struct tramp_img_dup_pkt	*dup_pkts;
+	u32 tramp_sect_next_addr;
+	struct ldr_section_info sect_info;
+
+	struct tramp_sym *symbol_head;
+	struct tramp_sym *symbol_tail;
+	u32 tramp_sym_next_index;
+	struct local_symbol *final_sym_table;
+
+	struct tramp_string *string_head;
+	struct tramp_string *string_tail;
+	u32 tramp_string_next_index;
+	u32 tramp_string_size;
+	char *final_string_table;
+
+	struct tramp_img_pkt *tramp_pkts;
+	struct tramp_img_dup_pkt *dup_pkts;
 };
 
 /*
  * States of the .cinit state machine
  */
 enum cinit_mode {
-	CI_count = 0,		/* expecting a count */
-	CI_address,		/* expecting an address */
+	CI_COUNT = 0,		/* expecting a count */
+	CI_ADDRESS,		/* expecting an address */
 #if CINIT_ALIGN < CINIT_ADDRESS	/* handle case of partial address field */
-	CI_partaddress,		/* have only part of the address */
+	CI_PARTADDRESS,		/* have only part of the address */
 #endif
-	CI_copy,		/* in the middle of copying data */
-	CI_done			/* end of .cinit table */
+	CI_COPY,		/* in the middle of copying data */
+	CI_DONE			/* end of .cinit table */
 };
 
 /*
@@ -234,11 +233,12 @@ enum cinit_mode {
  * an object
  */
 struct dload_state {
-	struct Dynamic_Loader_Stream *strm;	/* The module input stream */
-	struct Dynamic_Loader_Sym *mysym;	/* Symbols for this session */
-	struct Dynamic_Loader_Allocate *myalloc; /* target memory allocator */
-	struct Dynamic_Loader_Initialize *myio;	/* target memory initializer */
-	unsigned myoptions;	/* Options parameter Dynamic_Load_Module */
+	struct dynamic_loader_stream *strm;	/* The module input stream */
+	struct dynamic_loader_sym *mysym;	/* Symbols for this session */
+	/* target memory allocator */
+	struct dynamic_loader_allocate *myalloc;
+	struct dynamic_loader_initialize *myio;	/* target memory initializer */
+	unsigned myoptions;	/* Options parameter dynamic_load_module */
 
 	char *str_head;		/* Pointer to string table */
 #if BITS_PER_AU > BITS_PER_BYTE
@@ -252,23 +252,23 @@ struct dload_state {
 	unsigned debug_string_size;
 	/* Pointer to parallel section info for allocated sections only */
 	struct doff_scnhdr_t *sect_hdrs;	/* Pointer to section table */
-	struct LDR_SECTION_INFO *ldr_sections;
+	struct ldr_section_info *ldr_sections;
 #if TMS32060
 	/* The address of the start of the .bss section */
-	LDR_ADDR bss_run_base;
+	ldr_addr bss_run_base;
 #endif
-	struct Local_Symbol *local_symtab;	/* Relocation symbol table */
+	struct local_symbol *local_symtab;	/* Relocation symbol table */
 
 	/* pointer to DL section info for the section being relocated */
-	struct LDR_SECTION_INFO *image_secn;
+	struct ldr_section_info *image_secn;
 	/* change in run address for current section during relocation */
-	LDR_ADDR delta_runaddr;
-	LDR_ADDR image_offset;	/* offset of current packet in section */
+	ldr_addr delta_runaddr;
+	ldr_addr image_offset;	/* offset of current packet in section */
 	enum cinit_mode cinit_state;	/* current state of cload_cinit() */
 	int cinit_count;	/* the current count */
-	LDR_ADDR cinit_addr;	/* the current address */
-	s16 cinit_page;	/* the current page */
-	/* Handle to be returned by Dynamic_Load_Module */
+	ldr_addr cinit_addr;	/* the current address */
+	s16 cinit_page;		/* the current page */
+	/* Handle to be returned by dynamic_load_module */
 	struct my_handle *myhandle;
 	unsigned dload_errcount;	/* Total # of errors reported so far */
 	/* Number of target sections that require allocation and relocation */
@@ -281,13 +281,13 @@ struct dload_state {
 	struct doff_filehdr_t dfile_hdr;	/* DOFF file header structure */
 	struct doff_verify_rec_t verify;	/* Verify record */
 
-	struct tramp_info tramp;	/* Trampoline data, if needed  */
+	struct tramp_info tramp;	/* Trampoline data, if needed */
 
 	int relstkidx;		/* index into relocation value stack */
 	/* relocation value stack used in relexp.c */
-	RVALUE relstk[STATIC_EXPR_STK_SIZE];
+	rvalue relstk[STATIC_EXPR_STK_SIZE];
 
-} ;
+};
 
 #ifdef TARGET_ENDIANNESS
 #define TARGET_BIG_ENDIAN TARGET_ENDIANNESS
@@ -299,7 +299,7 @@ struct dload_state {
  * Exports from cload.c to rest of the world
  */
 extern void dload_error(struct dload_state *dlthis, const char *errtxt, ...);
-extern void dload_syms_error(struct Dynamic_Loader_Sym *syms,
+extern void dload_syms_error(struct dynamic_loader_sym *syms,
 			     const char *errtxt, ...);
 extern void dload_headers(struct dload_state *dlthis);
 extern void dload_strings(struct dload_state *dlthis, bool sec_names_only);
@@ -310,45 +310,43 @@ extern u32 dload_checksum(void *data, unsigned siz);
 #if HOST_ENDIANNESS
 extern uint32_t dload_reverse_checksum(void *data, unsigned siz);
 #if (TARGET_AU_BITS > 8) && (TARGET_AU_BITS < 32)
-extern uint32_t dload_reverse_checksum_16(void *data, unsigned siz);
+extern uint32_t dload_reverse_checksum16(void *data, unsigned siz);
 #endif
 #endif
 
-#define is_data_scn(zzz) (DLOAD_SECTION_TYPE((zzz)->type) != DLOAD_TEXT)
-#define is_data_scn_num(zzz) \
+#define IS_DATA_SCN(zzz) (DLOAD_SECTION_TYPE((zzz)->type) != DLOAD_TEXT)
+#define IS_DATA_SCN_NUM(zzz) \
 		(DLOAD_SECT_TYPE(&dlthis->sect_hdrs[(zzz)-1]) != DLOAD_TEXT)
 
 /*
  * exported by reloc.c
  */
-extern void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
-			struct reloc_record_t *rp, bool *tramps_generated,
-			bool second_pass);
+extern void dload_relocate(struct dload_state *dlthis, tgt_au_t * data,
+			   struct reloc_record_t *rp, bool * tramps_generated,
+			   bool second_pass);
 
-extern RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data,
+extern rvalue dload_unpack(struct dload_state *dlthis, tgt_au_t * data,
 			   int fieldsz, int offset, unsigned sgn);
 
-extern int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
+extern int dload_repack(struct dload_state *dlthis, rvalue val, tgt_au_t * data,
 			int fieldsz, int offset, unsigned sgn);
 
-
 /*
  * exported by tramp.c
  */
 extern bool dload_tramp_avail(struct dload_state *dlthis,
-			struct reloc_record_t *rp);
+			      struct reloc_record_t *rp);
 
 int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
-			u32 image_offset, struct image_packet_t *ipacket,
-			struct reloc_record_t *rp);
+			 u32 image_offset, struct image_packet_t *ipacket,
+			 struct reloc_record_t *rp);
 
 extern int dload_tramp_pkt_udpate(struct dload_state *dlthis,
-			s16 secnn, u32 image_offset,
-			struct image_packet_t *ipacket);
+				  s16 secnn, u32 image_offset,
+				  struct image_packet_t *ipacket);
 
 extern int dload_tramp_finalize(struct dload_state *dlthis);
 
 extern void dload_tramp_cleanup(struct dload_state *dlthis);
 
-
-#endif				/* __DLOAD_INTERNAL__ */
+#endif /* _DLOAD_INTERNAL_ */
diff --git a/drivers/dsp/bridge/dynload/doff.h b/drivers/dsp/bridge/dynload/doff.h
index 916bd72..5bf9924 100644
--- a/drivers/dsp/bridge/dynload/doff.h
+++ b/drivers/dsp/bridge/dynload/doff.h
@@ -33,18 +33,18 @@
 /* DOFF file header containing fields categorizing the remainder of the file */
 struct doff_filehdr_t {
 
-	/* string table size, including filename, in bytes   */
+	/* string table size, including filename, in bytes */
 	u32 df_strtab_size;
 
 	/* entry point if one exists */
 	u32 df_entrypt;
 
 	/* identifies byte ordering of file;
-	 * always set to BYTE_RESHUFFLE_VALUE  */
+	 * always set to BYTE_RESHUFFLE_VALUE */
 	u32 df_byte_reshuffle;
 
 	/* Size of the string table up to and including the last section name */
-	/* Size includes the name of the COFF file also     */
+	/* Size includes the name of the COFF file also */
 	u32 df_scn_name_size;
 
 #ifndef _BIG_ENDIAN
@@ -52,16 +52,16 @@ struct doff_filehdr_t {
 	u16 df_no_syms;
 
 	/* length in bytes of the longest string, including terminating NULL */
-	/* excludes the name of the file     */
+	/* excludes the name of the file */
 	u16 df_max_str_len;
 
-	/* total number of sections including no-load ones   */
+	/* total number of sections including no-load ones */
 	u16 df_no_scns;
 
 	/* number of sections containing target code allocated or downloaded */
 	u16 df_target_scns;
 
-	/* unique id for dll file format & version   */
+	/* unique id for dll file format & version */
 	u16 df_doff_version;
 
 	/* identifies ISA */
@@ -70,11 +70,11 @@ struct doff_filehdr_t {
 	/* useful file flags */
 	u16 df_flags;
 
-	/* section reference for entry point, N_UNDEF for none,   */
+	/* section reference for entry point, N_UNDEF for none, */
 	/* N_ABS for absolute address */
 	s16 df_entry_secn;
 #else
-	/* length of the longest string, including terminating NULL  */
+	/* length of the longest string, including terminating NULL */
 	u16 df_max_str_len;
 
 	/* number of symbols */
@@ -92,7 +92,7 @@ struct doff_filehdr_t {
 	/* unique id for dll file format & version */
 	u16 df_doff_version;
 
-	/* section reference for entry point, N_UNDEF for none,  */
+	/* section reference for entry point, N_UNDEF for none, */
 	/* N_ABS for absolute address */
 	s16 df_entry_secn;
 
@@ -102,7 +102,7 @@ struct doff_filehdr_t {
 	/* checksum for file header record */
 	u32 df_checksum;
 
-} ;
+};
 
 /* flags in the df_flags field */
 #define  DF_LITTLE   0x100
@@ -138,7 +138,7 @@ struct doff_verify_rec_t {
 	/* checksum for verification record */
 	u32 dv_verify_rec_checksum;
 
-} ;
+};
 
 /* String table is an array of null-terminated strings.  The first entry is
  * the filename, which is added by DLLcreate.  No new structure definitions
@@ -149,49 +149,49 @@ struct doff_verify_rec_t {
 /*
  *      !!WARNING!!
  *
- * This structure is expected to match in form LDR_SECTION_INFO in
+ * This structure is expected to match in form ldr_section_info in
  * dynamic_loader.h
  */
 
 struct doff_scnhdr_t {
 
-	s32 ds_offset;	/* offset into string table of name    */
-	s32 ds_paddr;	/* RUN address, in target AU           */
-	s32 ds_vaddr;	/* LOAD address, in target AU          */
-	s32 ds_size;	/* section size, in target AU          */
+	s32 ds_offset;		/* offset into string table of name */
+	s32 ds_paddr;		/* RUN address, in target AU */
+	s32 ds_vaddr;		/* LOAD address, in target AU */
+	s32 ds_size;		/* section size, in target AU */
 #ifndef _BIG_ENDIAN
-	u16 ds_page;	/* memory page id                      */
-	u16 ds_flags;	/* section flags                       */
+	u16 ds_page;		/* memory page id */
+	u16 ds_flags;		/* section flags */
 #else
-	u16 ds_flags;	/* section flags                       */
-	u16 ds_page;	/* memory page id                      */
+	u16 ds_flags;		/* section flags */
+	u16 ds_page;		/* memory page id */
 #endif
 	u32 ds_first_pkt_offset;
-	/* Absolute byte offset into the file  */
+	/* Absolute byte offset into the file */
 	/* where the first image record resides */
 
-	s32 ds_nipacks;	/* number of image packets             */
+	s32 ds_nipacks;		/* number of image packets */
 
 };
 
 /* Symbol table entry */
 struct doff_syment_t {
 
-	s32 dn_offset;	/* offset into string table of name    */
-	s32 dn_value;	/* value of symbol                     */
+	s32 dn_offset;		/* offset into string table of name */
+	s32 dn_value;		/* value of symbol */
 #ifndef _BIG_ENDIAN
-	s16 dn_scnum;	/* section number                      */
-	s16 dn_sclass;	/* storage class                       */
+	s16 dn_scnum;		/* section number */
+	s16 dn_sclass;		/* storage class */
 #else
-	s16 dn_sclass;	/* storage class                       */
-	s16 dn_scnum;	/* section number, 1-based             */
+	s16 dn_sclass;		/* storage class */
+	s16 dn_scnum;		/* section number, 1-based */
 #endif
 
-} ;
+};
 
 /* special values for dn_scnum */
-#define  DN_UNDEF  0		/* undefined symbol               */
-#define  DN_ABS    (-1)		/* value of symbol is absolute    */
+#define  DN_UNDEF  0		/* undefined symbol */
+#define  DN_ABS    (-1)		/* value of symbol is absolute */
 /* special values for dn_sclass */
 #define DN_EXT     2
 #define DN_STATLAB 20
@@ -202,44 +202,44 @@ struct doff_syment_t {
 #define IMAGE_PACKET_SIZE 1024
 
 /* An image packet contains a chunk of data from a section along with */
-/* information necessary for its processing.                          */
+/* information necessary for its processing. */
 struct image_packet_t {
 
-	s32 i_num_relocs;	/* number of relocations for   */
-	/* this packet                 */
+	s32 num_relocs;		/* number of relocations for */
+	/* this packet */
 
-	s32 i_packet_size;	/* number of bytes in array    */
-	/* "bits" occupied  by         */
-	/* valid data.  Could be       */
-	/* < IMAGE_PACKET_SIZE to      */
-	/* prevent splitting a         */
-	/* relocation across packets.  */
-	/* Last packet of a section    */
-	/* will most likely contain    */
-	/* < IMAGE_PACKET_SIZE bytes   */
-	/* of valid data               */
+	s32 packet_size;	/* number of bytes in array */
+	/* "bits" occupied  by */
+	/* valid data.  Could be */
+	/* < IMAGE_PACKET_SIZE to */
+	/* prevent splitting a */
+	/* relocation across packets. */
+	/* Last packet of a section */
+	/* will most likely contain */
+	/* < IMAGE_PACKET_SIZE bytes */
+	/* of valid data */
 
-	s32 i_checksum;	/* Checksum for image packet   */
-	/* and the corresponding       */
-	/* relocation records          */
+	s32 img_chksum;		/* Checksum for image packet */
+	/* and the corresponding */
+	/* relocation records */
 
-	u8 *i_bits;	/* Actual data in section      */
+	u8 *img_data;		/* Actual data in section */
 
 };
 
-/* The relocation structure definition matches the COFF version.  Offsets  */
-/* however are relative to the image packet base not the section base.     */
+/* The relocation structure definition matches the COFF version.  Offsets */
+/* however are relative to the image packet base not the section base. */
 struct reloc_record_t {
 
-	s32 r_vaddr;
+	s32 vaddr;
 
-	/* expressed in target AUs          */
+	/* expressed in target AUs */
 
 	union {
 		struct {
 #ifndef _BIG_ENDIAN
-			u8 _offset;	/* bit offset of rel fld      */
-			u8 _fieldsz;	/* size of rel fld            */
+			u8 _offset;	/* bit offset of rel fld */
+			u8 _fieldsz;	/* size of rel fld */
 			u8 _wordsz;	/* # bytes containing rel fld */
 			u8 _dum1;
 			u16 _dum2;
@@ -247,98 +247,98 @@ struct reloc_record_t {
 #else
 			unsigned _dum1:8;
 			unsigned _wordsz:8;	/* # bytes containing rel fld */
-			unsigned _fieldsz:8;	/* size of rel fld            */
-			unsigned _offset:8;	/* bit offset of rel fld      */
+			unsigned _fieldsz:8;	/* size of rel fld */
+			unsigned _offset:8;	/* bit offset of rel fld */
 			u16 _type;
 			u16 _dum2;
 #endif
 		} _r_field;
 
 		struct {
-			u32 _spc;	/* image packet relative PC   */
+			u32 _spc;	/* image packet relative PC */
 #ifndef _BIG_ENDIAN
 			u16 _dum;
-			u16 _type;	/* relocation type            */
+			u16 _type;	/* relocation type */
 #else
-			u16 _type;	/* relocation type            */
+			u16 _type;	/* relocation type */
 			u16 _dum;
 #endif
 		} _r_spc;
 
 		struct {
-			u32 _uval;	/* constant value             */
+			u32 _uval;	/* constant value */
 #ifndef _BIG_ENDIAN
 			u16 _dum;
-			u16 _type;	/* relocation type            */
+			u16 _type;	/* relocation type */
 #else
-			u16 _type;	/* relocation type            */
+			u16 _type;	/* relocation type */
 			u16 _dum;
 #endif
 		} _r_uval;
 
 		struct {
-			s32 _symndx;	/* 32-bit sym tbl index       */
+			s32 _symndx;	/* 32-bit sym tbl index */
 #ifndef _BIG_ENDIAN
-			u16 _disp;	/* extra addr encode data     */
-			u16 _type;	/* relocation type            */
+			u16 _disp;	/* extra addr encode data */
+			u16 _type;	/* relocation type */
 #else
-			u16 _type;	/* relocation type            */
-			u16 _disp;	/* extra addr encode data     */
+			u16 _type;	/* relocation type */
+			u16 _disp;	/* extra addr encode data */
 #endif
 		} _r_sym;
 	} _u_reloc;
 
-} ;
+};
 
 /* abbreviations for convenience */
-#ifndef r_type
-#define r_type      _u_reloc._r_sym._type
-#define r_uval      _u_reloc._r_uval._uval
-#define r_symndx    _u_reloc._r_sym._symndx
-#define r_offset    _u_reloc._r_field._offset
-#define r_fieldsz   _u_reloc._r_field._fieldsz
-#define r_wordsz    _u_reloc._r_field._wordsz
-#define r_disp      _u_reloc._r_sym._disp
+#ifndef TYPE
+#define TYPE      _u_reloc._r_sym._type
+#define UVAL      _u_reloc._r_uval._uval
+#define SYMNDX    _u_reloc._r_sym._symndx
+#define OFFSET    _u_reloc._r_field._offset
+#define FIELDSZ   _u_reloc._r_field._fieldsz
+#define WORDSZ    _u_reloc._r_field._wordsz
+#define R_DISP      _u_reloc._r_sym._disp
 #endif
 
-/*****************************************************************************/
-/*                                                                           */
-/* Important DOFF macros used for file processing                            */
-/*                                                                           */
-/*****************************************************************************/
+/**************************************************************************** */
+/* */
+/* Important DOFF macros used for file processing */
+/* */
+/**************************************************************************** */
 
 /* DOFF Versions */
 #define         DOFF0                       0
 
-/* Return the address/size >= to addr that is at a 32-bit boundary           */
-/* This assumes that a byte is 8 bits                                        */
+/* Return the address/size >= to addr that is at a 32-bit boundary */
+/* This assumes that a byte is 8 bits */
 #define         DOFF_ALIGN(addr)            (((addr) + 3) & ~UINT32_C(3))
 
-/*****************************************************************************/
-/*                                                                           */
-/* The DOFF section header flags field is laid out as follows:               */
-/*                                                                           */
-/*  Bits 0-3 : Section Type                                                  */
+/**************************************************************************** */
+/* */
+/* The DOFF section header flags field is laid out as follows: */
+/* */
+/*  Bits 0-3 : Section Type */
 /*  Bit    4 : Set when section requires target memory to be allocated by DL */
-/*  Bit    5 : Set when section requires downloading                         */
-/*  Bits 8-11: Alignment, same as COFF                                       */
-/*                                                                           */
-/*****************************************************************************/
+/*  Bit    5 : Set when section requires downloading */
+/*  Bits 8-11: Alignment, same as COFF */
+/* */
+/**************************************************************************** */
 
-/* Enum for DOFF section types (bits 0-3 of flag): See dynamic_loader.h      */
+/* Enum for DOFF section types (bits 0-3 of flag): See dynamic_loader.h */
 
-/* Macros to help processing of sections                                     */
+/* Macros to help processing of sections */
 #define DLOAD_SECT_TYPE(s_hdr)      ((s_hdr)->ds_flags & 0xF)
 
-/* DS_ALLOCATE indicates whether a section needs space on the target         */
+/* DS_ALLOCATE indicates whether a section needs space on the target */
 #define DS_ALLOCATE_MASK            0x10
 #define DS_NEEDS_ALLOCATION(s_hdr)  ((s_hdr)->ds_flags & DS_ALLOCATE_MASK)
 
-/* DS_DOWNLOAD indicates that the loader needs to copy bits                  */
+/* DS_DOWNLOAD indicates that the loader needs to copy bits */
 #define DS_DOWNLOAD_MASK            0x20
 #define DS_NEEDS_DOWNLOAD(s_hdr)    ((s_hdr)->ds_flags & DS_DOWNLOAD_MASK)
 
 /* Section alignment requirement in AUs */
 #define DS_ALIGNMENT(ds_flags) (1 << (((ds_flags) >> 8) & 0xF))
 
-#endif				/* _DOFF_H */
+#endif /* _DOFF_H */
diff --git a/drivers/dsp/bridge/dynload/getsection.c b/drivers/dsp/bridge/dynload/getsection.c
index 1c24b6a..2ac4f43 100644
--- a/drivers/dsp/bridge/dynload/getsection.c
+++ b/drivers/dsp/bridge/dynload/getsection.c
@@ -20,35 +20,38 @@
 /*
  * Error strings
  */
-static const char E_READSTRM[] = { "Error reading %s from input stream" };
-static const char E_SEEK[] = { "Set file position to %d failed" };
-static const char E_ISIZ[] = { "Bad image packet size %d" };
-static const char E_CHECKSUM[] = { "Checksum failed on %s" };
-static const char E_RELOC[] = { "DLOAD_GetSection unable to read"
-	"sections containing relocation entries"};
+static const char readstrm[] = { "Error reading %s from input stream" };
+static const char seek[] = { "Set file position to %d failed" };
+static const char isiz[] = { "Bad image packet size %d" };
+static const char err_checksum[] = { "Checksum failed on %s" };
+
+static const char err_reloc[] = { "dload_get_section unable to read"
+	    "sections containing relocation entries"
+};
+
 #if BITS_PER_AU > BITS_PER_BYTE
-static const char E_ALLOC[] = { "Syms->Allocate( %d ) failed" };
-static const char E_STBL[] = { "Bad string table offset " FMT_UI32 };
+static const char err_alloc[] = { "Syms->dload_allocate( %d ) failed" };
+static const char stbl[] = { "Bad string table offset " FMT_UI32 };
 #endif
 
 /*
  * we use the fact that DOFF section records are shaped just like
- * LDR_SECTION_INFO to reduce our section storage usage.  These macros
+ * ldr_section_info to reduce our section storage usage.  These macros
  * marks the places where that assumption is made
  */
-#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct LDR_SECTION_INFO *)(pdoffsec))
+#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct ldr_section_info *)(pdoffsec))
 #define LDRSEC_IS_DOFFSEC(ldrsec) ((struct doff_scnhdr_t *)(ldrsec))
 
-/***************************************************************/
-/********************* SUPPORT FUNCTIONS ***********************/
-/***************************************************************/
+/************************************************************** */
+/********************* SUPPORT FUNCTIONS ********************** */
+/************************************************************** */
 
 #if BITS_PER_AU > BITS_PER_BYTE
 /**************************************************************************
  * Procedure unpack_sec_name
  *
  * Parameters:
- *  dlthis		Handle from DLOAD_module_open for this module
+ *  dlthis		Handle from dload_module_open for this module
  *	soffset	    Byte offset into the string table
  *  dst         Place to store the expanded string
  *
@@ -57,24 +60,23 @@ static const char E_STBL[] = { "Bad string table offset " FMT_UI32 };
  * it in the process.  Returns a pointer just past the end of the stored
  * string on success, or NULL on failure.
  *
- *************************************************************************/
-static char *unpack_sec_name(struct dload_state *dlthis,
-			     u32 soffset, char *dst)
+ ************************************************************************ */
+static char *unpack_sec_name(struct dload_state *dlthis, u32 soffset, char *dst)
 {
 	u8 tmp, *src;
 
 	if (soffset >= dlthis->dfile_hdr.df_scn_name_size) {
-		dload_error(dlthis, E_STBL, soffset);
+		dload_error(dlthis, stbl, soffset);
 		return NULL;
 	}
-	src = (u8 *)dlthis->str_head +
+	src = (u8 *) dlthis->str_head +
 	    (soffset >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE));
 	if (soffset & 1)
 		*dst++ = *src++;	/* only 1 character in first word */
 	do {
 		tmp = *src++;
 		*dst = (tmp >> BITS_PER_BYTE)
-		if (!(*dst++))
+		    if (!(*dst++))
 			break;
 	} while ((*dst++ = tmp & BYTE_MASK));
 
@@ -85,23 +87,23 @@ static char *unpack_sec_name(struct dload_state *dlthis,
  * Procedure expand_sec_names
  *
  * Parameters:
- *  dlthis		Handle from DLOAD_module_open for this module
+ *  dlthis		Handle from dload_module_open for this module
  *
  * Effect:
  *    Allocates a buffer, unpacks and copies strings from string table into it.
  * Stores a pointer to the buffer into a state variable.
- **************************************************************************/
+ ************************************************************************* */
 static void expand_sec_names(struct dload_state *dlthis)
 {
 	char *xstrings, *curr, *next;
 	u32 xsize;
 	u16 sec;
-	struct LDR_SECTION_INFO *shp;
+	struct ldr_section_info *shp;
 	/* assume worst-case size requirement */
 	xsize = dlthis->dfile_hdr.df_max_str_len * dlthis->dfile_hdr.df_no_scns;
-	xstrings = (char *)dlthis->mysym->Allocate(dlthis->mysym, xsize);
+	xstrings = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, xsize);
 	if (xstrings == NULL) {
-		dload_error(dlthis, E_ALLOC, xsize);
+		dload_error(dlthis, err_alloc, xsize);
 		return;
 	}
 	dlthis->xstrings = xstrings;
@@ -119,12 +121,12 @@ static void expand_sec_names(struct dload_state *dlthis)
 
 #endif
 
-/***************************************************************/
-/********************* EXPORTED FUNCTIONS **********************/
-/***************************************************************/
+/************************************************************** */
+/********************* EXPORTED FUNCTIONS ********************* */
+/************************************************************** */
 
 /**************************************************************************
- * Procedure DLOAD_module_open
+ * Procedure dload_module_open
  *
  * Parameters:
  *	module	The input stream that supplies the module image
@@ -141,9 +143,9 @@ static void expand_sec_names(struct dload_state *dlthis)
  * Returns:
  *	NULL if an error is encountered, otherwise a module handle for use
  * in subsequent operations.
- **************************************************************************/
-DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream *module,
-				    struct Dynamic_Loader_Sym *syms)
+ ************************************************************************* */
+dload_module_info dload_module_open(struct dynamic_loader_stream *module,
+				    struct dynamic_loader_sym *syms)
 {
 	struct dload_state *dlthis;	/* internal state for this call */
 	unsigned *dp, sz;
@@ -161,7 +163,7 @@ DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream *module,
 	}
 
 	dlthis = (struct dload_state *)
-		 syms->Allocate(syms, sizeof(struct dload_state));
+	    syms->dload_allocate(syms, sizeof(struct dload_state));
 	if (!dlthis) {
 		/* not enough storage */
 		dload_syms_error(syms, "Can't allocate module info");
@@ -185,11 +187,11 @@ DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream *module,
 
 	/* skip ahead past the unread portion of the string table */
 	sec_start = sizeof(struct doff_filehdr_t) +
-		    sizeof(struct doff_verify_rec_t) +
-		    BYTE_TO_HOST(DOFF_ALIGN(dlthis->dfile_hdr.df_strtab_size));
+	    sizeof(struct doff_verify_rec_t) +
+	    BYTE_TO_HOST(DOFF_ALIGN(dlthis->dfile_hdr.df_strtab_size));
 
 	if (dlthis->strm->set_file_posn(dlthis->strm, sec_start) != 0) {
-		dload_error(dlthis, E_SEEK, sec_start);
+		dload_error(dlthis, seek, sec_start);
 		return NULL;
 	}
 
@@ -197,22 +199,22 @@ DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream *module,
 		dload_sections(dlthis);
 
 	if (dlthis->dload_errcount) {
-		DLOAD_module_close(dlthis);	/* errors, blow off our state */
+		dload_module_close(dlthis);	/* errors, blow off our state */
 		dlthis = NULL;
 		return NULL;
 	}
 #if BITS_PER_AU > BITS_PER_BYTE
-	/* Expand all section names from the string table into the   */
+	/* Expand all section names from the string table into the */
 	/* state variable, and convert section names from a relative */
 	/* string table offset to a pointers to the expanded string. */
 	expand_sec_names(dlthis);
 #else
 	/* Convert section names from a relative string table offset */
-	/* to a pointer into the string table.                       */
+	/* to a pointer into the string table. */
 	for (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {
-		struct LDR_SECTION_INFO *shp =
+		struct ldr_section_info *shp =
 		    DOFFSEC_IS_LDRSEC(&dlthis->sect_hdrs[sec]);
-		shp->name = dlthis->str_head + *(u32 *)&shp->name;
+		shp->name = dlthis->str_head + *(u32 *) &shp->name;
 	}
 #endif
 
@@ -220,26 +222,26 @@ DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream *module,
 }
 
 /***************************************************************************
- * Procedure DLOAD_GetSectionInfo
+ * Procedure dload_get_section_info
  *
  * Parameters:
- *  minfo		Handle from DLOAD_module_open for this module
+ *  minfo		Handle from dload_module_open for this module
  *	sectionName	Pointer to the string name of the section desired
  *	sectionInfo	Address of a section info structure pointer to be
  *			initialized
  *
  * Effect:
  *	Finds the specified section in the module information, and initializes
- * the provided struct LDR_SECTION_INFO pointer.
+ * the provided struct ldr_section_info pointer.
  *
  * Returns:
  *	true for success, false for section not found
- **************************************************************************/
-int DLOAD_GetSectionInfo(DLOAD_module_info minfo, const char *sectionName,
-		     const struct LDR_SECTION_INFO **const sectionInfo)
+ ************************************************************************* */
+int dload_get_section_info(dload_module_info minfo, const char *sectionName,
+			   const struct ldr_section_info **const sectionInfo)
 {
 	struct dload_state *dlthis;
-	struct LDR_SECTION_INFO *shp;
+	struct ldr_section_info *shp;
 	u16 sec;
 
 	dlthis = (struct dload_state *)minfo;
@@ -261,10 +263,10 @@ int DLOAD_GetSectionInfo(DLOAD_module_info minfo, const char *sectionName,
 #define REVERSE_REORDER_MAP(rawmap) ((rawmap) ^ 0x3030303)
 
 /**************************************************************************
- * Procedure DLOAD_GetSection
+ * Procedure dload_get_section
  *
  * Parameters:
- *  minfo		Handle from DLOAD_module_open for this module
+ *  minfo		Handle from dload_module_open for this module
  *	sectionInfo	Pointer to a section info structure for the desired
  *			section
  *	sectionData	Buffer to contain the section initialized data
@@ -275,9 +277,10 @@ int DLOAD_GetSectionInfo(DLOAD_module_info minfo, const char *sectionName,
  *
  * Returns:
  *	true for success, false for section not found
- **************************************************************************/
-int DLOAD_GetSection(DLOAD_module_info minfo,
-		 const struct LDR_SECTION_INFO *sectionInfo, void *sectionData)
+ ************************************************************************* */
+int dload_get_section(dload_module_info minfo,
+		      const struct ldr_section_info *sectionInfo,
+		      void *sectionData)
 {
 	struct dload_state *dlthis;
 	u32 pos;
@@ -286,7 +289,7 @@ int DLOAD_GetSection(DLOAD_module_info minfo,
 	struct image_packet_t ipacket;
 	s32 ipsize;
 	u32 checks;
-	s8 *dest = (s8 *)sectionData;
+	s8 *dest = (s8 *) sectionData;
 
 	dlthis = (struct dload_state *)minfo;
 	if (!dlthis)
@@ -298,16 +301,16 @@ int DLOAD_GetSection(DLOAD_module_info minfo,
 	/* skip ahead to the start of the first packet */
 	pos = BYTE_TO_HOST(DOFF_ALIGN((u32) sptr->ds_first_pkt_offset));
 	if (dlthis->strm->set_file_posn(dlthis->strm, pos) != 0) {
-		dload_error(dlthis, E_SEEK, pos);
+		dload_error(dlthis, seek, pos);
 		return false;
 	}
 
 	nip = sptr->ds_nipacks;
 	while ((nip -= 1) >= 0) {	/* for each packet */
 		/* get the fixed header bits */
-		if (dlthis->strm->
-		    read_buffer(dlthis->strm, &ipacket, IPH_SIZE) != IPH_SIZE) {
-			dload_error(dlthis, E_READSTRM, "image packet");
+		if (dlthis->strm->read_buffer(dlthis->strm, &ipacket,
+					      IPH_SIZE) != IPH_SIZE) {
+			dload_error(dlthis, readstrm, "image packet");
 			return false;
 		}
 		/* reorder the header if need be */
@@ -317,14 +320,14 @@ int DLOAD_GetSection(DLOAD_module_info minfo,
 		/* Now read the packet image bits. Note: round the size up to
 		 * the next multiple of 4 bytes; this is what checksum
 		 * routines want. */
-		ipsize = BYTE_TO_HOST(DOFF_ALIGN(ipacket.i_packet_size));
+		ipsize = BYTE_TO_HOST(DOFF_ALIGN(ipacket.packet_size));
 		if (ipsize > BYTE_TO_HOST(IMAGE_PACKET_SIZE)) {
-			dload_error(dlthis, E_ISIZ, ipsize);
+			dload_error(dlthis, isiz, ipsize);
 			return false;
 		}
 		if (dlthis->strm->read_buffer
 		    (dlthis->strm, dest, ipsize) != ipsize) {
-			dload_error(dlthis, E_READSTRM, "image packet");
+			dload_error(dlthis, readstrm, "image packet");
 			return false;
 		}
 		/* reorder the bytes if need be */
@@ -338,11 +341,11 @@ int DLOAD_GetSection(DLOAD_module_info minfo,
 		    TARGET_ORDER(REORDER_MAP(BYTE_RESHUFFLE_VALUE))) {
 			/* put image bytes in big-endian order, not PC order */
 			dload_reorder(dest, ipsize,
-				      TARGET_ORDER(dlthis->dfile_hdr.
-				      df_byte_reshuffle));
+				      TARGET_ORDER(dlthis->
+						dfile_hdr.df_byte_reshuffle));
 		}
 #if TARGET_AU_BITS > 8
-		checks = dload_reverse_checksum_16(dest, ipsize);
+		checks = dload_reverse_checksum16(dest, ipsize);
 #else
 		checks = dload_reverse_checksum(dest, ipsize);
 #endif
@@ -353,18 +356,18 @@ int DLOAD_GetSection(DLOAD_module_info minfo,
 		 * entries referring to fields that span the packet boundaries
 		 * may result in packets of sizes that are not multiple of
 		 * 4 bytes. Our checksum implementation works on 32-bit words
-		 * only.     */
-		if (ipacket.i_num_relocs != 0) {
-			dload_error(dlthis, E_RELOC, ipsize);
+		 * only. */
+		if (ipacket.num_relocs != 0) {
+			dload_error(dlthis, err_reloc, ipsize);
 			return false;
 		}
 
 		if (~checks) {
-			dload_error(dlthis, E_CHECKSUM, "image packet");
+			dload_error(dlthis, err_checksum, "image packet");
 			return false;
 		}
 
-		/*Advance destination ptr by the size of the just-read packet*/
+		/*Advance destination ptr by the size of the just-read packet */
 		dest += ipsize;
 	}
 
@@ -372,10 +375,10 @@ int DLOAD_GetSection(DLOAD_module_info minfo,
 }
 
 /***************************************************************************
- * Procedure DLOAD_module_close
+ * Procedure dload_module_close
  *
  * Parameters:
- *  minfo		Handle from DLOAD_module_open for this module
+ *  minfo		Handle from dload_module_open for this module
  *
  * Effect:
  *	Releases any storage associated with the module handle.  On return,
@@ -383,10 +386,10 @@ int DLOAD_GetSection(DLOAD_module_info minfo,
  *
  * Returns:
  *	Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report(), where syms was
- * an argument to DLOAD_module_open
- **************************************************************************/
-void DLOAD_module_close(DLOAD_module_info minfo)
+ * Individual errors are reported using syms->error_report(), where syms was
+ * an argument to dload_module_open
+ ************************************************************************* */
+void dload_module_close(dload_module_info minfo)
 {
 	struct dload_state *dlthis;
 
@@ -395,16 +398,19 @@ void DLOAD_module_close(DLOAD_module_info minfo)
 		return;
 
 	if (dlthis->str_head)
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->str_head);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->str_head);
 
 	if (dlthis->sect_hdrs)
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->sect_hdrs);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->sect_hdrs);
 
 #if BITS_PER_AU > BITS_PER_BYTE
 	if (dlthis->xstrings)
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->xstrings);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->xstrings);
 
 #endif
 
-	dlthis->mysym->Deallocate(dlthis->mysym, dlthis);
+	dlthis->mysym->dload_deallocate(dlthis->mysym, dlthis);
 }
diff --git a/drivers/dsp/bridge/dynload/header.h b/drivers/dsp/bridge/dynload/header.h
index 09b6c45..0264f97 100644
--- a/drivers/dsp/bridge/dynload/header.h
+++ b/drivers/dsp/bridge/dynload/header.h
@@ -27,8 +27,8 @@
 #define STATIC_EXPR_STK_SIZE 10
 
 #include <linux/types.h>
-typedef unsigned int            uint_least32_t;
-typedef unsigned short int	uint_least16_t;
+typedef unsigned int uint_least32_t;
+typedef unsigned short int uint_least16_t;
 
 #include "doff.h"
 #include <dspbridge/dynamic_loader.h>
diff --git a/drivers/dsp/bridge/dynload/module_list.h b/drivers/dsp/bridge/dynload/module_list.h
index 2a3e475..a216bb1 100644
--- a/drivers/dsp/bridge/dynload/module_list.h
+++ b/drivers/dsp/bridge/dynload/module_list.h
@@ -58,11 +58,11 @@
 
 #include <linux/types.h>
 
-/* Global pointer to the modules_header structure*/
+/* Global pointer to the modules_header structure */
 #define MODULES_HEADER "_DLModules"
 #define MODULES_HEADER_NO_UNDERSCORE "DLModules"
 
-/* Initial version number*/
+/* Initial version number */
 #define INIT_VERSION 1
 
 /* Verification number -- to be recorded in each module record */
@@ -76,8 +76,11 @@ struct dll_sect;
  * its address is contained in the global _DLModules pointer */
 struct modules_header {
 
-	/* Address of the first dll_module record in the list or NULL.
-	 Note: for C55x this is a word address (C55x data is word-addressable)*/
+	/*
+	 * Address of the first dll_module record in the list or NULL.
+	 * Note: for C55x this is a word address (C55x data is
+	 * word-addressable)
+	 */
 	u32 first_module;
 
 	/* Combined storage size (in target addressable units) of the
@@ -90,11 +93,12 @@ struct modules_header {
 	 * the list */
 	u16 update_flag;
 
-} ;
+};
 
 /* for each 32-bits in above structure, a bitmap, LSB first, whose bits are:
  * 0 => a 32-bit value, 1 => 2 16-bit values */
-#define MODULES_HEADER_BITMAP 0x2 /* swapping bitmap for type modules_header */
+/* swapping bitmap for type modules_header */
+#define MODULES_HEADER_BITMAP 0x2
 
 /* information recorded about each section in a module */
 struct dll_sect {
@@ -113,7 +117,7 @@ struct dll_sect {
 	 * (C55 addresses are really only 24-bits wide). */
 	u32 sect_run_adr;
 
-} ;
+};
 
 /* the rest of the entries in the list are module records */
 struct dll_module {
@@ -146,10 +150,10 @@ struct dll_module {
 
 	/* Array of num_sects elements of the module's section records */
 	struct dll_sect sects[1];
-} ;
+};
 
 /* for each 32 bits in above structure, a bitmap, LSB first, whose bits are:
  * 0 => a 32-bit value, 1 => 2 16-bit values */
 #define DLL_MODULE_BITMAP 0x6	/* swapping bitmap for type dll_module */
 
-#endif				/* _MODULE_LIST_H_ */
+#endif /* _MODULE_LIST_H_ */
diff --git a/drivers/dsp/bridge/dynload/params.h b/drivers/dsp/bridge/dynload/params.h
index 2e2f9e8..d797fcd 100644
--- a/drivers/dsp/bridge/dynload/params.h
+++ b/drivers/dsp/bridge/dynload/params.h
@@ -23,9 +23,12 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- * Host Properties
- */
+/******************************************************************************
+ *
+ *							Host Properties
+ *
+ **************************************************************************** */
+
 #define BITS_PER_BYTE 8		/* bits in the standard PC/SUN byte */
 #define LOG_BITS_PER_BYTE 3	/* log base 2 of same */
 #define BYTE_MASK ((1U<<BITS_PER_BYTE)-1)
@@ -37,8 +40,10 @@
 #define FMT_UI32 "0x%lx"
 #define FMT8_UI32 "%08lx"	/* same but no 0x, fixed width field */
 #else
-#define BITS_PER_AU 8	/* bits in the smallest addressable data storage unit */
-#define LOG_BITS_PER_AU 3  /* log base 2 of the same; useful for shift counts */
+/* bits in the smallest addressable data storage unit */
+#define BITS_PER_AU 8
+/* log base 2 of the same; useful for shift counts */
+#define LOG_BITS_PER_AU 3
 #define FMT_UI32 "0x%x"
 #define FMT8_UI32 "%08x"
 #endif
@@ -49,16 +54,18 @@
 
 /* !! don't be tempted to insert type definitions here; use <stdint.h> !! */
 
-/*
- * Target Properties
- */
+/******************************************************************************
+ *
+ *							Target Properties
+ *
+ **************************************************************************** */
 
-/*--------------------------------------------------------------------------*/
-/* TMS320C6x Target Specific Parameters (byte-addressable)                  */
-/*--------------------------------------------------------------------------*/
+/*-------------------------------------------------------------------------- */
+/* TMS320C6x Target Specific Parameters (byte-addressable) */
+/*-------------------------------------------------------------------------- */
 #if TMS32060
-#define MEMORG          0x0L	/* Size of configured memory  */
-#define MEMSIZE         0x0L	/* (full address space)  */
+#define MEMORG          0x0L	/* Size of configured memory */
+#define MEMSIZE         0x0L	/* (full address space) */
 
 #define CINIT_ALIGN     8	/* alignment of cinit record in TDATA AUs */
 #define CINIT_COUNT	4	/* width of count field in TDATA AUs */
@@ -66,7 +73,7 @@
 #define CINIT_PAGE_BITS	0	/* Number of LSBs of address that
 				 * are page number */
 
-#define LENIENT_SIGNED_RELEXPS 0	/* DOES SIGNED ALLOW MAX UNSIGNED   */
+#define LENIENT_SIGNED_RELEXPS 0	/* DOES SIGNED ALLOW MAX UNSIGNED */
 
 #undef TARGET_ENDIANNESS	/* may be big or little endian */
 
@@ -74,13 +81,12 @@
 #define TARGET_WORD_ALIGN(zz) (((zz) + 0x3) & -0x4)
 #endif
 
-
 /*--------------------------------------------------------------------------
  *
  *			DEFAULT SETTINGS and DERIVED PROPERTIES
  *
  * This section establishes defaults for values not specified above
- *--------------------------------------------------------------------------*/
+ *-------------------------------------------------------------------------- */
 #ifndef TARGET_AU_BITS
 #define TARGET_AU_BITS 8	/* width of the target addressable unit */
 #define LOG_TARGET_AU_BITS 3	/* log2 of same */
@@ -111,7 +117,9 @@
 #endif
 
 /*
+ *
  * Useful properties and conversions derived from the above
+ *
  */
 
 /*
@@ -201,11 +209,11 @@
 
 /* the unit in which we process target image data */
 #if TARGET_AU_BITS <= 8
-typedef u8 TgtAU_t;
+typedef u8 tgt_au_t;
 #elif TARGET_AU_BITS <= 16
-typedef u16 TgtAU_t;
+typedef u16 tgt_au_t;
 #else
-typedef u32 TgtAU_t;
+typedef u32 tgt_au_t;
 #endif
 
 /* size of that unit */
diff --git a/drivers/dsp/bridge/dynload/reloc.c b/drivers/dsp/bridge/dynload/reloc.c
index b9e2a9b..3ec4a49 100644
--- a/drivers/dsp/bridge/dynload/reloc.c
+++ b/drivers/dsp/bridge/dynload/reloc.c
@@ -18,7 +18,7 @@
 
 #if TMS32060
 /* the magic symbol for the start of BSS */
-static const char BSSSYMBOL[] = {".bss"};
+static const char bsssymbol[] = { ".bss" };
 #endif
 
 #if TMS32060
@@ -27,9 +27,9 @@ static const char BSSSYMBOL[] = {".bss"};
 
 #if TMS32060
 /* From coff.h - ignore these relocation operations */
-#define R_C60ALIGN     0x76       /* C60: Alignment info for compressor   */
-#define R_C60FPHEAD    0x77       /* C60: Explicit assembly directive     */
-#define R_C60NOCMP    0x100       /* C60: Don't compress this code scn    */
+#define R_C60ALIGN     0x76	/* C60: Alignment info for compressor */
+#define R_C60FPHEAD    0x77	/* C60: Explicit assembly directive */
+#define R_C60NOCMP    0x100	/* C60: Don't compress this code scn */
 #endif
 
 /**************************************************************************
@@ -38,21 +38,21 @@ static const char BSSSYMBOL[] = {".bss"};
  * Parameters:
  *	data	pointer to storage unit containing lowest host address of
  *		image data
- *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(RVALUE)*BITS_PER_AU
+ *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(rvalue)*BITS_PER_AU
  *	offset	Offset from LSB, 0 <= offset < BITS_PER_AU
  *	sgn	Signedness of the field (ROP_SGN, ROP_UNS, ROP_MAX, ROP_ANY)
  *
  * Effect:
  *	Extracts the specified field and returns it.
- **************************************************************************/
-RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data, int fieldsz,
+ ************************************************************************* */
+rvalue dload_unpack(struct dload_state *dlthis, tgt_au_t * data, int fieldsz,
 		    int offset, unsigned sgn)
 {
-	register RVALUE objval;
+	register rvalue objval;
 	register int shift, direction;
-	register TgtAU_t *dp = data;
+	register tgt_au_t *dp = data;
 
-	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value*/
+	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value */
 	/* * collect up enough bits to contain the desired field */
 	if (TARGET_BIG_ENDIAN) {
 		dp += (fieldsz + offset) >> LOG_TGTAU_BITS;
@@ -63,7 +63,7 @@ RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data, int fieldsz,
 	shift = TGTAU_BITS - offset;
 	while (shift <= fieldsz) {
 		dp += direction;
-		objval += (RVALUE)*dp << shift;
+		objval += (rvalue) *dp << shift;
 		shift += TGTAU_BITS;
 	}
 
@@ -71,14 +71,13 @@ RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data, int fieldsz,
 	if (sgn == ROP_UNS)
 		objval &= (2 << fieldsz) - 1;
 	else {
-		shift = sizeof(RVALUE) * BITS_PER_AU-1 - fieldsz;
+		shift = sizeof(rvalue) * BITS_PER_AU - 1 - fieldsz;
 		objval = (objval << shift) >> shift;
 	}
 
 	return objval;
 
-} /* dload_unpack */
-
+}				/* dload_unpack */
 
 /**************************************************************************
  * Procedure dload_repack
@@ -87,7 +86,7 @@ RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data, int fieldsz,
  *	val		Value to insert
  *	data	Pointer to storage unit containing lowest host address of
  * 		image data
- *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(RVALUE)*BITS_PER_AU
+ *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(rvalue)*BITS_PER_AU
  *	offset	Offset from LSB, 0 <= offset < BITS_PER_AU
  *	sgn	Signedness of the field (ROP_SGN, ROP_UNS, ROP_MAX, ROP_ANY)
  *
@@ -96,15 +95,15 @@ RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data, int fieldsz,
  *	success
  * or 1 if the value will not fit in the specified field according to the
  * specified signedness rule.
- **************************************************************************/
-static const unsigned char ovf_limit[] = {1, 2, 2};
-int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
+ ************************************************************************* */
+static const unsigned char ovf_limit[] = { 1, 2, 2 };
+
+int dload_repack(struct dload_state *dlthis, rvalue val, tgt_au_t * data,
 		 int fieldsz, int offset, unsigned sgn)
 {
-	register URVALUE objval, mask;
+	register urvalue objval, mask;
 	register int shift, direction;
-	register TgtAU_t *dp = data;
-
+	register tgt_au_t *dp = data;
 
 	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value */
 	/* clip the bits */
@@ -119,7 +118,7 @@ int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
 
 	/* insert LSBs */
 	*dp = (*dp & ~(mask << offset)) + (objval << offset);
-	shift = TGTAU_BITS-offset;
+	shift = TGTAU_BITS - offset;
 	/* align mask and objval with AU boundary */
 	objval >>= shift;
 	mask >>= shift;
@@ -136,18 +135,18 @@ int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
 	 */
 	if (sgn) {
 		unsigned tmp = (val >> fieldsz) + (sgn & 0x1);
-		if (tmp > ovf_limit[sgn-1])
+		if (tmp > ovf_limit[sgn - 1])
 			return 1;
 	}
 	return 0;
 
-} /* dload_repack */
+}				/* dload_repack */
 
 /* lookup table for the scaling amount in a C6x instruction */
 #if TMS32060
 #define SCALE_BITS 4		/* there are 4 bits in the scale field */
 #define SCALE_MASK 0x7		/* we really only use the bottom 3 bits */
-static const u8 C60_Scale[SCALE_MASK+1] = {
+static const u8 c60_scale[SCALE_MASK + 1] = {
 	1, 0, 0, 0, 1, 1, 2, 2
 };
 #endif
@@ -161,41 +160,41 @@ static const u8 C60_Scale[SCALE_MASK+1] = {
  *
  * Effect:
  *	Performs the specified relocation operation
- **************************************************************************/
-void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
-			struct reloc_record_t *rp, bool *tramps_genereted,
-			bool second_pass)
+ ************************************************************************* */
+void dload_relocate(struct dload_state *dlthis, tgt_au_t * data,
+		    struct reloc_record_t *rp, bool * tramps_genereted,
+		    bool second_pass)
 {
-	RVALUE val, reloc_amt, orig_val = 0;
+	rvalue val, reloc_amt, orig_val = 0;
 	unsigned int fieldsz = 0;
 	unsigned int offset = 0;
 	unsigned int reloc_info = 0;
 	unsigned int reloc_action = 0;
 	register int rx = 0;
-	RVALUE    *stackp = NULL;
+	rvalue *stackp = NULL;
 	int top;
-	struct Local_Symbol *svp = NULL;
+	struct local_symbol *svp = NULL;
 #ifdef RFV_SCALE
 	unsigned int scale = 0;
 #endif
 	struct image_packet_t *img_pkt = NULL;
 
 	/* The image packet data struct is only used during first pass
-	  * relocation in the event that a trampoline is needed.  2nd pass
-	  * relocation doesn't guarantee that data is coming from an
-	  * image_packet_t structure. See cload.c, dload_data for how i_bits is
-	  * set. If that changes this needs to be updated!!!  */
+	 * relocation in the event that a trampoline is needed.  2nd pass
+	 * relocation doesn't guarantee that data is coming from an
+	 * image_packet_t structure. See cload.c, dload_data for how img_data is
+	 * set. If that changes this needs to be updated!!! */
 	if (second_pass == false)
-		img_pkt = (struct image_packet_t *)((u8 *)data -
-				sizeof(struct image_packet_t));
+		img_pkt = (struct image_packet_t *)((u8 *) data -
+						    sizeof(struct
+							   image_packet_t));
 
-
-	rx = HASH_FUNC(rp->r_type);
-	while (rop_map1[rx] != rp->r_type) {
+	rx = HASH_FUNC(rp->TYPE);
+	while (rop_map1[rx] != rp->TYPE) {
 		rx = HASH_L(rop_map2[rx]);
 		if (rx < 0) {
 #if TMS32060
-			switch (rp->r_type) {
+			switch (rp->TYPE) {
 			case R_C60ALIGN:
 			case R_C60NOCMP:
 			case R_C60FPHEAD:
@@ -204,44 +203,45 @@ void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
 			default:
 				/* Unknown reloc type, print error and return */
 				dload_error(dlthis, "Bad coff operator 0x%x",
-						rp->r_type);
+					    rp->TYPE);
 			}
 #else
-			dload_error(dlthis, "Bad coff operator 0x%x",
-					rp->r_type);
+			dload_error(dlthis, "Bad coff operator 0x%x", rp->TYPE);
 #endif
 			return;
 		}
 	}
 	rx = HASH_I(rop_map2[rx]);
-	if ((rx < (sizeof(rop_action)/sizeof(uint_least16_t)))
-	   && (rx < (sizeof(rop_info)/sizeof(uint_least16_t))) && (rx > 0)) {
-		reloc_action = rop_action[rx]; reloc_info = rop_info[rx];
+	if ((rx < (sizeof(rop_action) / sizeof(uint_least16_t)))
+	    && (rx < (sizeof(rop_info) / sizeof(uint_least16_t))) && (rx > 0)) {
+		reloc_action = rop_action[rx];
+		reloc_info = rop_info[rx];
 	} else {
 		dload_error(dlthis, "Buffer Overflow - Array Index Out "
-				"of Bounds");
+			    "of Bounds");
 	}
 
 	/* Compute the relocation amount for the referenced symbol, if any */
-	reloc_amt = rp->r_uval;
+	reloc_amt = rp->UVAL;
 	if (RFV_SYM(reloc_info)) {	/* relocation uses a symbol reference */
 		/* If this is first pass, use the module local symbol table,
-		  * else use the trampoline symbol table.  */
-	       if (second_pass == false) {
-			if ((u32)rp->r_symndx < dlthis->dfile_hdr.df_no_syms) {
+		 * else use the trampoline symbol table. */
+		if (second_pass == false) {
+			if ((u32) rp->SYMNDX < dlthis->dfile_hdr.df_no_syms) {
 				/* real symbol reference */
-				svp = &dlthis->local_symtab[rp->r_symndx];
+				svp = &dlthis->local_symtab[rp->SYMNDX];
 				reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
-					    svp->delta : svp->value;
+				    svp->delta : svp->value;
 			}
 			/* reloc references current section */
-			else if (rp->r_symndx == -1) {
+			else if (rp->SYMNDX == -1) {
 				reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
-				dlthis->delta_runaddr :
-				dlthis->image_secn->run_addr;
+				    dlthis->delta_runaddr :
+				    dlthis->image_secn->run_addr;
 			}
 		}
-	}	/* relocation uses a symbol reference */
+	}
+	/* relocation uses a symbol reference */
 	/* Handle stack adjustment */
 	val = 0;
 	top = RFV_STK(reloc_info);
@@ -249,9 +249,9 @@ void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
 		top += dlthis->relstkidx - RSTK_UOP;
 		if (top >= STATIC_EXPR_STK_SIZE) {
 			dload_error(dlthis,
-			"Expression stack overflow in %s at offset "
-			FMT_UI32, dlthis->image_secn->name,
-			rp->r_vaddr + dlthis->image_offset);
+				    "Expression stack overflow in %s at offset "
+				    FMT_UI32, dlthis->image_secn->name,
+				    rp->vaddr + dlthis->image_offset);
 			return;
 		}
 		val = dlthis->relstk[dlthis->relstkidx];
@@ -264,29 +264,30 @@ void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
 		if (fieldsz) {	/* field info from table */
 			offset = RFV_POSN(reloc_action);
 			if (TARGET_BIG_ENDIAN)
-				/* make sure r_vaddr is the lowest target
+				/* make sure vaddr is the lowest target
 				 * address containing bits */
-				rp->r_vaddr += RFV_BIGOFF(reloc_info);
+				rp->vaddr += RFV_BIGOFF(reloc_info);
 		} else {	/* field info from relocation op */
-			fieldsz = rp->r_fieldsz; offset = rp->r_offset;
+			fieldsz = rp->FIELDSZ;
+			offset = rp->OFFSET;
 			if (TARGET_BIG_ENDIAN)
-				/* make sure r_vaddr is the lowest target
+				/* make sure vaddr is the lowest target
 				   address containing bits */
-				rp->r_vaddr += (rp->r_wordsz - offset - fieldsz)
-						>> LOG_TARGET_AU_BITS;
+				rp->vaddr += (rp->WORDSZ - offset - fieldsz)
+				    >> LOG_TARGET_AU_BITS;
 		}
-		data = (TgtAU_t *)((char *)data + TADDR_TO_HOST(rp->r_vaddr));
+		data = (tgt_au_t *) ((char *)data + TADDR_TO_HOST(rp->vaddr));
 		/* compute lowest host location of referenced data */
 #if BITS_PER_AU > TARGET_AU_BITS
 		/* conversion from target address to host address may lose
 		   address bits; add loss to offset */
 		if (TARGET_BIG_ENDIAN) {
-			offset += -((rp->r_vaddr << LOG_TARGET_AU_BITS) +
-				  offset + fieldsz) &
-				  (BITS_PER_AU-TARGET_AU_BITS);
+			offset += -((rp->vaddr << LOG_TARGET_AU_BITS) +
+				    offset + fieldsz) &
+			    (BITS_PER_AU - TARGET_AU_BITS);
 		} else {
-			offset += (rp->r_vaddr << LOG_TARGET_AU_BITS) &
-				  (BITS_PER_AU-1);
+			offset += (rp->vaddr << LOG_TARGET_AU_BITS) &
+			    (BITS_PER_AU - 1);
 		}
 #endif
 #ifdef RFV_SCALE
@@ -294,12 +295,13 @@ void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
 #endif
 	}
 	/* read the object value from the current image, if so ordered */
-	if (reloc_info & ROP_R) {    /* relocation reads current image value */
+	if (reloc_info & ROP_R) {
+		/* relocation reads current image value */
 		val = dload_unpack(dlthis, data, fieldsz, offset,
-		      RFV_SIGN(reloc_info));
-	/* Save off the original value in case the relo overflows and
-	  * we can trampoline it.  */
-	orig_val = val;
+				   RFV_SIGN(reloc_info));
+		/* Save off the original value in case the relo overflows and
+		 * we can trampoline it. */
+		orig_val = val;
 
 #ifdef RFV_SCALE
 		val <<= scale;
@@ -321,13 +323,13 @@ void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
 		 * (special reloc type) or to absolute destination
 		 * (symndx == -1).  In either case, set the appropriate
 		 * relocation amount to 0.
-		 *-----------------------------------------------------------*/
-		if (rp->r_symndx == -1)
+		 *----------------------------------------------------------- */
+		if (rp->SYMNDX == -1)
 			reloc_amt = 0;
 		val += reloc_amt - dlthis->delta_runaddr;
 		break;
 	case RACT_ADDISP:
-		val += rp->r_disp + reloc_amt;
+		val += rp->R_DISP + reloc_amt;
 		break;
 	case RACT_ASGPC:
 		val = dlthis->image_secn->run_addr + reloc_amt;
@@ -356,19 +358,19 @@ void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
 			val = *stackp % val;
 		break;
 	case RACT_SR:
-		if (val >= sizeof(RVALUE) * BITS_PER_AU)
+		if (val >= sizeof(rvalue) * BITS_PER_AU)
 			val = 0;
 		else if (stackp != NULL)
-			val = (URVALUE)*stackp >> val;
+			val = (urvalue) *stackp >> val;
 		break;
 	case RACT_ASR:
-		if (val >= sizeof(RVALUE)*BITS_PER_AU)
-			val = sizeof(RVALUE)*BITS_PER_AU - 1;
+		if (val >= sizeof(rvalue) * BITS_PER_AU)
+			val = sizeof(rvalue) * BITS_PER_AU - 1;
 		else if (stackp != NULL)
 			val = *stackp >> val;
 		break;
 	case RACT_SL:
-		if (val >= sizeof(RVALUE)*BITS_PER_AU)
+		if (val >= sizeof(rvalue) * BITS_PER_AU)
 			val = 0;
 		else if (stackp != NULL)
 			val = *stackp << val;
@@ -392,86 +394,91 @@ void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
 	case RACT_C6SECT:
 		/* actually needed address of secn containing symbol */
 		if (svp != NULL) {
-			if (rp->r_symndx >= 0)
+			if (rp->SYMNDX >= 0)
 				if (svp->secnn > 0)
 					reloc_amt = dlthis->ldr_sections
-						[svp->secnn-1].run_addr;
+					    [svp->secnn - 1].run_addr;
 		}
-	/* !!! FALL THRU !!! */
+		/* !!! FALL THRU !!! */
 	case RACT_C6BASE:
 		if (dlthis->bss_run_base == 0) {
 			struct dynload_symbol *symp;
-			symp = dlthis->mysym->Find_Matching_Symbol
-				(dlthis->mysym, BSSSYMBOL);
+			symp = dlthis->mysym->find_matching_symbol
+			    (dlthis->mysym, bsssymbol);
 			/* lookup value of global BSS base */
 			if (symp)
 				dlthis->bss_run_base = symp->value;
 			else
 				dload_error(dlthis,
-				     "Global BSS base referenced in %s offset"\
-				     FMT_UI32 " but not defined",
-				     dlthis->image_secn->name,
-				     rp->r_vaddr + dlthis->image_offset);
+					    "Global BSS base referenced in %s "
+					    "offset" FMT_UI32 " but not "
+					    "defined",
+					    dlthis->image_secn->name,
+					    rp->vaddr + dlthis->image_offset);
 		}
 		reloc_amt -= dlthis->bss_run_base;
 		/* !!! FALL THRU !!! */
 	case RACT_C6DSPL:
 		/* scale factor determined by 3 LSBs of field */
-		scale = C60_Scale[val & SCALE_MASK];
+		scale = c60_scale[val & SCALE_MASK];
 		offset += SCALE_BITS;
 		fieldsz -= SCALE_BITS;
 		val >>= SCALE_BITS;	/* ignore the scale field hereafter */
 		val <<= scale;
-		val += reloc_amt;		/* do the usual relocation */
-		if (((1 << scale)-1) & val)
+		val += reloc_amt;	/* do the usual relocation */
+		if (((1 << scale) - 1) & val)
 			dload_error(dlthis,
-				"Unaligned reference in %s offset " FMT_UI32,
-				dlthis->image_secn->name,
-				rp->r_vaddr + dlthis->image_offset);
+				    "Unaligned reference in %s offset "
+				    FMT_UI32, dlthis->image_secn->name,
+				    rp->vaddr + dlthis->image_offset);
 		break;
 #endif
-	}	/* relocation actions */
+	}			/* relocation actions */
 	/* * Put back result as required */
 	if (reloc_info & ROP_W) {	/* relocation writes image value */
 #ifdef RFV_SCALE
 		val >>= scale;
 #endif
 		if (dload_repack(dlthis, val, data, fieldsz, offset,
-		   RFV_SIGN(reloc_info))) {
+				 RFV_SIGN(reloc_info))) {
 			/* Check to see if this relo can be trampolined,
-			  * but only in first phase relocation.  2nd phase
-			  * relocation cannot trampoline.  */
+			 * but only in first phase relocation.  2nd phase
+			 * relocation cannot trampoline. */
 			if ((second_pass == false) &&
-				(dload_tramp_avail(dlthis, rp) == true)) {
+			    (dload_tramp_avail(dlthis, rp) == true)) {
 
 				/* Before generating the trampoline, restore
-				  * the value to its original so the 2nd pass
-				  *  relo will work.  */
+				 * the value to its original so the 2nd pass
+				 *  relo will work. */
 				dload_repack(dlthis, orig_val, data, fieldsz,
-					offset, RFV_SIGN(reloc_info));
+					     offset, RFV_SIGN(reloc_info));
 				if (!dload_tramp_generate(dlthis,
-					(dlthis->image_secn - dlthis->
-					ldr_sections), dlthis->image_offset,
-					img_pkt, rp)) {
-					dload_error(dlthis, "Failed to "
-					     "generate trampoline for bit "
-					     "overflow");
-					dload_error(dlthis, "Relocation value "
-					   FMT_UI32 " overflows %d bits in %s "
-					   "offset " FMT_UI32, val, fieldsz,
-					   dlthis->image_secn->name,
-					   dlthis->image_offset + rp->r_vaddr);
+							(dlthis->image_secn -
+							 dlthis->ldr_sections),
+							 dlthis->image_offset,
+							 img_pkt, rp)) {
+					dload_error(dlthis,
+						    "Failed to "
+						    "generate trampoline for "
+						    "bit overflow");
+					dload_error(dlthis,
+						    "Relocation val " FMT_UI32
+						    " overflows %d bits in %s "
+						    "offset " FMT_UI32, val,
+						    fieldsz,
+						    dlthis->image_secn->name,
+						    dlthis->image_offset +
+						    rp->vaddr);
 				} else
 					*tramps_genereted = true;
 			} else {
 				dload_error(dlthis, "Relocation value "
-					FMT_UI32 " overflows %d bits in %s"
-					" offset " FMT_UI32, val, fieldsz,
-					dlthis->image_secn->name,
-					dlthis->image_offset + rp->r_vaddr);
+					    FMT_UI32 " overflows %d bits in %s"
+					    " offset " FMT_UI32, val, fieldsz,
+					    dlthis->image_secn->name,
+					    dlthis->image_offset + rp->vaddr);
 			}
 		}
 	} else if (top)
 		*stackp = val;
-} /* reloc_value */
-
+}				/* reloc_value */
diff --git a/drivers/dsp/bridge/dynload/reloc_table.h b/drivers/dsp/bridge/dynload/reloc_table.h
index 1d25d18..6aab03d 100644
--- a/drivers/dsp/bridge/dynload/reloc_table.h
+++ b/drivers/dsp/bridge/dynload/reloc_table.h
@@ -14,8 +14,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __RELOC_TABLE_H__
-#define __RELOC_TABLE_H__
+#ifndef _RELOC_TABLE_H_
+#define _RELOC_TABLE_H_
 /*
  * Table of relocation operator properties
  */
@@ -32,11 +32,11 @@
 #define ROP_ANY	0		/* no overflow ever, just truncate the value */
 #define ROP_SGN	1		/* signed field */
 #define ROP_UNS	2		/* unsigned field */
-#define ROP_MAX 3	  /* allow maximum range of either signed or unsigned */
+#define ROP_MAX 3	/* allow maximum range of either signed or unsigned */
 
 /* How does the relocation operation use the symbol reference */
 #define ROP_IGN	0		/* no symbol is referenced */
-#define ROP_LIT 0		/* use rp->r_uval literal field */
+#define ROP_LIT 0		/* use rp->UVAL literal field */
 #define ROP_SYM	1		/* symbol value is used in relocation */
 #define ROP_SYMD 2		/* delta value vs last link is used */
 
@@ -49,13 +49,15 @@
 /*
  * Computational actions performed by the dynamic loader
  */
-enum Dload_Actions {
-	RACT_VAL,    /* don't alter the current val (from stack or mem fetch) */
-	RACT_ASGN,   /* set value to reference amount (from symbol reference) */
+enum dload_actions {
+	/* don't alter the current val (from stack or mem fetch) */
+	RACT_VAL,
+	/* set value to reference amount (from symbol reference) */
+	RACT_ASGN,
 	RACT_ADD,		/* add reference to value */
 	RACT_PCR,		/* add reference minus PC delta to value */
-	RACT_ADDISP,		/* add reference plus r_disp */
-	RACT_ASGPC,	/* set value to section address plus reference */
+	RACT_ADDISP,		/* add reference plus R_DISP */
+	RACT_ASGPC,		/* set value to section addr plus reference */
 
 	RACT_PLUS,		/* stack + */
 	RACT_SUB,		/* stack - */
@@ -97,4 +99,4 @@ enum Dload_Actions {
 #define RFV_BIGOFF(iii) ((iii) >> 8)
 #endif
 
-#endif				/* __RELOC_TABLE_H__ */
+#endif /* _RELOC_TABLE_H_ */
diff --git a/drivers/dsp/bridge/dynload/tramp.c b/drivers/dsp/bridge/dynload/tramp.c
index c2fe02d..7b593fc 100644
--- a/drivers/dsp/bridge/dynload/tramp.c
+++ b/drivers/dsp/bridge/dynload/tramp.c
@@ -30,28 +30,30 @@
 static int priv_tramp_sect_tgt_alloc(struct dload_state *dlthis)
 {
 	int ret_val = 0;
-	struct LDR_SECTION_INFO	*sect_info;
+	struct ldr_section_info *sect_info;
 
 	/*  Populate the trampoline loader section and allocate it on the
 	 * target.  The section name is ALWAYS the first string in the final
 	 * string table for trampolines.  The trampoline section is always
-	 * 1 beyond the total number of allocated sections.  */
+	 * 1 beyond the total number of allocated sections. */
 	sect_info = &dlthis->ldr_sections[dlthis->allocated_secn_count];
 
 	sect_info->name = dlthis->tramp.final_string_table;
 	sect_info->size = dlthis->tramp.tramp_sect_next_addr;
 	sect_info->context = 0;
 	sect_info->type =
-		(4 << 8) | DLOAD_TEXT | DS_ALLOCATE_MASK | DS_DOWNLOAD_MASK;
+	    (4 << 8) | DLOAD_TEXT | DS_ALLOCATE_MASK | DS_DOWNLOAD_MASK;
 	sect_info->page = 0;
 	sect_info->run_addr = 0;
 	sect_info->load_addr = 0;
-	ret_val = dlthis->myalloc->Allocate(dlthis->myalloc,
-			sect_info, DS_ALIGNMENT(sect_info->type));
+	ret_val = dlthis->myalloc->dload_allocate(dlthis->myalloc,
+						  sect_info,
+						  DS_ALIGNMENT
+						  (sect_info->type));
 
 	if (ret_val == 0)
 		dload_error(dlthis, "Failed to allocate target memory for"
-							" trampoline");
+			    " trampoline");
 
 	return ret_val;
 }
@@ -88,26 +90,26 @@ static void priv_tramp_sym_gen_name(u32 value, char *dst)
 	volatile char *dst_local = dst;
 	u8 tmp;
 
-	/*  Clear out the destination, including the ending NULL  */
+	/*  Clear out the destination, including the ending NULL */
 	for (i = 0; i < (TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN); i++)
 		*(dst_local + i) = 0;
 
-	/*  Copy the prefix to start  */
+	/*  Copy the prefix to start */
 	for (i = 0; i < strlen(TRAMP_SYM_PREFIX); i++) {
 		*dst_local = *(prefix + i);
 		dst_local++;
 	}
 
-	/*  Now convert the value passed in to a string equiv of the hex  */
+	/*  Now convert the value passed in to a string equiv of the hex */
 	for (i = 0; i < sizeof(value); i++) {
 #ifndef _BIG_ENDIAN
-		tmp = *(((u8 *)&value) + (sizeof(value) - 1) - i);
+		tmp = *(((u8 *) &value) + (sizeof(value) - 1) - i);
 		*dst_local = priv_h2a((tmp & 0xF0) >> 4);
 		dst_local++;
 		*dst_local = priv_h2a(tmp & 0x0F);
 		dst_local++;
 #else
-		tmp = *(((u8 *)&value) + i);
+		tmp = *(((u8 *) &value) + i);
 		*dst_local = priv_h2a((tmp & 0xF0) >> 4);
 		dst_local++;
 		*dst_local = priv_h2a(tmp & 0x0F);
@@ -115,7 +117,7 @@ static void priv_tramp_sym_gen_name(u32 value, char *dst)
 #endif
 	}
 
-	/*  NULL terminate  */
+	/*  NULL terminate */
 	*dst_local = 0;
 }
 
@@ -126,23 +128,28 @@ static void priv_tramp_sym_gen_name(u32 value, char *dst)
  *	  trampoline section name and trampoline point symbols.
  */
 static struct tramp_string *priv_tramp_string_create(struct dload_state *dlthis,
-	  u32 str_len, char *str)
+						     u32 str_len, char *str)
 {
 	struct tramp_string *new_string = NULL;
 	u32 i;
 
-	/*  Create a new string object with the specified size.  */
-	new_string = (struct tramp_string *)dlthis->mysym->Allocate(
-		dlthis->mysym, (sizeof(struct tramp_string) + str_len + 1));
+	/*  Create a new string object with the specified size. */
+	new_string =
+	    (struct tramp_string *)dlthis->mysym->dload_allocate(dlthis->mysym,
+								 (sizeof
+								  (struct
+								   tramp_string)
+								  + str_len +
+								  1));
 	if (new_string != NULL) {
 		/*  Clear the string first.  This ensures the ending NULL is
-		 * present and the optimizer won't touch it.  */
+		 * present and the optimizer won't touch it. */
 		for (i = 0; i < (sizeof(struct tramp_string) + str_len + 1);
-				i++)
-			*((u8 *)new_string + i) = 0;
+		     i++)
+			*((u8 *) new_string + i) = 0;
 
 		/*  Add this string to our virtual table by assigning it the
-		 * next index and pushing it to the tail of the list.  */
+		 * next index and pushing it to the tail of the list. */
 		new_string->index = dlthis->tramp.tramp_string_next_index;
 		dlthis->tramp.tramp_string_next_index++;
 		dlthis->tramp.tramp_string_size += str_len + 1;
@@ -155,7 +162,7 @@ static struct tramp_string *priv_tramp_string_create(struct dload_state *dlthis,
 
 		dlthis->tramp.string_tail = new_string;
 
-		/*  Copy the string over to the new object  */
+		/*  Copy the string over to the new object */
 		for (i = 0; i < str_len; i++)
 			new_string->str[i] = str[i];
 	}
@@ -169,7 +176,7 @@ static struct tramp_string *priv_tramp_string_create(struct dload_state *dlthis,
  *	  provided string.  If not match is found, NULL is returned.
  */
 static struct tramp_string *priv_tramp_string_find(struct dload_state *dlthis,
-								char *str)
+						   char *str)
 {
 	struct tramp_string *cur_str = NULL;
 	struct tramp_string *ret_val = NULL;
@@ -177,18 +184,17 @@ static struct tramp_string *priv_tramp_string_find(struct dload_state *dlthis,
 	u32 str_len = strlen(str);
 
 	for (cur_str = dlthis->tramp.string_head;
-		 (ret_val == NULL) && (cur_str != NULL);
-		 cur_str = cur_str->next) {
+	     (ret_val == NULL) && (cur_str != NULL); cur_str = cur_str->next) {
 		/*  If the string lengths aren't equal, don't bother
-		 * comparing  */
+		 * comparing */
 		if (str_len != strlen(cur_str->str))
 			continue;
 
-		/*  Walk the strings until one of them ends  */
+		/*  Walk the strings until one of them ends */
 		for (i = 0; i < str_len; i++) {
 			/*  If they don't match in the current position then
 			 * break out now, no sense in continuing to look at
-			 * this string.  */
+			 * this string. */
 			if (str[i] != cur_str->str[i])
 				break;
 		}
@@ -215,44 +221,45 @@ static int priv_string_tbl_finalize(struct dload_state *dlthis)
 
 	/*  Allocate enough space for all strings that have been created.  The
 	 * table is simply all strings concatenated together will NULL
-	 * endings.  */
+	 * endings. */
 	dlthis->tramp.final_string_table =
-		(char *)dlthis->mysym->Allocate(dlthis->mysym,
-					dlthis->tramp.tramp_string_size);
+	    (char *)dlthis->mysym->dload_allocate(dlthis->mysym,
+						  dlthis->tramp.
+						  tramp_string_size);
 	if (dlthis->tramp.final_string_table != NULL) {
 		/*  We got our buffer, walk the list and release the nodes as*
-		 * we go  */
+		 * we go */
 		cur_loc = dlthis->tramp.final_string_table;
 		cur_string = dlthis->tramp.string_head;
 		while (cur_string != NULL) {
-			/*  Move the head/tail pointers  */
+			/*  Move the head/tail pointers */
 			dlthis->tramp.string_head = cur_string->next;
 			if (dlthis->tramp.string_tail == cur_string)
 				dlthis->tramp.string_tail = NULL;
 
-			/*  Copy the string contents  */
+			/*  Copy the string contents */
 			for (tmp = cur_string->str;
-				 *tmp != '\0';
-				 tmp++, cur_loc++)
+			     *tmp != '\0'; tmp++, cur_loc++)
 				*cur_loc = *tmp;
 
 			/*  Pick up the NULL termination since it was missed by
-			 * breaking using it to end the above loop.  */
+			 * breaking using it to end the above loop. */
 			*cur_loc = '\0';
 			cur_loc++;
 
 			/*  Free the string node, we don't need it any more. */
-			dlthis->mysym->Deallocate(dlthis->mysym, cur_string);
+			dlthis->mysym->dload_deallocate(dlthis->mysym,
+							cur_string);
 
-			/*  Move our pointer to the next one  */
+			/*  Move our pointer to the next one */
 			cur_string = dlthis->tramp.string_head;
 		}
 
-		/*  Update our return value to success  */
+		/*  Update our return value to success */
 		ret_val = 1;
 	} else
 		dload_error(dlthis, "Failed to allocate trampoline "
-						"string table");
+			    "string table");
 
 	return ret_val;
 }
@@ -269,14 +276,14 @@ static u32 priv_tramp_sect_alloc(struct dload_state *dlthis, u32 tramp_size)
 	u32 ret_val;
 
 	/*  If the next available address is 0, this is our first allocation.
-	 * Create a section name string to go into the string table .  */
+	 * Create a section name string to go into the string table . */
 	if (dlthis->tramp.tramp_sect_next_addr == 0) {
 		dload_syms_error(dlthis->mysym, "*** WARNING ***  created "
-			"dynamic TRAMPOLINE section for module %s",
-			dlthis->str_head);
+				 "dynamic TRAMPOLINE section for module %s",
+				 dlthis->str_head);
 	}
 
-	/*  Reserve space for the new trampoline  */
+	/*  Reserve space for the new trampoline */
 	ret_val = dlthis->tramp.tramp_sect_next_addr;
 	dlthis->tramp.tramp_sect_next_addr += tramp_size;
 	return ret_val;
@@ -290,31 +297,33 @@ static u32 priv_tramp_sect_alloc(struct dload_state *dlthis, u32 tramp_size)
  *	  reference.
  */
 static struct tramp_sym *priv_tramp_sym_create(struct dload_state *dlthis,
-			u32 str_index, struct Local_Symbol *tmp_sym)
+					       u32 str_index,
+					       struct local_symbol *tmp_sym)
 {
-	struct tramp_sym	*new_sym = NULL;
+	struct tramp_sym *new_sym = NULL;
 	u32 i;
 
-	/*  Allocate new space for the symbol in the symbol table.  */
-	new_sym = (struct tramp_sym *)dlthis->mysym->Allocate(dlthis->mysym,
-						   sizeof(struct tramp_sym));
+	/*  Allocate new space for the symbol in the symbol table. */
+	new_sym =
+	    (struct tramp_sym *)dlthis->mysym->dload_allocate(dlthis->mysym,
+					      sizeof(struct tramp_sym));
 	if (new_sym != NULL) {
 		for (i = 0; i != sizeof(struct tramp_sym); i++)
 			*((char *)new_sym + i) = 0;
 
 		/*  Assign this symbol the next symbol index for easier
-		 * reference later during relocation.  */
+		 * reference later during relocation. */
 		new_sym->index = dlthis->tramp.tramp_sym_next_index;
 		dlthis->tramp.tramp_sym_next_index++;
 
 		/*  Populate the symbol information.  At this point any
 		 * trampoline symbols will be the offset location, not the
 		 * final.  Copy over the symbol info to start, then be sure to
-		 * get the string index from the trampoline string table.  */
+		 * get the string index from the trampoline string table. */
 		new_sym->sym_info = *tmp_sym;
 		new_sym->str_index = str_index;
 
-		/*  Push the new symbol to the tail of the symbol table list  */
+		/*  Push the new symbol to the tail of the symbol table list */
 		new_sym->next = NULL;
 		if (dlthis->tramp.symbol_head == NULL)
 			dlthis->tramp.symbol_head = new_sym;
@@ -334,14 +343,13 @@ static struct tramp_sym *priv_tramp_sym_create(struct dload_state *dlthis,
  *	  symbol object, if found.  Otherwise return NULL.
  */
 static struct tramp_sym *priv_tramp_sym_get(struct dload_state *dlthis,
-						 u32 string_index)
+					    u32 string_index)
 {
 	struct tramp_sym *sym_found = NULL;
 
-	/*  Walk the symbol table list and search vs. the string index  */
+	/*  Walk the symbol table list and search vs. the string index */
 	for (sym_found = dlthis->tramp.symbol_head;
-		 sym_found != NULL;
-		 sym_found = sym_found->next) {
+	     sym_found != NULL; sym_found = sym_found->next) {
 		if (sym_found->str_index == string_index)
 			break;
 	}
@@ -356,13 +364,13 @@ static struct tramp_sym *priv_tramp_sym_get(struct dload_state *dlthis,
  *	  return NULL.
  */
 static struct tramp_sym *priv_tramp_sym_find(struct dload_state *dlthis,
-							char *string)
+					     char *string)
 {
 	struct tramp_sym *sym_found = NULL;
 	struct tramp_string *str_found = NULL;
 
 	/*  First, search for the string, then search for the sym based on the
-		string index.  */
+	   string index. */
 	str_found = priv_tramp_string_find(dlthis, string);
 	if (str_found != NULL)
 		sym_found = priv_tramp_sym_get(dlthis, str_found->index);
@@ -381,29 +389,29 @@ static int priv_tramp_sym_finalize(struct dload_state *dlthis)
 {
 	int ret_val = 0;
 	struct tramp_sym *cur_sym;
-	struct LDR_SECTION_INFO *tramp_sect =
-		&dlthis->ldr_sections[dlthis->allocated_secn_count];
-	struct Local_Symbol *new_sym;
+	struct ldr_section_info *tramp_sect =
+	    &dlthis->ldr_sections[dlthis->allocated_secn_count];
+	struct local_symbol *new_sym;
 
 	/*  Allocate a table to hold a flattened version of all symbols
-	 * created.  */
+	 * created. */
 	dlthis->tramp.final_sym_table =
-		(struct Local_Symbol *)dlthis->mysym->Allocate(
-			dlthis->mysym, (sizeof(struct Local_Symbol) *
-			dlthis->tramp.tramp_sym_next_index));
+	    (struct local_symbol *)dlthis->mysym->dload_allocate(dlthis->mysym,
+				 (sizeof(struct local_symbol) * dlthis->tramp.
+						  tramp_sym_next_index));
 	if (dlthis->tramp.final_sym_table != NULL) {
 		/*  Walk the list of all symbols, copy it over to the flattened
 		 * table. After it has been copied, the node can be freed as
-		 * it is no longer needed.  */
+		 * it is no longer needed. */
 		new_sym = dlthis->tramp.final_sym_table;
 		cur_sym = dlthis->tramp.symbol_head;
 		while (cur_sym != NULL) {
-			/*  Pop it off the list  */
+			/*  Pop it off the list */
 			dlthis->tramp.symbol_head = cur_sym->next;
 			if (cur_sym == dlthis->tramp.symbol_tail)
 				dlthis->tramp.symbol_tail = NULL;
 
-			/*  Copy the symbol contents into the flat table  */
+			/*  Copy the symbol contents into the flat table */
 			*new_sym = cur_sym->sym_info;
 
 			/*  Now finaize the symbol.  If it is in the tramp
@@ -413,16 +421,16 @@ static int priv_tramp_sym_finalize(struct dload_state *dlthis)
 			 * NOTE: THIS CODE ASSUMES THAT THE TRAMPOLINE IS
 			 * REFERENCED LIKE A CALL TO AN EXTERNAL SO VALUE AND
 			 * DELTA ARE THE SAME.  SEE THE FUNCTION dload_symbols
-			 * WHERE DN_UNDEF IS HANDLED FOR MORE REFERENCE.  */
+			 * WHERE DN_UNDEF IS HANDLED FOR MORE REFERENCE. */
 			if (new_sym->secnn < 0) {
 				new_sym->value += tramp_sect->load_addr;
 				new_sym->delta = new_sym->value;
 			}
 
-			/*  Let go of the symbol node  */
-			dlthis->mysym->Deallocate(dlthis->mysym, cur_sym);
+			/*  Let go of the symbol node */
+			dlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);
 
-			/*  Move to the next node  */
+			/*  Move to the next node */
 			cur_sym = dlthis->tramp.symbol_head;
 			new_sym++;
 		}
@@ -442,7 +450,7 @@ static int priv_tramp_sym_finalize(struct dload_state *dlthis)
  *	to the trampoline list.
  */
 static int priv_tgt_img_gen(struct dload_state *dlthis, u32 base,
-		u32 gen_index, struct tramp_sym *new_ext_sym)
+			    u32 gen_index, struct tramp_sym *new_ext_sym)
 {
 	struct tramp_img_pkt *new_img_pkt = NULL;
 	u32 i;
@@ -452,31 +460,31 @@ static int priv_tgt_img_gen(struct dload_state *dlthis, u32 base,
 	struct reloc_record_t *cur_relo;
 	int ret_val = 0;
 
-	/*  Allocate a new image packet and set it up.  */
+	/*  Allocate a new image packet and set it up. */
 	new_img_pkt =
-		(struct tramp_img_pkt *)dlthis->mysym->Allocate(dlthis->mysym,
-								 pkt_size);
+	    (struct tramp_img_pkt *)dlthis->mysym->dload_allocate(dlthis->mysym,
+								  pkt_size);
 	if (new_img_pkt != NULL) {
-		/*  Save the base, this is where it goes in the section  */
+		/*  Save the base, this is where it goes in the section */
 		new_img_pkt->base = base;
 
 		/*  Copy over the image data and relos from the target table */
-		pkt_data = (u8 *)&new_img_pkt->hdr;
-		gen_tbl_entry = (u8 *)&tramp_gen_info[gen_index];
+		pkt_data = (u8 *) &new_img_pkt->hdr;
+		gen_tbl_entry = (u8 *) &tramp_gen_info[gen_index];
 		for (i = 0; i < pkt_size; i++) {
 			*pkt_data = *gen_tbl_entry;
 			pkt_data++;
 			gen_tbl_entry++;
 		}
 
-		/*  Update the relocations to point to the external symbol  */
+		/*  Update the relocations to point to the external symbol */
 		cur_relo =
-			(struct reloc_record_t *)((u8 *)&new_img_pkt->hdr +
-					   new_img_pkt->hdr.relo_offset);
+		    (struct reloc_record_t *)((u8 *) &new_img_pkt->hdr +
+					      new_img_pkt->hdr.relo_offset);
 		for (i = 0; i < new_img_pkt->hdr.num_relos; i++)
-			cur_relo[i].r_symndx = new_ext_sym->index;
+			cur_relo[i].SYMNDX = new_ext_sym->index;
 
-		/*  Add it to the trampoline list.  */
+		/*  Add it to the trampoline list. */
 		new_img_pkt->next = dlthis->tramp.tramp_pkts;
 		dlthis->tramp.tramp_pkts = new_img_pkt;
 
@@ -495,7 +503,7 @@ static int priv_tgt_img_gen(struct dload_state *dlthis, u32 base,
  *	  TRAMPOLINES ARE TREATED AS 2ND PASS even though this is really
  *	  the first (and only) relocation that will be performed on them.
  */
-static int priv_pkt_relo(struct dload_state *dlthis, TgtAU_t *data,
+static int priv_pkt_relo(struct dload_state *dlthis, tgt_au_t * data,
 			 struct reloc_record_t *rp[], u32 relo_count)
 {
 	int ret_val = 1;
@@ -504,7 +512,7 @@ static int priv_pkt_relo(struct dload_state *dlthis, TgtAU_t *data,
 
 	/*  Walk through all of the relos and process them.  This function is
 	 * the equivalent of relocate_packet() from cload.c, but specialized
-	 * for trampolines and 2nd phase relocations.  */
+	 * for trampolines and 2nd phase relocations. */
 	for (i = 0; i < relo_count; i++)
 		dload_relocate(dlthis, data, rp[i], &tmp, true);
 
@@ -528,49 +536,51 @@ static int priv_tramp_pkt_finalize(struct dload_state *dlthis)
 	u32 relos_done;
 	u32 i;
 	struct reloc_record_t *cur_relo;
-	struct LDR_SECTION_INFO *sect_info =
-		&dlthis->ldr_sections[dlthis->allocated_secn_count];
+	struct ldr_section_info *sect_info =
+	    &dlthis->ldr_sections[dlthis->allocated_secn_count];
 
 	/*  Walk the list of trampoline packets and relocate each packet.  This
 	 * function is the trampoline equivalent of dload_data() from
-	 * cload.c.  */
+	 * cload.c. */
 	cur_pkt = dlthis->tramp.tramp_pkts;
 	while ((ret_val != 0) && (cur_pkt != NULL)) {
-		/*  Remove the pkt from the list  */
+		/*  Remove the pkt from the list */
 		dlthis->tramp.tramp_pkts = cur_pkt->next;
 
-		/*  Setup section and image offset information for the relo  */
+		/*  Setup section and image offset information for the relo */
 		dlthis->image_secn = sect_info;
 		dlthis->image_offset = cur_pkt->base;
 		dlthis->delta_runaddr = sect_info->run_addr;
 
-		/*  Walk through all relos for the packet  */
+		/*  Walk through all relos for the packet */
 		relos_done = 0;
-		cur_relo = (struct reloc_record_t *)((u8 *)&cur_pkt->hdr +
-						  cur_pkt->hdr.relo_offset);
+		cur_relo = (struct reloc_record_t *)((u8 *) &cur_pkt->hdr +
+						     cur_pkt->hdr.relo_offset);
 		while (relos_done < cur_pkt->hdr.num_relos) {
 #ifdef ENABLE_TRAMP_DEBUG
 			dload_syms_error(dlthis->mysym,
-				 "===> Trampoline %x branches to %x",
-				 sect_info->run_addr + dlthis->image_offset,
-				 dlthis->tramp.
-				 final_sym_table[cur_relo->r_symndx].value);
+					 "===> Trampoline %x branches to %x",
+					 sect_info->run_addr +
+					 dlthis->image_offset,
+					 dlthis->
+					 tramp.final_sym_table[cur_relo->
+							       SYMNDX].value);
 #endif
 
 			for (i = 0;
-				 ((i < MAX_RELOS_PER_PASS) &&
-				  ((i + relos_done) < cur_pkt->hdr.num_relos));
-				 i++)
+			     ((i < MAX_RELOS_PER_PASS) &&
+			      ((i + relos_done) < cur_pkt->hdr.num_relos)); i++)
 				relos[i] = cur_relo + i;
 
-			/*  Do the actual relo  */
+			/*  Do the actual relo */
 			ret_val = priv_pkt_relo(dlthis,
-						(TgtAU_t *)&cur_pkt->payload,
+						(tgt_au_t *) &cur_pkt->payload,
 						relos, i);
 			if (ret_val == 0) {
 				dload_error(dlthis,
-				"Relocation of trampoline pkt at %x failed",
-				cur_pkt->base + sect_info->run_addr);
+					    "Relocation of trampoline pkt at %x"
+					    " failed", cur_pkt->base +
+					    sect_info->run_addr);
 				break;
 			}
 
@@ -578,25 +588,29 @@ static int priv_tramp_pkt_finalize(struct dload_state *dlthis)
 			cur_relo += i;
 		}
 
-		/*  Make sure we didn't hit a problem  */
+		/*  Make sure we didn't hit a problem */
 		if (ret_val != 0) {
 			/*  Relos are done for the packet, write it to the
-			 * target  */
+			 * target */
 			ret_val = dlthis->myio->writemem(dlthis->myio,
-					   &cur_pkt->payload,
-					   sect_info->load_addr + cur_pkt->base
-					   , sect_info, BYTE_TO_HOST(
-					   cur_pkt->hdr.tramp_code_size));
+							 &cur_pkt->payload,
+							 sect_info->load_addr +
+							 cur_pkt->base,
+							 sect_info,
+							 BYTE_TO_HOST
+							 (cur_pkt->hdr.
+							  tramp_code_size));
 			if (ret_val == 0) {
 				dload_error(dlthis,
-					"Write to " FMT_UI32 " failed",
-					sect_info->load_addr + cur_pkt->base);
+					    "Write to " FMT_UI32 " failed",
+					    sect_info->load_addr +
+					    cur_pkt->base);
 			}
 
-			/*  Done with the pkt, let it go  */
-			dlthis->mysym->Deallocate(dlthis->mysym, cur_pkt);
+			/*  Done with the pkt, let it go */
+			dlthis->mysym->dload_deallocate(dlthis->mysym, cur_pkt);
 
-			/*  Get the next packet to process  */
+			/*  Get the next packet to process */
 			cur_pkt = dlthis->tramp.tramp_pkts;
 		}
 	}
@@ -627,78 +641,84 @@ static int priv_dup_pkt_finalize(struct dload_state *dlthis)
 	 * pkt that was generated and performs all relocations that were
 	 * deferred to a 2nd pass.  This is the equivalent of dload_data() from
 	 * cload.c, but does not need the additional reorder and checksum
-	 * processing as it has already been done.  */
+	 * processing as it has already been done. */
 	cur_pkt = dlthis->tramp.dup_pkts;
 	while ((ret_val != 0) && (cur_pkt != NULL)) {
 		/*  Remove the node from the list, we'll be freeing it
-		 * shortly  */
+		 * shortly */
 		dlthis->tramp.dup_pkts = cur_pkt->next;
 
-		/*  Setup the section and image offset for relocation  */
+		/*  Setup the section and image offset for relocation */
 		dlthis->image_secn = &dlthis->ldr_sections[cur_pkt->secnn];
 		dlthis->image_offset = cur_pkt->offset;
 
 		/*  In order to get the delta run address, we need to reference
 		 * the original section header.  It's a bit ugly, but needed
-		 * for relo.  */
-		i = (s32)(dlthis->image_secn - dlthis->ldr_sections);
+		 * for relo. */
+		i = (s32) (dlthis->image_secn - dlthis->ldr_sections);
 		sect_hdr = dlthis->sect_hdrs + i;
 		dlthis->delta_runaddr = sect_hdr->ds_paddr;
 
-		/*  Walk all relos in the chain and process each.  */
+		/*  Walk all relos in the chain and process each. */
 		cur_relo = cur_pkt->relo_chain;
 		while (cur_relo != NULL) {
-			/*  Process them a chunk at a time to be efficient  */
+			/*  Process them a chunk at a time to be efficient */
 			for (i = 0; (i < MAX_RELOS_PER_PASS)
-				 && (cur_relo != NULL);
-				 i++, cur_relo = cur_relo->next) {
+			     && (cur_relo != NULL);
+			     i++, cur_relo = cur_relo->next) {
 				relos[i] = &cur_relo->relo;
 				cur_pkt->relo_chain = cur_relo->next;
 			}
 
-			/*  Do the actual relo  */
+			/*  Do the actual relo */
 			ret_val = priv_pkt_relo(dlthis,
-				cur_pkt->img_pkt.i_bits,
-				relos, i);
+						cur_pkt->img_pkt.img_data,
+						relos, i);
 			if (ret_val == 0) {
 				dload_error(dlthis,
-					"Relocation of dup pkt at %x failed",
-					cur_pkt->offset + dlthis->image_secn->
-					run_addr);
+					    "Relocation of dup pkt at %x"
+					    " failed", cur_pkt->offset +
+					    dlthis->image_secn->run_addr);
 				break;
 			}
 
 			/*  Release all of these relos, we're done with them */
 			while (i > 0) {
-				dlthis->mysym->Deallocate(dlthis->mysym,
-					  GET_CONTAINER(relos[i - 1],
-					struct tramp_img_dup_relo, relo));
+				dlthis->mysym->dload_deallocate(dlthis->mysym,
+						GET_CONTAINER
+						(relos[i - 1],
+						 struct tramp_img_dup_relo,
+						 relo));
 				i--;
 			}
 
 			/*  DO NOT ADVANCE cur_relo, IT IS ALREADY READY TO
-			 * GO!  */
+			 * GO! */
 		}
 
 		/* Done with all relos.  Make sure we didn't have a problem and
-		 * write it out to the target  */
+		 * write it out to the target */
 		if (ret_val != 0) {
 			ret_val = dlthis->myio->writemem(dlthis->myio,
-				   cur_pkt->img_pkt.i_bits,
-				   dlthis->image_secn->load_addr +
-				   cur_pkt->offset, dlthis->image_secn,
-				   BYTE_TO_HOST(cur_pkt->
-				   img_pkt.i_packet_size));
+							 cur_pkt->img_pkt.
+							 img_data,
+							 dlthis->image_secn->
+							 load_addr +
+							 cur_pkt->offset,
+							 dlthis->image_secn,
+							 BYTE_TO_HOST
+							 (cur_pkt->img_pkt.
+							  packet_size));
 			if (ret_val == 0) {
 				dload_error(dlthis,
-					"Write to " FMT_UI32 " failed",
-					dlthis->image_secn->load_addr +
-					cur_pkt->offset);
+					    "Write to " FMT_UI32 " failed",
+					    dlthis->image_secn->load_addr +
+					    cur_pkt->offset);
 			}
 
-			dlthis->mysym->Deallocate(dlthis->mysym, cur_pkt);
+			dlthis->mysym->dload_deallocate(dlthis->mysym, cur_pkt);
 
-			/*  Advance to the next packet  */
+			/*  Advance to the next packet */
 			cur_pkt = dlthis->tramp.dup_pkts;
 		}
 	}
@@ -713,16 +733,15 @@ static int priv_dup_pkt_finalize(struct dload_state *dlthis)
  *	  the duplicate packet if found, otherwise NULL.
  */
 static struct tramp_img_dup_pkt *priv_dup_find(struct dload_state *dlthis,
-					s16 secnn, u32 image_offset)
+					       s16 secnn, u32 image_offset)
 {
 	struct tramp_img_dup_pkt *cur_pkt = NULL;
 
 	for (cur_pkt = dlthis->tramp.dup_pkts;
-		 cur_pkt != NULL;
-		 cur_pkt = cur_pkt->next) {
+	     cur_pkt != NULL; cur_pkt = cur_pkt->next) {
 		if ((cur_pkt->secnn == secnn) &&
-			(cur_pkt->offset == image_offset)) {
-			/*  Found a match, break out  */
+		    (cur_pkt->offset == image_offset)) {
+			/*  Found a match, break out */
 			break;
 		}
 	}
@@ -743,8 +762,10 @@ static struct tramp_img_dup_pkt *priv_dup_find(struct dload_state *dlthis,
  *	  the dup packet's relo chain for 2nd pass relocation later.
  */
 static int priv_img_pkt_dup(struct dload_state *dlthis,
-	s16 secnn, u32 image_offset, struct image_packet_t *ipacket,
-	struct reloc_record_t *rp, struct tramp_sym *new_tramp_sym)
+			    s16 secnn, u32 image_offset,
+			    struct image_packet_t *ipacket,
+			    struct reloc_record_t *rp,
+			    struct tramp_sym *new_tramp_sym)
 {
 	struct tramp_img_dup_pkt *dup_pkt = NULL;
 	u32 new_dup_size;
@@ -753,31 +774,31 @@ static int priv_img_pkt_dup(struct dload_state *dlthis,
 	struct tramp_img_dup_relo *dup_relo = NULL;
 
 	/*  Determinne if this image packet is already being tracked in the
-		dup list for other trampolines.  */
+	   dup list for other trampolines. */
 	dup_pkt = priv_dup_find(dlthis, secnn, image_offset);
 
 	if (dup_pkt == NULL) {
 		/*  This image packet does not exist in our tracking, so create
-		 * a new one and add it to the head of the list.  */
+		 * a new one and add it to the head of the list. */
 		new_dup_size = sizeof(struct tramp_img_dup_pkt) +
-						ipacket->i_packet_size;
+		    ipacket->packet_size;
 
 		dup_pkt = (struct tramp_img_dup_pkt *)
-			dlthis->mysym->Allocate(dlthis->mysym, new_dup_size);
+		    dlthis->mysym->dload_allocate(dlthis->mysym, new_dup_size);
 		if (dup_pkt != NULL) {
-			/*  Save off the section and offset information  */
+			/*  Save off the section and offset information */
 			dup_pkt->secnn = secnn;
 			dup_pkt->offset = image_offset;
 			dup_pkt->relo_chain = NULL;
 
-			/*  Copy the original packet content  */
+			/*  Copy the original packet content */
 			dup_pkt->img_pkt = *ipacket;
-			dup_pkt->img_pkt.i_bits = (u8 *)(dup_pkt + 1);
-			for (i = 0; i < ipacket->i_packet_size; i++)
-				*(dup_pkt->img_pkt.i_bits + i) =
-					*(ipacket->i_bits + i);
+			dup_pkt->img_pkt.img_data = (u8 *) (dup_pkt + 1);
+			for (i = 0; i < ipacket->packet_size; i++)
+				*(dup_pkt->img_pkt.img_data + i) =
+				    *(ipacket->img_data + i);
 
-			/*  Add the packet to the dup list  */
+			/*  Add the packet to the dup list */
 			dup_pkt->next = dlthis->tramp.dup_pkts;
 			dlthis->tramp.dup_pkts = dup_pkt;
 		} else
@@ -786,33 +807,33 @@ static int priv_img_pkt_dup(struct dload_state *dlthis,
 		/*  The image packet contents could have changed since
 		 * trampoline detection happens during relocation of the image
 		 * packets.  So, we need to update the image packet contents
-		 * before adding relo information.  */
-		for (i = 0; i < dup_pkt->img_pkt.i_packet_size; i++)
-			*(dup_pkt->img_pkt.i_bits + i) =
-				*(ipacket->i_bits + i);
+		 * before adding relo information. */
+		for (i = 0; i < dup_pkt->img_pkt.packet_size; i++)
+			*(dup_pkt->img_pkt.img_data + i) =
+			    *(ipacket->img_data + i);
 	}
 
 	/*  Since the previous code may have allocated a new dup packet for us,
-		double check that we actually have one.  */
+	   double check that we actually have one. */
 	if (dup_pkt != NULL) {
 		/*  Allocate a new node for the relo chain.  Each image packet
 		 * can potentially have multiple relocations that cause a
 		 * trampoline to be generated.  So, we keep them in a chain,
-		 * order is not important.  */
-		dup_relo = dlthis->mysym->Allocate(dlthis->mysym,
-					   sizeof(struct tramp_img_dup_relo));
+		 * order is not important. */
+		dup_relo = dlthis->mysym->dload_allocate(dlthis->mysym,
+					 sizeof(struct tramp_img_dup_relo));
 		if (dup_relo != NULL) {
 			/*  Copy the relo contents, adjust for the new
-			 * trampoline and add it to the list.  */
+			 * trampoline and add it to the list. */
 			dup_relo->relo = *rp;
-			dup_relo->relo.r_symndx = new_tramp_sym->index;
+			dup_relo->relo.SYMNDX = new_tramp_sym->index;
 
 			dup_relo->next = dup_pkt->relo_chain;
 			dup_pkt->relo_chain = dup_relo;
 
 			/*  That's it, we're done.  Make sure we update our
 			 * return value to be success since everything finished
-			 * ok  */
+			 * ok */
 			ret_val = 1;
 		} else
 			dload_error(dlthis, "Unable to alloc dup relo");
@@ -832,8 +853,8 @@ bool dload_tramp_avail(struct dload_state *dlthis, struct reloc_record_t *rp)
 	u16 map_index;
 	u16 gen_index;
 
-	/*  Check type hash vs. target tramp table  */
-	map_index = HASH_FUNC(rp->r_type);
+	/*  Check type hash vs. target tramp table */
+	map_index = HASH_FUNC(rp->TYPE);
 	gen_index = tramp_map[map_index];
 	if (gen_index != TRAMP_NO_GEN_AVAIL)
 		ret_val = true;
@@ -850,103 +871,109 @@ bool dload_tramp_avail(struct dload_state *dlthis, struct reloc_record_t *rp)
  *	  finalization.
  */
 int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
-	u32 image_offset, struct image_packet_t *ipacket,
-	struct reloc_record_t *rp)
+			 u32 image_offset, struct image_packet_t *ipacket,
+			 struct reloc_record_t *rp)
 {
 	u16 map_index;
 	u16 gen_index;
 	int ret_val = 1;
 	char tramp_sym_str[TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN];
-	struct Local_Symbol *ref_sym;
-	struct tramp_sym	*new_tramp_sym;
-	struct tramp_sym	*new_ext_sym;
+	struct local_symbol *ref_sym;
+	struct tramp_sym *new_tramp_sym;
+	struct tramp_sym *new_ext_sym;
 	struct tramp_string *new_tramp_str;
 	u32 new_tramp_base;
-	struct Local_Symbol tmp_sym;
-	struct Local_Symbol ext_tmp_sym;
+	struct local_symbol tmp_sym;
+	struct local_symbol ext_tmp_sym;
 
-	/*  Hash the relo type to get our generator information  */
-	map_index = HASH_FUNC(rp->r_type);
+	/*  Hash the relo type to get our generator information */
+	map_index = HASH_FUNC(rp->TYPE);
 	gen_index = tramp_map[map_index];
 	if (gen_index != TRAMP_NO_GEN_AVAIL) {
 		/*  If this is the first trampoline, create the section name in
-		 * our string table for debug help later.  */
+		 * our string table for debug help later. */
 		if (dlthis->tramp.string_head == NULL) {
 			priv_tramp_string_create(dlthis,
-				 strlen(TRAMP_SECT_NAME), TRAMP_SECT_NAME);
+						 strlen(TRAMP_SECT_NAME),
+						 TRAMP_SECT_NAME);
 		}
-
 #ifdef ENABLE_TRAMP_DEBUG
 		dload_syms_error(dlthis->mysym,
-			 "Trampoline at img loc %x, references %x",
-			 dlthis->ldr_sections[secnn].run_addr + image_offset +
-			 rp->r_vaddr,
-			 dlthis->local_symtab[rp->r_symndx].value);
+				 "Trampoline at img loc %x, references %x",
+				 dlthis->ldr_sections[secnn].run_addr +
+				 image_offset + rp->vaddr,
+				 dlthis->local_symtab[rp->SYMNDX].value);
 #endif
 
 		/*  Generate the trampoline string, check if already defined.
 		 * If the relo symbol index is -1, it means we need the section
 		 * info for relo later.  To do this we'll dummy up a symbol
-		 * with the section delta and run addresses.  */
-		if (rp->r_symndx == -1) {
+		 * with the section delta and run addresses. */
+		if (rp->SYMNDX == -1) {
 			ext_tmp_sym.value =
-				dlthis->ldr_sections[secnn].run_addr;
+			    dlthis->ldr_sections[secnn].run_addr;
 			ext_tmp_sym.delta = dlthis->sect_hdrs[secnn].ds_paddr;
 			ref_sym = &ext_tmp_sym;
 		} else
-			ref_sym = &(dlthis->local_symtab[rp->r_symndx]);
+			ref_sym = &(dlthis->local_symtab[rp->SYMNDX]);
 
 		priv_tramp_sym_gen_name(ref_sym->value, tramp_sym_str);
 		new_tramp_sym = priv_tramp_sym_find(dlthis, tramp_sym_str);
 		if (new_tramp_sym == NULL) {
 			/*  If tramp string not defined, create it and a new
 			 * string, and symbol for it as well as the original
-			 * symbol which caused the trampoline.  */
+			 * symbol which caused the trampoline. */
 			new_tramp_str = priv_tramp_string_create(dlthis,
-				 strlen(tramp_sym_str), tramp_sym_str);
+								strlen
+								(tramp_sym_str),
+								 tramp_sym_str);
 			if (new_tramp_str == NULL) {
 				dload_error(dlthis, "Failed to create new "
-					"trampoline string\n");
+					    "trampoline string\n");
 				ret_val = 0;
 			} else {
 				/*  Allocate tramp section space for the new
-				 * tramp from the target  */
+				 * tramp from the target */
 				new_tramp_base = priv_tramp_sect_alloc(dlthis,
-							   tramp_size_get());
+						       tramp_size_get());
 
 				/*  We have a string, create the new symbol and
-				 * duplicate the external.  */
+				 * duplicate the external. */
 				tmp_sym.value = new_tramp_base;
 				tmp_sym.delta = 0;
 				tmp_sym.secnn = -1;
 				tmp_sym.sclass = 0;
 				new_tramp_sym = priv_tramp_sym_create(dlthis,
-					  new_tramp_str->index, &tmp_sym);
+							      new_tramp_str->
+							      index,
+							      &tmp_sym);
 
-				new_ext_sym = priv_tramp_sym_create(dlthis,
-								-1, ref_sym);
+				new_ext_sym = priv_tramp_sym_create(dlthis, -1,
+								    ref_sym);
 
 				if ((new_tramp_sym != NULL) &&
-					(new_ext_sym != NULL)) {
+				    (new_ext_sym != NULL)) {
 					/*  Call the image generator to get the
 					 * new image data and fix up its
 					 * relocations for the external
-					 * symbol.  */
+					 * symbol. */
 					ret_val = priv_tgt_img_gen(dlthis,
-					   new_tramp_base, gen_index,
-					   new_ext_sym);
+								 new_tramp_base,
+								 gen_index,
+								 new_ext_sym);
 
 					/*  Add generated image data to tramp
-					 * image list  */
+					 * image list */
 					if (ret_val != 1) {
-						dload_error(dlthis, "Failed to"
-						   " create image packet for "
-						   "trampoline\n");
+						dload_error(dlthis, "Failed to "
+							    "create img pkt for"
+							    " trampoline\n");
 					}
 				} else {
 					dload_error(dlthis, "Failed to create "
-					   "new tramp syms (%8.8X, %8.8X)\n",
-					   new_tramp_sym, new_ext_sym);
+						    "new tramp syms "
+						    "(%8.8X, %8.8X)\n",
+						    new_tramp_sym, new_ext_sym);
 					ret_val = 0;
 				}
 			}
@@ -954,13 +981,13 @@ int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
 
 		/*  Duplicate the image data and relo record that caused the
 		 * tramp, including update the relo data to point to the tramp
-		 * symbol.  */
+		 * symbol. */
 		if (ret_val == 1) {
 			ret_val = priv_img_pkt_dup(dlthis, secnn, image_offset,
-				   ipacket, rp, new_tramp_sym);
+						   ipacket, rp, new_tramp_sym);
 			if (ret_val != 1) {
 				dload_error(dlthis, "Failed to create dup of "
-					"original img pkt\n");
+					    "original img pkt\n");
 			}
 		}
 	}
@@ -979,24 +1006,25 @@ int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
  *	  written to the target since all relo is done.
  */
 int dload_tramp_pkt_udpate(struct dload_state *dlthis, s16 secnn,
-	   u32 image_offset, struct image_packet_t *ipacket)
+			   u32 image_offset, struct image_packet_t *ipacket)
 {
 	struct tramp_img_dup_pkt *dup_pkt = NULL;
 	s32 i;
 	int ret_val = 0;
 
 	/*  Find the image packet in question, the caller needs us to update it
-		since a trampoline was previously generated.  */
+	   since a trampoline was previously generated. */
 	dup_pkt = priv_dup_find(dlthis, secnn, image_offset);
 	if (dup_pkt != NULL) {
-		for (i = 0; i < dup_pkt->img_pkt.i_packet_size; i++)
-			*(dup_pkt->img_pkt.i_bits + i) = *(ipacket->i_bits + i);
+		for (i = 0; i < dup_pkt->img_pkt.packet_size; i++)
+			*(dup_pkt->img_pkt.img_data + i) =
+			    *(ipacket->img_data + i);
 
 		ret_val = 1;
 	} else {
 		dload_error(dlthis,
-			"Unable to find existing DUP pkt for %x, offset %x",
-			secnn, image_offset);
+			    "Unable to find existing DUP pkt for %x, offset %x",
+			    secnn, image_offset);
 
 	}
 
@@ -1017,26 +1045,26 @@ int dload_tramp_finalize(struct dload_state *dlthis)
 
 	if (dlthis->tramp.tramp_sect_next_addr != 0) {
 		/*  Finalize strings into a flat table.  This is needed so it
-		 * can be added to the debug string table later.  */
+		 * can be added to the debug string table later. */
 		ret_val = priv_string_tbl_finalize(dlthis);
 
 		/*  Do target allocation for section BEFORE finalizing
-		 * symbols.  */
+		 * symbols. */
 		if (ret_val != 0)
 			ret_val = priv_tramp_sect_tgt_alloc(dlthis);
 
 		/*  Finalize symbols with their correct target information and
-		 * flatten  */
+		 * flatten */
 		if (ret_val != 0)
 			ret_val = priv_tramp_sym_finalize(dlthis);
 
 		/*  Finalize all trampoline packets.  This performs the
 		 * relocation on the packets as well as writing them to target
-		 * memory.  */
+		 * memory. */
 		if (ret_val != 0)
 			ret_val = priv_tramp_pkt_finalize(dlthis);
 
-		/*  Perform a 2nd pass relocation on the dup list.  */
+		/*  Perform a 2nd pass relocation on the dup list. */
 		if (ret_val != 0)
 			ret_val = priv_dup_pkt_finalize(dlthis);
 	}
@@ -1061,58 +1089,55 @@ void dload_tramp_cleanup(struct dload_state *dlthis)
 	struct tramp_img_dup_pkt *cur_dup_pkt;
 	struct tramp_img_dup_relo *cur_dup_relo;
 
-	/*  If there were no tramps generated, just return  */
+	/*  If there were no tramps generated, just return */
 	if (tramp->tramp_sect_next_addr == 0)
 		return;
 
-	/*  Destroy all tramp information  */
+	/*  Destroy all tramp information */
 	for (cur_sym = tramp->symbol_head;
-		 cur_sym != NULL;
-		 cur_sym = tramp->symbol_head) {
+	     cur_sym != NULL; cur_sym = tramp->symbol_head) {
 		tramp->symbol_head = cur_sym->next;
 		if (tramp->symbol_tail == cur_sym)
 			tramp->symbol_tail = NULL;
 
-		dlthis->mysym->Deallocate(dlthis->mysym, cur_sym);
+		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);
 	}
 
 	if (tramp->final_sym_table != NULL)
-		dlthis->mysym->Deallocate(dlthis->mysym,
-			tramp->final_sym_table);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						tramp->final_sym_table);
 
 	for (cur_string = tramp->string_head;
-		 cur_string != NULL;
-		 cur_string = tramp->string_head) {
+	     cur_string != NULL; cur_string = tramp->string_head) {
 		tramp->string_head = cur_string->next;
 		if (tramp->string_tail == cur_string)
 			tramp->string_tail = NULL;
 
-		dlthis->mysym->Deallocate(dlthis->mysym, cur_string);
+		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_string);
 	}
 
 	if (tramp->final_string_table != NULL)
-		dlthis->mysym->Deallocate(dlthis->mysym,
-			tramp->final_string_table);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						tramp->final_string_table);
 
 	for (cur_tramp_pkt = tramp->tramp_pkts;
-		 cur_tramp_pkt != NULL;
-		 cur_tramp_pkt = tramp->tramp_pkts) {
+	     cur_tramp_pkt != NULL; cur_tramp_pkt = tramp->tramp_pkts) {
 		tramp->tramp_pkts = cur_tramp_pkt->next;
-		dlthis->mysym->Deallocate(dlthis->mysym, cur_tramp_pkt);
+		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_tramp_pkt);
 	}
 
 	for (cur_dup_pkt = tramp->dup_pkts;
-		 cur_dup_pkt != NULL;
-		 cur_dup_pkt = tramp->dup_pkts) {
+	     cur_dup_pkt != NULL; cur_dup_pkt = tramp->dup_pkts) {
 		tramp->dup_pkts = cur_dup_pkt->next;
 
 		for (cur_dup_relo = cur_dup_pkt->relo_chain;
-			 cur_dup_relo != NULL;
-			 cur_dup_relo = cur_dup_pkt->relo_chain) {
+		     cur_dup_relo != NULL;
+		     cur_dup_relo = cur_dup_pkt->relo_chain) {
 			cur_dup_pkt->relo_chain = cur_dup_relo->next;
-			dlthis->mysym->Deallocate(dlthis->mysym, cur_dup_relo);
+			dlthis->mysym->dload_deallocate(dlthis->mysym,
+							cur_dup_relo);
 		}
 
-		dlthis->mysym->Deallocate(dlthis->mysym, cur_dup_pkt);
+		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_dup_pkt);
 	}
 }
diff --git a/drivers/dsp/bridge/dynload/tramp_table_c6000.c b/drivers/dsp/bridge/dynload/tramp_table_c6000.c
index acda513..e38d631 100644
--- a/drivers/dsp/bridge/dynload/tramp_table_c6000.c
+++ b/drivers/dsp/bridge/dynload/tramp_table_c6000.c
@@ -17,22 +17,21 @@
 #include "dload_internal.h"
 
 /*  These are defined in coff.h, but may not be available on all platforms
-	so we'll go ahead and define them here.  */
+	so we'll go ahead and define them here. */
 #ifndef R_C60LO16
-#define R_C60LO16	  0x54	   /* C60: MVK Low Half Register	  */
-#define R_C60HI16	  0x55	   /* C60: MVKH/MVKLH High Half Register  */
+#define R_C60LO16	  0x54	/* C60: MVK Low Half Register */
+#define R_C60HI16	  0x55	/* C60: MVKH/MVKLH High Half Register */
 #endif
 
 #define C6X_TRAMP_WORD_COUNT			8
 #define C6X_TRAMP_MAX_RELOS			 8
 
-/*  THIS HASH FUNCTION MUST MATCH THE ONE IN reloc_table_c6000.c  */
+/*  THIS HASH FUNCTION MUST MATCH THE ONE IN reloc_table_c6000.c */
 #define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
 
-
-/*  THIS MUST MATCH reloc_record_t FOR A SYMBOL BASED RELO  */
+/*  THIS MUST MATCH reloc_record_t FOR A SYMBOL BASED RELO */
 struct c6000_relo_record {
-	s32 r_vaddr;
+	s32 vaddr;
 	s32 symndx;
 #ifndef _BIG_ENDIAN
 	u16 disp;
@@ -44,15 +43,13 @@ struct c6000_relo_record {
 };
 
 struct c6000_gen_code {
-	struct tramp_gen_code_hdr	hdr;
+	struct tramp_gen_code_hdr hdr;
 	u32 tramp_instrs[C6X_TRAMP_WORD_COUNT];
 	struct c6000_relo_record relos[C6X_TRAMP_MAX_RELOS];
 };
 
-
-/*  Hash mapping for relos that can cause trampolines.  */
-static const u16 tramp_map[] =
-{
+/*  Hash mapping for relos that can cause trampolines. */
+static const u16 tramp_map[] = {
 	65535,
 	65535,
 	65535,
@@ -119,53 +116,48 @@ static const u16 tramp_map[] =
 	65535
 };
 
-
-static const struct c6000_gen_code   tramp_gen_info[] =
-{
-	/*  Tramp caused by R_C60PCR21  */
+static const struct c6000_gen_code tramp_gen_info[] = {
+	/*  Tramp caused by R_C60PCR21 */
 	{
-		/*  Header - 8 instructions, 2 relos  */
-		{
-			sizeof(u32) * C6X_TRAMP_WORD_COUNT,
-			2,
-			FIELD_OFFSET(struct c6000_gen_code, relos)
-		},
-
-		/*  Trampoline instructions  */
-		{
-			0x053C54F7,	/*	 STW.D2T2  B10, *sp--[2]  */
-			0x0500002A,	/*  || MVK.S2	<blank>, B10   */
-			0x0500006A,	/*	 MVKH.S2   <blank>, B10   */
-			0x00280362,	/*	 B.S2	  B10		*/
-			0x053C52E6,	/*	 LDW.D2T2  *++sp[2], B10  */
-			0x00006000,	/*	 NOP	   4		*/
-			0x00000000,	/*	 NOP			*/
-			0x00000000	/*	 NOP			*/
-		},
-
-		/*  Relocations  */
-		{
-			{ 4, 0, 0, R_C60LO16 },
-			{ 8, 0, 0, R_C60HI16 },
-			{ 0, 0, 0, 0x0000 },
-			{ 0, 0, 0, 0x0000 },
-			{ 0, 0, 0, 0x0000 },
-			{ 0, 0, 0, 0x0000 },
-			{ 0, 0, 0, 0x0000 },
-			{ 0, 0, 0, 0x0000 }
-		}
-	}
+	 /*  Header - 8 instructions, 2 relos */
+	 {
+	  sizeof(u32) * C6X_TRAMP_WORD_COUNT,
+	  2,
+	  FIELD_OFFSET(struct c6000_gen_code, relos)
+	  },
+
+	 /*  Trampoline instructions */
+	 {
+	  0x053C54F7,		/*       STW.D2T2  B10, *sp--[2] */
+	  0x0500002A,		/*  || MVK.S2   <blank>, B10 */
+	  0x0500006A,		/*       MVKH.S2   <blank>, B10 */
+	  0x00280362,		/*       B.S2     B10 */
+	  0x053C52E6,		/*       LDW.D2T2  *++sp[2], B10 */
+	  0x00006000,		/*       NOP       4 */
+	  0x00000000,		/*       NOP */
+	  0x00000000		/*       NOP */
+	  },
+
+	 /*  Relocations */
+	 {
+	  {4, 0, 0, R_C60LO16},
+	  {8, 0, 0, R_C60HI16},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000}
+	  }
+	 }
 };
 
-
-
-/*  TARGET SPECIFIC FUNCTIONS THAT MUST BE DEFINED  */
+/*  TARGET SPECIFIC FUNCTIONS THAT MUST BE DEFINED */
 static u32 tramp_size_get(void)
 {
 	return sizeof(u32) * C6X_TRAMP_WORD_COUNT;
 }
 
-
 static u32 tramp_img_pkt_size_get(void)
 {
 	return sizeof(struct c6000_gen_code);
diff --git a/drivers/dsp/bridge/gen/gb.c b/drivers/dsp/bridge/gen/gb.c
index 1b11c15..1874f0b 100644
--- a/drivers/dsp/bridge/gen/gb.c
+++ b/drivers/dsp/bridge/gen/gb.c
@@ -23,21 +23,21 @@
 #include <dspbridge/gs.h>
 #include <dspbridge/gb.h>
 
-typedef GB_BitNum GB_WordNum;
+typedef gb_bit_num gb_word_num;
 
-struct GB_TMap {
-	GB_BitNum len;
-	GB_WordNum wcnt;
+struct gb_t_map {
+	gb_bit_num len;
+	gb_word_num wcnt;
 	u32 *words;
 };
 
 /*
- *  ======== GB_clear ========
+ *  ======== gb_clear ========
  *  purpose:
  *      Clears a bit in the bit map.
  */
 
-void GB_clear(struct GB_TMap *map, GB_BitNum bitn)
+void gb_clear(struct gb_t_map *map, gb_bit_num bitn)
 {
 	u32 mask;
 
@@ -46,26 +46,26 @@ void GB_clear(struct GB_TMap *map, GB_BitNum bitn)
 }
 
 /*
- *  ======== GB_create ========
+ *  ======== gb_create ========
  *  purpose:
  *      Creates a bit map.
  */
 
-struct GB_TMap *GB_create(GB_BitNum len)
+struct gb_t_map *gb_create(gb_bit_num len)
 {
-	struct GB_TMap *map;
-	GB_WordNum i;
-	map = (struct GB_TMap *)GS_alloc(sizeof(struct GB_TMap));
+	struct gb_t_map *map;
+	gb_word_num i;
+	map = (struct gb_t_map *)gs_alloc(sizeof(struct gb_t_map));
 	if (map != NULL) {
 		map->len = len;
 		map->wcnt = len / BITS_PER_LONG + 1;
-		map->words = (u32 *)GS_alloc(map->wcnt * sizeof(u32));
+		map->words = (u32 *) gs_alloc(map->wcnt * sizeof(u32));
 		if (map->words != NULL) {
 			for (i = 0; i < map->wcnt; i++)
 				map->words[i] = 0L;
 
 		} else {
-			GS_frees(map, sizeof(struct GB_TMap));
+			gs_frees(map, sizeof(struct gb_t_map));
 			map = NULL;
 		}
 	}
@@ -74,51 +74,51 @@ struct GB_TMap *GB_create(GB_BitNum len)
 }
 
 /*
- *  ======== GB_delete ========
+ *  ======== gb_delete ========
  *  purpose:
  *      Frees a bit map.
  */
 
-void GB_delete(struct GB_TMap *map)
+void gb_delete(struct gb_t_map *map)
 {
-	GS_frees(map->words, map->wcnt * sizeof(u32));
-	GS_frees(map, sizeof(struct GB_TMap));
+	gs_frees(map->words, map->wcnt * sizeof(u32));
+	gs_frees(map, sizeof(struct gb_t_map));
 }
 
 /*
- *  ======== GB_findandset ========
+ *  ======== gb_findandset ========
  *  purpose:
  *      Finds a free bit and sets it.
  */
-GB_BitNum GB_findandset(struct GB_TMap *map)
+gb_bit_num gb_findandset(struct gb_t_map *map)
 {
-	GB_BitNum bitn;
+	gb_bit_num bitn;
 
-	bitn = GB_minclear(map);
+	bitn = gb_minclear(map);
 
 	if (bitn != GB_NOBITS)
-		GB_set(map, bitn);
+		gb_set(map, bitn);
 
 	return bitn;
 }
 
 /*
- *  ======== GB_minclear ========
+ *  ======== gb_minclear ========
  *  purpose:
  *      returns the location of the first unset bit in the bit map.
  */
-GB_BitNum GB_minclear(struct GB_TMap *map)
+gb_bit_num gb_minclear(struct gb_t_map *map)
 {
-	GB_BitNum bit_location = 0;
-	GB_BitNum bitAcc = 0;
-	GB_WordNum i;
-	GB_BitNum bit;
+	gb_bit_num bit_location = 0;
+	gb_bit_num bit_acc = 0;
+	gb_word_num i;
+	gb_bit_num bit;
 	u32 *word;
 
 	for (word = map->words, i = 0; i < map->wcnt; word++, i++) {
 		if (~*word) {
-			for (bit = 0; bit < BITS_PER_LONG; bit++, bitAcc++) {
-				if (bitAcc == map->len)
+			for (bit = 0; bit < BITS_PER_LONG; bit++, bit_acc++) {
+				if (bit_acc == map->len)
 					return GB_NOBITS;
 
 				if (~*word & (1L << bit)) {
@@ -128,7 +128,7 @@ GB_BitNum GB_minclear(struct GB_TMap *map)
 
 			}
 		} else {
-			bitAcc += BITS_PER_LONG;
+			bit_acc += BITS_PER_LONG;
 		}
 	}
 
@@ -136,12 +136,12 @@ GB_BitNum GB_minclear(struct GB_TMap *map)
 }
 
 /*
- *  ======== GB_set ========
+ *  ======== gb_set ========
  *  purpose:
  *      Sets a bit in the bit map.
  */
 
-void GB_set(struct GB_TMap *map, GB_BitNum bitn)
+void gb_set(struct gb_t_map *map, gb_bit_num bitn)
 {
 	u32 mask;
 
@@ -150,12 +150,12 @@ void GB_set(struct GB_TMap *map, GB_BitNum bitn)
 }
 
 /*
- *  ======== GB_test ========
+ *  ======== gb_test ========
  *  purpose:
  *      Returns true if the bit is set in the specified location.
  */
 
-bool GB_test(struct GB_TMap *map, GB_BitNum bitn)
+bool gb_test(struct gb_t_map *map, gb_bit_num bitn)
 {
 	bool state;
 	u32 mask;
diff --git a/drivers/dsp/bridge/gen/gh.c b/drivers/dsp/bridge/gen/gh.c
index 252efaf..dc211ae 100644
--- a/drivers/dsp/bridge/gen/gh.c
+++ b/drivers/dsp/bridge/gen/gh.c
@@ -22,107 +22,110 @@
 
 #include <dspbridge/gh.h>
 
-struct Elem {
-	struct Elem *next;
+struct element {
+	struct element *next;
 	u8 data[1];
 };
 
-struct GH_THashTab {
-	u16 maxBucket;
-	u16 valSize;
-	struct Elem **buckets;
+struct gh_t_hash_tab {
+	u16 max_bucket;
+	u16 val_size;
+	struct element **buckets;
 	 u16(*hash) (void *, u16);
 	 bool(*match) (void *, void *);
-	 void(*delete) (void *);
+	void (*delete) (void *);
 };
 
-static void Nop(void *p);
-static s32 curInit;
+static void noop(void *p);
+static s32 cur_init;
 static void myfree(void *ptr, s32 size);
 
 /*
- *  ======== GH_create ========
+ *  ======== gh_create ========
  */
 
-struct GH_THashTab *GH_create(u16 maxBucket, u16 valSize,
-		u16(*hash)(void *, u16), bool(*match)(void *, void *),
-		void(*delete)(void *))
+struct gh_t_hash_tab *gh_create(u16 max_bucket, u16 val_size,
+				u16(*hash) (void *, u16), bool(*match) (void *,
+									void *),
+				void (*delete) (void *))
 {
-	struct GH_THashTab *hashTab;
+	struct gh_t_hash_tab *hash_tab;
 	u16 i;
-	hashTab = (struct GH_THashTab *)GS_alloc(sizeof(struct GH_THashTab));
-	if (hashTab == NULL)
+	hash_tab =
+	    (struct gh_t_hash_tab *)gs_alloc(sizeof(struct gh_t_hash_tab));
+	if (hash_tab == NULL)
 		return NULL;
-	hashTab->maxBucket = maxBucket;
-	hashTab->valSize = valSize;
-	hashTab->hash = hash;
-	hashTab->match = match;
-	hashTab->delete = delete == NULL ? Nop : delete;
-
-	hashTab->buckets = (struct Elem **)
-			   GS_alloc(sizeof(struct Elem *) * maxBucket);
-	if (hashTab->buckets == NULL) {
-		GH_delete(hashTab);
+	hash_tab->max_bucket = max_bucket;
+	hash_tab->val_size = val_size;
+	hash_tab->hash = hash;
+	hash_tab->match = match;
+	hash_tab->delete = delete == NULL ? noop : delete;
+
+	hash_tab->buckets = (struct element **)
+	    gs_alloc(sizeof(struct element *) * max_bucket);
+	if (hash_tab->buckets == NULL) {
+		gh_delete(hash_tab);
 		return NULL;
 	}
 
-	for (i = 0; i < maxBucket; i++)
-		hashTab->buckets[i] = NULL;
+	for (i = 0; i < max_bucket; i++)
+		hash_tab->buckets[i] = NULL;
 
-	return hashTab;
+	return hash_tab;
 }
 
 /*
- *  ======== GH_delete ========
+ *  ======== gh_delete ========
  */
-void GH_delete(struct GH_THashTab *hashTab)
+void gh_delete(struct gh_t_hash_tab *hash_tab)
 {
-	struct Elem *elem, *next;
+	struct element *elem, *next;
 	u16 i;
 
-	if (hashTab != NULL) {
-		if (hashTab->buckets != NULL) {
-			for (i = 0; i < hashTab->maxBucket; i++) {
-				for (elem = hashTab->buckets[i]; elem != NULL;
-				    elem = next) {
+	if (hash_tab != NULL) {
+		if (hash_tab->buckets != NULL) {
+			for (i = 0; i < hash_tab->max_bucket; i++) {
+				for (elem = hash_tab->buckets[i]; elem != NULL;
+				     elem = next) {
 					next = elem->next;
-					(*hashTab->delete) (elem->data);
-					myfree(elem, sizeof(struct Elem) - 1 +
-					      hashTab->valSize);
+					(*hash_tab->delete) (elem->data);
+					myfree(elem,
+					       sizeof(struct element) - 1 +
+					       hash_tab->val_size);
 				}
 			}
 
-			myfree(hashTab->buckets, sizeof(struct Elem *)
-			      * hashTab->maxBucket);
+			myfree(hash_tab->buckets, sizeof(struct element *)
+			       * hash_tab->max_bucket);
 		}
 
-		myfree(hashTab, sizeof(struct GH_THashTab));
+		myfree(hash_tab, sizeof(struct gh_t_hash_tab));
 	}
 }
 
 /*
- *  ======== GH_exit ========
+ *  ======== gh_exit ========
  */
 
-void GH_exit(void)
+void gh_exit(void)
 {
-	if (curInit-- == 1)
-		GS_exit();
+	if (cur_init-- == 1)
+		gs_exit();
 
 }
 
 /*
- *  ======== GH_find ========
+ *  ======== gh_find ========
  */
 
-void *GH_find(struct GH_THashTab *hashTab, void *key)
+void *gh_find(struct gh_t_hash_tab *hash_tab, void *key)
 {
-	struct Elem *elem;
+	struct element *elem;
 
-	elem = hashTab->buckets[(*hashTab->hash)(key, hashTab->maxBucket)];
+	elem = hash_tab->buckets[(*hash_tab->hash) (key, hash_tab->max_bucket)];
 
 	for (; elem; elem = elem->next) {
-		if ((*hashTab->match)(key, elem->data))
+		if ((*hash_tab->match) (key, elem->data))
 			return elem->data;
 	}
 
@@ -130,37 +133,37 @@ void *GH_find(struct GH_THashTab *hashTab, void *key)
 }
 
 /*
- *  ======== GH_init ========
+ *  ======== gh_init ========
  */
 
-void GH_init(void)
+void gh_init(void)
 {
-	if (curInit++ == 0)
-		GS_init();
+	if (cur_init++ == 0)
+		gs_init();
 }
 
 /*
- *  ======== GH_insert ========
+ *  ======== gh_insert ========
  */
 
-void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value)
+void *gh_insert(struct gh_t_hash_tab *hash_tab, void *key, void *value)
 {
-	struct Elem *elem;
+	struct element *elem;
 	u16 i;
 	char *src, *dst;
 
-	elem = (struct Elem *)GS_alloc(sizeof(struct Elem) - 1 +
-		hashTab->valSize);
+	elem = (struct element *)gs_alloc(sizeof(struct element) - 1 +
+					  hash_tab->val_size);
 	if (elem != NULL) {
 
 		dst = (char *)elem->data;
 		src = (char *)value;
-		for (i = 0; i < hashTab->valSize; i++)
+		for (i = 0; i < hash_tab->val_size; i++)
 			*dst++ = *src++;
 
-		i = (*hashTab->hash)(key, hashTab->maxBucket);
-		elem->next = hashTab->buckets[i];
-		hashTab->buckets[i] = elem;
+		i = (*hash_tab->hash) (key, hash_tab->max_bucket);
+		elem->next = hash_tab->buckets[i];
+		hash_tab->buckets[i] = elem;
 
 		return elem->data;
 	}
@@ -169,10 +172,10 @@ void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value)
 }
 
 /*
- *  ======== Nop ========
+ *  ======== noop ========
  */
 /* ARGSUSED */
-static void Nop(void *p)
+static void noop(void *p)
 {
 	p = p;			/* stifle compiler warning */
 }
@@ -182,5 +185,5 @@ static void Nop(void *p)
  */
 static void myfree(void *ptr, s32 size)
 {
-	GS_free(ptr);
+	gs_free(ptr);
 }
diff --git a/drivers/dsp/bridge/gen/gs.c b/drivers/dsp/bridge/gen/gs.c
index 05b2e56..3b0f3a7 100644
--- a/drivers/dsp/bridge/gen/gs.c
+++ b/drivers/dsp/bridge/gen/gs.c
@@ -30,15 +30,15 @@
 static u32 cumsize;
 
 /*
- *  ======== GS_alloc ========
+ *  ======== gs_alloc ========
  *  purpose:
  *      Allocates memory of the specified size.
  */
-void *GS_alloc(u32 size)
+void *gs_alloc(u32 size)
 {
 	void *p;
 
-	p = MEM_Calloc(size, MEM_PAGED);
+	p = mem_calloc(size, MEM_PAGED);
 	if (p == NULL)
 		return NULL;
 	cumsize += size;
@@ -46,21 +46,21 @@ void *GS_alloc(u32 size)
 }
 
 /*
- *  ======== GS_exit ========
+ *  ======== gs_exit ========
  *  purpose:
  *      Discontinue the usage of the GS module.
  */
-void GS_exit(void)
+void gs_exit(void)
 {
 	/* Do nothing */
 }
 
 /*
- *  ======== GS_free ========
+ *  ======== gs_free ========
  *  purpose:
  *      Frees the memory.
  */
-void GS_free(void *ptr)
+void gs_free(void *ptr)
 {
 	kfree(ptr);
 	/* ack! no size info */
@@ -68,22 +68,22 @@ void GS_free(void *ptr)
 }
 
 /*
- *  ======== GS_frees ========
+ *  ======== gs_frees ========
  *  purpose:
  *      Frees the memory.
  */
-void GS_frees(void *ptr, u32 size)
+void gs_frees(void *ptr, u32 size)
 {
 	kfree(ptr);
 	cumsize -= size;
 }
 
 /*
- *  ======== GS_init ========
+ *  ======== gs_init ========
  *  purpose:
  *      Initializes the GS module.
  */
-void GS_init(void)
+void gs_init(void)
 {
 	/* Do nothing */
 }
diff --git a/drivers/dsp/bridge/gen/uuidutil.c b/drivers/dsp/bridge/gen/uuidutil.c
index 165ca86..ce9319d 100644
--- a/drivers/dsp/bridge/gen/uuidutil.c
+++ b/drivers/dsp/bridge/gen/uuidutil.c
@@ -16,7 +16,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*  ----------------------------------- Host OS  */
+/*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
 /*  ----------------------------------- DSP/BIOS Bridge */
@@ -30,27 +30,28 @@
 #include <dspbridge/uuidutil.h>
 
 /*
- *  ======== UUID_UuidToString ========
+ *  ======== uuid_uuid_to_string ========
  *  Purpose:
- *      Converts a struct DSP_UUID to a string.
+ *      Converts a struct dsp_uuid to a string.
  *      Note: snprintf format specifier is:
  *      %[flags] [width] [.precision] [{h | l | I64 | L}]type
  */
-void UUID_UuidToString(IN struct DSP_UUID *pUuid, OUT char *pszUuid,
-		       IN s32 size)
+void uuid_uuid_to_string(IN struct dsp_uuid *uuid_obj, OUT char *pszUuid,
+			 IN s32 size)
 {
 	s32 i;			/* return result from snprintf. */
 
-	DBC_Require(pUuid && pszUuid);
+	DBC_REQUIRE(uuid_obj && pszUuid);
 
 	i = snprintf(pszUuid, size,
 		     "%.8X_%.4X_%.4X_%.2X%.2X_%.2X%.2X%.2X%.2X%.2X%.2X",
-		     pUuid->ulData1, pUuid->usData2, pUuid->usData3,
-		     pUuid->ucData4, pUuid->ucData5, pUuid->ucData6[0],
-		     pUuid->ucData6[1], pUuid->ucData6[2], pUuid->ucData6[3],
-		     pUuid->ucData6[4], pUuid->ucData6[5]);
+		     uuid_obj->ul_data1, uuid_obj->us_data2, uuid_obj->us_data3,
+		     uuid_obj->uc_data4, uuid_obj->uc_data5,
+		     uuid_obj->uc_data6[0], uuid_obj->uc_data6[1],
+		     uuid_obj->uc_data6[2], uuid_obj->uc_data6[3],
+		     uuid_obj->uc_data6[4], uuid_obj->uc_data6[5]);
 
-	DBC_Ensure(i != -1);
+	DBC_ENSURE(i != -1);
 }
 
 /*
@@ -111,11 +112,11 @@ static int htoi(char c)
 }
 
 /*
- *  ======== UUID_UuidFromString ========
+ *  ======== uuid_uuid_from_string ========
  *  Purpose:
- *      Converts a string to a struct DSP_UUID.
+ *      Converts a string to a struct dsp_uuid.
  */
-void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
+void uuid_uuid_from_string(IN char *pszUuid, OUT struct dsp_uuid *uuid_obj)
 {
 	char c;
 	s32 i, j;
@@ -134,7 +135,7 @@ void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->ulData1 = result;
+	uuid_obj->ul_data1 = result;
 
 	/* Step over underscore */
 	temp++;
@@ -151,7 +152,7 @@ void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->usData2 = (u16)result;
+	uuid_obj->us_data2 = (u16) result;
 
 	/* Step over underscore */
 	temp++;
@@ -168,7 +169,7 @@ void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->usData3 = (u16)result;
+	uuid_obj->us_data3 = (u16) result;
 
 	/* Step over underscore */
 	temp++;
@@ -185,7 +186,7 @@ void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->ucData4 = (u8)result;
+	uuid_obj->uc_data4 = (u8) result;
 
 	result = 0;
 	for (i = 0; i < 2; i++) {
@@ -199,7 +200,7 @@ void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->ucData5 = (u8)result;
+	uuid_obj->uc_data5 = (u8) result;
 
 	/* Step over underscore */
 	temp++;
@@ -217,6 +218,6 @@ void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
 			/* Go to next character in string */
 			temp++;
 		}
-		pUuid->ucData6[j] = (u8)result;
+		uuid_obj->uc_data6[j] = (u8) result;
 	}
 }
diff --git a/drivers/dsp/bridge/hw/EasiGlobal.h b/drivers/dsp/bridge/hw/EasiGlobal.h
index b023826..9b45aa7 100644
--- a/drivers/dsp/bridge/hw/EasiGlobal.h
+++ b/drivers/dsp/bridge/hw/EasiGlobal.h
@@ -14,8 +14,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __EASIGLOBAL_H
-#define __EASIGLOBAL_H
+#ifndef _EASIGLOBAL_H
+#define _EASIGLOBAL_H
 #include <linux/types.h>
 
 /*
@@ -29,14 +29,13 @@
 #define READ_WRITE   3
 
 /*
- * MACRO:        _DEBUG_LEVEL_1_EASI
+ * MACRO:        _DEBUG_LEVEL1_EASI
  *
  * DESCRIPTION:  A MACRO which can be used to indicate that a particular beach
  *               register access function was called.
  *
  * NOTE:         We currently dont use this functionality.
  */
-#define _DEBUG_LEVEL_1_EASI(easiNum)     ((void)0)
-
-#endif	/* __EASIGLOBAL_H */
+#define _DEBUG_LEVEL1_EASI(easiNum)     ((void)0)
 
+#endif /* _EASIGLOBAL_H */
diff --git a/drivers/dsp/bridge/hw/GlobalTypes.h b/drivers/dsp/bridge/hw/GlobalTypes.h
index 73a2d93..5cc7ac0 100644
--- a/drivers/dsp/bridge/hw/GlobalTypes.h
+++ b/drivers/dsp/bridge/hw/GlobalTypes.h
@@ -16,8 +16,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __GLOBALTYPES_H
-#define __GLOBALTYPES_H
+#ifndef _GLOBALTYPES_H
+#define _GLOBALTYPES_H
 
 /*
  * Definition: TRUE, FALSE
@@ -50,173 +50,166 @@
  *
  * DESCRIPTION:  offset in bytes from start of 32-bit word.
  */
-#define LOWER_16BIT_OFFSET	  0
-#define UPPER_16BIT_OFFSET	  2
+#define LOWER16BIT_OFFSET	  0
+#define UPPER16BIT_OFFSET	  2
 
-#define LOWER_8BIT_OFFSET	   0
-#define LOWER_MIDDLE_8BIT_OFFSET    1
-#define UPPER_MIDDLE_8BIT_OFFSET    2
-#define UPPER_8BIT_OFFSET	   3
+#define LOWER8BIT_OFFSET	   0
+#define LOWER_MIDDLE8BIT_OFFSET    1
+#define UPPER_MIDDLE8BIT_OFFSET    2
+#define UPPER8BIT_OFFSET	   3
 
-#define LOWER_8BIT_OF16_OFFSET      0
-#define UPPER_8BIT_OF16_OFFSET      1
+#define LOWER8BIT_OF16_OFFSET      0
+#define UPPER8BIT_OF16_OFFSET      1
 
 /*
  * Definition: *BIT_SHIFT
  *
  * DESCRIPTION:  offset in bits from start of 32-bit word.
  */
-#define LOWER_16BIT_SHIFT	  0
-#define UPPER_16BIT_SHIFT	  16
+#define LOWER16BIT_SHIFT	  0
+#define UPPER16BIT_SHIFT	  16
 
-#define LOWER_8BIT_SHIFT	   0
-#define LOWER_MIDDLE_8BIT_SHIFT    8
-#define UPPER_MIDDLE_8BIT_SHIFT    16
-#define UPPER_8BIT_SHIFT	   24
-
-#define LOWER_8BIT_OF16_SHIFT      0
-#define UPPER_8BIT_OF16_SHIFT      8
+#define LOWER8BIT_SHIFT	   0
+#define LOWER_MIDDLE8BIT_SHIFT    8
+#define UPPER_MIDDLE8BIT_SHIFT    16
+#define UPPER8BIT_SHIFT	   24
 
+#define LOWER8BIT_OF16_SHIFT      0
+#define UPPER8BIT_OF16_SHIFT      8
 
 /*
- * Definition: LOWER_16BIT_MASK
+ * Definition: LOWER16BIT_MASK
  *
  * DESCRIPTION: 16 bit mask used for inclusion of lower 16 bits i.e. mask out
  *		the upper 16 bits
  */
-#define LOWER_16BIT_MASK	0x0000FFFF
-
+#define LOWER16BIT_MASK	0x0000FFFF
 
 /*
- * Definition: LOWER_8BIT_MASK
+ * Definition: LOWER8BIT_MASK
  *
  * DESCRIPTION: 8 bit masks used for inclusion of 8 bits i.e. mask out
  *		the upper 16 bits
  */
-#define LOWER_8BIT_MASK	   0x000000FF
+#define LOWER8BIT_MASK	   0x000000FF
 
 /*
- * Definition: RETURN_32BITS_FROM_16LOWER_AND_16UPPER(lower16Bits, upper16Bits)
+ * Definition: RETURN32BITS_FROM16LOWER_AND16UPPER(lower16Bits, upper16Bits)
  *
  * DESCRIPTION: Returns a 32 bit value given a 16 bit lower value and a 16
  *		bit upper value
  */
-#define RETURN_32BITS_FROM_16LOWER_AND_16UPPER(lower16Bits, upper16Bits)\
-    (((((u32)lower16Bits)  & LOWER_16BIT_MASK)) | \
-     (((((u32)upper16Bits) & LOWER_16BIT_MASK) << UPPER_16BIT_SHIFT)))
+#define RETURN32BITS_FROM16LOWER_AND16UPPER(lower16Bits, upper16Bits)\
+    (((((u32)lower16Bits)  & LOWER16BIT_MASK)) | \
+     (((((u32)upper16Bits) & LOWER16BIT_MASK) << UPPER16BIT_SHIFT)))
 
 /*
- * Definition: RETURN_16BITS_FROM_8LOWER_AND_8UPPER(lower16Bits, upper16Bits)
+ * Definition: RETURN16BITS_FROM8LOWER_AND8UPPER(lower16Bits, upper16Bits)
  *
  * DESCRIPTION:  Returns a 16 bit value given a 8 bit lower value and a 8
  *	       bit upper value
  */
-#define RETURN_16BITS_FROM_8LOWER_AND_8UPPER(lower8Bits, upper8Bits)\
-    (((((u32)lower8Bits)  & LOWER_8BIT_MASK)) | \
-     (((((u32)upper8Bits) & LOWER_8BIT_MASK) << UPPER_8BIT_OF16_SHIFT)))
+#define RETURN16BITS_FROM8LOWER_AND8UPPER(lower8Bits, upper8Bits)\
+    (((((u32)lower8Bits)  & LOWER8BIT_MASK)) | \
+     (((((u32)upper8Bits) & LOWER8BIT_MASK) << UPPER8BIT_OF16_SHIFT)))
 
 /*
- * Definition: RETURN_32BITS_FROM_4_8BIT_VALUES(lower8Bits, lowerMiddle8Bits,
+ * Definition: RETURN32BITS_FROM48BIT_VALUES(lower8Bits, lowerMiddle8Bits,
  * 					lowerUpper8Bits, upper8Bits)
  *
  * DESCRIPTION:  Returns a 32 bit value given four 8 bit values
  */
-#define RETURN_32BITS_FROM_4_8BIT_VALUES(lower8Bits, lowerMiddle8Bits,\
+#define RETURN32BITS_FROM48BIT_VALUES(lower8Bits, lowerMiddle8Bits,\
 	lowerUpper8Bits, upper8Bits)\
-	(((((u32)lower8Bits) & LOWER_8BIT_MASK)) | \
-	(((((u32)lowerMiddle8Bits) & LOWER_8BIT_MASK) <<\
-		LOWER_MIDDLE_8BIT_SHIFT)) | \
-	(((((u32)lowerUpper8Bits) & LOWER_8BIT_MASK) <<\
-		UPPER_MIDDLE_8BIT_SHIFT)) | \
-	(((((u32)upper8Bits) & LOWER_8BIT_MASK) <<\
-		UPPER_8BIT_SHIFT)))
+	(((((u32)lower8Bits) & LOWER8BIT_MASK)) | \
+	(((((u32)lowerMiddle8Bits) & LOWER8BIT_MASK) <<\
+		LOWER_MIDDLE8BIT_SHIFT)) | \
+	(((((u32)lowerUpper8Bits) & LOWER8BIT_MASK) <<\
+		UPPER_MIDDLE8BIT_SHIFT)) | \
+	(((((u32)upper8Bits) & LOWER8BIT_MASK) <<\
+		UPPER8BIT_SHIFT)))
 
 /*
- * Definition: READ_LOWER_16BITS_OF_32(value32bits)
+ * Definition: READ_LOWER16BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 16 lower bits of 32bit value
  */
-#define READ_LOWER_16BITS_OF_32(value32bits)\
-    ((u16)((u32)(value32bits) & LOWER_16BIT_MASK))
+#define READ_LOWER16BITS_OF32(value32bits)\
+    ((u16)((u32)(value32bits) & LOWER16BIT_MASK))
 
 /*
- * Definition: READ_UPPER_16BITS_OF_32(value32bits)
+ * Definition: READ_UPPER16BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 16 lower bits of 32bit value
  */
-#define READ_UPPER_16BITS_OF_32(value32bits)\
-	(((u16)((u32)(value32bits) >> UPPER_16BIT_SHIFT)) &\
-	LOWER_16BIT_MASK)
-
+#define READ_UPPER16BITS_OF32(value32bits)\
+	(((u16)((u32)(value32bits) >> UPPER16BIT_SHIFT)) &\
+	LOWER16BIT_MASK)
 
 /*
- * Definition: READ_LOWER_8BITS_OF_32(value32bits)
+ * Definition: READ_LOWER8BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 8 lower bits of 32bit value
  */
-#define READ_LOWER_8BITS_OF_32(value32bits)\
-    ((u8)((u32)(value32bits) & LOWER_8BIT_MASK))
+#define READ_LOWER8BITS_OF32(value32bits)\
+    ((u8)((u32)(value32bits) & LOWER8BIT_MASK))
 
 /*
- * Definition: READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)
+ * Definition: READ_LOWER_MIDDLE8BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 8 lower middle bits of 32bit value
  */
-#define READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)\
-	(((u8)((u32)(value32bits) >> LOWER_MIDDLE_8BIT_SHIFT)) &\
-	LOWER_8BIT_MASK)
+#define READ_LOWER_MIDDLE8BITS_OF32(value32bits)\
+	(((u8)((u32)(value32bits) >> LOWER_MIDDLE8BIT_SHIFT)) &\
+	LOWER8BIT_MASK)
 
 /*
- * Definition: READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)
+ * Definition: READ_LOWER_MIDDLE8BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 8 lower middle bits of 32bit value
  */
-#define READ_UPPER_MIDDLE_8BITS_OF_32(value32bits)\
-	(((u8)((u32)(value32bits) >> LOWER_MIDDLE_8BIT_SHIFT)) &\
-	LOWER_8BIT_MASK)
+#define READ_UPPER_MIDDLE8BITS_OF32(value32bits)\
+	(((u8)((u32)(value32bits) >> LOWER_MIDDLE8BIT_SHIFT)) &\
+	LOWER8BIT_MASK)
 
 /*
- * Definition: READ_UPPER_8BITS_OF_32(value32bits)
+ * Definition: READ_UPPER8BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 8 upper bits of 32bit value
  */
-#define READ_UPPER_8BITS_OF_32(value32bits)\
-    (((u8)((u32)(value32bits) >> UPPER_8BIT_SHIFT)) & LOWER_8BIT_MASK)
-
+#define READ_UPPER8BITS_OF32(value32bits)\
+    (((u8)((u32)(value32bits) >> UPPER8BIT_SHIFT)) & LOWER8BIT_MASK)
 
 /*
- * Definition: READ_LOWER_8BITS_OF_16(value16bits)
+ * Definition: READ_LOWER8BITS_OF16(value16bits)
  *
  * DESCRIPTION:  Returns a 8 lower bits of 16bit value
  */
-#define READ_LOWER_8BITS_OF_16(value16bits)\
-    ((u8)((u16)(value16bits) & LOWER_8BIT_MASK))
+#define READ_LOWER8BITS_OF16(value16bits)\
+    ((u8)((u16)(value16bits) & LOWER8BIT_MASK))
 
 /*
- * Definition: READ_UPPER_8BITS_OF_16(value32bits)
+ * Definition: READ_UPPER8BITS_OF16(value32bits)
  *
  * DESCRIPTION:  Returns a 8 upper bits of 16bit value
  */
-#define READ_UPPER_8BITS_OF_16(value16bits)\
-    (((u8)((u32)(value16bits) >> UPPER_8BIT_SHIFT)) & LOWER_8BIT_MASK)
-
-
+#define READ_UPPER8BITS_OF16(value16bits)\
+    (((u8)((u32)(value16bits) >> UPPER8BIT_SHIFT)) & LOWER8BIT_MASK)
 
 /* UWORD16:  16 bit tpyes */
 
+/* reg_uword8, reg_word8: 8 bit register types */
+typedef volatile unsigned char reg_uword8;
+typedef volatile signed char reg_word8;
 
-/* REG_UWORD8, REG_WORD8: 8 bit register types */
-typedef volatile unsigned char  REG_UWORD8;
-typedef volatile signed   char  REG_WORD8;
-
-/* REG_UWORD16, REG_WORD16: 16 bit register types */
+/* reg_uword16, reg_word16: 16 bit register types */
 #ifndef OMAPBRIDGE_TYPES
-typedef volatile unsigned short REG_UWORD16;
+typedef volatile unsigned short reg_uword16;
 #endif
-typedef volatile	  short REG_WORD16;
+typedef volatile short reg_word16;
 
-/* REG_UWORD32, REG_WORD32: 32 bit register types */
-typedef volatile unsigned long  REG_UWORD32;
+/* reg_uword32, REG_WORD32: 32 bit register types */
+typedef volatile unsigned long reg_uword32;
 
 /* FLOAT
  *
@@ -224,72 +217,70 @@ typedef volatile unsigned long  REG_UWORD32;
  * calculation is very CPU expensive, and you should only  use if you
  * absolutely need this. */
 
-
 /* boolean_t:  Boolean Type True, False */
-/* ReturnCode_t:  Return codes to be returned by all library functions */
-typedef enum ReturnCode_label {
-    RET_OK = 0,
-    RET_FAIL = -1,
-    RET_BAD_NULL_PARAM = -2,
-    RET_PARAM_OUT_OF_RANGE = -3,
-    RET_INVALID_ID = -4,
-    RET_EMPTY = -5,
-    RET_FULL = -6,
-    RET_TIMEOUT = -7,
-    RET_INVALID_OPERATION = -8,
-
-    /* Add new error codes at end of above list */
-
-    RET_NUM_RET_CODES     /* this should ALWAYS be LAST entry */
-} ReturnCode_t, *pReturnCode_t;
-
-/* MACRO: RD_MEM_8, WR_MEM_8
+/* return_code_t:  Return codes to be returned by all library functions */
+typedef enum return_code_label {
+	RET_OK = 0,
+	RET_FAIL = -1,
+	RET_BAD_NULL_PARAM = -2,
+	RET_PARAM_OUT_OF_RANGE = -3,
+	RET_INVALID_ID = -4,
+	RET_EMPTY = -5,
+	RET_FULL = -6,
+	RET_TIMEOUT = -7,
+	RET_INVALID_OPERATION = -8,
+
+	/* Add new error codes at end of above list */
+
+	RET_NUM_RET_CODES	/* this should ALWAYS be LAST entry */
+} return_code_t, *preturn_code_t;
+
+/* MACRO: RD_MEM8, WR_MEM8
  *
  * DESCRIPTION:  32 bit memory access macros
  */
-#define RD_MEM_8(addr)	((u8)(*((u8 *)(addr))))
-#define WR_MEM_8(addr, data)	(*((u8 *)(addr)) = (u8)(data))
+#define RD_MEM8(addr)	((u8)(*((u8 *)(addr))))
+#define WR_MEM8(addr, data)	(*((u8 *)(addr)) = (u8)(data))
 
-/* MACRO: RD_MEM_8_VOLATILE, WR_MEM_8_VOLATILE
+/* MACRO: RD_MEM8_VOLATILE, WR_MEM8_VOLATILE
  *
  * DESCRIPTION:  8 bit register access macros
  */
-#define RD_MEM_8_VOLATILE(addr)	((u8)(*((REG_UWORD8 *)(addr))))
-#define WR_MEM_8_VOLATILE(addr, data) (*((REG_UWORD8 *)(addr)) = (u8)(data))
-
+#define RD_MEM8_VOLATILE(addr)	((u8)(*((reg_uword8 *)(addr))))
+#define WR_MEM8_VOLATILE(addr, data) (*((reg_uword8 *)(addr)) = (u8)(data))
 
 /*
- * MACRO: RD_MEM_16, WR_MEM_16
+ * MACRO: RD_MEM16, WR_MEM16
  *
  * DESCRIPTION:  16 bit memory access macros
  */
-#define RD_MEM_16(addr)	((u16)(*((u16 *)(addr))))
-#define WR_MEM_16(addr, data)	(*((u16 *)(addr)) = (u16)(data))
+#define RD_MEM16(addr)	((u16)(*((u16 *)(addr))))
+#define WR_MEM16(addr, data)	(*((u16 *)(addr)) = (u16)(data))
 
 /*
- * MACRO: RD_MEM_16_VOLATILE, WR_MEM_16_VOLATILE
+ * MACRO: RD_MEM16_VOLATILE, WR_MEM16_VOLATILE
  *
  * DESCRIPTION:  16 bit register access macros
  */
-#define RD_MEM_16_VOLATILE(addr)	((u16)(*((REG_UWORD16 *)(addr))))
-#define WR_MEM_16_VOLATILE(addr, data)	(*((REG_UWORD16 *)(addr)) =\
+#define RD_MEM16_VOLATILE(addr)	((u16)(*((reg_uword16 *)(addr))))
+#define WR_MEM16_VOLATILE(addr, data)	(*((reg_uword16 *)(addr)) =\
 					(u16)(data))
 
 /*
- * MACRO: RD_MEM_32, WR_MEM_32
+ * MACRO: RD_MEM32, WR_MEM32
  *
  * DESCRIPTION:  32 bit memory access macros
  */
-#define RD_MEM_32(addr)	((u32)(*((u32 *)(addr))))
-#define WR_MEM_32(addr, data)	(*((u32 *)(addr)) = (u32)(data))
+#define RD_MEM32(addr)	((u32)(*((u32 *)(addr))))
+#define WR_MEM32(addr, data)	(*((u32 *)(addr)) = (u32)(data))
 
 /*
- * MACRO: RD_MEM_32_VOLATILE, WR_MEM_32_VOLATILE
+ * MACRO: RD_MEM32_VOLATILE, WR_MEM32_VOLATILE
  *
  * DESCRIPTION:  32 bit register access macros
  */
-#define RD_MEM_32_VOLATILE(addr)	((u32)(*((REG_UWORD32 *)(addr))))
-#define WR_MEM_32_VOLATILE(addr, data)	(*((REG_UWORD32 *)(addr)) =\
+#define RD_MEM32_VOLATILE(addr)	((u32)(*((reg_uword32 *)(addr))))
+#define WR_MEM32_VOLATILE(addr, data)	(*((reg_uword32 *)(addr)) =\
 					(u32)(data))
 
 /* Not sure if this all belongs here */
@@ -314,4 +305,4 @@ typedef enum ReturnCode_label {
 #define CHECK_INPUT_RANGE_NO_SPY_MIN0(actualValue, maxValidValue,\
 	returnCodeIfMismatch)
 
-#endif	/* __GLOBALTYPES_H */
+#endif /* _GLOBALTYPES_H */
diff --git a/drivers/dsp/bridge/hw/IPIAccInt.h b/drivers/dsp/bridge/hw/IPIAccInt.h
index dde0ef0..644fd0d 100644
--- a/drivers/dsp/bridge/hw/IPIAccInt.h
+++ b/drivers/dsp/bridge/hw/IPIAccInt.h
@@ -22,5 +22,5 @@
 #define SYSC_IVA2BOOTADDR_OFFSET                0x400
 #define SYSC_IVA2BOOTADDR_MASK                 0xfffffc00
 
-#endif				/* _IPI_ACC_INT_H */
+#endif /* _IPI_ACC_INT_H */
 /* EOF */
diff --git a/drivers/dsp/bridge/hw/MLBAccInt.h b/drivers/dsp/bridge/hw/MLBAccInt.h
index 6b27d31..93fcd0c 100644
--- a/drivers/dsp/bridge/hw/MLBAccInt.h
+++ b/drivers/dsp/bridge/hw/MLBAccInt.h
@@ -19,113 +19,107 @@
 
 /* Mappings of level 1 EASI function numbers to function names */
 
-#define EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32   (MLB_BASE_EASIL1 + 3)
-#define EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32  (MLB_BASE_EASIL1 + 4)
-#define EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32   (MLB_BASE_EASIL1 + 7)
-#define EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32  (MLB_BASE_EASIL1 + 17)
-#define EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32 (MLB_BASE_EASIL1 + 29)
-#define EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32 \
+#define EASIL1_MLBMAILBOX_SYSCONFIG_READ_REGISTER32   (MLB_BASE_EASIL1 + 3)
+#define EASIL1_MLBMAILBOX_SYSCONFIG_WRITE_REGISTER32  (MLB_BASE_EASIL1 + 4)
+#define EASIL1_MLBMAILBOX_SYSCONFIGS_IDLE_MODE_READ32   (MLB_BASE_EASIL1 + 7)
+#define EASIL1_MLBMAILBOX_SYSCONFIGS_IDLE_MODE_WRITE32  (MLB_BASE_EASIL1 + 17)
+#define EASIL1_MLBMAILBOX_SYSCONFIG_SOFT_RESET_WRITE32 (MLB_BASE_EASIL1 + 29)
+#define EASIL1_MLBMAILBOX_SYSCONFIG_AUTO_IDLE_READ32 \
 						(MLB_BASE_EASIL1 + 33)
-#define EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32   (MLB_BASE_EASIL1 + 39)
-#define EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32  (MLB_BASE_EASIL1 + 44)
-#define EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32 \
+#define EASIL1_MLBMAILBOX_SYSCONFIG_AUTO_IDLE_WRITE32   (MLB_BASE_EASIL1 + 39)
+#define EASIL1_MLBMAILBOX_SYSSTATUS_RESET_DONE_READ32  (MLB_BASE_EASIL1 + 44)
+#define EASIL1_MLBMAILBOX_MESSAGE015_READ_REGISTER32 \
 						(MLB_BASE_EASIL1 + 50)
-#define EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32  \
+#define EASIL1_MLBMAILBOX_MESSAGE015_WRITE_REGISTER32  \
 						(MLB_BASE_EASIL1 + 51)
-#define EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32  \
+#define EASIL1_MLBMAILBOX_FIFOSTATUS015_READ_REGISTER32  \
 						(MLB_BASE_EASIL1 + 56)
-#define EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32 \
+#define EASIL1_MLBMAILBOX_FIFOSTATUS015_FIFO_FULL_M_BM_READ32 \
 						(MLB_BASE_EASIL1 + 57)
-#define EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32  \
+#define EASIL1_MLBMAILBOX_MSGSTATUS015_NB_OF_MSG_M_BM_READ32  \
 						(MLB_BASE_EASIL1 + 60)
-#define EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32  \
+#define EASIL1_MLBMAILBOX_IRQSTATUS03_READ_REGISTER32  \
 						(MLB_BASE_EASIL1 + 62)
-#define EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32 \
+#define EASIL1_MLBMAILBOX_IRQSTATUS03_WRITE_REGISTER32 \
 						(MLB_BASE_EASIL1 + 63)
-#define EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32    \
+#define EASIL1_MLBMAILBOX_IRQENABLE03_READ_REGISTER32    \
 						(MLB_BASE_EASIL1 + 192)
-#define EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32   \
+#define EASIL1_MLBMAILBOX_IRQENABLE03_WRITE_REGISTER32   \
 						(MLB_BASE_EASIL1 + 193)
 
 /* Register set MAILBOX_MESSAGE___REGSET_0_15 address offset, bank address
  * increment and number of banks */
 
-#define MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET    (u32)(0x0040)
-#define MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP   (u32)(0x0004)
+#define MLB_MAILBOX_MESSAGE_REGSET015_OFFSET    (u32)(0x0040)
+#define MLB_MAILBOX_MESSAGE_REGSET015_STEP   (u32)(0x0004)
 
 /* Register offset address definitions relative to register set
  * MAILBOX_MESSAGE___REGSET_0_15 */
 
-#define MLB_MAILBOX_MESSAGE___0_15_OFFSET   (u32)(0x0)
-
+#define MLB_MAILBOX_MESSAGE015_OFFSET   (u32)(0x0)
 
 /* Register set MAILBOX_FIFOSTATUS___REGSET_0_15 address offset, bank address
  * increment and number of banks */
 
-#define MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET  (u32)(0x0080)
-#define MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP   (u32)(0x0004)
+#define MLB_MAILBOX_FIFOSTATUS_REGSET015_OFFSET  (u32)(0x0080)
+#define MLB_MAILBOX_FIFOSTATUS_REGSET015_STEP   (u32)(0x0004)
 
 /* Register offset address definitions relative to register set
  * MAILBOX_FIFOSTATUS___REGSET_0_15 */
 
-#define MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET    (u32)(0x0)
-
+#define MLB_MAILBOX_FIFOSTATUS015_OFFSET    (u32)(0x0)
 
 /* Register set MAILBOX_MSGSTATUS___REGSET_0_15 address offset, bank address
  * increment and number of banks */
 
-#define MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET  (u32)(0x00c0)
-#define MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP    (u32)(0x0004)
+#define MLB_MAILBOX_MSGSTATUS_REGSET015_OFFSET  (u32)(0x00c0)
+#define MLB_MAILBOX_MSGSTATUS_REGSET015_STEP    (u32)(0x0004)
 
 /* Register offset address definitions relative to register set
  * MAILBOX_MSGSTATUS___REGSET_0_15 */
 
-#define MLB_MAILBOX_MSGSTATUS___0_15_OFFSET    (u32)(0x0)
-
+#define MLB_MAILBOX_MSGSTATUS015_OFFSET    (u32)(0x0)
 
 /* Register set MAILBOX_IRQSTATUS___REGSET_0_3 address offset, bank address
  * increment and number of banks */
 
-#define MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET        (u32)(0x0100)
-#define MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP          (u32)(0x0008)
+#define MLB_MAILBOX_IRQSTATUS_REGSET03_OFFSET        (u32)(0x0100)
+#define MLB_MAILBOX_IRQSTATUS_REGSET03_STEP          (u32)(0x0008)
 
 /* Register offset address definitions relative to register set
  * MAILBOX_IRQSTATUS___REGSET_0_3 */
 
-#define MLB_MAILBOX_IRQSTATUS___0_3_OFFSET        (u32)(0x0)
-
+#define MLB_MAILBOX_IRQSTATUS03_OFFSET        (u32)(0x0)
 
 /* Register set MAILBOX_IRQENABLE___REGSET_0_3 address offset, bank address
  * increment and number of banks */
 
-#define MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET     (u32)(0x0104)
-#define MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP     (u32)(0x0008)
+#define MLB_MAILBOX_IRQENABLE_REGSET03_OFFSET     (u32)(0x0104)
+#define MLB_MAILBOX_IRQENABLE_REGSET03_STEP     (u32)(0x0008)
 
 /* Register offset address definitions relative to register set
  * MAILBOX_IRQENABLE___REGSET_0_3 */
 
-#define MLB_MAILBOX_IRQENABLE___0_3_OFFSET          (u32)(0x0)
-
+#define MLB_MAILBOX_IRQENABLE03_OFFSET          (u32)(0x0)
 
 /* Register offset address definitions */
 
 #define MLB_MAILBOX_SYSCONFIG_OFFSET            (u32)(0x10)
 #define MLB_MAILBOX_SYSSTATUS_OFFSET            (u32)(0x14)
 
-
 /* Bitfield mask and offset declarations */
 
-#define MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK        (u32)(0x18)
-#define MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET      (u32)(3)
-#define MLB_MAILBOX_SYSCONFIG_SoftReset_MASK        (u32)(0x2)
-#define MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET      (u32)(1)
-#define MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK          (u32)(0x1)
-#define MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET        (u32)(0)
-#define MLB_MAILBOX_SYSSTATUS_ResetDone_MASK         (u32)(0x1)
-#define MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET         (u32)(0)
-#define MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_MASK   (u32)(0x1)
-#define MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_OFFSET  (u32)(0)
-#define MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_MASK    (u32)(0x7f)
-#define MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_OFFSET    (u32)(0)
+#define MLB_MAILBOX_SYSCONFIG_S_IDLE_MODE_MASK        (u32)(0x18)
+#define MLB_MAILBOX_SYSCONFIG_S_IDLE_MODE_OFFSET      (u32)(3)
+#define MLB_MAILBOX_SYSCONFIG_SOFT_RESET_MASK        (u32)(0x2)
+#define MLB_MAILBOX_SYSCONFIG_SOFT_RESET_OFFSET      (u32)(1)
+#define MLB_MAILBOX_SYSCONFIG_AUTO_IDLE_MASK          (u32)(0x1)
+#define MLB_MAILBOX_SYSCONFIG_AUTO_IDLE_OFFSET        (u32)(0)
+#define MLB_MAILBOX_SYSSTATUS_RESET_DONE_MASK         (u32)(0x1)
+#define MLB_MAILBOX_SYSSTATUS_RESET_DONE_OFFSET         (u32)(0)
+#define MLB_MAILBOX_FIFOSTATUS015_FIFO_FULL_M_BM_MASK   (u32)(0x1)
+#define MLB_MAILBOX_FIFOSTATUS015_FIFO_FULL_M_BM_OFFSET  (u32)(0)
+#define MLB_MAILBOX_MSGSTATUS015_NB_OF_MSG_M_BM_MASK    (u32)(0x7f)
+#define MLB_MAILBOX_MSGSTATUS015_NB_OF_MSG_M_BM_OFFSET    (u32)(0)
 
 #endif /* _MLB_ACC_INT_H */
diff --git a/drivers/dsp/bridge/hw/MLBRegAcM.h b/drivers/dsp/bridge/hw/MLBRegAcM.h
index 7f9accb..ba2f5e1 100644
--- a/drivers/dsp/bridge/hw/MLBRegAcM.h
+++ b/drivers/dsp/bridge/hw/MLBRegAcM.h
@@ -24,159 +24,157 @@
 
 #if defined(USE_LEVEL_1_MACROS)
 
-#define MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress)			 \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32), \
+#define MLBMAILBOX_SYSCONFIG_READ_REGISTER32(baseAddress)			 \
+	(_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_SYSCONFIG_READ_REGISTER32), \
 	__raw_readl(((baseAddress)) + MLB_MAILBOX_SYSCONFIG_OFFSET))
 
-
-#define MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, value)		\
+#define MLBMAILBOX_SYSCONFIG_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;		\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32);\
+	_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_SYSCONFIG_WRITE_REGISTER32);\
 	__raw_writel(newValue, ((baseAddress)) + offset);		\
 } while (0)
 
-#define MLBMAILBOX_SYSCONFIGSIdleModeRead32(baseAddress)		  \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32), \
+#define MLBMAILBOX_SYSCONFIGS_IDLE_MODE_READ32(baseAddress)		  \
+	(_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGS_IDLE_MODE_READ32), \
 	(((__raw_readl((((u32)(baseAddress)) +				  \
 	(MLB_MAILBOX_SYSCONFIG_OFFSET)))) &				  \
-	MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK) >>			  \
-	MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET))
+	MLB_MAILBOX_SYSCONFIG_S_IDLE_MODE_MASK) >>			  \
+	MLB_MAILBOX_SYSCONFIG_S_IDLE_MODE_OFFSET))
 
-#define MLBMAILBOX_SYSCONFIGSIdleModeWrite32(baseAddress, value)	  \
+#define MLBMAILBOX_SYSCONFIGS_IDLE_MODE_WRITE32(baseAddress, value)	  \
 do {									  \
 	const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;		  \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	  \
 	register u32 newValue = ((u32)(value));				  \
-	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32); \
-	data &= ~(MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK);		  \
-	newValue <<= MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET;		  \
-	newValue &= MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK;		  \
+	_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGS_IDLE_MODE_WRITE32); \
+	data &= ~(MLB_MAILBOX_SYSCONFIG_S_IDLE_MODE_MASK);		  \
+	newValue <<= MLB_MAILBOX_SYSCONFIG_S_IDLE_MODE_OFFSET;		  \
+	newValue &= MLB_MAILBOX_SYSCONFIG_S_IDLE_MODE_MASK;		  \
 	newValue |= data;						  \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		  \
 } while (0)
 
-#define MLBMAILBOX_SYSCONFIGSoftResetWrite32(baseAddress, value)	    \
+#define MLBMAILBOX_SYSCONFIG_SOFT_RESET_WRITE32(baseAddress, value)	    \
 do {									    \
 	const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;		    \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	    \
 	register u32 newValue = ((u32)(value));				    \
-	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32);   \
-	data &= ~(MLB_MAILBOX_SYSCONFIG_SoftReset_MASK);		    \
-	newValue <<= MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET;		    \
-	newValue &= MLB_MAILBOX_SYSCONFIG_SoftReset_MASK;		    \
+	_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_SYSCONFIG_SOFT_RESET_WRITE32);   \
+	data &= ~(MLB_MAILBOX_SYSCONFIG_SOFT_RESET_MASK);		    \
+	newValue <<= MLB_MAILBOX_SYSCONFIG_SOFT_RESET_OFFSET;		    \
+	newValue &= MLB_MAILBOX_SYSCONFIG_SOFT_RESET_MASK;		    \
 	newValue |= data;						    \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		    \
 } while (0)
 
-#define MLBMAILBOX_SYSCONFIGAutoIdleRead32(baseAddress)			 \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32), \
+#define MLBMAILBOX_SYSCONFIG_AUTO_IDLE_READ32(baseAddress)			 \
+	(_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_SYSCONFIG_AUTO_IDLE_READ32), \
 	(((__raw_readl((((u32)(baseAddress)) +				 \
 	(MLB_MAILBOX_SYSCONFIG_OFFSET)))) &				 \
-	MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK) >>				 \
-	MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET))
+	MLB_MAILBOX_SYSCONFIG_AUTO_IDLE_MASK) >>				 \
+	MLB_MAILBOX_SYSCONFIG_AUTO_IDLE_OFFSET))
 
-#define MLBMAILBOX_SYSCONFIGAutoIdleWrite32(baseAddress, value)		 \
+#define MLBMAILBOX_SYSCONFIG_AUTO_IDLE_WRITE32(baseAddress, value)		 \
 do {									 \
 	const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;		 \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	 \
 	register u32 newValue = ((u32)(value));				 \
-	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32); \
-	data &= ~(MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK);			 \
-	newValue <<= MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET;		 \
-	newValue &= MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK;		 \
+	_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_SYSCONFIG_AUTO_IDLE_WRITE32); \
+	data &= ~(MLB_MAILBOX_SYSCONFIG_AUTO_IDLE_MASK);			 \
+	newValue <<= MLB_MAILBOX_SYSCONFIG_AUTO_IDLE_OFFSET;		 \
+	newValue &= MLB_MAILBOX_SYSCONFIG_AUTO_IDLE_MASK;		 \
 	newValue |= data;						 \
 	__raw_writel(newValue, (u32)(baseAddress)+offset);		 \
 } while (0)
 
-#define MLBMAILBOX_SYSSTATUSResetDoneRead32(baseAddress)\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32), \
+#define MLBMAILBOX_SYSSTATUS_RESET_DONE_READ32(baseAddress)\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_SYSSTATUS_RESET_DONE_READ32), \
 	(((__raw_readl((((u32)(baseAddress)) +				  \
 	(MLB_MAILBOX_SYSSTATUS_OFFSET)))) &				  \
-	MLB_MAILBOX_SYSSTATUS_ResetDone_MASK) >>			  \
-	MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET))
+	MLB_MAILBOX_SYSSTATUS_RESET_DONE_MASK) >>			  \
+	MLB_MAILBOX_SYSSTATUS_RESET_DONE_OFFSET))
 
-#define MLBMAILBOX_MESSAGE___0_15ReadRegister32(baseAddress, bank)	      \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32), \
+#define MLBMAILBOX_MESSAGE015_READ_REGISTER32(baseAddress, bank)	      \
+	(_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_MESSAGE015_READ_REGISTER32), \
 	__raw_readl(((baseAddress)) +					      \
-	(MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +			      \
-	MLB_MAILBOX_MESSAGE___0_15_OFFSET +				      \
-	((bank) * MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP))))
+	(MLB_MAILBOX_MESSAGE_REGSET015_OFFSET +			      \
+	MLB_MAILBOX_MESSAGE015_OFFSET +				      \
+	((bank) * MLB_MAILBOX_MESSAGE_REGSET015_STEP))))
 
-#define MLBMAILBOX_MESSAGE___0_15WriteRegister32(baseAddress, bank, value)    \
+#define MLBMAILBOX_MESSAGE015_WRITE_REGISTER32(baseAddress, bank, value)    \
 do {									      \
-	const u32 offset = MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +	      \
-	MLB_MAILBOX_MESSAGE___0_15_OFFSET +				      \
-	((bank) * MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP);		      \
+	const u32 offset = MLB_MAILBOX_MESSAGE_REGSET015_OFFSET +	      \
+	MLB_MAILBOX_MESSAGE015_OFFSET +				      \
+	((bank) * MLB_MAILBOX_MESSAGE_REGSET015_STEP);		      \
 	register u32 newValue = ((u32)(value));				      \
-	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_MESSAGE015_WRITE_REGISTER32); \
 	__raw_writel(newValue, ((baseAddress)) + offset);		      \
 } while (0)
 
-#define MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32(baseAddress, bank)	\
-	(_DEBUG_LEVEL_1_EASI						\
-	(EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32),		\
+#define MLBMAILBOX_FIFOSTATUS015_READ_REGISTER32(baseAddress, bank)	\
+	(_DEBUG_LEVEL1_EASI						\
+	(EASIL1_MLBMAILBOX_FIFOSTATUS015_READ_REGISTER32),		\
 	__raw_readl(((u32)(baseAddress)) +				\
-	(MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +			\
-	MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET +				\
-	((bank) * MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP))))
+	(MLB_MAILBOX_FIFOSTATUS_REGSET015_OFFSET +			\
+	MLB_MAILBOX_FIFOSTATUS015_OFFSET +				\
+	((bank) * MLB_MAILBOX_FIFOSTATUS_REGSET015_STEP))))
 
-#define MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32(baseAddress, bank) \
-	(_DEBUG_LEVEL_1_EASI(						 \
-	EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32),		 \
+#define MLBMAILBOX_FIFOSTATUS015_FIFO_FULL_M_BM_READ32(baseAddress, bank) \
+	(_DEBUG_LEVEL1_EASI(						 \
+	EASIL1_MLBMAILBOX_FIFOSTATUS015_FIFO_FULL_M_BM_READ32),		 \
 	(((__raw_readl(((baseAddress)) +				 \
-	(MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +			 \
-	MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET +				 \
-	((bank) * MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP)))) &	 \
-	MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_MASK) >>		 \
-	MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_OFFSET))
-
-#define MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32(baseAddress, bank)	\
-	(_DEBUG_LEVEL_1_EASI(						\
-	EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32),		\
+	(MLB_MAILBOX_FIFOSTATUS_REGSET015_OFFSET +			 \
+	MLB_MAILBOX_FIFOSTATUS015_OFFSET +				 \
+	((bank) * MLB_MAILBOX_FIFOSTATUS_REGSET015_STEP)))) &	 \
+	MLB_MAILBOX_FIFOSTATUS015_FIFO_FULL_M_BM_MASK) >>		 \
+	MLB_MAILBOX_FIFOSTATUS015_FIFO_FULL_M_BM_OFFSET))
+
+#define MLBMAILBOX_MSGSTATUS015_NB_OF_MSG_M_BM_READ32(baseAddress, bank)	\
+	(_DEBUG_LEVEL1_EASI(						\
+	EASIL1_MLBMAILBOX_MSGSTATUS015_NB_OF_MSG_M_BM_READ32),		\
 	(((__raw_readl(((baseAddress)) +				\
-	(MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET +			\
-	MLB_MAILBOX_MSGSTATUS___0_15_OFFSET +				\
-	((bank) * MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP)))) &	\
-	MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_MASK) >>		\
-	MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_OFFSET))
-
-#define MLBMAILBOX_IRQSTATUS___0_3ReadRegister32(baseAddress, bank)	       \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32), \
+	(MLB_MAILBOX_MSGSTATUS_REGSET015_OFFSET +			\
+	MLB_MAILBOX_MSGSTATUS015_OFFSET +				\
+	((bank) * MLB_MAILBOX_MSGSTATUS_REGSET015_STEP)))) &	\
+	MLB_MAILBOX_MSGSTATUS015_NB_OF_MSG_M_BM_MASK) >>		\
+	MLB_MAILBOX_MSGSTATUS015_NB_OF_MSG_M_BM_OFFSET))
+
+#define MLBMAILBOX_IRQSTATUS03_READ_REGISTER32(baseAddress, bank)	       \
+	(_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS03_READ_REGISTER32), \
 	__raw_readl(((baseAddress)) +					       \
-	(MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +			       \
-	MLB_MAILBOX_IRQSTATUS___0_3_OFFSET +				       \
-	((bank) * MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP))))
+	(MLB_MAILBOX_IRQSTATUS_REGSET03_OFFSET +			       \
+	MLB_MAILBOX_IRQSTATUS03_OFFSET +				       \
+	((bank) * MLB_MAILBOX_IRQSTATUS_REGSET03_STEP))))
 
-#define MLBMAILBOX_IRQSTATUS___0_3WriteRegister32(baseAddress, bank, value)    \
+#define MLBMAILBOX_IRQSTATUS03_WRITE_REGISTER32(baseAddress, bank, value)    \
 do {									       \
-	const u32 offset = MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +	       \
-	MLB_MAILBOX_IRQSTATUS___0_3_OFFSET +				       \
-	((bank) * MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP);		       \
+	const u32 offset = MLB_MAILBOX_IRQSTATUS_REGSET03_OFFSET +	       \
+	MLB_MAILBOX_IRQSTATUS03_OFFSET +				       \
+	((bank) * MLB_MAILBOX_IRQSTATUS_REGSET03_STEP);		       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS03_WRITE_REGISTER32); \
 	__raw_writel(newValue, ((baseAddress)) + offset);		       \
 } while (0)
 
-#define MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress, bank)	       \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32), \
+#define MLBMAILBOX_IRQENABLE03_READ_REGISTER32(baseAddress, bank)	       \
+	(_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_IRQENABLE03_READ_REGISTER32), \
 	__raw_readl(((baseAddress)) +					       \
-	(MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +			       \
-	MLB_MAILBOX_IRQENABLE___0_3_OFFSET +				       \
-	((bank) * MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP))))
-
+	(MLB_MAILBOX_IRQENABLE_REGSET03_OFFSET +			       \
+	MLB_MAILBOX_IRQENABLE03_OFFSET +				       \
+	((bank) * MLB_MAILBOX_IRQENABLE_REGSET03_STEP))))
 
-#define MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, bank, value)    \
+#define MLBMAILBOX_IRQENABLE03_WRITE_REGISTER32(baseAddress, bank, value)    \
 do {									       \
-	const u32 offset = MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +	       \
-	MLB_MAILBOX_IRQENABLE___0_3_OFFSET +				       \
-	((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP);		       \
+	const u32 offset = MLB_MAILBOX_IRQENABLE_REGSET03_OFFSET +	       \
+	MLB_MAILBOX_IRQENABLE03_OFFSET +				       \
+	((bank)*MLB_MAILBOX_IRQENABLE_REGSET03_STEP);		       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_MLBMAILBOX_IRQENABLE03_WRITE_REGISTER32); \
 	__raw_writel(newValue, ((baseAddress)) + offset);		       \
 } while (0)
 
-#endif	/* USE_LEVEL_1_MACROS */
+#endif /* USE_LEVEL_1_MACROS */
 
 #endif /* _MLB_REG_ACM_H */
diff --git a/drivers/dsp/bridge/hw/MMUAccInt.h b/drivers/dsp/bridge/hw/MMUAccInt.h
index 6ca1573..1cefca3 100644
--- a/drivers/dsp/bridge/hw/MMUAccInt.h
+++ b/drivers/dsp/bridge/hw/MMUAccInt.h
@@ -19,29 +19,29 @@
 
 /* Mappings of level 1 EASI function numbers to function names */
 
-#define EASIL1_MMUMMU_SYSCONFIGReadRegister32 (MMU_BASE_EASIL1 + 3)
-#define EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32  (MMU_BASE_EASIL1 + 17)
-#define EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32    (MMU_BASE_EASIL1 + 39)
-#define EASIL1_MMUMMU_IRQSTATUSWriteRegister32   (MMU_BASE_EASIL1 + 51)
-#define EASIL1_MMUMMU_IRQENABLEReadRegister32 (MMU_BASE_EASIL1 + 102)
-#define EASIL1_MMUMMU_IRQENABLEWriteRegister32 (MMU_BASE_EASIL1 + 103)
-#define EASIL1_MMUMMU_WALKING_STTWLRunningRead32 (MMU_BASE_EASIL1 + 156)
-#define EASIL1_MMUMMU_CNTLTWLEnableRead32 (MMU_BASE_EASIL1 + 174)
-#define EASIL1_MMUMMU_CNTLTWLEnableWrite32   (MMU_BASE_EASIL1 + 180)
-#define EASIL1_MMUMMU_CNTLMMUEnableWrite32     (MMU_BASE_EASIL1 + 190)
-#define EASIL1_MMUMMU_FAULT_ADReadRegister32   (MMU_BASE_EASIL1 + 194)
-#define EASIL1_MMUMMU_TTBWriteRegister32  (MMU_BASE_EASIL1 + 198)
-#define EASIL1_MMUMMU_LOCKReadRegister32   (MMU_BASE_EASIL1 + 203)
-#define EASIL1_MMUMMU_LOCKWriteRegister32  (MMU_BASE_EASIL1 + 204)
-#define EASIL1_MMUMMU_LOCKBaseValueRead32  (MMU_BASE_EASIL1 + 205)
-#define EASIL1_MMUMMU_LOCKCurrentVictimRead32 (MMU_BASE_EASIL1 + 209)
-#define EASIL1_MMUMMU_LOCKCurrentVictimWrite32 (MMU_BASE_EASIL1 + 211)
-#define EASIL1_MMUMMU_LOCKCurrentVictimSet32  (MMU_BASE_EASIL1 + 212)
-#define EASIL1_MMUMMU_LD_TLBReadRegister32    (MMU_BASE_EASIL1 + 213)
-#define EASIL1_MMUMMU_LD_TLBWriteRegister32   (MMU_BASE_EASIL1 + 214)
-#define EASIL1_MMUMMU_CAMWriteRegister32   (MMU_BASE_EASIL1 + 226)
-#define EASIL1_MMUMMU_RAMWriteRegister32 (MMU_BASE_EASIL1 + 268)
-#define EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32  (MMU_BASE_EASIL1 + 322)
+#define EASIL1_MMUMMU_SYSCONFIG_READ_REGISTER32 (MMU_BASE_EASIL1 + 3)
+#define EASIL1_MMUMMU_SYSCONFIG_IDLE_MODE_WRITE32  (MMU_BASE_EASIL1 + 17)
+#define EASIL1_MMUMMU_SYSCONFIG_AUTO_IDLE_WRITE32    (MMU_BASE_EASIL1 + 39)
+#define EASIL1_MMUMMU_IRQSTATUS_WRITE_REGISTER32   (MMU_BASE_EASIL1 + 51)
+#define EASIL1_MMUMMU_IRQENABLE_READ_REGISTER32 (MMU_BASE_EASIL1 + 102)
+#define EASIL1_MMUMMU_IRQENABLE_WRITE_REGISTER32 (MMU_BASE_EASIL1 + 103)
+#define EASIL1_MMUMMU_WALKING_STTWL_RUNNING_READ32 (MMU_BASE_EASIL1 + 156)
+#define EASIL1_MMUMMU_CNTLTWL_ENABLE_READ32 (MMU_BASE_EASIL1 + 174)
+#define EASIL1_MMUMMU_CNTLTWL_ENABLE_WRITE32   (MMU_BASE_EASIL1 + 180)
+#define EASIL1_MMUMMU_CNTLMMU_ENABLE_WRITE32     (MMU_BASE_EASIL1 + 190)
+#define EASIL1_MMUMMU_FAULT_AD_READ_REGISTER32   (MMU_BASE_EASIL1 + 194)
+#define EASIL1_MMUMMU_TTB_WRITE_REGISTER32  (MMU_BASE_EASIL1 + 198)
+#define EASIL1_MMUMMU_LOCK_READ_REGISTER32   (MMU_BASE_EASIL1 + 203)
+#define EASIL1_MMUMMU_LOCK_WRITE_REGISTER32  (MMU_BASE_EASIL1 + 204)
+#define EASIL1_MMUMMU_LOCK_BASE_VALUE_READ32  (MMU_BASE_EASIL1 + 205)
+#define EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_READ32 (MMU_BASE_EASIL1 + 209)
+#define EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_WRITE32 (MMU_BASE_EASIL1 + 211)
+#define EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_SET32  (MMU_BASE_EASIL1 + 212)
+#define EASIL1_MMUMMU_LD_TLB_READ_REGISTER32    (MMU_BASE_EASIL1 + 213)
+#define EASIL1_MMUMMU_LD_TLB_WRITE_REGISTER32   (MMU_BASE_EASIL1 + 214)
+#define EASIL1_MMUMMU_CAM_WRITE_REGISTER32   (MMU_BASE_EASIL1 + 226)
+#define EASIL1_MMUMMU_RAM_WRITE_REGISTER32 (MMU_BASE_EASIL1 + 268)
+#define EASIL1_MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32  (MMU_BASE_EASIL1 + 322)
 
 /* Register offset address definitions */
 #define MMU_MMU_SYSCONFIG_OFFSET   0x10
@@ -58,19 +58,19 @@
 #define MMU_MMU_GFLUSH_OFFSET  0x60
 #define MMU_MMU_FLUSH_ENTRY_OFFSET  0x64
 /* Bitfield mask and offset declarations */
-#define MMU_MMU_SYSCONFIG_IdleMode_MASK  0x18
-#define MMU_MMU_SYSCONFIG_IdleMode_OFFSET  3
-#define MMU_MMU_SYSCONFIG_AutoIdle_MASK  0x1
-#define MMU_MMU_SYSCONFIG_AutoIdle_OFFSET   0
-#define MMU_MMU_WALKING_ST_TWLRunning_MASK 0x1
-#define MMU_MMU_WALKING_ST_TWLRunning_OFFSET  0
-#define MMU_MMU_CNTL_TWLEnable_MASK 0x4
-#define MMU_MMU_CNTL_TWLEnable_OFFSET 2
-#define MMU_MMU_CNTL_MMUEnable_MASK    0x2
-#define MMU_MMU_CNTL_MMUEnable_OFFSET   1
-#define MMU_MMU_LOCK_BaseValue_MASK 0xfc00
-#define MMU_MMU_LOCK_BaseValue_OFFSET   10
-#define MMU_MMU_LOCK_CurrentVictim_MASK   0x3f0
-#define MMU_MMU_LOCK_CurrentVictim_OFFSET    4
+#define MMU_MMU_SYSCONFIG_IDLE_MODE_MASK  0x18
+#define MMU_MMU_SYSCONFIG_IDLE_MODE_OFFSET  3
+#define MMU_MMU_SYSCONFIG_AUTO_IDLE_MASK  0x1
+#define MMU_MMU_SYSCONFIG_AUTO_IDLE_OFFSET   0
+#define MMU_MMU_WALKING_ST_TWL_RUNNING_MASK 0x1
+#define MMU_MMU_WALKING_ST_TWL_RUNNING_OFFSET  0
+#define MMU_MMU_CNTL_TWL_ENABLE_MASK 0x4
+#define MMU_MMU_CNTL_TWL_ENABLE_OFFSET 2
+#define MMU_MMU_CNTL_MMU_ENABLE_MASK    0x2
+#define MMU_MMU_CNTL_MMU_ENABLE_OFFSET   1
+#define MMU_MMU_LOCK_BASE_VALUE_MASK 0xfc00
+#define MMU_MMU_LOCK_BASE_VALUE_OFFSET   10
+#define MMU_MMU_LOCK_CURRENT_VICTIM_MASK   0x3f0
+#define MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET    4
 
 #endif /* _MMU_ACC_INT_H */
diff --git a/drivers/dsp/bridge/hw/MMURegAcM.h b/drivers/dsp/bridge/hw/MMURegAcM.h
index 00ef881..b6914ef 100644
--- a/drivers/dsp/bridge/hw/MMURegAcM.h
+++ b/drivers/dsp/bridge/hw/MMURegAcM.h
@@ -25,201 +25,201 @@
 
 #if defined(USE_LEVEL_1_MACROS)
 
-#define MMUMMU_SYSCONFIGReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGReadRegister32),	\
+#define MMUMMU_SYSCONFIG_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_READ_REGISTER32),	\
 	__raw_readl((baseAddress) + MMU_MMU_SYSCONFIG_OFFSET))
 
-#define MMUMMU_SYSCONFIGIdleModeWrite32(baseAddress, value)		\
+#define MMUMMU_SYSCONFIG_IDLE_MODE_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;			\
 	register u32 data = __raw_readl((baseAddress) + offset);	\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32);	\
-	data &= ~(MMU_MMU_SYSCONFIG_IdleMode_MASK);			\
-	newValue <<= MMU_MMU_SYSCONFIG_IdleMode_OFFSET;			\
-	newValue &= MMU_MMU_SYSCONFIG_IdleMode_MASK;			\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_IDLE_MODE_WRITE32);	\
+	data &= ~(MMU_MMU_SYSCONFIG_IDLE_MODE_MASK);			\
+	newValue <<= MMU_MMU_SYSCONFIG_IDLE_MODE_OFFSET;			\
+	newValue &= MMU_MMU_SYSCONFIG_IDLE_MODE_MASK;			\
 	newValue |= data;						\
 	__raw_writel(newValue, baseAddress + offset);			\
 } while (0)
 
-#define MMUMMU_SYSCONFIGAutoIdleWrite32(baseAddress, value)		\
+#define MMUMMU_SYSCONFIG_AUTO_IDLE_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;			\
 	register u32 data = __raw_readl((baseAddress) + offset);	\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32);	\
-	data &= ~(MMU_MMU_SYSCONFIG_AutoIdle_MASK);			\
-	newValue <<= MMU_MMU_SYSCONFIG_AutoIdle_OFFSET;			\
-	newValue &= MMU_MMU_SYSCONFIG_AutoIdle_MASK;			\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_AUTO_IDLE_WRITE32);	\
+	data &= ~(MMU_MMU_SYSCONFIG_AUTO_IDLE_MASK);			\
+	newValue <<= MMU_MMU_SYSCONFIG_AUTO_IDLE_OFFSET;			\
+	newValue &= MMU_MMU_SYSCONFIG_AUTO_IDLE_MASK;			\
 	newValue |= data;						\
 	__raw_writel(newValue, baseAddress + offset);			\
 } while (0)
 
-#define MMUMMU_IRQSTATUSReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSReadRegister32),	\
+#define MMUMMU_IRQSTATUS_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQSTATUSReadRegister32),	\
 	__raw_readl((baseAddress) + MMU_MMU_IRQSTATUS_OFFSET))
 
-#define MMUMMU_IRQSTATUSWriteRegister32(baseAddress, value)		\
+#define MMUMMU_IRQSTATUS_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = MMU_MMU_IRQSTATUS_OFFSET;			\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSWriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQSTATUS_WRITE_REGISTER32);	\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define MMUMMU_IRQENABLEReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEReadRegister32),	\
+#define MMUMMU_IRQENABLE_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQENABLE_READ_REGISTER32),	\
 	__raw_readl((baseAddress) + MMU_MMU_IRQENABLE_OFFSET))
 
-#define MMUMMU_IRQENABLEWriteRegister32(baseAddress, value)		\
+#define MMUMMU_IRQENABLE_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = MMU_MMU_IRQENABLE_OFFSET;			\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEWriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQENABLE_WRITE_REGISTER32);	\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define MMUMMU_WALKING_STTWLRunningRead32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_WALKING_STTWLRunningRead32),	\
+#define MMUMMU_WALKING_STTWL_RUNNING_READ32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_WALKING_STTWL_RUNNING_READ32),	\
 	(((__raw_readl(((baseAddress) + (MMU_MMU_WALKING_ST_OFFSET))))	\
-	& MMU_MMU_WALKING_ST_TWLRunning_MASK) >>			\
-	MMU_MMU_WALKING_ST_TWLRunning_OFFSET))
+	& MMU_MMU_WALKING_ST_TWL_RUNNING_MASK) >>			\
+	MMU_MMU_WALKING_ST_TWL_RUNNING_OFFSET))
 
-#define MMUMMU_CNTLTWLEnableRead32(baseAddress)				\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableRead32),	\
+#define MMUMMU_CNTLTWL_ENABLE_READ32(baseAddress)				\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLTWL_ENABLE_READ32),	\
 	(((__raw_readl(((baseAddress)+(MMU_MMU_CNTL_OFFSET)))) &	\
-	MMU_MMU_CNTL_TWLEnable_MASK) >>					\
-	MMU_MMU_CNTL_TWLEnable_OFFSET))
+	MMU_MMU_CNTL_TWL_ENABLE_MASK) >>					\
+	MMU_MMU_CNTL_TWL_ENABLE_OFFSET))
 
-#define MMUMMU_CNTLTWLEnableWrite32(baseAddress, value)			\
+#define MMUMMU_CNTLTWL_ENABLE_WRITE32(baseAddress, value)			\
 do {									\
 	const u32 offset = MMU_MMU_CNTL_OFFSET;				\
 	register u32 data = __raw_readl((baseAddress) + offset);	\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableWrite32);	\
-	data &= ~(MMU_MMU_CNTL_TWLEnable_MASK);				\
-	newValue <<= MMU_MMU_CNTL_TWLEnable_OFFSET;			\
-	newValue &= MMU_MMU_CNTL_TWLEnable_MASK;			\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLTWL_ENABLE_WRITE32);	\
+	data &= ~(MMU_MMU_CNTL_TWL_ENABLE_MASK);				\
+	newValue <<= MMU_MMU_CNTL_TWL_ENABLE_OFFSET;			\
+	newValue &= MMU_MMU_CNTL_TWL_ENABLE_MASK;			\
 	newValue |= data;						\
 	__raw_writel(newValue, baseAddress+offset);			\
 } while (0)
 
-#define MMUMMU_CNTLMMUEnableWrite32(baseAddress, value)			\
+#define MMUMMU_CNTLMMU_ENABLE_WRITE32(baseAddress, value)			\
 do {									\
 	const u32 offset = MMU_MMU_CNTL_OFFSET;				\
 	register u32 data = __raw_readl((baseAddress) + offset);	\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLMMUEnableWrite32);	\
-	data &= ~(MMU_MMU_CNTL_MMUEnable_MASK);				\
-	newValue <<= MMU_MMU_CNTL_MMUEnable_OFFSET;			\
-	newValue &= MMU_MMU_CNTL_MMUEnable_MASK;			\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLMMU_ENABLE_WRITE32);	\
+	data &= ~(MMU_MMU_CNTL_MMU_ENABLE_MASK);				\
+	newValue <<= MMU_MMU_CNTL_MMU_ENABLE_OFFSET;			\
+	newValue &= MMU_MMU_CNTL_MMU_ENABLE_MASK;			\
 	newValue |= data;						\
 	__raw_writel(newValue, baseAddress + offset);			\
 } while (0)
 
-#define MMUMMU_FAULT_ADReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FAULT_ADReadRegister32),	\
+#define MMUMMU_FAULT_AD_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_FAULT_AD_READ_REGISTER32),	\
 	__raw_readl((baseAddress) + MMU_MMU_FAULT_AD_OFFSET))
 
-#define MMUMMU_TTBWriteRegister32(baseAddress, value)			\
+#define MMUMMU_TTB_WRITE_REGISTER32(baseAddress, value)			\
 do {									\
 	const u32 offset = MMU_MMU_TTB_OFFSET;				\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_TTBWriteRegister32);		\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_TTB_WRITE_REGISTER32);		\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define MMUMMU_LOCKReadRegister32(baseAddress)				\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKReadRegister32),		\
+#define MMUMMU_LOCK_READ_REGISTER32(baseAddress)				\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_READ_REGISTER32),		\
 	__raw_readl((baseAddress) + MMU_MMU_LOCK_OFFSET))
 
-#define MMUMMU_LOCKWriteRegister32(baseAddress, value)			\
+#define MMUMMU_LOCK_WRITE_REGISTER32(baseAddress, value)			\
 do {									\
 	const u32 offset = MMU_MMU_LOCK_OFFSET;				\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKWriteRegister32);		\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_WRITE_REGISTER32);		\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define MMUMMU_LOCKBaseValueRead32(baseAddress)				\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueRead32),	\
+#define MMUMMU_LOCK_BASE_VALUE_READ32(baseAddress)				\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_BASE_VALUE_READ32),	\
 	(((__raw_readl(((baseAddress) + (MMU_MMU_LOCK_OFFSET)))) &	\
-	MMU_MMU_LOCK_BaseValue_MASK) >>	MMU_MMU_LOCK_BaseValue_OFFSET))	\
+	MMU_MMU_LOCK_BASE_VALUE_MASK) >>	MMU_MMU_LOCK_BASE_VALUE_OFFSET))	\
 
-#define MMUMMU_LOCKBaseValueWrite32(baseAddress, value)			\
+#define MMUMMU_LOCK_BASE_VALUE_WRITE32(baseAddress, value)			\
 do {									\
 	const u32 offset = MMU_MMU_LOCK_OFFSET;				\
 	register u32 data = __raw_readl((baseAddress) + offset);	\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueWrite32);	\
-	data &= ~(MMU_MMU_LOCK_BaseValue_MASK);				\
-	newValue <<= MMU_MMU_LOCK_BaseValue_OFFSET;			\
-	newValue &= MMU_MMU_LOCK_BaseValue_MASK;			\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCKBaseValueWrite32);	\
+	data &= ~(MMU_MMU_LOCK_BASE_VALUE_MASK);				\
+	newValue <<= MMU_MMU_LOCK_BASE_VALUE_OFFSET;			\
+	newValue &= MMU_MMU_LOCK_BASE_VALUE_MASK;			\
 	newValue |= data;						\
 	__raw_writel(newValue, baseAddress+offset);			\
 } while (0)
 
-#define MMUMMU_LOCKCurrentVictimRead32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimRead32),	\
+#define MMUMMU_LOCK_CURRENT_VICTIM_READ32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_READ32),	\
 	(((__raw_readl(((baseAddress) + (MMU_MMU_LOCK_OFFSET)))) &	\
-	MMU_MMU_LOCK_CurrentVictim_MASK) >>				\
-	MMU_MMU_LOCK_CurrentVictim_OFFSET))
+	MMU_MMU_LOCK_CURRENT_VICTIM_MASK) >>				\
+	MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET))
 
-#define MMUMMU_LOCKCurrentVictimWrite32(baseAddress, value)		\
+#define MMUMMU_LOCK_CURRENT_VICTIM_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = MMU_MMU_LOCK_OFFSET;				\
 	register u32 data = __raw_readl((baseAddress) + offset);	\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimWrite32);	\
-	data &= ~(MMU_MMU_LOCK_CurrentVictim_MASK);			\
-	newValue <<= MMU_MMU_LOCK_CurrentVictim_OFFSET;			\
-	newValue &= MMU_MMU_LOCK_CurrentVictim_MASK;			\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_WRITE32);	\
+	data &= ~(MMU_MMU_LOCK_CURRENT_VICTIM_MASK);			\
+	newValue <<= MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET;			\
+	newValue &= MMU_MMU_LOCK_CURRENT_VICTIM_MASK;			\
 	newValue |= data;						\
 	__raw_writel(newValue, baseAddress + offset);			\
 } while (0)
 
-#define MMUMMU_LOCKCurrentVictimSet32(var, value)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimSet32),	\
-	(((var) & ~(MMU_MMU_LOCK_CurrentVictim_MASK)) |			\
-	(((value) << MMU_MMU_LOCK_CurrentVictim_OFFSET) &		\
-	MMU_MMU_LOCK_CurrentVictim_MASK)))
+#define MMUMMU_LOCK_CURRENT_VICTIM_SET32(var, value)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_SET32),	\
+	(((var) & ~(MMU_MMU_LOCK_CURRENT_VICTIM_MASK)) |			\
+	(((value) << MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET) &		\
+	MMU_MMU_LOCK_CURRENT_VICTIM_MASK)))
 
-#define MMUMMU_LD_TLBReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBReadRegister32),	\
+#define MMUMMU_LD_TLB_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LD_TLB_READ_REGISTER32),	\
 	__raw_readl((baseAddress) + MMU_MMU_LD_TLB_OFFSET))
 
-#define MMUMMU_LD_TLBWriteRegister32(baseAddress, value)		\
+#define MMUMMU_LD_TLB_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = MMU_MMU_LD_TLB_OFFSET;			\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBWriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LD_TLB_WRITE_REGISTER32);	\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define MMUMMU_CAMWriteRegister32(baseAddress, value)			\
+#define MMUMMU_CAM_WRITE_REGISTER32(baseAddress, value)			\
 do {									\
 	const u32 offset = MMU_MMU_CAM_OFFSET;				\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CAMWriteRegister32);		\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CAM_WRITE_REGISTER32);		\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define MMUMMU_RAMWriteRegister32(baseAddress, value)			\
+#define MMUMMU_RAM_WRITE_REGISTER32(baseAddress, value)			\
 do {									\
 	const u32 offset = MMU_MMU_RAM_OFFSET;				\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_RAMWriteRegister32);		\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_RAM_WRITE_REGISTER32);		\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define MMUMMU_FLUSH_ENTRYWriteRegister32(baseAddress, value)		\
+#define MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = MMU_MMU_FLUSH_ENTRY_OFFSET;			\
 	register u32 newValue = (value);				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32);	\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#endif	/* USE_LEVEL_1_MACROS */
+#endif /* USE_LEVEL_1_MACROS */
 
 #endif /* _MMU_REG_ACM_H */
diff --git a/drivers/dsp/bridge/hw/PRCMAccInt.h b/drivers/dsp/bridge/hw/PRCMAccInt.h
index 5a11f01..7a513b0 100644
--- a/drivers/dsp/bridge/hw/PRCMAccInt.h
+++ b/drivers/dsp/bridge/hw/PRCMAccInt.h
@@ -19,91 +19,97 @@
 
 /* Mappings of level 1 EASI function numbers to function names */
 
-#define EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32  \
+#define EASIL1_PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32  \
 						(PRCM_BASE_EASIL1 + 349)
-#define EASIL1_PRCMCM_FCLKEN1_COREReadRegister32	(PRCM_BASE_EASIL1 + 743)
-#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32	(PRCM_BASE_EASIL1 + 951)
-#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32	(PRCM_BASE_EASIL1 + 961)
-#define EASIL1_PRCMCM_ICLKEN1_COREReadRegister32	\
+#define EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32	(PRCM_BASE_EASIL1 + 743)
+#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32	(PRCM_BASE_EASIL1 + 951)
+#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32	(PRCM_BASE_EASIL1 + 961)
+#define EASIL1_PRCMCM_ICLKEN1_CORE_READ_REGISTER32	\
 						(PRCM_BASE_EASIL1 + 1087)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32	\
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXES_WRITE32	\
 						(PRCM_BASE_EASIL1 + 1105)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32	\
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32	\
 						(PRCM_BASE_EASIL1 + 1305)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32	\
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32	\
 						(PRCM_BASE_EASIL1 + 1315)
-#define EASIL1_PRCMCM_CLKSEL1_CORECLKSEL_L3ReadIssel132	\
+#define EASIL1_PRCMCM_CLKSEL1_CORECLKSEL_L3_READ_ISSEL132	\
 						(PRCM_BASE_EASIL1 + 2261)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32	\
 						(PRCM_BASE_EASIL1 + 2364)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32	\
 						(PRCM_BASE_EASIL1 + 2365)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32	\
 						(PRCM_BASE_EASIL1 + 2366)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32	\
 						(PRCM_BASE_EASIL1 + 2380)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32	\
 						(PRCM_BASE_EASIL1 + 2381)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32	\
 						(PRCM_BASE_EASIL1 + 2382)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32	\
 						(PRCM_BASE_EASIL1 + 2397)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32	\
 						(PRCM_BASE_EASIL1 + 2398)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32	\
 						(PRCM_BASE_EASIL1 + 2413)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32	\
 						(PRCM_BASE_EASIL1 + 2414)
-#define EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32	\
+#define EASIL1_PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32	\
 						(PRCM_BASE_EASIL1 + 3747)
-#define EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32	(PRCM_BASE_EASIL1 + 3834)
-#define EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32	\
+#define EASIL1_PRCMCM_FCLKEN_DSPEN_DSP_WRITE32	(PRCM_BASE_EASIL1 + 3834)
+#define EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3846)
-#define EASIL1_PRCMCM_IDLEST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 3850)
-#define EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32	(PRCM_BASE_EASIL1 + 3857)
-#define EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32	(PRCM_BASE_EASIL1 + 3863)
-#define EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32	\
+#define EASIL1_PRCMCM_IDLEST_DSP_READ_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 3850)
+#define EASIL1_PRCMCM_IDLEST_DSPST_IPI_READ32	(PRCM_BASE_EASIL1 + 3857)
+#define EASIL1_PRCMCM_IDLEST_DSPST_DSP_READ32	(PRCM_BASE_EASIL1 + 3863)
+#define EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3877)
-#define EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32	(PRCM_BASE_EASIL1 + 3927)
-#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32	\
+#define EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32	\
+						(PRCM_BASE_EASIL1 + 3927)
+#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3941)
-#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32	\
+#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3965)
-#define EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32	\
+#define EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32	\
 						(PRCM_BASE_EASIL1 + 3987)
-#define EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32	\
+#define EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3993)
-#define EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32	(PRCM_BASE_EASIL1 + 3997)
-#define EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32	\
+#define EASIL1_PRCMRM_RSTCTRL_DSP_READ_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 3997)
+#define EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32	\
 						(PRCM_BASE_EASIL1 + 4025)
-#define EASIL1_PRCMRM_RSTST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 4029)
-#define EASIL1_PRCMRM_RSTST_DSPWriteRegister32	(PRCM_BASE_EASIL1 + 4030)
-#define EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32	\
+#define EASIL1_PRCMRM_RSTST_DSP_READ_REGISTER32	(PRCM_BASE_EASIL1 + 4029)
+#define EASIL1_PRCMRM_RSTST_DSP_WRITE_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 4030)
+#define EASIL1_PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32	\
 						(PRCM_BASE_EASIL1 + 4165)
-#define EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32	\
+#define EASIL1_PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32	\
 						(PRCM_BASE_EASIL1 + 4193)
-#define EASIL1_PRCMPM_PWSTST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 4197)
-#define EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32	\
+#define EASIL1_PRCMPM_PWSTST_DSP_READ_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 4197)
+#define EASIL1_PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32	\
 						(PRCM_BASE_EASIL1 + 4198)
-#define EASIL1_PRCMPM_PWSTST_DSPPowerStateStGet32	\
+#define EASIL1_PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32	\
 						(PRCM_BASE_EASIL1 + 4235)
-#define EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32	\
+#define EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32	\
 						(PRCM_BASE_EASIL1 + 4368)
-#define EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32	\
+#define EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32	\
 						(PRCM_BASE_EASIL1 + 4370)
-#define EASIL1_CM_CLKSEL_PER_GPT5Write32k32	(PRCM_BASE_EASIL1 + 4372)
-#define EASIL1_CM_CLKSEL_PER_GPT6Write32k32	(PRCM_BASE_EASIL1 + 4373)
-#define EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32	\
+#define EASIL1_CM_CLKSEL_PER_GPT5_WRITE32K32	(PRCM_BASE_EASIL1 + 4372)
+#define EASIL1_CM_CLKSEL_PER_GPT6_WRITE32K32	(PRCM_BASE_EASIL1 + 4373)
+#define EASIL1_PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32	\
 						(PRCM_BASE_EASIL1 + 4374)
-#define EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32	\
+#define EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32	\
 						(PRCM_BASE_EASIL1 + 4375)
-#define EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32	\
+#define EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32	\
 						(PRCM_BASE_EASIL1 + 4376)
-#define EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32	\
+#define EASIL1_PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32	\
 						(PRCM_BASE_EASIL1 + 4377)
-#define EASIL1_PRCMPM_PWSTST_IVA2PowerStateStGet32	\
+#define EASIL1_PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32	\
 						(PRCM_BASE_EASIL1 + 4378)
-#define EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32	(PRCM_BASE_EASIL1 + 4379)
+#define EASIL1_PRCMPM_PWSTST_IVA2_READ_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 4379)
 
 /* Register offset address definitions */
 
@@ -128,8 +134,8 @@
 
 /* Bitfield mask and offset declarations */
 
-#define PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK         (u32)(0x1)
-#define PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET       (u32)(0)
+#define PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_MASK         (u32)(0x1)
+#define PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_OFFSET       (u32)(0)
 
 #define PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK               (u32)(0x400)
 #define PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET             (u32)(10)
@@ -155,8 +161,8 @@
 #define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK           (u32)(0x300)
 #define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET         (u32)(8)
 
-#define PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK            (u32)(0x3800000)
-#define PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET          (u32)(23)
+#define PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_MASK            (u32)(0x3800000)
+#define PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_OFFSET          (u32)(23)
 
 #define PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK              (u32)(0x2)
 #define PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET            (u32)(1)
@@ -176,29 +182,29 @@
 #define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK              (u32)(0x1f)
 #define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET            (u32)(0)
 
-#define PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK        (u32)(0x1)
-#define PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET      (u32)(0)
+#define PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK        (u32)(0x1)
+#define PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET      (u32)(0)
 
-#define PRCM_PM_PWSTCTRL_DSP_ForceState_MASK            (u32)(0x40000)
-#define PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET          (u32)(18)
+#define PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK            (u32)(0x40000)
+#define PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_OFFSET          (u32)(18)
 
-#define PRCM_PM_PWSTCTRL_DSP_PowerState_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET          (u32)(0)
+#define PRCM_PM_PWSTCTRL_DSP_POWER_STATE_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTCTRL_DSP_POWER_STATE_OFFSET          (u32)(0)
 
-#define PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET          (u32)(0)
+#define PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET          (u32)(0)
 
-#define PRCM_PM_PWSTST_DSP_InTransition_MASK            (u32)(0x100000)
-#define PRCM_PM_PWSTST_DSP_InTransition_OFFSET          (u32)(20)
+#define PRCM_PM_PWSTST_DSP_IN_TRANSITION_MASK            (u32)(0x100000)
+#define PRCM_PM_PWSTST_DSP_IN_TRANSITION_OFFSET          (u32)(20)
 
-#define PRCM_PM_PWSTST_IVA2_InTransition_MASK            (u32)(0x100000)
-#define PRCM_PM_PWSTST_IVA2_InTransition_OFFSET          (u32)(20)
+#define PRCM_PM_PWSTST_IVA2_IN_TRANSITION_MASK            (u32)(0x100000)
+#define PRCM_PM_PWSTST_IVA2_IN_TRANSITION_OFFSET          (u32)(20)
 
-#define PRCM_PM_PWSTST_DSP_PowerStateSt_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTST_DSP_PowerStateSt_OFFSET          (u32)(0)
+#define PRCM_PM_PWSTST_DSP_POWER_STATE_ST_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTST_DSP_POWER_STATE_ST_OFFSET          (u32)(0)
 
-#define PRCM_PM_PWSTST_IVA2_PowerStateSt_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTST_IVA2_PowerStateSt_OFFSET          (u32)(0)
+#define PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_OFFSET          (u32)(0)
 
 #define CM_FCLKEN_PER_OFFSET		(u32)(0x0)
 #define CM_FCLKEN_PER_GPT5_OFFSET         (u32)(6)
@@ -220,7 +226,6 @@
 #define CM_CLKSEL_PER_GPT6_OFFSET   (u32)(4)
 #define CM_CLKSEL_PER_GPT6_MASK       (u32)(0x10)
 
-
 #define CM_FCLKEN_IVA2_OFFSET		(u32)(0x0)
 #define CM_FCLKEN_IVA2_EN_MASK	(u32)(0x1)
 #define CM_FCLKEN_IVA2_EN_OFFSET	(u32)(0x0)
@@ -232,13 +237,12 @@
 #define CM_FCLKEN1_CORE_OFFSET 	(u32)(0xA00)
 
 #define CM_ICLKEN1_CORE_OFFSET  	(u32)(0xA10)
-#define CM_ICLKEN1_CORE_EN_MAILBOXES_MASK  (u32)(0x00000080)   /* bit 7 */
+#define CM_ICLKEN1_CORE_EN_MAILBOXES_MASK  (u32)(0x00000080)	/* bit 7 */
 #define CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET	(u32)(7)
 
 #define CM_CLKSTCTRL_IVA2_OFFSET (u32)(0x0)
 #define CM_CLKSTCTRL_IVA2_MASK    (u32)(0x3)
 
-
 #define PRM_RSTCTRL_IVA2_OFFSET  	(u32)(0x50)
 #define PRM_RSTCTRL_IVA2_RST1_MASK	(u32)(0x1)
 #define PRM_RSTCTRL_IVA2_RST1_OFFSET	(u32)(0x0)
@@ -247,54 +251,53 @@
 #define PRM_RSTCTRL_IVA2_RST3_MASK	(u32)(0x4)
 #define PRM_RSTCTRL_IVA2_RST3_OFFSET	(u32)(0x2)
 
-
 /* The following represent the enumerated values for each bitfield */
 
-enum PRCMPRCM_CLKCFG_CTRLValid_configE {
-    PRCMPRCM_CLKCFG_CTRLValid_configUpdated = 0x0000,
-    PRCMPRCM_CLKCFG_CTRLValid_configClk_valid = 0x0001
-} ;
-
-enum PRCMCM_CLKSEL2_CORECLKSEL_GPT8E {
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT832k = 0x0000,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys = 0x0001,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext = 0x0002,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Reserved = 0x0003
-} ;
-
-enum PRCMCM_CLKSEL2_CORECLKSEL_GPT7E {
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT732k = 0x0000,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys = 0x0001,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext = 0x0002,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Reserved = 0x0003
-} ;
-
-enum PRCMCM_CLKSEL2_CORECLKSEL_GPT6E {
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT632k = 0x0000,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys = 0x0001,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext = 0x0002,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Reserved = 0x0003
-} ;
-
-enum PRCMCM_CLKSEL2_CORECLKSEL_GPT5E {
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT532k = 0x0000,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys = 0x0001,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext = 0x0002,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Reserved = 0x0003
-} ;
-
-enum PRCMPM_PWSTCTRL_DSPPowerStateE {
-    PRCMPM_PWSTCTRL_DSPPowerStateON = 0x0000,
-    PRCMPM_PWSTCTRL_DSPPowerStateRET = 0x0001,
-    PRCMPM_PWSTCTRL_DSPPowerStateReserved = 0x0002,
-    PRCMPM_PWSTCTRL_DSPPowerStateOFF = 0x0003
-} ;
-
-enum PRCMPM_PWSTCTRL_IVA2PowerStateE {
-    PRCMPM_PWSTCTRL_IVA2PowerStateON = 0x0003,
-    PRCMPM_PWSTCTRL_IVA2PowerStateRET = 0x0001,
-    PRCMPM_PWSTCTRL_IVA2PowerStateReserved = 0x0002,
-    PRCMPM_PWSTCTRL_IVA2PowerStateOFF = 0x0000
-} ;
+enum prcmprcm_clkcfg_ctrl_valid_config_e {
+	PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_UPDATED = 0x0000,
+	PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_CLK_VALID = 0x0001
+};
+
+enum prcmcm_clksel2_coreclksel_gpt8e {
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT832K = 0x0000,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_SYS = 0x0001,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_EXT = 0x0002,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_RESERVED = 0x0003
+};
+
+enum prcmcm_clksel2_coreclksel_gpt7e {
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT732K = 0x0000,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_SYS = 0x0001,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_EXT = 0x0002,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_RESERVED = 0x0003
+};
+
+enum prcmcm_clksel2_coreclksel_gpt6e {
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT632K = 0x0000,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_SYS = 0x0001,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_EXT = 0x0002,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_RESERVED = 0x0003
+};
+
+enum prcmcm_clksel2_coreclksel_gpt5e {
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT532K = 0x0000,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_SYS = 0x0001,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_EXT = 0x0002,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_RESERVED = 0x0003
+};
+
+enum prcmpm_pwstctrl_dsp_power_state_e {
+	PRCMPM_PWSTCTRL_DSP_POWER_STATE_ON = 0x0000,
+	PRCMPM_PWSTCTRL_DSP_POWER_STATE_RET = 0x0001,
+	PRCMPM_PWSTCTRL_DSP_POWER_STATE_RESERVED = 0x0002,
+	PRCMPM_PWSTCTRL_DSP_POWER_STATE_OFF = 0x0003
+};
+
+enum prcmpm_pwstctrl_iva2_power_state_e {
+	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_ON = 0x0003,
+	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_RET = 0x0001,
+	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_RESERVED = 0x0002,
+	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_OFF = 0x0000
+};
 
 #endif /* _PRCM_ACC_INT_H */
diff --git a/drivers/dsp/bridge/hw/PRCMRegAcM.h b/drivers/dsp/bridge/hw/PRCMRegAcM.h
index 080a998..fe7b6cd 100644
--- a/drivers/dsp/bridge/hw/PRCMRegAcM.h
+++ b/drivers/dsp/bridge/hw/PRCMRegAcM.h
@@ -26,33 +26,33 @@
 
 #if defined(USE_LEVEL_1_MACROS)
 
-#define PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32(baseAddress)	       \
+#define PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32(baseAddress)	       \
 do {									       \
 	const u32 offset = PRCM_PRCM_CLKCFG_CTRL_OFFSET;		       \
-	const u32 newValue = (u32)PRCMPRCM_CLKCFG_CTRLValid_configClk_valid << \
-			PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET;	       \
+	const u32 newValue = (u32)PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_CLK_VALID << \
+			PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_OFFSET;	       \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(						       \
-		EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32);      \
-	data &= ~(PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK);		       \
+	_DEBUG_LEVEL1_EASI(						       \
+		EASIL1_PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32);      \
+	data &= ~(PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define CM_FCLKEN_PERReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),	\
+#define CM_FCLKEN_PER_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),	\
 	__raw_readl(((u32)(baseAddress)) + CM_FCLKEN_PER_OFFSET))
 
-#define CM_ICLKEN_PERReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),	\
+#define CM_ICLKEN_PER_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),	\
 	__raw_readl(((u32)(baseAddress)) + CM_ICLKEN_PER_OFFSET))
 
-#define CM_FCLKEN_PER_GPT5WriteRegister32(baseAddress, value)		\
+#define CM_FCLKEN_PER_GPT5_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = CM_FCLKEN_PER_OFFSET;			\
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32);	\
 	data &= ~(CM_FCLKEN_PER_GPT5_MASK);				\
 	newValue <<= CM_FCLKEN_PER_GPT5_OFFSET;				\
 	newValue &= CM_FCLKEN_PER_GPT5_MASK;				\
@@ -60,12 +60,12 @@ do {									\
 	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
 } while (0)
 
-#define CM_FCLKEN_PER_GPT6WriteRegister32(baseAddress, value)		\
+#define CM_FCLKEN_PER_GPT6_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = CM_FCLKEN_PER_OFFSET;			\
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32);	\
 	data &= ~(CM_FCLKEN_PER_GPT6_MASK);				\
 	newValue <<= CM_FCLKEN_PER_GPT6_OFFSET;				\
 	newValue &= CM_FCLKEN_PER_GPT6_MASK;				\
@@ -73,12 +73,12 @@ do {									\
 	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
 } while (0)
 
-#define CM_ICLKEN_PER_GPT5WriteRegister32(baseAddress, value)		\
+#define CM_ICLKEN_PER_GPT5_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = CM_ICLKEN_PER_OFFSET;			\
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32);	\
 	data &= ~(CM_ICLKEN_PER_GPT5_MASK);				\
 	newValue <<= CM_ICLKEN_PER_GPT5_OFFSET;				\
 	newValue &= CM_ICLKEN_PER_GPT5_MASK;				\
@@ -86,12 +86,12 @@ do {									\
 	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
 } while (0)
 
-#define CM_ICLKEN_PER_GPT6WriteRegister32(baseAddress, value)		\
+#define CM_ICLKEN_PER_GPT6_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = CM_ICLKEN_PER_OFFSET;			\
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32);	\
 	data &= ~(CM_ICLKEN_PER_GPT6_MASK);				\
 	newValue <<= CM_ICLKEN_PER_GPT6_OFFSET;				\
 	newValue &= CM_ICLKEN_PER_GPT6_MASK;				\
@@ -99,17 +99,16 @@ do {									\
 	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
 } while (0)
 
-#define CM_FCLKEN1_COREReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),	\
+#define CM_FCLKEN1_CORE_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),	\
 	__raw_readl(((u32)(baseAddress)) + CM_FCLKEN1_CORE_OFFSET))
 
-
-#define PRCMCM_FCLKEN1_COREEN_GPT8Write32(baseAddress, value)		\
+#define PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;			\
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32);	\
 	data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK);			\
 	newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET;		\
 	newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK;			\
@@ -117,12 +116,12 @@ do {									\
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		\
 } while (0)
 
-#define PRCMCM_FCLKEN1_COREEN_GPT7Write32(baseAddress, value)		\
+#define PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;			\
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32);	\
 	data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK);			\
 	newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET;		\
 	newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK;			\
@@ -130,17 +129,17 @@ do {									\
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		\
 } while (0)
 
-#define CM_ICLKEN1_COREReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREReadRegister32),	\
+#define CM_ICLKEN1_CORE_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_CORE_READ_REGISTER32),	\
 	__raw_readl(((u32)(baseAddress)) + CM_ICLKEN1_CORE_OFFSET))
 
-#define CM_ICLKEN1_COREEN_MAILBOXESWrite32(baseAddress, value)		    \
+#define CM_ICLKEN1_COREEN_MAILBOXES_WRITE32(baseAddress, value)		    \
 do {									    \
 	const u32 offset = CM_ICLKEN1_CORE_OFFSET;			    \
 	register u32 data = 						    \
 	__raw_readl(((u32)(baseAddress)) + offset);			    \
 	register u32 newValue = ((u32)(value));				    \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXES_WRITE32); \
 	data &= ~(CM_ICLKEN1_CORE_EN_MAILBOXES_MASK);			    \
 	newValue <<= CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET;		    \
 	newValue &= CM_ICLKEN1_CORE_EN_MAILBOXES_MASK;			    \
@@ -148,12 +147,12 @@ do {									    \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		    \
 } while (0)
 
-#define PRCMCM_ICLKEN1_COREEN_GPT8Write32(baseAddress, value)		\
+#define PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;			\
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32);	\
 	data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK);			\
 	newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET;		\
 	newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK;			\
@@ -161,12 +160,12 @@ do {									\
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		\
 } while (0)
 
-#define PRCMCM_ICLKEN1_COREEN_GPT7Write32(baseAddress, value)		\
+#define PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;			\
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32);	\
 	data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK);			\
 	newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET;		\
 	newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK;			\
@@ -174,164 +173,163 @@ do {									\
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		\
 } while (0)
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32(baseAddress)		      \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32(baseAddress)		      \
 do {									      \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832k <<	      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832K <<	      \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;		      \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32); \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);		      \
 	data |= newValue;						      \
 	__raw_writel(data, (u32)(baseAddress) + offset);		      \
 } while (0)
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32(baseAddress)		      \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32(baseAddress)		      \
 do {									      \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys <<	      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8_SYS <<	      \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;		      \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32); \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);		      \
 	data |= newValue;						      \
 	__raw_writel(data, (u32)(baseAddress) + offset);		      \
 } while (0)
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32(baseAddress)		      \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32(baseAddress)		      \
 do {									      \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext <<	      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8_EXT <<	      \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;		      \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32); \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);		      \
 	data |= newValue;						      \
 	__raw_writel(data, (u32)(baseAddress) + offset);		      \
 } while (0)
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32(baseAddress)		      \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32(baseAddress)		      \
 do {									      \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732k <<	      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732K <<	      \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;		      \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32); \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);		      \
 	data |= newValue;						      \
 	__raw_writel(data, (u32)(baseAddress) + offset);		      \
 } while (0)
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32(baseAddress)		      \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32(baseAddress)		      \
 do {									      \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys <<	      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7_SYS <<	      \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;		      \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32); \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32); \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);		      \
 	data |= newValue;						      \
 	__raw_writel(data, (u32)(baseAddress) + offset);		      \
 } while (0)
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32(baseAddress)		       \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32(baseAddress)		       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext <<	       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7_EXT <<	       \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;		       \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32);  \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32);  \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32(baseAddress)		       \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32(baseAddress)		       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys <<	       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6_SYS <<	       \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;		       \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32);  \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32);  \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32(baseAddress)		       \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32(baseAddress)		       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext <<	       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6_EXT <<	       \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;		       \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32);  \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32);  \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define CM_CLKSEL_PER_GPT5Write32k32(baseAddress)			       \
+#define CM_CLKSEL_PER_GPT5_WRITE32K32(baseAddress)			       \
 do {									       \
 	const u32 offset = CM_CLKSEL_PER_OFFSET;			       \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<	       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532K <<	       \
 		CM_CLKSEL_PER_GPT5_OFFSET;				       \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT5Write32k32);	       \
+	_DEBUG_LEVEL1_EASI(EASIL1_CM_CLKSEL_PER_GPT5_WRITE32K32);	       \
 	data &= ~(CM_CLKSEL_PER_GPT5_MASK);				       \
 	data |= newValue;						       \
 	__raw_writel(data, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define CM_CLKSEL_PER_GPT6Write32k32(baseAddress)			       \
+#define CM_CLKSEL_PER_GPT6_WRITE32K32(baseAddress)			       \
 do {									       \
 	const u32 offset = CM_CLKSEL_PER_OFFSET;			       \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<	       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532K <<	       \
 		CM_CLKSEL_PER_GPT6_OFFSET;				       \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT6Write32k32);	       \
+	_DEBUG_LEVEL1_EASI(EASIL1_CM_CLKSEL_PER_GPT6_WRITE32K32);	       \
 	data &= ~(CM_CLKSEL_PER_GPT6_MASK);				       \
 	data |= newValue;						       \
 	__raw_writel(data, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32(baseAddress)		       \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32(baseAddress)		       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys <<	       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5_SYS <<	       \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;		       \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32);  \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32);  \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (u32)(baseAddress) + offset);		       \
 } while (0);
 
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32(baseAddress)		       \
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32(baseAddress)		       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
-	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext <<	       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5_EXT <<	       \
 		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;		       \
 	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32);  \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32);  \
 	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32(baseAddress)		       \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32),      \
+#define PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32(baseAddress)		       \
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32),      \
 	(((__raw_readl((((u32)(baseAddress)) +				       \
 	(PRCM_CM_CLKSEL1_PLL_OFFSET)))) &				       \
-	PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK) >>			       \
-	PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET))
+	PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_MASK) >>			       \
+	PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_OFFSET))
 
-#define CM_FCLKEN_IVA2EN_DSPWrite32(baseAddress, value)			       \
+#define CM_FCLKEN_IVA2EN_DSP_WRITE32(baseAddress, value)			       \
 do {									       \
 	const u32 offset = CM_FCLKEN_IVA2_OFFSET;			       \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32);	       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSP_WRITE32);	       \
 	data &= ~(CM_FCLKEN_IVA2_EN_MASK);				       \
 	newValue <<= CM_FCLKEN_IVA2_EN_OFFSET;				       \
 	newValue &= CM_FCLKEN_IVA2_EN_MASK;				       \
@@ -339,12 +337,12 @@ do {									       \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32(baseAddress, value)		       \
+#define PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32(baseAddress, value)		       \
 do {									       \
 	const u32 offset = PRCM_CM_ICLKEN_DSP_OFFSET;			       \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32);	       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32);	       \
 	data &= ~(PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK);			       \
 	newValue <<= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET;		       \
 	newValue &= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK;			       \
@@ -352,30 +350,28 @@ do {									       \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMCM_IDLEST_DSPReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPReadRegister32),	\
+#define PRCMCM_IDLEST_DSP_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSP_READ_REGISTER32),	\
 	__raw_readl(((u32)(baseAddress)) + PRCM_CM_IDLEST_DSP_OFFSET))
 
-
-#define PRCMCM_IDLEST_DSPST_IPIRead32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32),	\
+#define PRCMCM_IDLEST_DSPST_IPI_READ32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPI_READ32),	\
 	(((__raw_readl((((u32)(baseAddress)) +				\
 	(PRCM_CM_IDLEST_DSP_OFFSET)))) &				\
 	PRCM_CM_IDLEST_DSP_ST_IPI_MASK) >>				\
 	PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET))
 
-
-#define PRM_IDLEST_IVA2ST_IVA2Read32(baseAddress)\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32),	       \
+#define PRM_IDLEST_IVA2ST_IVA2_READ32(baseAddress)\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSP_READ32),	       \
 	(((__raw_readl((((u32)(baseAddress)) + (CM_IDLEST_IVA2_OFFSET)))) &    \
 	CM_IDLEST_IVA2_ST_IVA2_MASK) >>	CM_IDLEST_IVA2_ST_IVA2_OFFSET))
 
-#define PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32(baseAddress, value)	       \
+#define PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32(baseAddress, value)	       \
 do {									       \
 	const u32 offset = PRCM_CM_AUTOIDLE_DSP_OFFSET;			       \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32);    \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32);    \
 	data &= ~(PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK);		       \
 	newValue <<= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET;		       \
 	newValue &= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK;		       \
@@ -383,13 +379,12 @@ do {									       \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-
-#define PRCMCM_CLKSEL_DSPSYNC_DSPWrite32(baseAddress, value)		       \
+#define PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32(baseAddress, value)		       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;			       \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32);	       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32);	       \
 	data &= ~(PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK);			       \
 	newValue <<= PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET;		       \
 	newValue &= PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK;			       \
@@ -397,13 +392,12 @@ do {									       \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-
-#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32(baseAddress, value)	       \
+#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32(baseAddress, value)	       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;			       \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32);     \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32);     \
 	data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK);		       \
 	newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET;		       \
 	newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK;		       \
@@ -411,12 +405,12 @@ do {									       \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32(baseAddress, value)		       \
+#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32(baseAddress, value)		       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;			       \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32);	       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32);	       \
 	data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK);			       \
 	newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET;		       \
 	newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK;			       \
@@ -424,12 +418,12 @@ do {									       \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMCM_CLKSTCTRL_IVA2WriteRegister32(baseAddress, value)	       \
+#define PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32(baseAddress, value)	       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSTCTRL_IVA2_OFFSET;		       \
 	register u32 data = __raw_readl(((baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32);      \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32);      \
 	data &= ~(CM_CLKSTCTRL_IVA2_MASK);				       \
 	newValue <<= CM_CLKSTCTRL_IVA2_OFFSET;				       \
 	newValue &= CM_CLKSTCTRL_IVA2_MASK;				       \
@@ -437,37 +431,36 @@ do {									       \
 	__raw_writel(newValue, (baseAddress) + offset);			       \
 } while (0)
 
-
-#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32(baseAddress)		       \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32),  \
+#define PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32(baseAddress)		       \
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32),  \
 	(((__raw_readl((((u32)(baseAddress)) +				       \
 	(PRCM_CM_CLKSTCTRL_DSP_OFFSET)))) &				       \
-	PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK) >>			       \
-	PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET))
+	PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK) >>			       \
+	PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET))
 
-#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32(baseAddress, value)	       \
+#define PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32(baseAddress, value)	       \
 do {									       \
 	const u32 offset = PRCM_CM_CLKSTCTRL_DSP_OFFSET;		       \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32);  \
-	data &= ~(PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK);		       \
-	newValue <<= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET;	       \
-	newValue &= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK;		       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32);  \
+	data &= ~(PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK);		       \
+	newValue <<= PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET;	       \
+	newValue &= PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK;		       \
 	newValue |= data;						       \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
 } while (0)
 
-#define PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32),	\
+#define PRCMRM_RSTCTRL_DSP_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSP_READ_REGISTER32),	\
 	__raw_readl(((baseAddress)) + PRCM_RM_RSTCTRL_DSP_OFFSET))
 
-#define PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress, value)		       \
+#define PRM_RSTCTRL_IVA2RST1_DSP_WRITE32(baseAddress, value)		       \
 do {									       \
 	const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;			       \
 	register u32 data = __raw_readl(((baseAddress)) + offset);	       \
 	register u32 newValue = ((u32)(value));				       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);	       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);	       \
 	data &= ~(PRM_RSTCTRL_IVA2_RST1_MASK);				       \
 	newValue <<= PRM_RSTCTRL_IVA2_RST1_OFFSET;			       \
 	newValue &= PRM_RSTCTRL_IVA2_RST1_MASK;				       \
@@ -475,12 +468,12 @@ do {									       \
 	__raw_writel(newValue, (baseAddress) + offset);			       \
 } while (0)
 
-#define PRM_RSTCTRL_IVA2RST2_DSPWrite32(baseAddress, value)		\
+#define PRM_RSTCTRL_IVA2RST2_DSP_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;			\
 	register u32 data = __raw_readl(((baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);	\
 	data &= ~(PRM_RSTCTRL_IVA2_RST2_MASK);				\
 	newValue <<= PRM_RSTCTRL_IVA2_RST2_OFFSET;			\
 	newValue &= PRM_RSTCTRL_IVA2_RST2_MASK;				\
@@ -488,12 +481,12 @@ do {									\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define PRM_RSTCTRL_IVA2RST3_DSPWrite32(baseAddress, value)		\
+#define PRM_RSTCTRL_IVA2RST3_DSP_WRITE32(baseAddress, value)		\
 do {									\
 	const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;			\
 	register u32 data = __raw_readl(((baseAddress)) + offset);	\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);	\
 	data &= ~(PRM_RSTCTRL_IVA2_RST3_MASK);				\
 	newValue <<= PRM_RSTCTRL_IVA2_RST3_OFFSET;			\
 	newValue &= PRM_RSTCTRL_IVA2_RST3_MASK;				\
@@ -501,101 +494,99 @@ do {									\
 	__raw_writel(newValue, (baseAddress) + offset);			\
 } while (0)
 
-#define PRCMRM_RSTST_DSPReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPReadRegister32),	\
+#define PRCMRM_RSTST_DSP_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTST_DSP_READ_REGISTER32),	\
 	__raw_readl(((baseAddress)) + PRCM_RM_RSTST_DSP_OFFSET))
 
-#define PRCMRM_RSTST_DSPWriteRegister32(baseAddress, value)		\
+#define PRCMRM_RSTST_DSP_WRITE_REGISTER32(baseAddress, value)		\
 do {									\
 	const u32 offset = PRCM_RM_RSTST_DSP_OFFSET;			\
 	register u32 newValue = ((u32)(value));				\
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPWriteRegister32);	\
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTST_DSP_WRITE_REGISTER32);	\
 	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
 } while (0)
 
-#define PRCMPM_PWSTCTRL_DSPForceStateWrite32(baseAddress, value)	  \
+#define PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32(baseAddress, value)	  \
 do {									  \
 	const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;			  \
 	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	  \
 	register u32 newValue = ((u32)(value));				  \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32); \
-	data &= ~(PRCM_PM_PWSTCTRL_DSP_ForceState_MASK);		  \
-	newValue <<= PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET;		  \
-	newValue &= PRCM_PM_PWSTCTRL_DSP_ForceState_MASK;		  \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32); \
+	data &= ~(PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK);		  \
+	newValue <<= PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_OFFSET;		  \
+	newValue &= PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK;		  \
 	newValue |= data;						  \
 	__raw_writel(newValue, (u32)(baseAddress) + offset);		  \
 } while (0)
 
-#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32(baseAddress)		       \
+#define PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32(baseAddress)		       \
 do {									       \
 	const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;		       \
-	const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateON <<	       \
-		PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;		       \
+	const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2_POWER_STATE_ON <<	       \
+		PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET;		       \
 	register u32 data = __raw_readl((baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32);   \
-	data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);		       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32);   \
+	data &= ~(PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (baseAddress) + offset);			       \
 } while (0)
 
-#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32(baseAddress)		       \
+#define PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32(baseAddress)		       \
 do {									       \
 	const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;		       \
-	const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateOFF <<	       \
-		PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;		       \
+	const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2_POWER_STATE_OFF <<	       \
+		PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET;		       \
 	register u32 data = __raw_readl((baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32);  \
-	data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);		       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32);  \
+	data &= ~(PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (baseAddress) + offset);			       \
 } while (0)
 
-#define PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32(baseAddress)		       \
+#define PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32(baseAddress)		       \
 do {									       \
 	const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;			       \
-	const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSPPowerStateRET <<	       \
-		PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET;			       \
+	const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSP_POWER_STATE_RET <<	       \
+		PRCM_PM_PWSTCTRL_DSP_POWER_STATE_OFFSET;			       \
 	register u32 data = __raw_readl((baseAddress) + offset);	       \
-	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32);   \
-	data &= ~(PRCM_PM_PWSTCTRL_DSP_PowerState_MASK);		       \
+	_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32);   \
+	data &= ~(PRCM_PM_PWSTCTRL_DSP_POWER_STATE_MASK);		       \
 	data |= newValue;						       \
 	__raw_writel(data, (baseAddress) + offset);			       \
 } while (0)
 
-#define PRCMPM_PWSTST_DSPReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPReadRegister32),	\
+#define PRCMPM_PWSTST_DSP_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_READ_REGISTER32),	\
 	__raw_readl(((u32)(baseAddress)) + PRCM_PM_PWSTST_DSP_OFFSET))
 
-
-#define PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress)			\
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32),	\
+#define PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress)			\
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_READ_REGISTER32),	\
 	__raw_readl((baseAddress) + PRCM_PM_PWSTST_IVA2_OFFSET))
 
-
-#define PRCMPM_PWSTST_DSPInTransitionRead32(baseAddress)		       \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32),      \
+#define PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32(baseAddress)		       \
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32),      \
 	(((__raw_readl((((u32)(baseAddress)) + 				       \
 	(PRCM_PM_PWSTST_DSP_OFFSET)))) &				       \
-	PRCM_PM_PWSTST_DSP_InTransition_MASK) >>			       \
-	PRCM_PM_PWSTST_DSP_InTransition_OFFSET))
+	PRCM_PM_PWSTST_DSP_IN_TRANSITION_MASK) >>			       \
+	PRCM_PM_PWSTST_DSP_IN_TRANSITION_OFFSET))
 
-#define PRCMPM_PWSTST_IVA2InTransitionRead32(baseAddress)		       \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32),     \
+#define PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32(baseAddress)		       \
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32),     \
 	(((__raw_readl((((baseAddress)) +	 			       \
 	(PRCM_PM_PWSTST_IVA2_OFFSET)))) &				       \
-	PRCM_PM_PWSTST_IVA2_InTransition_MASK) >>			       \
-	PRCM_PM_PWSTST_IVA2_InTransition_OFFSET))
+	PRCM_PM_PWSTST_IVA2_IN_TRANSITION_MASK) >>			       \
+	PRCM_PM_PWSTST_IVA2_IN_TRANSITION_OFFSET))
 
-#define PRCMPM_PWSTST_DSPPowerStateStGet32(var)				       \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPPowerStateStGet32),       \
-	(u32)((((u32)(var)) & PRCM_PM_PWSTST_DSP_PowerStateSt_MASK) >>	       \
-	PRCM_PM_PWSTST_DSP_PowerStateSt_OFFSET))
+#define PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32(var)				       \
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32),       \
+	(u32)((((u32)(var)) & PRCM_PM_PWSTST_DSP_POWER_STATE_ST_MASK) >>	       \
+	PRCM_PM_PWSTST_DSP_POWER_STATE_ST_OFFSET))
 
-#define PRCMPM_PWSTST_IVA2PowerStateStGet32(var)			       \
-	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2PowerStateStGet32),      \
-	(u32)((((u32)(var)) & PRCM_PM_PWSTST_IVA2_PowerStateSt_MASK) >>	       \
-	PRCM_PM_PWSTST_IVA2_PowerStateSt_OFFSET))
+#define PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32(var)			       \
+	(_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32),      \
+	(u32)((((u32)(var)) & PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_MASK) >>	       \
+	PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_OFFSET))
 
-#endif  /* USE_LEVEL_1_MACROS */
+#endif /* USE_LEVEL_1_MACROS */
 
 #endif /* _PRCM_REG_ACM_H */
diff --git a/drivers/dsp/bridge/hw/hw_defs.h b/drivers/dsp/bridge/hw/hw_defs.h
index 827fff3..98f6045 100644
--- a/drivers/dsp/bridge/hw/hw_defs.h
+++ b/drivers/dsp/bridge/hw/hw_defs.h
@@ -16,47 +16,45 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __HW_DEFS_H
-#define __HW_DEFS_H
+#ifndef _HW_DEFS_H
+#define _HW_DEFS_H
 
 #include <GlobalTypes.h>
 
 /* Page size */
-#define HW_PAGE_SIZE_4KB   0x1000
-#define HW_PAGE_SIZE_64KB  0x10000
-#define HW_PAGE_SIZE_1MB   0x100000
-#define HW_PAGE_SIZE_16MB  0x1000000
+#define HW_PAGE_SIZE4KB   0x1000
+#define HW_PAGE_SIZE64KB  0x10000
+#define HW_PAGE_SIZE1MB   0x100000
+#define HW_PAGE_SIZE16MB  0x1000000
 
-/* HW_STATUS:  return type for HW API */
-typedef long HW_STATUS;
+/* hw_status:  return type for HW API */
+typedef long hw_status;
 
 /*  Macro used to set and clear any bit */
 #define HW_CLEAR	0
 #define HW_SET		1
 
-/* HW_Endianism_t:  Enumerated Type used to specify the endianism
+/* hw_endianism_t:  Enumerated Type used to specify the endianism
  *		Do NOT change these values. They are used as bit fields. */
-enum HW_Endianism_t {
-    HW_LITTLE_ENDIAN,
-    HW_BIG_ENDIAN
+enum hw_endianism_t {
+	HW_LITTLE_ENDIAN,
+	HW_BIG_ENDIAN
+};
 
-} ;
-
-/* HW_ElementSize_t:  Enumerated Type used to specify the element size
+/* hw_element_size_t:  Enumerated Type used to specify the element size
  *		Do NOT change these values. They are used as bit fields. */
-enum HW_ElementSize_t {
-    HW_ELEM_SIZE_8BIT,
-    HW_ELEM_SIZE_16BIT,
-    HW_ELEM_SIZE_32BIT,
-    HW_ELEM_SIZE_64BIT
-
-} ;
-
-/* HW_IdleMode_t:  Enumerated Type used to specify Idle modes */
-	enum HW_IdleMode_t {
-		HW_FORCE_IDLE,
-		HW_NO_IDLE,
-		HW_SMART_IDLE
-	} ;
-
-#endif  /* __HW_DEFS_H */
+enum hw_element_size_t {
+	HW_ELEM_SIZE8BIT,
+	HW_ELEM_SIZE16BIT,
+	HW_ELEM_SIZE32BIT,
+	HW_ELEM_SIZE64BIT
+};
+
+/* hw_idle_mode_t:  Enumerated Type used to specify Idle modes */
+enum hw_idle_mode_t {
+	HW_FORCE_IDLE,
+	HW_NO_IDLE,
+	HW_SMART_IDLE
+};
+
+#endif /* _HW_DEFS_H */
diff --git a/drivers/dsp/bridge/hw/hw_dspssC64P.c b/drivers/dsp/bridge/hw/hw_dspssC64P.c
index c1124fd..89e9316 100644
--- a/drivers/dsp/bridge/hw/hw_dspssC64P.c
+++ b/drivers/dsp/bridge/hw/hw_dspssC64P.c
@@ -25,13 +25,13 @@
 #include <IPIAccInt.h>
 
 /* HW FUNCTIONS */
-HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
-		      enum HW_DSPSYSC_BootMode_t bootMode,
-		      const u32 bootAddress)
+hw_status hw_dspss_boot_mode_set(const void __iomem *baseAddress,
+				 enum hw_dspsysc_boot_mode_t bootMode,
+				 const u32 bootAddress)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 	u32 offset = SYSC_IVA2BOOTMOD_OFFSET;
-	u32 alignedBootAddr;
+	u32 aligned_boot_addr;
 
 	/* if Boot mode it DIRECT BOOT, check that the bootAddress is
 	 * aligned to atleast 1K :: TODO */
@@ -39,9 +39,9 @@ HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
 
 	offset = SYSC_IVA2BOOTADDR_OFFSET;
 
-	alignedBootAddr = bootAddress & SYSC_IVA2BOOTADDR_MASK;
+	aligned_boot_addr = bootAddress & SYSC_IVA2BOOTADDR_MASK;
 
-	__raw_writel(alignedBootAddr, (baseAddress) + offset);
+	__raw_writel(aligned_boot_addr, (baseAddress) + offset);
 
 	return status;
 }
diff --git a/drivers/dsp/bridge/hw/hw_dspssC64P.h b/drivers/dsp/bridge/hw/hw_dspssC64P.h
index 2af5415..af0c38b 100644
--- a/drivers/dsp/bridge/hw/hw_dspssC64P.h
+++ b/drivers/dsp/bridge/hw/hw_dspssC64P.h
@@ -16,22 +16,22 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __HW_DSPSS_H
-#define __HW_DSPSS_H
+#ifndef _HW_DSPSS_H
+#define _HW_DSPSS_H
 #include <linux/types.h>
 
-	enum HW_DSPSYSC_BootMode_t {
-		HW_DSPSYSC_DIRECTBOOT = 0x0,
-		HW_DSPSYSC_IDLEBOOT = 0x1,
-		HW_DSPSYSC_SELFLOOPBOOT = 0x2,
-		HW_DSPSYSC_USRBOOTSTRAP = 0x3,
-		HW_DSPSYSC_DEFAULTRESTORE = 0x4
-	} ;
+enum hw_dspsysc_boot_mode_t {
+	HW_DSPSYSC_DIRECTBOOT = 0x0,
+	HW_DSPSYSC_IDLEBOOT = 0x1,
+	HW_DSPSYSC_SELFLOOPBOOT = 0x2,
+	HW_DSPSYSC_USRBOOTSTRAP = 0x3,
+	HW_DSPSYSC_DEFAULTRESTORE = 0x4
+};
 
 #define HW_DSP_IDLEBOOT_ADDR   0x007E0000
 
-	extern HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
-					enum HW_DSPSYSC_BootMode_t bootMode,
+extern hw_status hw_dspss_boot_mode_set(const void __iomem *baseAddress,
+					enum hw_dspsysc_boot_mode_t bootMode,
 					const u32 bootAddress);
 
-#endif				/* __HW_DSPSS_H */
+#endif /* _HW_DSPSS_H */
diff --git a/drivers/dsp/bridge/hw/hw_mmu.c b/drivers/dsp/bridge/hw/hw_mmu.c
index abaf0f6..ddcdfee 100644
--- a/drivers/dsp/bridge/hw/hw_mmu.c
+++ b/drivers/dsp/bridge/hw/hw_mmu.c
@@ -36,16 +36,18 @@
 
 #define MMU_LOAD_TLB	0x00000001
 
-/* HW_MMUPageSize_t:  Enumerated Type used to specify the MMU Page Size(SLSS) */
-enum HW_MMUPageSize_t {
-    HW_MMU_SECTION,
-    HW_MMU_LARGE_PAGE,
-    HW_MMU_SMALL_PAGE,
-    HW_MMU_SUPERSECTION
-} ;
+/*
+ * hw_mmu_page_size_t: Enumerated Type used to specify the MMU Page Size(SLSS)
+ */
+enum hw_mmu_page_size_t {
+	HW_MMU_SECTION,
+	HW_MMU_LARGE_PAGE,
+	HW_MMU_SMALL_PAGE,
+	HW_MMU_SUPERSECTION
+};
 
 /*
-* FUNCTION	      : MMU_FlushEntry
+* FUNCTION	      : mmu_flush_entry
 *
 * INPUTS:
 *
@@ -55,7 +57,7 @@ enum HW_MMUPageSize_t {
 *
 * RETURNS:
 *
-*       Type		: HW_STATUS
+*       Type		: hw_status
 *       Description     : RET_OK		 -- No errors occured
 *			 RET_BAD_NULL_PARAM     -- A Pointer
 *						Paramater was set to NULL
@@ -66,11 +68,11 @@ enum HW_MMUPageSize_t {
 *
 * METHOD:	       : Check the Input parameter and Flush a
 *			 single entry in the TLB.
-*/
-static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress);
+ */
+static hw_status mmu_flush_entry(const void __iomem *baseAddress);
 
 /*
-* FUNCTION	      : MMU_SetCAMEntry
+* FUNCTION	      : mmu_set_cam_entry
 *
 * INPUTS:
 *
@@ -92,13 +94,13 @@ static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress);
 *       Description     : It indicates the TLB entry is valid entry or not
 *
 *
-*       Identifier      : virtualAddrTag
+*       Identifier      : virtual_addr_tag
 *       Type	    	: const u32
 *       Description     : virtual Address
 *
 * RETURNS:
 *
-*       Type	    	: HW_STATUS
+*       Type	    	: hw_status
 *       Description     : RET_OK		 -- No errors occured
 *			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
 *						   was set to NULL
@@ -108,15 +110,15 @@ static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress);
 * PURPOSE:	      	: Set MMU_CAM reg
 *
 * METHOD:	       	: Check the Input parameters and set the CAM entry.
-*/
-static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
-				   const u32    pageSize,
-				   const u32    preservedBit,
-				   const u32    validBit,
-				   const u32    virtualAddrTag);
+ */
+static hw_status mmu_set_cam_entry(const void __iomem *baseAddress,
+				   const u32 pageSize,
+				   const u32 preservedBit,
+				   const u32 validBit,
+				   const u32 virtual_addr_tag);
 
 /*
-* FUNCTION	      : MMU_SetRAMEntry
+* FUNCTION	      : mmu_set_ram_entry
 *
 * INPUTS:
 *
@@ -130,20 +132,20 @@ static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
 *			 virtual   Address shouldpoint
 *
 *       Identifier      : endianism
-*       Type	    	: HW_Endianism_t
+*       Type	    	: hw_endianism_t
 *       Description     : endianism for the given page
 *
-*       Identifier      : elementSize
-*       Type	    	: HW_ElementSize_t
+*       Identifier      : element_size
+*       Type	    	: hw_element_size_t
 *       Description     : The element size ( 8,16, 32 or 64 bit)
 *
-*       Identifier      : mixedSize
-*       Type	    	: HW_MMUMixedSize_t
+*       Identifier      : mixed_size
+*       Type	    	: hw_mmu_mixed_size_t
 *       Description     : Element Size to follow CPU or TLB
 *
 * RETURNS:
 *
-*       Type	    	: HW_STATUS
+*       Type	    	: hw_status
 *       Description     : RET_OK		 -- No errors occured
 *			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
 *							was set to NULL
@@ -153,433 +155,433 @@ static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
 * PURPOSE:	      : Set MMU_CAM reg
 *
 * METHOD:	       : Check the Input parameters and set the RAM entry.
-*/
-static HW_STATUS MMU_SetRAMEntry(const void __iomem *baseAddress,
-				   const u32	physicalAddr,
-				   enum HW_Endianism_t      endianism,
-				   enum HW_ElementSize_t    elementSize,
-				   enum HW_MMUMixedSize_t   mixedSize);
+ */
+static hw_status mmu_set_ram_entry(const void __iomem *baseAddress,
+				   const u32 physicalAddr,
+				   enum hw_endianism_t endianism,
+				   enum hw_element_size_t element_size,
+				   enum hw_mmu_mixed_size_t mixed_size);
 
 /* HW FUNCTIONS */
 
-HW_STATUS HW_MMU_Enable(const void __iomem *baseAddress)
+hw_status hw_mmu_enable(const void __iomem *baseAddress)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_CNTLMMUEnableWrite32(baseAddress, HW_SET);
+	MMUMMU_CNTLMMU_ENABLE_WRITE32(baseAddress, HW_SET);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_Disable(const void __iomem *baseAddress)
+hw_status hw_mmu_disable(const void __iomem *baseAddress)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_CNTLMMUEnableWrite32(baseAddress, HW_CLEAR);
+	MMUMMU_CNTLMMU_ENABLE_WRITE32(baseAddress, HW_CLEAR);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_NumLockedSet(const void __iomem *baseAddress,
+hw_status hw_mmu_num_locked_set(const void __iomem *baseAddress,
 				u32 numLockedEntries)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_LOCKBaseValueWrite32(baseAddress, numLockedEntries);
+	MMUMMU_LOCK_BASE_VALUE_WRITE32(baseAddress, numLockedEntries);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_VictimNumSet(const void __iomem *baseAddress,
+hw_status hw_mmu_victim_num_set(const void __iomem *baseAddress,
 				u32 victimEntryNum)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_LOCKCurrentVictimWrite32(baseAddress, victimEntryNum);
+	MMUMMU_LOCK_CURRENT_VICTIM_WRITE32(baseAddress, victimEntryNum);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_EventAck(const void __iomem *baseAddress, u32 irqMask)
+hw_status hw_mmu_event_ack(const void __iomem *baseAddress, u32 irqMask)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_IRQSTATUSWriteRegister32(baseAddress, irqMask);
+	MMUMMU_IRQSTATUS_WRITE_REGISTER32(baseAddress, irqMask);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_EventDisable(const void __iomem *baseAddress,
-				u32 irqMask)
+hw_status hw_mmu_event_disable(const void __iomem *baseAddress, u32 irqMask)
 {
-    HW_STATUS status = RET_OK;
-    u32 irqReg;
+	hw_status status = RET_OK;
+	u32 irq_reg;
 
-    irqReg = MMUMMU_IRQENABLEReadRegister32(baseAddress);
+	irq_reg = MMUMMU_IRQENABLE_READ_REGISTER32(baseAddress);
 
-    MMUMMU_IRQENABLEWriteRegister32(baseAddress, irqReg & ~irqMask);
+	MMUMMU_IRQENABLE_WRITE_REGISTER32(baseAddress, irq_reg & ~irqMask);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_EventEnable(const void __iomem *baseAddress, u32 irqMask)
+hw_status hw_mmu_event_enable(const void __iomem *baseAddress, u32 irqMask)
 {
-    HW_STATUS status = RET_OK;
-    u32 irqReg;
+	hw_status status = RET_OK;
+	u32 irq_reg;
 
-    irqReg = MMUMMU_IRQENABLEReadRegister32(baseAddress);
+	irq_reg = MMUMMU_IRQENABLE_READ_REGISTER32(baseAddress);
 
-    MMUMMU_IRQENABLEWriteRegister32(baseAddress, irqReg | irqMask);
+	MMUMMU_IRQENABLE_WRITE_REGISTER32(baseAddress, irq_reg | irqMask);
 
-    return status;
+	return status;
 }
 
-
-HW_STATUS HW_MMU_EventStatus(const void __iomem *baseAddress, u32 *irqMask)
+hw_status hw_mmu_event_status(const void __iomem *baseAddress, u32 *irqMask)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    *irqMask = MMUMMU_IRQSTATUSReadRegister32(baseAddress);
+	*irqMask = MMUMMU_IRQSTATUS_READ_REGISTER32(baseAddress);
 
-    return status;
+	return status;
 }
 
-
-HW_STATUS HW_MMU_FaultAddrRead(const void __iomem *baseAddress, u32 *addr)
+hw_status hw_mmu_fault_addr_read(const void __iomem *baseAddress, u32 *addr)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    /*Check the input Parameters*/
-    CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		      RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
 
-    /* read values from register */
-    *addr = MMUMMU_FAULT_ADReadRegister32(baseAddress);
+	/* read values from register */
+	*addr = MMUMMU_FAULT_AD_READ_REGISTER32(baseAddress);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TTBSet(const void __iomem *baseAddress, u32 TTBPhysAddr)
+hw_status hw_mmu_ttb_set(const void __iomem *baseAddress, u32 TTBPhysAddr)
 {
-    HW_STATUS status = RET_OK;
-    u32 loadTTB;
+	hw_status status = RET_OK;
+	u32 load_ttb;
 
-   /*Check the input Parameters*/
-   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
 
-   loadTTB = TTBPhysAddr & ~0x7FUL;
-   /* write values to register */
-   MMUMMU_TTBWriteRegister32(baseAddress, loadTTB);
+	load_ttb = TTBPhysAddr & ~0x7FUL;
+	/* write values to register */
+	MMUMMU_TTB_WRITE_REGISTER32(baseAddress, load_ttb);
 
-   return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TWLEnable(const void __iomem *baseAddress)
+hw_status hw_mmu_twl_enable(const void __iomem *baseAddress)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_CNTLTWLEnableWrite32(baseAddress, HW_SET);
+	MMUMMU_CNTLTWL_ENABLE_WRITE32(baseAddress, HW_SET);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TWLDisable(const void __iomem *baseAddress)
+hw_status hw_mmu_twl_disable(const void __iomem *baseAddress)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_CNTLTWLEnableWrite32(baseAddress, HW_CLEAR);
+	MMUMMU_CNTLTWL_ENABLE_WRITE32(baseAddress, HW_CLEAR);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TLBFlush(const void __iomem *baseAddress, u32 virtualAddr,
-			     u32 pageSize)
+hw_status hw_mmu_tlb_flush(const void __iomem *baseAddress, u32 virtualAddr,
+			   u32 pageSize)
 {
-    HW_STATUS status = RET_OK;
-    u32 virtualAddrTag;
-    enum HW_MMUPageSize_t pgSizeBits;
+	hw_status status = RET_OK;
+	u32 virtual_addr_tag;
+	enum hw_mmu_page_size_t pg_size_bits;
 
-    switch (pageSize) {
-    case HW_PAGE_SIZE_4KB:
-	pgSizeBits = HW_MMU_SMALL_PAGE;
-	break;
+	switch (pageSize) {
+	case HW_PAGE_SIZE4KB:
+		pg_size_bits = HW_MMU_SMALL_PAGE;
+		break;
 
-    case HW_PAGE_SIZE_64KB:
-	pgSizeBits = HW_MMU_LARGE_PAGE;
-	break;
+	case HW_PAGE_SIZE64KB:
+		pg_size_bits = HW_MMU_LARGE_PAGE;
+		break;
 
-    case HW_PAGE_SIZE_1MB:
-	pgSizeBits = HW_MMU_SECTION;
-	break;
+	case HW_PAGE_SIZE1MB:
+		pg_size_bits = HW_MMU_SECTION;
+		break;
 
-    case HW_PAGE_SIZE_16MB:
-	pgSizeBits = HW_MMU_SUPERSECTION;
-	break;
+	case HW_PAGE_SIZE16MB:
+		pg_size_bits = HW_MMU_SUPERSECTION;
+		break;
 
-    default:
-	return RET_FAIL;
-    }
+	default:
+		return RET_FAIL;
+	}
 
-    /* Generate the 20-bit tag from virtual address */
-    virtualAddrTag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
+	/* Generate the 20-bit tag from virtual address */
+	virtual_addr_tag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
 
-    MMU_SetCAMEntry(baseAddress, pgSizeBits, 0, 0, virtualAddrTag);
+	mmu_set_cam_entry(baseAddress, pg_size_bits, 0, 0, virtual_addr_tag);
 
-    MMU_FlushEntry(baseAddress);
+	mmu_flush_entry(baseAddress);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TLBAdd(const void __iomem *baseAddress,
-			   u32	      physicalAddr,
-			   u32	      virtualAddr,
-			   u32	      pageSize,
-			   u32	      entryNum,
-			   struct HW_MMUMapAttrs_t    *mapAttrs,
-			   s8 preservedBit, s8 validBit)
+hw_status hw_mmu_tlb_add(const void __iomem *baseAddress,
+			 u32 physicalAddr,
+			 u32 virtualAddr,
+			 u32 pageSize,
+			 u32 entryNum,
+			 struct hw_mmu_map_attrs_t *map_attrs,
+			 s8 preservedBit, s8 validBit)
 {
-    HW_STATUS  status = RET_OK;
-    u32 lockReg;
-    u32 virtualAddrTag;
-    enum HW_MMUPageSize_t mmuPgSize;
-
-    /*Check the input Parameters*/
-    CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		      RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
-    CHECK_INPUT_RANGE_MIN0(pageSize, MMU_PAGE_MAX, RET_PARAM_OUT_OF_RANGE,
-			   RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
-    CHECK_INPUT_RANGE_MIN0(mapAttrs->elementSize, MMU_ELEMENTSIZE_MAX,
-			RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
-			RES_INVALID_INPUT_PARAM);
-
-    switch (pageSize) {
-    case HW_PAGE_SIZE_4KB:
-	mmuPgSize = HW_MMU_SMALL_PAGE;
-	break;
-
-    case HW_PAGE_SIZE_64KB:
-	mmuPgSize = HW_MMU_LARGE_PAGE;
-	break;
-
-    case HW_PAGE_SIZE_1MB:
-	mmuPgSize = HW_MMU_SECTION;
-	break;
-
-    case HW_PAGE_SIZE_16MB:
-	mmuPgSize = HW_MMU_SUPERSECTION;
-	break;
-
-    default:
-	return RET_FAIL;
-    }
-
-    lockReg = MMUMMU_LOCKReadRegister32(baseAddress);
-
-    /* Generate the 20-bit tag from virtual address */
-    virtualAddrTag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
-
-    /* Write the fields in the CAM Entry Register */
-    MMU_SetCAMEntry(baseAddress,  mmuPgSize, preservedBit, validBit,
-		    virtualAddrTag);
-
-    /* Write the different fields of the RAM Entry Register */
-    /* endianism of the page,Element Size of the page (8, 16, 32, 64 bit)*/
-    MMU_SetRAMEntry(baseAddress, physicalAddr, mapAttrs->endianism,
-		    mapAttrs->elementSize, mapAttrs->mixedSize);
-
-    /* Update the MMU Lock Register */
-    /* currentVictim between lockedBaseValue and (MMU_Entries_Number - 1)*/
-    MMUMMU_LOCKCurrentVictimWrite32(baseAddress, entryNum);
-
-    /* Enable loading of an entry in TLB by writing 1
+	hw_status status = RET_OK;
+	u32 lock_reg;
+	u32 virtual_addr_tag;
+	enum hw_mmu_page_size_t mmu_pg_size;
+
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(pageSize, MMU_PAGE_MAX, RET_PARAM_OUT_OF_RANGE,
+			       RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(map_attrs->element_size, MMU_ELEMENTSIZE_MAX,
+			       RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
+			       RES_INVALID_INPUT_PARAM);
+
+	switch (pageSize) {
+	case HW_PAGE_SIZE4KB:
+		mmu_pg_size = HW_MMU_SMALL_PAGE;
+		break;
+
+	case HW_PAGE_SIZE64KB:
+		mmu_pg_size = HW_MMU_LARGE_PAGE;
+		break;
+
+	case HW_PAGE_SIZE1MB:
+		mmu_pg_size = HW_MMU_SECTION;
+		break;
+
+	case HW_PAGE_SIZE16MB:
+		mmu_pg_size = HW_MMU_SUPERSECTION;
+		break;
+
+	default:
+		return RET_FAIL;
+	}
+
+	lock_reg = MMUMMU_LOCK_READ_REGISTER32(baseAddress);
+
+	/* Generate the 20-bit tag from virtual address */
+	virtual_addr_tag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
+
+	/* Write the fields in the CAM Entry Register */
+	mmu_set_cam_entry(baseAddress, mmu_pg_size, preservedBit, validBit,
+			  virtual_addr_tag);
+
+	/* Write the different fields of the RAM Entry Register */
+	/* endianism of the page,Element Size of the page (8, 16, 32, 64 bit) */
+	mmu_set_ram_entry(baseAddress, physicalAddr, map_attrs->endianism,
+			  map_attrs->element_size, map_attrs->mixed_size);
+
+	/* Update the MMU Lock Register */
+	/* currentVictim between lockedBaseValue and (MMU_Entries_Number - 1) */
+	MMUMMU_LOCK_CURRENT_VICTIM_WRITE32(baseAddress, entryNum);
+
+	/* Enable loading of an entry in TLB by writing 1
 	   into LD_TLB_REG register */
-    MMUMMU_LD_TLBWriteRegister32(baseAddress, MMU_LOAD_TLB);
+	MMUMMU_LD_TLB_WRITE_REGISTER32(baseAddress, MMU_LOAD_TLB);
 
+	MMUMMU_LOCK_WRITE_REGISTER32(baseAddress, lock_reg);
 
-    MMUMMU_LOCKWriteRegister32(baseAddress, lockReg);
-
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_PteSet(const u32	pgTblVa,
-			   u32	      physicalAddr,
-			   u32	      virtualAddr,
-			   u32	      pageSize,
-			   struct HW_MMUMapAttrs_t    *mapAttrs)
+hw_status hw_mmu_pte_set(const u32 pg_tbl_va,
+			 u32 physicalAddr,
+			 u32 virtualAddr,
+			 u32 pageSize, struct hw_mmu_map_attrs_t *map_attrs)
 {
-    HW_STATUS status = RET_OK;
-    u32 pteAddr, pteVal;
-    s32 numEntries = 1;
-
-    switch (pageSize) {
-    case HW_PAGE_SIZE_4KB:
-	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
-				    virtualAddr & MMU_SMALL_PAGE_MASK);
-	pteVal = ((physicalAddr & MMU_SMALL_PAGE_MASK) |
-		    (mapAttrs->endianism << 9) |
-		    (mapAttrs->elementSize << 4) |
-		    (mapAttrs->mixedSize << 11) | 2
-		  );
-	break;
-
-    case HW_PAGE_SIZE_64KB:
-	numEntries = 16;
-	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
-				    virtualAddr & MMU_LARGE_PAGE_MASK);
-	pteVal = ((physicalAddr & MMU_LARGE_PAGE_MASK) |
-		    (mapAttrs->endianism << 9) |
-		    (mapAttrs->elementSize << 4) |
-		    (mapAttrs->mixedSize << 11) | 1
-		  );
-	break;
-
-    case HW_PAGE_SIZE_1MB:
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SECTION_ADDR_MASK);
-	pteVal = ((((physicalAddr & MMU_SECTION_ADDR_MASK) |
-		     (mapAttrs->endianism << 15) |
-		     (mapAttrs->elementSize << 10) |
-		     (mapAttrs->mixedSize << 17)) &
-		     ~0x40000) | 0x2
-		 );
-	break;
-
-    case HW_PAGE_SIZE_16MB:
-	numEntries = 16;
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SSECTION_ADDR_MASK);
-	pteVal = (((physicalAddr & MMU_SSECTION_ADDR_MASK) |
-		      (mapAttrs->endianism << 15) |
-		      (mapAttrs->elementSize << 10) |
-		      (mapAttrs->mixedSize << 17)
-		    ) | 0x40000 | 0x2
-		  );
-	break;
-
-    case HW_MMU_COARSE_PAGE_SIZE:
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SECTION_ADDR_MASK);
-	pteVal = (physicalAddr & MMU_PAGE_TABLE_MASK) | 1;
-	break;
-
-    default:
-	return RET_FAIL;
-    }
-
-    while (--numEntries >= 0)
-	((u32 *)pteAddr)[numEntries] = pteVal;
-
-    return status;
+	hw_status status = RET_OK;
+	u32 pte_addr, pte_val;
+	s32 num_entries = 1;
+
+	switch (pageSize) {
+	case HW_PAGE_SIZE4KB:
+		pte_addr = hw_mmu_pte_addr_l2(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SMALL_PAGE_MASK);
+		pte_val =
+		    ((physicalAddr & MMU_SMALL_PAGE_MASK) |
+		     (map_attrs->endianism << 9) | (map_attrs->
+						    element_size << 4) |
+		     (map_attrs->mixed_size << 11) | 2);
+		break;
+
+	case HW_PAGE_SIZE64KB:
+		num_entries = 16;
+		pte_addr = hw_mmu_pte_addr_l2(pg_tbl_va,
+					      virtualAddr &
+					      MMU_LARGE_PAGE_MASK);
+		pte_val =
+		    ((physicalAddr & MMU_LARGE_PAGE_MASK) |
+		     (map_attrs->endianism << 9) | (map_attrs->
+						    element_size << 4) |
+		     (map_attrs->mixed_size << 11) | 1);
+		break;
+
+	case HW_PAGE_SIZE1MB:
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SECTION_ADDR_MASK);
+		pte_val =
+		    ((((physicalAddr & MMU_SECTION_ADDR_MASK) |
+		       (map_attrs->endianism << 15) | (map_attrs->
+						       element_size << 10) |
+		       (map_attrs->mixed_size << 17)) & ~0x40000) | 0x2);
+		break;
+
+	case HW_PAGE_SIZE16MB:
+		num_entries = 16;
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SSECTION_ADDR_MASK);
+		pte_val =
+		    (((physicalAddr & MMU_SSECTION_ADDR_MASK) |
+		      (map_attrs->endianism << 15) | (map_attrs->
+						      element_size << 10) |
+		      (map_attrs->mixed_size << 17)
+		     ) | 0x40000 | 0x2);
+		break;
+
+	case HW_MMU_COARSE_PAGE_SIZE:
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SECTION_ADDR_MASK);
+		pte_val = (physicalAddr & MMU_PAGE_TABLE_MASK) | 1;
+		break;
+
+	default:
+		return RET_FAIL;
+	}
+
+	while (--num_entries >= 0)
+		((u32 *) pte_addr)[num_entries] = pte_val;
+
+	return status;
 }
 
-HW_STATUS HW_MMU_PteClear(const u32  pgTblVa,
-			     u32	virtualAddr,
-			     u32	pgSize)
+hw_status hw_mmu_pte_clear(const u32 pg_tbl_va, u32 virtualAddr, u32 page_size)
 {
-    HW_STATUS status = RET_OK;
-    u32 pteAddr;
-    s32 numEntries = 1;
-
-    switch (pgSize) {
-    case HW_PAGE_SIZE_4KB:
-	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
-				    virtualAddr & MMU_SMALL_PAGE_MASK);
-	break;
-
-    case HW_PAGE_SIZE_64KB:
-	numEntries = 16;
-	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
-				    virtualAddr & MMU_LARGE_PAGE_MASK);
-	break;
-
-    case HW_PAGE_SIZE_1MB:
-    case HW_MMU_COARSE_PAGE_SIZE:
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SECTION_ADDR_MASK);
-	break;
-
-    case HW_PAGE_SIZE_16MB:
-	numEntries = 16;
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SSECTION_ADDR_MASK);
-	break;
-
-    default:
-	return RET_FAIL;
-    }
-
-    while (--numEntries >= 0)
-	((u32 *)pteAddr)[numEntries] = 0;
-
-    return status;
+	hw_status status = RET_OK;
+	u32 pte_addr;
+	s32 num_entries = 1;
+
+	switch (page_size) {
+	case HW_PAGE_SIZE4KB:
+		pte_addr = hw_mmu_pte_addr_l2(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SMALL_PAGE_MASK);
+		break;
+
+	case HW_PAGE_SIZE64KB:
+		num_entries = 16;
+		pte_addr = hw_mmu_pte_addr_l2(pg_tbl_va,
+					      virtualAddr &
+					      MMU_LARGE_PAGE_MASK);
+		break;
+
+	case HW_PAGE_SIZE1MB:
+	case HW_MMU_COARSE_PAGE_SIZE:
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SECTION_ADDR_MASK);
+		break;
+
+	case HW_PAGE_SIZE16MB:
+		num_entries = 16;
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SSECTION_ADDR_MASK);
+		break;
+
+	default:
+		return RET_FAIL;
+	}
+
+	while (--num_entries >= 0)
+		((u32 *) pte_addr)[num_entries] = 0;
+
+	return status;
 }
 
-/* MMU_FlushEntry */
-static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress)
+/* mmu_flush_entry */
+static hw_status mmu_flush_entry(const void __iomem *baseAddress)
 {
-   HW_STATUS status = RET_OK;
-   u32 flushEntryData = 0x1;
+	hw_status status = RET_OK;
+	u32 flush_entry_data = 0x1;
 
-   /*Check the input Parameters*/
-   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
 
-   /* write values to register */
-   MMUMMU_FLUSH_ENTRYWriteRegister32(baseAddress, flushEntryData);
+	/* write values to register */
+	MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32(baseAddress, flush_entry_data);
 
-   return status;
+	return status;
 }
 
-/* MMU_SetCAMEntry */
-static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
-				   const u32    pageSize,
-				   const u32    preservedBit,
-				   const u32    validBit,
-				   const u32    virtualAddrTag)
+/* mmu_set_cam_entry */
+static hw_status mmu_set_cam_entry(const void __iomem *baseAddress,
+				   const u32 pageSize,
+				   const u32 preservedBit,
+				   const u32 validBit,
+				   const u32 virtual_addr_tag)
 {
-   HW_STATUS status = RET_OK;
-   u32 mmuCamReg;
+	hw_status status = RET_OK;
+	u32 mmu_cam_reg;
 
-   /*Check the input Parameters*/
-   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
 
-   mmuCamReg = (virtualAddrTag << 12);
-   mmuCamReg = (mmuCamReg) | (pageSize) |  (validBit << 2) |
-	       (preservedBit << 3) ;
+	mmu_cam_reg = (virtual_addr_tag << 12);
+	mmu_cam_reg = (mmu_cam_reg) | (pageSize) | (validBit << 2) |
+	    (preservedBit << 3);
 
-   /* write values to register */
-   MMUMMU_CAMWriteRegister32(baseAddress, mmuCamReg);
+	/* write values to register */
+	MMUMMU_CAM_WRITE_REGISTER32(baseAddress, mmu_cam_reg);
 
-   return status;
+	return status;
 }
 
-/* MMU_SetRAMEntry */
-static HW_STATUS MMU_SetRAMEntry(const void __iomem *baseAddress,
-				   const u32       physicalAddr,
-				   enum HW_Endianism_t     endianism,
-				   enum HW_ElementSize_t   elementSize,
-				   enum HW_MMUMixedSize_t  mixedSize)
+/* mmu_set_ram_entry */
+static hw_status mmu_set_ram_entry(const void __iomem *baseAddress,
+				   const u32 physicalAddr,
+				   enum hw_endianism_t endianism,
+				   enum hw_element_size_t element_size,
+				   enum hw_mmu_mixed_size_t mixed_size)
 {
-   HW_STATUS status = RET_OK;
-   u32 mmuRamReg;
-
-   /*Check the input Parameters*/
-   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
-   CHECK_INPUT_RANGE_MIN0(elementSize, MMU_ELEMENTSIZE_MAX,
-		   RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
-		   RES_INVALID_INPUT_PARAM);
+	hw_status status = RET_OK;
+	u32 mmu_ram_reg;
 
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(element_size, MMU_ELEMENTSIZE_MAX,
+			       RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
+			       RES_INVALID_INPUT_PARAM);
 
-   mmuRamReg = (physicalAddr & MMU_ADDR_MASK);
-   mmuRamReg = (mmuRamReg) | ((endianism << 9) |  (elementSize << 7) |
-	       (mixedSize << 6));
+	mmu_ram_reg = (physicalAddr & MMU_ADDR_MASK);
+	mmu_ram_reg = (mmu_ram_reg) | ((endianism << 9) | (element_size << 7) |
+				       (mixed_size << 6));
 
-   /* write values to register */
-   MMUMMU_RAMWriteRegister32(baseAddress, mmuRamReg);
+	/* write values to register */
+	MMUMMU_RAM_WRITE_REGISTER32(baseAddress, mmu_ram_reg);
 
-   return status;
+	return status;
 
 }
diff --git a/drivers/dsp/bridge/hw/hw_mmu.h b/drivers/dsp/bridge/hw/hw_mmu.h
index ddb0843..9b13468 100644
--- a/drivers/dsp/bridge/hw/hw_mmu.h
+++ b/drivers/dsp/bridge/hw/hw_mmu.h
@@ -16,8 +16,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __HW_MMU_H
-#define __HW_MMU_H
+#ifndef _HW_MMU_H
+#define _HW_MMU_H
 
 #include <linux/types.h>
 
@@ -27,139 +27,135 @@
 
 #define HW_MMU_COARSE_PAGE_SIZE 0x400
 
-/* HW_MMUMixedSize_t:  Enumerated Type used to specify whether to follow
+/* hw_mmu_mixed_size_t:  Enumerated Type used to specify whether to follow
 			CPU/TLB Element size */
-enum HW_MMUMixedSize_t {
+enum hw_mmu_mixed_size_t {
 	HW_MMU_TLBES,
 	HW_MMU_CPUES
+};
 
-} ;
-
-/* HW_MMUMapAttrs_t:  Struct containing MMU mapping attributes */
-struct HW_MMUMapAttrs_t {
-	enum HW_Endianism_t     endianism;
-	enum HW_ElementSize_t   elementSize;
-	enum HW_MMUMixedSize_t  mixedSize;
+/* hw_mmu_map_attrs_t:  Struct containing MMU mapping attributes */
+struct hw_mmu_map_attrs_t {
+	enum hw_endianism_t endianism;
+	enum hw_element_size_t element_size;
+	enum hw_mmu_mixed_size_t mixed_size;
 	bool donotlockmpupage;
-} ;
+};
 
-extern HW_STATUS HW_MMU_Enable(const void __iomem *baseAddress);
+extern hw_status hw_mmu_enable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_Disable(const void __iomem *baseAddress);
+extern hw_status hw_mmu_disable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_NumLockedSet(const void __iomem *baseAddress,
-					u32 numLockedEntries);
+extern hw_status hw_mmu_num_locked_set(const void __iomem *baseAddress,
+				       u32 numLockedEntries);
 
-extern HW_STATUS HW_MMU_VictimNumSet(const void __iomem *baseAddress,
-					u32 victimEntryNum);
+extern hw_status hw_mmu_victim_num_set(const void __iomem *baseAddress,
+				       u32 victimEntryNum);
 
 /* For MMU faults */
-extern HW_STATUS HW_MMU_EventAck(const void __iomem *baseAddress,
-				    u32 irqMask);
+extern hw_status hw_mmu_event_ack(const void __iomem *baseAddress,
+				  u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventDisable(const void __iomem *baseAddress,
-					u32 irqMask);
+extern hw_status hw_mmu_event_disable(const void __iomem *baseAddress,
+				      u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventEnable(const void __iomem *baseAddress,
-				       u32 irqMask);
+extern hw_status hw_mmu_event_enable(const void __iomem *baseAddress,
+				     u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventStatus(const void __iomem *baseAddress,
-				       u32 *irqMask);
+extern hw_status hw_mmu_event_status(const void __iomem *baseAddress,
+				     u32 *irqMask);
 
-extern HW_STATUS HW_MMU_FaultAddrRead(const void __iomem *baseAddress,
-					 u32 *addr);
+extern hw_status hw_mmu_fault_addr_read(const void __iomem *baseAddress,
+					u32 *addr);
 
 /* Set the TT base address */
-extern HW_STATUS HW_MMU_TTBSet(const void __iomem *baseAddress,
-				  u32 TTBPhysAddr);
-
-extern HW_STATUS HW_MMU_TWLEnable(const void __iomem *baseAddress);
+extern hw_status hw_mmu_ttb_set(const void __iomem *baseAddress,
+				u32 TTBPhysAddr);
 
-extern HW_STATUS HW_MMU_TWLDisable(const void __iomem *baseAddress);
+extern hw_status hw_mmu_twl_enable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_TLBFlush(const void __iomem *baseAddress,
-				    u32 virtualAddr,
-				    u32 pageSize);
+extern hw_status hw_mmu_twl_disable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_TLBAdd(const void __iomem *baseAddress,
-				  u32	   physicalAddr,
-				  u32	   virtualAddr,
-				  u32	   pageSize,
-				  u32	    entryNum,
-				  struct HW_MMUMapAttrs_t *mapAttrs,
-				  s8 preservedBit, s8 validBit);
+extern hw_status hw_mmu_tlb_flush(const void __iomem *baseAddress,
+				  u32 virtualAddr, u32 pageSize);
 
+extern hw_status hw_mmu_tlb_add(const void __iomem *baseAddress,
+				u32 physicalAddr,
+				u32 virtualAddr,
+				u32 pageSize,
+				u32 entryNum,
+				struct hw_mmu_map_attrs_t *map_attrs,
+				s8 preservedBit, s8 validBit);
 
 /* For PTEs */
-extern HW_STATUS HW_MMU_PteSet(const u32     pgTblVa,
-				  u32	   physicalAddr,
-				  u32	   virtualAddr,
-				  u32	   pageSize,
-				  struct HW_MMUMapAttrs_t *mapAttrs);
+extern hw_status hw_mmu_pte_set(const u32 pg_tbl_va,
+				u32 physicalAddr,
+				u32 virtualAddr,
+				u32 pageSize,
+				struct hw_mmu_map_attrs_t *map_attrs);
 
-extern HW_STATUS HW_MMU_PteClear(const u32   pgTblVa,
-				    u32	 pgSize,
-				    u32	 virtualAddr);
+extern hw_status hw_mmu_pte_clear(const u32 pg_tbl_va,
+				  u32 page_size, u32 virtualAddr);
 
-static inline u32 HW_MMU_PteAddrL1(u32 L1_base, u32 va)
+static inline u32 hw_mmu_pte_addr_l1(u32 L1_base, u32 va)
 {
-	u32 pteAddr;
-	u32 VA_31_to_20;
+	u32 pte_addr;
+	u32 va31_to20;
 
-	VA_31_to_20  = va >> (20 - 2); /* Left-shift by 2 here itself */
-	VA_31_to_20 &= 0xFFFFFFFCUL;
-	pteAddr = L1_base + VA_31_to_20;
+	va31_to20 = va >> (20 - 2);	/* Left-shift by 2 here itself */
+	va31_to20 &= 0xFFFFFFFCUL;
+	pte_addr = L1_base + va31_to20;
 
-	return pteAddr;
+	return pte_addr;
 }
 
-static inline u32 HW_MMU_PteAddrL2(u32 L2_base, u32 va)
+static inline u32 hw_mmu_pte_addr_l2(u32 L2_base, u32 va)
 {
-	u32 pteAddr;
+	u32 pte_addr;
 
-	pteAddr = (L2_base & 0xFFFFFC00) | ((va >> 10) & 0x3FC);
+	pte_addr = (L2_base & 0xFFFFFC00) | ((va >> 10) & 0x3FC);
 
-	return pteAddr;
+	return pte_addr;
 }
 
-static inline u32 HW_MMU_PteCoarseL1(u32 pteVal)
+static inline u32 hw_mmu_pte_coarse_l1(u32 pte_val)
 {
-	u32 pteCoarse;
+	u32 pte_coarse;
 
-	pteCoarse = pteVal & 0xFFFFFC00;
+	pte_coarse = pte_val & 0xFFFFFC00;
 
-	return pteCoarse;
+	return pte_coarse;
 }
 
-static inline u32 HW_MMU_PteSizeL1(u32 pteVal)
+static inline u32 hw_mmu_pte_size_l1(u32 pte_val)
 {
-	u32 pteSize = 0;
+	u32 pte_size = 0;
 
-	if ((pteVal & 0x3) == 0x1) {
+	if ((pte_val & 0x3) == 0x1) {
 		/* Points to L2 PT */
-		pteSize = HW_MMU_COARSE_PAGE_SIZE;
+		pte_size = HW_MMU_COARSE_PAGE_SIZE;
 	}
 
-	if ((pteVal & 0x3) == 0x2) {
-		if (pteVal & (1 << 18))
-			pteSize = HW_PAGE_SIZE_16MB;
+	if ((pte_val & 0x3) == 0x2) {
+		if (pte_val & (1 << 18))
+			pte_size = HW_PAGE_SIZE16MB;
 		else
-			pteSize = HW_PAGE_SIZE_1MB;
+			pte_size = HW_PAGE_SIZE1MB;
 	}
 
-	return pteSize;
+	return pte_size;
 }
 
-static inline u32 HW_MMU_PteSizeL2(u32 pteVal)
+static inline u32 hw_mmu_pte_size_l2(u32 pte_val)
 {
-    u32 pteSize = 0;
+	u32 pte_size = 0;
 
-    if (pteVal & 0x2)
-	pteSize = HW_PAGE_SIZE_4KB;
-    else if (pteVal & 0x1)
-	pteSize = HW_PAGE_SIZE_64KB;
+	if (pte_val & 0x2)
+		pte_size = HW_PAGE_SIZE4KB;
+	else if (pte_val & 0x1)
+		pte_size = HW_PAGE_SIZE64KB;
 
-    return pteSize;
+	return pte_size;
 }
 
-#endif  /* __HW_MMU_H */
+#endif /* _HW_MMU_H */
diff --git a/drivers/dsp/bridge/hw/hw_prcm.c b/drivers/dsp/bridge/hw/hw_prcm.c
index 703ca67..8c95dac 100644
--- a/drivers/dsp/bridge/hw/hw_prcm.c
+++ b/drivers/dsp/bridge/hw/hw_prcm.c
@@ -21,45 +21,47 @@
 #include <hw_defs.h>
 #include <hw_prcm.h>
 
-static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
-				    enum HW_RstModule_t r, s8 val);
+static hw_status hw_rst_write_val(const void __iomem *baseAddress,
+				  enum hw_rst_module_t r, s8 val);
 
-HW_STATUS HW_RST_Reset(const void __iomem *baseAddress, enum HW_RstModule_t r)
+hw_status hw_rst_reset(const void __iomem *baseAddress, enum hw_rst_module_t r)
 {
-	return HW_RST_WriteVal(baseAddress, r, HW_SET);
+	return hw_rst_write_val(baseAddress, r, HW_SET);
 }
 
-HW_STATUS HW_RST_UnReset(const void __iomem *baseAddress, enum HW_RstModule_t r)
+hw_status hw_rst_un_reset(const void __iomem *baseAddress,
+			  enum hw_rst_module_t r)
 {
-	return HW_RST_WriteVal(baseAddress, r, HW_CLEAR);
+	return hw_rst_write_val(baseAddress, r, HW_CLEAR);
 }
 
-static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
-				    enum HW_RstModule_t r, s8 val)
+static hw_status hw_rst_write_val(const void __iomem *baseAddress,
+				  enum hw_rst_module_t r, s8 val)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
 	switch (r) {
 	case HW_RST1_IVA2:
-	    PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress, val);
-	    break;
+		PRM_RSTCTRL_IVA2RST1_DSP_WRITE32(baseAddress, val);
+		break;
 	case HW_RST2_IVA2:
-	    PRM_RSTCTRL_IVA2RST2_DSPWrite32(baseAddress, val);
-	    break;
+		PRM_RSTCTRL_IVA2RST2_DSP_WRITE32(baseAddress, val);
+		break;
 	case HW_RST3_IVA2:
-	    PRM_RSTCTRL_IVA2RST3_DSPWrite32(baseAddress, val);
-	    break;
+		PRM_RSTCTRL_IVA2RST3_DSP_WRITE32(baseAddress, val);
+		break;
 	default:
-	    status = RET_FAIL;
-	    break;
+		status = RET_FAIL;
+		break;
 	}
 	return status;
 }
 
-HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
-		enum HW_PwrModule_t p, enum HW_PwrState_t *value)
+hw_status hw_pwr_iva2_state_get(const void __iomem *baseAddress,
+				enum hw_pwr_module_t p,
+				enum hw_pwr_state_t *value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 	u32 temp;
 
 	switch (p) {
@@ -67,13 +69,13 @@ HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
 		/* wait until Transition is complete */
 		do {
 			/* mdelay(1); */
-			temp = PRCMPM_PWSTST_IVA2InTransitionRead32
-				(baseAddress);
+			temp = PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32
+			    (baseAddress);
 
 		} while (temp);
 
-		temp = PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress);
-		*value = PRCMPM_PWSTST_IVA2PowerStateStGet32(temp);
+		temp = PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress);
+		*value = PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32(temp);
 		break;
 
 	default:
@@ -83,33 +85,35 @@ HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
 	return status;
 }
 
-HW_STATUS HW_PWRST_IVA2RegGet(const void __iomem *baseAddress, u32 *value)
+hw_status hw_pwrst_iva2_reg_get(const void __iomem *baseAddress, u32 *value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-	*value = PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress);
+	*value = PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress);
 
 	return status;
 }
 
-
-HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
-				     enum HW_PwrModule_t p,
-				     enum HW_PwrState_t value)
+hw_status hw_pwr_iva2_power_state_set(const void __iomem *baseAddress,
+				      enum hw_pwr_module_t p,
+				      enum hw_pwr_state_t value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
 	switch (p) {
 	case HW_PWR_DOMAIN_DSP:
 		switch (value) {
 		case HW_PWR_STATE_ON:
-			PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32(baseAddress);
+			PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32
+			    (baseAddress);
 			break;
 		case HW_PWR_STATE_RET:
-			PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32(baseAddress);
+			PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32
+			    (baseAddress);
 			break;
 		case HW_PWR_STATE_OFF:
-			PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32(baseAddress);
+			PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32
+			    (baseAddress);
 			break;
 		default:
 			status = RET_FAIL;
@@ -125,33 +129,33 @@ HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
 	return status;
 }
 
-HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const void __iomem *baseAddress,
-				      enum HW_TransitionState_t val)
+hw_status hw_pwr_clkctrl_iva2_reg_set(const void __iomem *baseAddress,
+				      enum hw_transition_state_t val)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-	PRCMCM_CLKSTCTRL_IVA2WriteRegister32(baseAddress, val);
+	PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32(baseAddress, val);
 
 	return status;
 
 }
 
-HW_STATUS HW_RSTST_RegGet(const void __iomem *baseAddress,
-		enum HW_RstModule_t m, u32 *value)
+hw_status hw_rstst_reg_get(const void __iomem *baseAddress,
+			   enum hw_rst_module_t m, u32 *value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-	*value = PRCMRM_RSTST_DSPReadRegister32(baseAddress);
+	*value = PRCMRM_RSTST_DSP_READ_REGISTER32(baseAddress);
 
 	return status;
 }
 
-HW_STATUS HW_RSTCTRL_RegGet(const void __iomem *baseAddress,
-		enum HW_RstModule_t m, u32 *value)
+hw_status hw_rstctrl_reg_get(const void __iomem *baseAddress,
+			     enum hw_rst_module_t m, u32 *value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-	*value = PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress);
+	*value = PRCMRM_RSTCTRL_DSP_READ_REGISTER32(baseAddress);
 
 	return status;
 }
diff --git a/drivers/dsp/bridge/hw/hw_prcm.h b/drivers/dsp/bridge/hw/hw_prcm.h
index 07f16ff..fd07f32 100644
--- a/drivers/dsp/bridge/hw/hw_prcm.h
+++ b/drivers/dsp/bridge/hw/hw_prcm.h
@@ -16,146 +16,141 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __HW_PRCM_H
-#define __HW_PRCM_H
+#ifndef _HW_PRCM_H
+#define _HW_PRCM_H
 
 /* HW_ClkModule:  Enumerated Type used to specify the clock domain */
 
-enum HW_ClkModule_t {
+enum hw_clk_module_t {
 /* DSP Domain */
-    HW_CLK_DSP_CPU,
-    HW_CLK_DSP_IPI_MMU,
-    HW_CLK_IVA_ARM,
-    HW_CLK_IVA_COP,	/* IVA Coprocessor */
+	HW_CLK_DSP_CPU,
+	HW_CLK_DSP_IPI_MMU,
+	HW_CLK_IVA_ARM,
+	HW_CLK_IVA_COP,		/* IVA Coprocessor */
 
 /* Core Domain */
-    HW_CLK_FN_WDT4,	/* Functional Clock */
-    HW_CLK_FN_WDT3,
-    HW_CLK_FN_UART2,
-    HW_CLK_FN_UART1,
-    HW_CLK_GPT5,
-    HW_CLK_GPT6,
-    HW_CLK_GPT7,
-    HW_CLK_GPT8,
-
-    HW_CLK_IF_WDT4,	/* Interface Clock */
-    HW_CLK_IF_WDT3,
-    HW_CLK_IF_UART2,
-    HW_CLK_IF_UART1,
-    HW_CLK_IF_MBOX
-
-} ;
-
-enum HW_ClkSubsys_t {
-    HW_CLK_DSPSS,
-    HW_CLK_IVASS
-} ;
+	HW_CLK_FN_WDT4,		/* Functional Clock */
+	HW_CLK_FN_WDT3,
+	HW_CLK_FN_UART2,
+	HW_CLK_FN_UART1,
+	HW_CLK_GPT5,
+	HW_CLK_GPT6,
+	HW_CLK_GPT7,
+	HW_CLK_GPT8,
+
+	HW_CLK_IF_WDT4,		/* Interface Clock */
+	HW_CLK_IF_WDT3,
+	HW_CLK_IF_UART2,
+	HW_CLK_IF_UART1,
+	HW_CLK_IF_MBOX
+};
+
+enum hw_clk_subsys_t {
+	HW_CLK_DSPSS,
+	HW_CLK_IVASS
+};
 
 /* HW_GPtimers:  General purpose timers */
-enum HW_GPtimer_t {
-    HW_GPT5 = 5,
-    HW_GPT6 = 6,
-    HW_GPT7 = 7,
-    HW_GPT8 = 8
-} ;
-
+enum hw_g_ptimer_t {
+	HW_GPT5 = 5,
+	HW_GPT6 = 6,
+	HW_GPT7 = 7,
+	HW_GPT8 = 8
+};
 
 /* GP timers Input clock type:  General purpose timers */
-enum HW_Clocktype_t {
-    HW_CLK_32KHz = 0,
-    HW_CLK_SYS   = 1,
-    HW_CLK_EXT   = 2
-} ;
+enum hw_clocktype_t {
+	HW_CLK32K_HZ = 0,
+	HW_CLK_SYS = 1,
+	HW_CLK_EXT = 2
+};
 
 /* HW_ClkDiv:  Clock divisors */
-enum HW_ClkDiv_t {
-    HW_CLK_DIV_1 = 0x1,
-    HW_CLK_DIV_2 = 0x2,
-    HW_CLK_DIV_3 = 0x3,
-    HW_CLK_DIV_4 = 0x4,
-    HW_CLK_DIV_6 = 0x6,
-    HW_CLK_DIV_8 = 0x8,
-    HW_CLK_DIV_12 = 0xC
-} ;
+enum hw_clk_div_t {
+	HW_CLK_DIV1 = 0x1,
+	HW_CLK_DIV2 = 0x2,
+	HW_CLK_DIV3 = 0x3,
+	HW_CLK_DIV4 = 0x4,
+	HW_CLK_DIV6 = 0x6,
+	HW_CLK_DIV8 = 0x8,
+	HW_CLK_DIV12 = 0xC
+};
 
 /* HW_RstModule:  Enumerated Type used to specify the module to be reset */
-enum HW_RstModule_t {
-    HW_RST1_IVA2,  /* Reset the DSP */
-    HW_RST2_IVA2,  /* Reset MMU and LEON HWa */
-    HW_RST3_IVA2   /* Reset LEON sequencer */
-} ;
+enum hw_rst_module_t {
+	HW_RST1_IVA2,		/* Reset the DSP */
+	HW_RST2_IVA2,		/* Reset MMU and LEON HWa */
+	HW_RST3_IVA2		/* Reset LEON sequencer */
+};
 
 /* HW_PwrModule:  Enumerated Type used to specify the power domain */
-enum HW_PwrModule_t {
+enum hw_pwr_module_t {
 /* Domains */
-    HW_PWR_DOMAIN_CORE,
-    HW_PWR_DOMAIN_MPU,
-    HW_PWR_DOMAIN_WAKEUP,
-    HW_PWR_DOMAIN_DSP,
+	HW_PWR_DOMAIN_CORE,
+	HW_PWR_DOMAIN_MPU,
+	HW_PWR_DOMAIN_WAKEUP,
+	HW_PWR_DOMAIN_DSP,
 
 /* Sub-domains */
-    HW_PWR_DSP_IPI,	/* IPI = Intrusive Port Interface */
-    HW_PWR_IVA_ISP	 /* ISP = Intrusive Slave Port */
-} ;
-
-enum HW_PwrState_t {
-    HW_PWR_STATE_OFF,
-    HW_PWR_STATE_RET,
-    HW_PWR_STATE_INACT,
-    HW_PWR_STATE_ON = 3
-} ;
-
-enum HW_ForceState_t {
-    HW_FORCE_OFF,
-    HW_FORCE_ON
-} ;
-
-enum HW_IdleState_t {
-    HW_ACTIVE,
-    HW_STANDBY
-
-} ;
-
-enum HW_TransitionState_t {
-    HW_AUTOTRANS_DIS,
-    HW_SW_SUP_SLEEP,
-    HW_SW_SUP_WAKEUP,
-    HW_AUTOTRANS_EN
-} ;
-
-
-extern HW_STATUS HW_RST_Reset(const void __iomem *baseAddress,
-				 enum HW_RstModule_t r);
-
-extern HW_STATUS HW_RST_UnReset(const void __iomem *baseAddress,
-				   enum HW_RstModule_t r);
-
-extern HW_STATUS HW_RSTCTRL_RegGet(const void __iomem *baseAddress,
-					     enum HW_RstModule_t p,
-					     u32 *value);
-extern HW_STATUS HW_RSTST_RegGet(const void __iomem *baseAddress,
-					   enum HW_RstModule_t p, u32 *value);
-
-extern HW_STATUS HW_PWR_PowerStateSet(const u32 baseAddress,
-						enum HW_PwrModule_t p,
-						enum HW_PwrState_t value);
-
-extern HW_STATUS HW_CLK_SetInputClock(const u32 baseAddress,
-					enum HW_GPtimer_t gpt,
-					enum HW_Clocktype_t c);
-
-extern HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
-					enum HW_PwrModule_t p,
-					enum HW_PwrState_t *value);
-
-extern HW_STATUS HW_PWRST_IVA2RegGet(const void __iomem *baseAddress,
-						u32 *value);
-
-extern HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
-					    enum HW_PwrModule_t p,
-					    enum HW_PwrState_t value);
-
-extern HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const void __iomem *baseAddress,
-					     enum HW_TransitionState_t val);
-
-#endif  /* __HW_PRCM_H */
+	HW_PWR_DSP_IPI,		/* IPI = Intrusive Port Interface */
+	HW_PWR_IVA_ISP		/* ISP = Intrusive Slave Port */
+};
+
+enum hw_pwr_state_t {
+	HW_PWR_STATE_OFF,
+	HW_PWR_STATE_RET,
+	HW_PWR_STATE_INACT,
+	HW_PWR_STATE_ON = 3
+};
+
+enum hw_force_state_t {
+	HW_FORCE_OFF,
+	HW_FORCE_ON
+};
+
+enum hw_idle_state_t {
+	HW_ACTIVE,
+	HW_STANDBY
+};
+
+enum hw_transition_state_t {
+	HW_AUTOTRANS_DIS,
+	HW_SW_SUP_SLEEP,
+	HW_SW_SUP_WAKEUP,
+	HW_AUTOTRANS_EN
+};
+
+extern hw_status hw_rst_reset(const void __iomem *baseAddress,
+			      enum hw_rst_module_t r);
+
+extern hw_status hw_rst_un_reset(const void __iomem *baseAddress,
+				 enum hw_rst_module_t r);
+
+extern hw_status hw_rstctrl_reg_get(const void __iomem *baseAddress,
+				    enum hw_rst_module_t p, u32 *value);
+extern hw_status hw_rstst_reg_get(const void __iomem *baseAddress,
+				  enum hw_rst_module_t p, u32 *value);
+
+extern hw_status hw_pwr_power_state_set(const u32 baseAddress,
+					enum hw_pwr_module_t p,
+					enum hw_pwr_state_t value);
+
+extern hw_status hw_clk_set_input_clock(const u32 baseAddress,
+					enum hw_g_ptimer_t gpt,
+					enum hw_clocktype_t c);
+
+extern hw_status hw_pwr_iva2_state_get(const void __iomem *baseAddress,
+				       enum hw_pwr_module_t p,
+				       enum hw_pwr_state_t *value);
+
+extern hw_status hw_pwrst_iva2_reg_get(const void __iomem *baseAddress,
+				       u32 *value);
+
+extern hw_status hw_pwr_iva2_power_state_set(const void __iomem *baseAddress,
+					     enum hw_pwr_module_t p,
+					     enum hw_pwr_state_t value);
+
+extern hw_status hw_pwr_clkctrl_iva2_reg_set(const void __iomem *baseAddress,
+					     enum hw_transition_state_t val);
+
+#endif /* _HW_PRCM_H */
diff --git a/drivers/dsp/bridge/pmgr/chnl.c b/drivers/dsp/bridge/pmgr/chnl.c
index cf74cc5..1300d38 100644
--- a/drivers/dsp/bridge/pmgr/chnl.c
+++ b/drivers/dsp/bridge/pmgr/chnl.c
@@ -45,128 +45,125 @@
 #include <dspbridge/chnl.h>
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;
+static u32 refs;
 
 /*
- *  ======== CHNL_Create ========
+ *  ======== chnl_create ========
  *  Purpose:
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given 'Bridge board.
  */
-DSP_STATUS CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-		       struct DEV_OBJECT *hDevObject,
-		       IN CONST struct CHNL_MGRATTRS *pMgrAttrs)
+dsp_status chnl_create(OUT struct chnl_mgr **phChnlMgr,
+		       struct dev_object *hdev_obj,
+		       IN CONST struct chnl_mgrattrs *pMgrAttrs)
 {
-	DSP_STATUS status;
-	struct CHNL_MGR *hChnlMgr;
-	struct CHNL_MGR_ *pChnlMgr = NULL;
+	dsp_status status;
+	struct chnl_mgr *hchnl_mgr;
+	struct chnl_mgr_ *chnl_mgr_obj = NULL;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phChnlMgr != NULL);
-	DBC_Require(pMgrAttrs != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phChnlMgr != NULL);
+	DBC_REQUIRE(pMgrAttrs != NULL);
 
 	*phChnlMgr = NULL;
 
 	/* Validate args: */
-	if ((0 < pMgrAttrs->cChannels) &&
-	   (pMgrAttrs->cChannels <= CHNL_MAXCHANNELS))
+	if ((0 < pMgrAttrs->max_channels) &&
+	    (pMgrAttrs->max_channels <= CHNL_MAXCHANNELS))
 		status = DSP_SOK;
-	else if (pMgrAttrs->cChannels == 0)
+	else if (pMgrAttrs->max_channels == 0)
 		status = DSP_EINVALIDARG;
 	else
 		status = CHNL_E_MAXCHANNELS;
 
-	if (pMgrAttrs->uWordSize == 0)
+	if (pMgrAttrs->word_size == 0)
 		status = CHNL_E_INVALIDWORDSIZE;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetChnlMgr(hDevObject, &hChnlMgr);
-		if (DSP_SUCCEEDED(status) && hChnlMgr != NULL)
+		status = dev_get_chnl_mgr(hdev_obj, &hchnl_mgr);
+		if (DSP_SUCCEEDED(status) && hchnl_mgr != NULL)
 			status = CHNL_E_MGREXISTS;
 
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		struct WMD_DRV_INTERFACE *pIntfFxns;
-		status = DEV_GetIntfFxns(hDevObject, &pIntfFxns);
-		if (pIntfFxns) {
+		struct bridge_drv_interface *intf_fxns;
+		dev_get_intf_fxns(hdev_obj, &intf_fxns);
+		if (intf_fxns) {
 			/* Let WMD channel module finish the create */
-			status = (*pIntfFxns->pfnChnlCreate)(&hChnlMgr,
-						hDevObject, pMgrAttrs);
+			status = (*intf_fxns->pfn_chnl_create)(&hchnl_mgr,
+						hdev_obj, pMgrAttrs);
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Fill in WCD channel module's fields of the
-			 * CHNL_MGR structure */
-			pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
-			pChnlMgr->pIntfFxns = pIntfFxns;
+			 * chnl_mgr structure */
+			chnl_mgr_obj = (struct chnl_mgr_ *)hchnl_mgr;
+			chnl_mgr_obj->intf_fxns = intf_fxns;
 			/* Finally, return the new channel manager handle: */
-			*phChnlMgr = hChnlMgr;
+			*phChnlMgr = hchnl_mgr;
 		}
 	}
 
-	DBC_Ensure(DSP_FAILED(status) || CHNL_IsValidMgr(pChnlMgr));
+	DBC_ENSURE(DSP_FAILED(status) || CHNL_IS_VALID_MGR(chnl_mgr_obj));
 
 	return status;
 }
 
 /*
- *  ======== CHNL_Destroy ========
+ *  ======== chnl_destroy ========
  *  Purpose:
  *      Close all open channels, and destroy the channel manager.
  */
-DSP_STATUS CHNL_Destroy(struct CHNL_MGR *hChnlMgr)
+dsp_status chnl_destroy(struct chnl_mgr *hchnl_mgr)
 {
-	struct CHNL_MGR_ *pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status;
+	struct chnl_mgr_ *chnl_mgr_obj = (struct chnl_mgr_ *)hchnl_mgr;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (CHNL_IsValidMgr(pChnlMgr)) {
-		pIntfFxns = pChnlMgr->pIntfFxns;
-		/* Let WMD channel module destroy the CHNL_MGR: */
-		status = (*pIntfFxns->pfnChnlDestroy)(hChnlMgr);
+	if (CHNL_IS_VALID_MGR(chnl_mgr_obj)) {
+		intf_fxns = chnl_mgr_obj->intf_fxns;
+		/* Let WMD channel module destroy the chnl_mgr: */
+		status = (*intf_fxns->pfn_chnl_destroy) (hchnl_mgr);
 	} else {
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_FAILED(status) || !CHNL_IsValidMgr(pChnlMgr));
+	DBC_ENSURE(DSP_FAILED(status) || !CHNL_IS_VALID_MGR(chnl_mgr_obj));
 
 	return status;
 }
 
 /*
- *  ======== CHNL_Exit ========
+ *  ======== chnl_exit ========
  *  Purpose:
  *      Discontinue usage of the CHNL module.
  */
-void CHNL_Exit(void)
+void chnl_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
-
 /*
- *  ======== CHNL_Init ========
+ *  ======== chnl_init ========
  *  Purpose:
  *      Initialize the CHNL module's private state.
  */
-bool CHNL_Init(void)
+bool chnl_init(void)
 {
-	bool fRetval = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (fRetval)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
-
-
diff --git a/drivers/dsp/bridge/pmgr/chnlobj.h b/drivers/dsp/bridge/pmgr/chnlobj.h
index 3c2b14f..ceff374 100644
--- a/drivers/dsp/bridge/pmgr/chnlobj.h
+++ b/drivers/dsp/bridge/pmgr/chnlobj.h
@@ -24,33 +24,32 @@
 #include <dspbridge/wmd.h>
 
 /* Object validateion macros: */
-#define CHNL_IsValidMgr(h) \
-		((h != NULL) && ((h)->dwSignature == CHNL_MGRSIGNATURE))
+#define CHNL_IS_VALID_MGR(h) \
+		((h != NULL) && ((h)->dw_signature == CHNL_MGRSIGNATURE))
 
-#define CHNL_IsValidChnl(h)\
-		((h != NULL) && ((h)->dwSignature == CHNL_SIGNATURE))
+#define CHNL_IS_VALID_CHNL(h)\
+		((h != NULL) && ((h)->dw_signature == CHNL_SIGNATURE))
 
 /*
- *  This struct is the first field in a CHNL_MGR struct, as implemented in
+ *  This struct is the first field in a chnl_mgr struct, as implemented in
  *  a WMD channel class library.  Other, implementation specific fields
  *  follow this structure in memory.
  */
-struct CHNL_MGR_ {
-	/* These must be the first fields in a CHNL_MGR struct: */
-	u32 dwSignature;	/* Used for object validation.   */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
-} ;
+struct chnl_mgr_ {
+	/* These must be the first fields in a chnl_mgr struct: */
+	u32 dw_signature;	/* Used for object validation. */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD. */
+};
 
 /*
- *  This struct is the first field in a CHNL_OBJECT struct, as implemented in
+ *  This struct is the first field in a chnl_object struct, as implemented in
  *  a WMD channel class library.  Other, implementation specific fields
  *  follow this structure in memory.
  */
-struct CHNL_OBJECT_ {
-	/* These must be the first fields in a CHNL_OBJECT struct: */
-	u32 dwSignature;	/* Used for object validation.      */
-	struct CHNL_MGR_ *pChnlMgr;	/* Pointer back to channel manager. */
-} ;
-
-#endif				/* CHNLOBJ_ */
+struct chnl_object_ {
+	/* These must be the first fields in a chnl_object struct: */
+	u32 dw_signature;	/* Used for object validation. */
+	struct chnl_mgr_ *chnl_mgr_obj;	/* Pointer back to channel manager. */
+};
 
+#endif /* CHNLOBJ_ */
diff --git a/drivers/dsp/bridge/pmgr/cmm.c b/drivers/dsp/bridge/pmgr/cmm.c
index 5401b41..7974014 100644
--- a/drivers/dsp/bridge/pmgr/cmm.c
+++ b/drivers/dsp/bridge/pmgr/cmm.c
@@ -55,10 +55,10 @@
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 /* Object signatures */
 #define CMMSIGNATURE       0x004d4d43	/* "CMM"   (in reverse) */
-#define SMEMSIGNATURE      0x4D454D53	/* "SMEM"  SM space     */
-#define CMMXLATESIGNATURE  0x584d4d43	/* "CMMX"  CMM Xlator   */
+#define SMEMSIGNATURE      0x4D454D53	/* "SMEM"  SM space */
+#define CMMXLATESIGNATURE  0x584d4d43	/* "CMMX"  CMM Xlator */
 
-#define NEXT_PA(pNode)   (pNode->dwPA + pNode->ulSize)
+#define NEXT_PA(pnode)   (pnode->dw_pa + pnode->ul_size)
 
 /* Other bus/platform translations */
 #define DSPPA2GPPPA(base, x, y)  ((x)+(y))
@@ -70,231 +70,240 @@
  *      sma - shared memory allocator.
  *      vma - virtual memory allocator.(not used).
  */
-struct CMM_ALLOCATOR {	/* sma */
-	u32 dwSignature;	/* SMA allocator signature SMEMSIGNATURE */
-	unsigned int dwSmBase;		/* Start of physical SM block */
-	u32 ulSmSize;		/* Size of SM block in bytes */
-	unsigned int dwVmBase;		/* Start of VM block. (Dev driver
-				 * context for 'sma') */
-	u32 dwDSPPhysAddrOffset;	/* DSP PA to GPP PA offset for this
+struct cmm_allocator {		/* sma */
+	u32 dw_signature;	/* SMA allocator signature SMEMSIGNATURE */
+	unsigned int shm_base;	/* Start of physical SM block */
+	u32 ul_sm_size;		/* Size of SM block in bytes */
+	unsigned int dw_vm_base;	/* Start of VM block. (Dev driver
+					 * context for 'sma') */
+	u32 dw_dsp_phys_addr_offset;	/* DSP PA to GPP PA offset for this
 					 * SM space */
-	s8 cFactor;			/* DSPPa to GPPPa Conversion Factor */
-	unsigned int dwDSPBase;	/* DSP virt base byte address */
-	u32 ulDSPSize;	/* DSP seg size in bytes */
-	struct CMM_OBJECT *hCmmMgr;	/* back ref to parent mgr */
-	struct LST_LIST *pFreeListHead;	/* node list of available memory */
-	struct LST_LIST *pInUseListHead;	/* node list of memory in use */
-} ;
-
-struct CMM_XLATOR {	/* Pa<->Va translator object */
-	u32 dwSignature;	/* "CMMX" */
-	struct CMM_OBJECT *hCmmMgr;  /* CMM object this translator associated */
+	s8 c_factor;		/* DSPPa to GPPPa Conversion Factor */
+	unsigned int dw_dsp_base;	/* DSP virt base byte address */
+	u32 ul_dsp_size;	/* DSP seg size in bytes */
+	struct cmm_object *hcmm_mgr;	/* back ref to parent mgr */
+	/* node list of available memory */
+	struct lst_list *free_list_head;
+	/* node list of memory in use */
+	struct lst_list *in_use_list_head;
+};
+
+struct cmm_xlator {		/* Pa<->Va translator object */
+	u32 dw_signature;	/* "CMMX" */
+	/* CMM object this translator associated */
+	struct cmm_object *hcmm_mgr;
 	/*
 	 *  Client process virtual base address that corresponds to phys SM
-	 *  base address for translator's ulSegId.
+	 *  base address for translator's ul_seg_id.
 	 *  Only 1 segment ID currently supported.
 	 */
-	unsigned int dwVirtBase;	/* virtual base address */
-	u32 ulVirtSize;	/* size of virt space in bytes */
-	u32 ulSegId;		/* Segment Id */
-} ;
+	unsigned int dw_virt_base;	/* virtual base address */
+	u32 ul_virt_size;	/* size of virt space in bytes */
+	u32 ul_seg_id;		/* Segment Id */
+};
 
 /* CMM Mgr */
-struct CMM_OBJECT {
-	u32 dwSignature;	/* Used for object validation */
+struct cmm_object {
+	u32 dw_signature;	/* Used for object validation */
 	/*
 	 * Cmm Lock is used to serialize access mem manager for multi-threads.
 	 */
-	struct SYNC_CSOBJECT *hCmmLock;	/* Lock to access cmm mgr */
-	struct LST_LIST *pNodeFreeListHead;	/* Free list of memory nodes */
-	u32 ulMinBlockSize;	/* Min SM block; default 16 bytes */
-	u32 dwPageSize;	/* Memory Page size (1k/4k) */
+	struct mutex cmm_lock;	/* Lock to access cmm mgr */
+	struct lst_list *node_free_list_head;	/* Free list of memory nodes */
+	u32 ul_min_block_size;	/* Min SM block; default 16 bytes */
+	u32 dw_page_size;	/* Memory Page size (1k/4k) */
 	/* GPP SM segment ptrs */
-	struct CMM_ALLOCATOR *paGPPSMSegTab[CMM_MAXGPPSEGS];
-} ;
+	struct cmm_allocator *pa_gppsm_seg_tab[CMM_MAXGPPSEGS];
+};
 
 /* Default CMM Mgr attributes */
-static struct CMM_MGRATTRS CMM_DFLTMGRATTRS = {
-	16	/* ulMinBlockSize, min block size(bytes) allocated by cmm mgr */
+static struct cmm_mgrattrs cmm_dfltmgrattrs = {
+	/* ul_min_block_size, min block size(bytes) allocated by cmm mgr */
+	16
 };
 
 /* Default allocation attributes */
-static struct CMM_ATTRS CMM_DFLTALCTATTRS = {
-	1			/* ulSegId, default segment Id for allocator */
+static struct cmm_attrs cmm_dfltalctattrs = {
+	1		/* ul_seg_id, default segment Id for allocator */
 };
 
 /* Address translator default attrs */
-static struct CMM_XLATORATTRS CMM_DFLTXLATORATTRS = {
-	1,	/* ulSegId, does not have to match CMM_DFLTALCTATTRS ulSegId */
-	0,			/* dwDSPBufs */
-	0,			/* dwDSPBufSize */
-	NULL,			/* pVmBase */
-	0,			/* dwVmSize */
+static struct cmm_xlatorattrs cmm_dfltxlatorattrs = {
+	/* ul_seg_id, does not have to match cmm_dfltalctattrs ul_seg_id */
+	1,
+	0,			/* dw_dsp_bufs */
+	0,			/* dw_dsp_buf_size */
+	NULL,			/* vm_base */
+	0,			/* dw_vm_size */
 };
 
 /* SM node representing a block of memory. */
-struct CMM_MNODE {
-	struct list_head link;		/* must be 1st element */
-	u32 dwPA;		/* Phys addr */
-	u32 dwVA;		/* Virtual address in device process context */
-	u32 ulSize;		/* SM block size in bytes */
-       u32 hClientProc;        /* Process that allocated this mem block */
-} ;
-
+struct cmm_mnode {
+	struct list_head link;	/* must be 1st element */
+	u32 dw_pa;		/* Phys addr */
+	u32 dw_va;		/* Virtual address in device process context */
+	u32 ul_size;		/* SM block size in bytes */
+	u32 client_proc;	/* Process that allocated this mem block */
+};
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /*  ----------------------------------- Function Prototypes */
-static void AddToFreeList(struct CMM_ALLOCATOR *pAllocator,
-			  struct CMM_MNODE *pNode);
-static struct CMM_ALLOCATOR *GetAllocator(struct CMM_OBJECT *pCmmMgr,
-					  u32 ulSegId);
-static struct CMM_MNODE *GetFreeBlock(struct CMM_ALLOCATOR *pAllocator,
-				      u32 uSize);
-static struct CMM_MNODE *GetNode(struct CMM_OBJECT *pCmmMgr, u32 dwPA,
-				 u32 dwVA, u32 ulSize);
+static void add_to_free_list(struct cmm_allocator *allocator,
+			     struct cmm_mnode *pnode);
+static struct cmm_allocator *get_allocator(struct cmm_object *cmm_mgr_obj,
+					   u32 ul_seg_id);
+static struct cmm_mnode *get_free_block(struct cmm_allocator *allocator,
+					u32 usize);
+static struct cmm_mnode *get_node(struct cmm_object *cmm_mgr_obj, u32 dw_pa,
+				  u32 dw_va, u32 ul_size);
 /* get available slot for new allocator */
-static s32 GetSlot(struct CMM_OBJECT *hCmmMgr);
-static void UnRegisterGPPSMSeg(struct CMM_ALLOCATOR *pSMA);
+static s32 get_slot(struct cmm_object *hcmm_mgr);
+static void un_register_gppsm_seg(struct cmm_allocator *psma);
 
 /*
- *  ======== CMM_CallocBuf ========
+ *  ======== cmm_calloc_buf ========
  *  Purpose:
  *      Allocate a SM buffer, zero contents, and return the physical address
- *      and optional driver context virtual address(ppBufVA).
+ *      and optional driver context virtual address(pp_buf_va).
  *
  *      The freelist is sorted in increasing size order. Get the first
  *      block that satifies the request and sort the remaining back on
  *      the freelist; if large enough. The kept block is placed on the
  *      inUseList.
  */
-void *CMM_CallocBuf(struct CMM_OBJECT *hCmmMgr, u32 uSize,
-		    struct CMM_ATTRS *pAttrs, OUT void **ppBufVA)
+void *cmm_calloc_buf(struct cmm_object *hcmm_mgr, u32 usize,
+		     struct cmm_attrs *pattrs, OUT void **pp_buf_va)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	void *pBufPA = NULL;
-	struct CMM_MNODE *pNode = NULL;
-	struct CMM_MNODE *pNewNode = NULL;
-	struct CMM_ALLOCATOR *pAllocator = NULL;
-	u32 uDeltaSize;
-	u8 *pByte = NULL;
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	void *buf_pa = NULL;
+	struct cmm_mnode *pnode = NULL;
+	struct cmm_mnode *new_node = NULL;
+	struct cmm_allocator *allocator = NULL;
+	u32 delta_size;
+	u8 *pbyte = NULL;
 	s32 cnt;
 
-	if (pAttrs == NULL)
-		pAttrs = &CMM_DFLTALCTATTRS;
+	if (pattrs == NULL)
+		pattrs = &cmm_dfltalctattrs;
 
-	if (ppBufVA != NULL)
-		*ppBufVA = NULL;
+	if (pp_buf_va != NULL)
+		*pp_buf_va = NULL;
 
-	if ((MEM_IsValidHandle(pCmmMgr, CMMSIGNATURE)) && (uSize != 0)) {
-		if (pAttrs->ulSegId > 0) {
-			/* SegId > 0 is SM  */
+	if ((MEM_IS_VALID_HANDLE(cmm_mgr_obj, CMMSIGNATURE)) && (usize != 0)) {
+		if (pattrs->ul_seg_id > 0) {
+			/* SegId > 0 is SM */
 			/* get the allocator object for this segment id */
-			pAllocator = GetAllocator(pCmmMgr, pAttrs->ulSegId);
-			/* keep block size a multiple of ulMinBlockSize */
-			uSize = ((uSize - 1) & ~(pCmmMgr->ulMinBlockSize - 1))
-				+ pCmmMgr->ulMinBlockSize;
-			SYNC_EnterCS(pCmmMgr->hCmmLock);
-			pNode = GetFreeBlock(pAllocator, uSize);
+			allocator =
+			    get_allocator(cmm_mgr_obj, pattrs->ul_seg_id);
+			/* keep block size a multiple of ul_min_block_size */
+			usize =
+			    ((usize - 1) & ~(cmm_mgr_obj->ul_min_block_size -
+					     1))
+			    + cmm_mgr_obj->ul_min_block_size;
+			mutex_lock(&cmm_mgr_obj->cmm_lock);
+			pnode = get_free_block(allocator, usize);
 		}
-		if (pNode) {
-			uDeltaSize = (pNode->ulSize - uSize);
-			if (uDeltaSize >= pCmmMgr->ulMinBlockSize) {
+		if (pnode) {
+			delta_size = (pnode->ul_size - usize);
+			if (delta_size >= cmm_mgr_obj->ul_min_block_size) {
 				/* create a new block with the leftovers and
 				 * add to freelist */
-				pNewNode = GetNode(pCmmMgr, pNode->dwPA + uSize,
-					   pNode->dwVA + uSize,
-					   (u32)uDeltaSize);
-				if (pNewNode) {
+				new_node =
+				    get_node(cmm_mgr_obj, pnode->dw_pa + usize,
+					     pnode->dw_va + usize,
+					     (u32) delta_size);
+				if (new_node) {
 					/* leftovers go free */
-					AddToFreeList(pAllocator, pNewNode);
+					add_to_free_list(allocator, new_node);
 				}
 				/* adjust our node's size */
-				pNode->ulSize = uSize;
+				pnode->ul_size = usize;
 			}
 			/* Tag node with client process requesting allocation
 			 * We'll need to free up a process's alloc'd SM if the
 			 * client process goes away.
 			 */
 			/* Return TGID instead of process handle */
-			pNode->hClientProc = current->tgid;
+			pnode->client_proc = current->tgid;
 
 			/* put our node on InUse list */
-			LST_PutTail(pAllocator->pInUseListHead,
-				   (struct list_head *)pNode);
-			pBufPA = (void *)pNode->dwPA;	/* physical address */
+			lst_put_tail(allocator->in_use_list_head,
+				     (struct list_head *)pnode);
+			buf_pa = (void *)pnode->dw_pa;	/* physical address */
 			/* clear mem */
-			pByte = (u8 *)pNode->dwVA;
-			for (cnt = 0; cnt < (s32) uSize; cnt++, pByte++)
-				*pByte = 0;
+			pbyte = (u8 *) pnode->dw_va;
+			for (cnt = 0; cnt < (s32) usize; cnt++, pbyte++)
+				*pbyte = 0;
 
-			if (ppBufVA != NULL) {
+			if (pp_buf_va != NULL) {
 				/* Virtual address */
-				*ppBufVA = (void *)pNode->dwVA;
+				*pp_buf_va = (void *)pnode->dw_va;
 			}
 		}
-		SYNC_LeaveCS(pCmmMgr->hCmmLock);
+		mutex_unlock(&cmm_mgr_obj->cmm_lock);
 	}
-	return pBufPA;
+	return buf_pa;
 }
 
 /*
- *  ======== CMM_Create ========
+ *  ======== cmm_create ========
  *  Purpose:
  *      Create a communication memory manager object.
  */
-DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
-		      struct DEV_OBJECT *hDevObject,
-		      IN CONST struct CMM_MGRATTRS *pMgrAttrs)
+dsp_status cmm_create(OUT struct cmm_object **ph_cmm_mgr,
+		      struct dev_object *hdev_obj,
+		      IN CONST struct cmm_mgrattrs *pMgrAttrs)
 {
-	struct CMM_OBJECT *pCmmObject = NULL;
-	DSP_STATUS status = DSP_SOK;
-	struct UTIL_SYSINFO sysInfo;
+	struct cmm_object *cmm_obj = NULL;
+	dsp_status status = DSP_SOK;
+	struct util_sysinfo sys_info;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phCmmMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ph_cmm_mgr != NULL);
 
-	*phCmmMgr = NULL;
+	*ph_cmm_mgr = NULL;
 	/* create, zero, and tag a cmm mgr object */
-	MEM_AllocObject(pCmmObject, struct CMM_OBJECT, CMMSIGNATURE);
-	if (pCmmObject != NULL) {
+	MEM_ALLOC_OBJECT(cmm_obj, struct cmm_object, CMMSIGNATURE);
+	if (cmm_obj != NULL) {
 		if (pMgrAttrs == NULL)
-			pMgrAttrs = &CMM_DFLTMGRATTRS;	/* set defaults */
+			pMgrAttrs = &cmm_dfltmgrattrs;	/* set defaults */
 
 		/* 4 bytes minimum */
-		DBC_Assert(pMgrAttrs->ulMinBlockSize >= 4);
+		DBC_ASSERT(pMgrAttrs->ul_min_block_size >= 4);
 		/* save away smallest block allocation for this cmm mgr */
-		pCmmObject->ulMinBlockSize = pMgrAttrs->ulMinBlockSize;
+		cmm_obj->ul_min_block_size = pMgrAttrs->ul_min_block_size;
 		/* save away the systems memory page size */
-		sysInfo.dwPageSize = PAGE_SIZE;
-		sysInfo.dwAllocationGranularity = PAGE_SIZE;
-		sysInfo.dwNumberOfProcessors = 1;
+		sys_info.dw_page_size = PAGE_SIZE;
+		sys_info.dw_allocation_granularity = PAGE_SIZE;
+		sys_info.dw_number_of_processors = 1;
 		if (DSP_SUCCEEDED(status)) {
-			pCmmObject->dwPageSize = sysInfo.dwPageSize;
+			cmm_obj->dw_page_size = sys_info.dw_page_size;
 		} else {
-			pCmmObject->dwPageSize = 0;
+			cmm_obj->dw_page_size = 0;
 			status = DSP_EFAIL;
 		}
 		/* Note: DSP SM seg table(aDSPSMSegTab[]) zero'd by
-		 * MEM_AllocObject */
+		 * MEM_ALLOC_OBJECT */
 		if (DSP_SUCCEEDED(status)) {
 			/* create node free list */
-			pCmmObject->pNodeFreeListHead = MEM_Calloc(sizeof(struct
-				LST_LIST), MEM_NONPAGED);
-			if (pCmmObject->pNodeFreeListHead == NULL)
+			cmm_obj->node_free_list_head =
+					mem_calloc(sizeof(struct lst_list),
+						   MEM_NONPAGED);
+			if (cmm_obj->node_free_list_head == NULL)
 				status = DSP_EMEMORY;
 			else
-				INIT_LIST_HEAD(&pCmmObject->pNodeFreeListHead->
-					head);
+				INIT_LIST_HEAD(&cmm_obj->
+					       node_free_list_head->head);
 		}
 		if (DSP_SUCCEEDED(status))
-			status = SYNC_InitializeCS(&pCmmObject->hCmmLock);
+			mutex_init(&cmm_obj->cmm_lock);
 
 		if (DSP_SUCCEEDED(status))
-			*phCmmMgr = pCmmObject;
+			*ph_cmm_mgr = cmm_obj;
 		else
-			CMM_Destroy(pCmmObject, true);
+			cmm_destroy(cmm_obj, true);
 
 	} else {
 		status = DSP_EMEMORY;
@@ -303,30 +312,30 @@ DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
 }
 
 /*
- *  ======== CMM_Destroy ========
+ *  ======== cmm_destroy ========
  *  Purpose:
  *      Release the communication memory manager resources.
  */
-DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce)
+dsp_status cmm_destroy(struct cmm_object *hcmm_mgr, bool bForce)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	struct CMM_INFO tempInfo;
-	DSP_STATUS status = DSP_SOK;
-	s32 nSlot;
-	struct CMM_MNODE *pNode;
-
-	DBC_Require(cRefs > 0);
-	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	struct cmm_info temp_info;
+	dsp_status status = DSP_SOK;
+	s32 slot_seg;
+	struct cmm_mnode *pnode;
+
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
-	SYNC_EnterCS(pCmmMgr->hCmmLock);
+	mutex_lock(&cmm_mgr_obj->cmm_lock);
 	/* If not force then fail if outstanding allocations exist */
 	if (!bForce) {
 		/* Check for outstanding memory allocations */
-		status = CMM_GetInfo(hCmmMgr, &tempInfo);
+		status = cmm_get_info(hcmm_mgr, &temp_info);
 		if (DSP_SUCCEEDED(status)) {
-			if (tempInfo.ulTotalInUseCnt > 0) {
+			if (temp_info.ul_total_in_use_cnt > 0) {
 				/* outstanding allocations */
 				status = DSP_EFAIL;
 			}
@@ -334,296 +343,302 @@ DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce)
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* UnRegister SM allocator */
-		for (nSlot = 0; nSlot < CMM_MAXGPPSEGS; nSlot++) {
-			if (pCmmMgr->paGPPSMSegTab[nSlot] != NULL) {
-				UnRegisterGPPSMSeg(pCmmMgr->
-						   paGPPSMSegTab[nSlot]);
+		for (slot_seg = 0; slot_seg < CMM_MAXGPPSEGS; slot_seg++) {
+			if (cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] != NULL) {
+				un_register_gppsm_seg
+				    (cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg]);
 				/* Set slot to NULL for future reuse */
-				pCmmMgr->paGPPSMSegTab[nSlot] = NULL;
+				cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] = NULL;
 			}
 		}
 	}
-	if (pCmmMgr->pNodeFreeListHead != NULL) {
+	if (cmm_mgr_obj->node_free_list_head != NULL) {
 		/* Free the free nodes */
-		while (!LST_IsEmpty(pCmmMgr->pNodeFreeListHead)) {
-			pNode = (struct CMM_MNODE *)LST_GetHead(pCmmMgr->
-				 pNodeFreeListHead);
-			kfree(pNode);
+		while (!LST_IS_EMPTY(cmm_mgr_obj->node_free_list_head)) {
+			pnode = (struct cmm_mnode *)
+			    lst_get_head(cmm_mgr_obj->node_free_list_head);
+			kfree(pnode);
 		}
 		/* delete NodeFreeList list */
-		kfree(pCmmMgr->pNodeFreeListHead);
+		kfree(cmm_mgr_obj->node_free_list_head);
 	}
-	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	mutex_unlock(&cmm_mgr_obj->cmm_lock);
 	if (DSP_SUCCEEDED(status)) {
 		/* delete CS & cmm mgr object */
-		SYNC_DeleteCS(pCmmMgr->hCmmLock);
-		MEM_FreeObject(pCmmMgr);
+		mutex_destroy(&cmm_mgr_obj->cmm_lock);
+		MEM_FREE_OBJECT(cmm_mgr_obj);
 	}
 	return status;
 }
 
 /*
- *  ======== CMM_Exit ========
+ *  ======== cmm_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
  */
-void CMM_Exit(void)
+void cmm_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 }
 
 /*
- *  ======== CMM_FreeBuf ========
+ *  ======== cmm_free_buf ========
  *  Purpose:
  *      Free the given buffer.
  */
-DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT *hCmmMgr, void *pBufPA, u32 ulSegId)
+dsp_status cmm_free_buf(struct cmm_object *hcmm_mgr, void *buf_pa,
+			u32 ul_seg_id)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	DSP_STATUS status = DSP_EPOINTER;
-	struct CMM_MNODE *pCurNode = NULL;
-	struct CMM_ALLOCATOR *pAllocator = NULL;
-	struct CMM_ATTRS *pAttrs;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBufPA != NULL);
-
-	if (ulSegId == 0) {
-		pAttrs = &CMM_DFLTALCTATTRS;
-		ulSegId = pAttrs->ulSegId;
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	dsp_status status = DSP_EPOINTER;
+	struct cmm_mnode *mnode_obj = NULL;
+	struct cmm_allocator *allocator = NULL;
+	struct cmm_attrs *pattrs;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(buf_pa != NULL);
+
+	if (ul_seg_id == 0) {
+		pattrs = &cmm_dfltalctattrs;
+		ul_seg_id = pattrs->ul_seg_id;
 	}
-	if (!(MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) || !(ulSegId > 0)) {
+	if (!(MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) ||
+	    !(ul_seg_id > 0)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
 	/* get the allocator for this segment id */
-	pAllocator = GetAllocator(pCmmMgr, ulSegId);
-	if (pAllocator != NULL) {
-		SYNC_EnterCS(pCmmMgr->hCmmLock);
-		pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->
-			    pInUseListHead);
-		while (pCurNode) {
-			if ((u32)pBufPA == pCurNode->dwPA) {
+	allocator = get_allocator(cmm_mgr_obj, ul_seg_id);
+	if (allocator != NULL) {
+		mutex_lock(&cmm_mgr_obj->cmm_lock);
+		mnode_obj =
+		    (struct cmm_mnode *)lst_first(allocator->in_use_list_head);
+		while (mnode_obj) {
+			if ((u32) buf_pa == mnode_obj->dw_pa) {
 				/* Found it */
-				LST_RemoveElem(pAllocator->pInUseListHead,
-					      (struct list_head *)pCurNode);
+				lst_remove_elem(allocator->in_use_list_head,
+						(struct list_head *)mnode_obj);
 				/* back to freelist */
-				AddToFreeList(pAllocator, pCurNode);
+				add_to_free_list(allocator, mnode_obj);
 				status = DSP_SOK;	/* all right! */
 				break;
 			}
 			/* next node. */
-			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-					pInUseListHead,
-					(struct list_head *)pCurNode);
+			mnode_obj = (struct cmm_mnode *)
+			    lst_next(allocator->in_use_list_head,
+				     (struct list_head *)mnode_obj);
 		}
-		SYNC_LeaveCS(pCmmMgr->hCmmLock);
+		mutex_unlock(&cmm_mgr_obj->cmm_lock);
 	}
 	return status;
 }
 
 /*
- *  ======== CMM_GetHandle ========
+ *  ======== cmm_get_handle ========
  *  Purpose:
  *      Return the communication memory manager object for this device.
  *      This is typically called from the client process.
  */
-DSP_STATUS CMM_GetHandle(void *hProcessor,
-			OUT struct CMM_OBJECT **phCmmMgr)
+dsp_status cmm_get_handle(void *hprocessor, OUT struct cmm_object ** ph_cmm_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phCmmMgr != NULL);
-	if (hProcessor != NULL)
-		status = PROC_GetDevObject(hProcessor, &hDevObject);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ph_cmm_mgr != NULL);
+	if (hprocessor != NULL)
+		status = proc_get_dev_object(hprocessor, &hdev_obj);
 	else
-		hDevObject = DEV_GetFirst();	/* default */
+		hdev_obj = dev_get_first();	/* default */
 
 	if (DSP_SUCCEEDED(status))
-		status = DEV_GetCmmMgr(hDevObject, phCmmMgr);
+		status = dev_get_cmm_mgr(hdev_obj, ph_cmm_mgr);
 
 	return status;
 }
 
 /*
- *  ======== CMM_GetInfo ========
+ *  ======== cmm_get_info ========
  *  Purpose:
  *      Return the current memory utilization information.
  */
-DSP_STATUS CMM_GetInfo(struct CMM_OBJECT *hCmmMgr,
-		       OUT struct CMM_INFO *pCmmInfo)
+dsp_status cmm_get_info(struct cmm_object *hcmm_mgr,
+			OUT struct cmm_info *cmm_info_obj)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	u32 ulSeg;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_ALLOCATOR *pAltr;
-	struct CMM_MNODE *pCurNode = NULL;
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	u32 ul_seg;
+	dsp_status status = DSP_SOK;
+	struct cmm_allocator *altr;
+	struct cmm_mnode *mnode_obj = NULL;
 
-	DBC_Require(pCmmInfo != NULL);
+	DBC_REQUIRE(cmm_info_obj != NULL);
 
-	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
-	SYNC_EnterCS(pCmmMgr->hCmmLock);
-	pCmmInfo->ulNumGPPSMSegs = 0;	/* # of SM segments */
-	pCmmInfo->ulTotalInUseCnt = 0;	/* Total # of outstanding alloc */
-	pCmmInfo->ulMinBlockSize = pCmmMgr->ulMinBlockSize; /* min block size */
+	mutex_lock(&cmm_mgr_obj->cmm_lock);
+	cmm_info_obj->ul_num_gppsm_segs = 0;	/* # of SM segments */
+	/* Total # of outstanding alloc */
+	cmm_info_obj->ul_total_in_use_cnt = 0;
+	/* min block size */
+	cmm_info_obj->ul_min_block_size = cmm_mgr_obj->ul_min_block_size;
 	/* check SM memory segments */
-	for (ulSeg = 1; ulSeg <= CMM_MAXGPPSEGS; ulSeg++) {
+	for (ul_seg = 1; ul_seg <= CMM_MAXGPPSEGS; ul_seg++) {
 		/* get the allocator object for this segment id */
-		pAltr = GetAllocator(pCmmMgr, ulSeg);
-		if (pAltr != NULL) {
-			pCmmInfo->ulNumGPPSMSegs++;
-			pCmmInfo->segInfo[ulSeg - 1].dwSegBasePa =
-				pAltr->dwSmBase - pAltr->ulDSPSize;
-			pCmmInfo->segInfo[ulSeg - 1].ulTotalSegSize =
-				pAltr->ulDSPSize + pAltr->ulSmSize;
-			pCmmInfo->segInfo[ulSeg - 1].dwGPPBasePA =
-				pAltr->dwSmBase;
-			pCmmInfo->segInfo[ulSeg - 1].ulGPPSize =
-				pAltr->ulSmSize;
-			pCmmInfo->segInfo[ulSeg - 1].dwDSPBaseVA =
-				pAltr->dwDSPBase;
-			pCmmInfo->segInfo[ulSeg - 1].ulDSPSize =
-				pAltr->ulDSPSize;
-			pCmmInfo->segInfo[ulSeg - 1].dwSegBaseVa =
-				pAltr->dwVmBase - pAltr->ulDSPSize;
-			pCmmInfo->segInfo[ulSeg - 1].ulInUseCnt = 0;
-			pCurNode = (struct CMM_MNODE *)LST_First(pAltr->
-				pInUseListHead);
+		altr = get_allocator(cmm_mgr_obj, ul_seg);
+		if (altr != NULL) {
+			cmm_info_obj->ul_num_gppsm_segs++;
+			cmm_info_obj->seg_info[ul_seg - 1].dw_seg_base_pa =
+			    altr->shm_base - altr->ul_dsp_size;
+			cmm_info_obj->seg_info[ul_seg - 1].ul_total_seg_size =
+			    altr->ul_dsp_size + altr->ul_sm_size;
+			cmm_info_obj->seg_info[ul_seg - 1].dw_gpp_base_pa =
+			    altr->shm_base;
+			cmm_info_obj->seg_info[ul_seg - 1].ul_gpp_size =
+			    altr->ul_sm_size;
+			cmm_info_obj->seg_info[ul_seg - 1].dw_dsp_base_va =
+			    altr->dw_dsp_base;
+			cmm_info_obj->seg_info[ul_seg - 1].ul_dsp_size =
+			    altr->ul_dsp_size;
+			cmm_info_obj->seg_info[ul_seg - 1].dw_seg_base_va =
+			    altr->dw_vm_base - altr->ul_dsp_size;
+			cmm_info_obj->seg_info[ul_seg - 1].ul_in_use_cnt = 0;
+			mnode_obj = (struct cmm_mnode *)
+			    lst_first(altr->in_use_list_head);
 			/* Count inUse blocks */
-			while (pCurNode) {
-				pCmmInfo->ulTotalInUseCnt++;
-				pCmmInfo->segInfo[ulSeg - 1].ulInUseCnt++;
+			while (mnode_obj) {
+				cmm_info_obj->ul_total_in_use_cnt++;
+				cmm_info_obj->seg_info[ul_seg -
+						       1].ul_in_use_cnt++;
 				/* next node. */
-				pCurNode = (struct CMM_MNODE *)LST_Next(pAltr->
-					pInUseListHead,
-					(struct list_head *)pCurNode);
+				mnode_obj = (struct cmm_mnode *)
+				    lst_next(altr->in_use_list_head,
+					     (struct list_head *)mnode_obj);
 			}
 		}
-	}		/* end for */
-	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	}			/* end for */
+	mutex_unlock(&cmm_mgr_obj->cmm_lock);
 	return status;
 }
 
 /*
- *  ======== CMM_Init ========
+ *  ======== cmm_init ========
  *  Purpose:
  *      Initializes private state of CMM module.
  */
-bool CMM_Init(void)
+bool cmm_init(void)
 {
-	bool fRetval = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
-	if (fRetval)
-		cRefs++;
+	DBC_REQUIRE(refs >= 0);
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== CMM_RegisterGPPSMSeg ========
+ *  ======== cmm_register_gppsm_seg ========
  *  Purpose:
  *      Register a block of SM with the CMM to be used for later GPP SM
  *      allocations.
  */
-DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 dwGPPBasePA,
-				u32 ulSize, u32 dwDSPAddrOffset,
-				s8 cFactor, u32 dwDSPBase,
-				u32 ulDSPSize, u32 *pulSegId,
-				u32 dwGPPBaseVA)
+dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
+				  u32 dw_gpp_base_pa, u32 ul_size,
+				  u32 dwDSPAddrOffset, s8 c_factor,
+				  u32 dw_dsp_base, u32 ul_dsp_size,
+				  u32 *pulSegId, u32 dw_gpp_base_va)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	struct CMM_ALLOCATOR *pSMA = NULL;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_MNODE *pNewNode;
-	s32 nSlot;
-
-	DBC_Require(ulSize > 0);
-	DBC_Require(pulSegId != NULL);
-	DBC_Require(dwGPPBasePA != 0);
-	DBC_Require(dwGPPBaseVA != 0);
-	DBC_Require((cFactor <= CMM_ADDTODSPPA) &&
-		   (cFactor >= CMM_SUBFROMDSPPA));
-	dev_dbg(bridge, "%s: dwGPPBasePA %x ulSize %x dwDSPAddrOffset %x "
-			"dwDSPBase %x ulDSPSize %x dwGPPBaseVA %x\n", __func__,
-			dwGPPBasePA, ulSize, dwDSPAddrOffset, dwDSPBase,
-			ulDSPSize, dwGPPBaseVA);
-	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	struct cmm_allocator *psma = NULL;
+	dsp_status status = DSP_SOK;
+	struct cmm_mnode *new_node;
+	s32 slot_seg;
+
+	DBC_REQUIRE(ul_size > 0);
+	DBC_REQUIRE(pulSegId != NULL);
+	DBC_REQUIRE(dw_gpp_base_pa != 0);
+	DBC_REQUIRE(dw_gpp_base_va != 0);
+	DBC_REQUIRE((c_factor <= CMM_ADDTODSPPA) &&
+		    (c_factor >= CMM_SUBFROMDSPPA));
+	dev_dbg(bridge, "%s: dw_gpp_base_pa %x ul_size %x dwDSPAddrOffset %x "
+		"dw_dsp_base %x ul_dsp_size %x dw_gpp_base_va %x\n", __func__,
+		dw_gpp_base_pa, ul_size, dwDSPAddrOffset, dw_dsp_base,
+		ul_dsp_size, dw_gpp_base_va);
+	if (!MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
 	/* make sure we have room for another allocator */
-	SYNC_EnterCS(pCmmMgr->hCmmLock);
-	nSlot = GetSlot(pCmmMgr);
-	if (nSlot < 0) {
+	mutex_lock(&cmm_mgr_obj->cmm_lock);
+	slot_seg = get_slot(cmm_mgr_obj);
+	if (slot_seg < 0) {
 		/* get a slot number */
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	/* Check if input ulSize is big enough to alloc at least one block */
+	/* Check if input ul_size is big enough to alloc at least one block */
 	if (DSP_SUCCEEDED(status)) {
-		if (ulSize < pCmmMgr->ulMinBlockSize) {
+		if (ul_size < cmm_mgr_obj->ul_min_block_size) {
 			status = DSP_EINVALIDARG;
 			goto func_end;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* create, zero, and tag an SM allocator object */
-		MEM_AllocObject(pSMA, struct CMM_ALLOCATOR, SMEMSIGNATURE);
+		MEM_ALLOC_OBJECT(psma, struct cmm_allocator, SMEMSIGNATURE);
 	}
-	if (pSMA != NULL) {
-		pSMA->hCmmMgr = hCmmMgr;	/* ref to parent */
-		pSMA->dwSmBase = dwGPPBasePA;	/* SM Base phys */
-		pSMA->ulSmSize = ulSize;	/* SM segment size in bytes */
-		pSMA->dwVmBase = dwGPPBaseVA;
-		pSMA->dwDSPPhysAddrOffset = dwDSPAddrOffset;
-		pSMA->cFactor = cFactor;
-		pSMA->dwDSPBase = dwDSPBase;
-		pSMA->ulDSPSize = ulDSPSize;
-		if (pSMA->dwVmBase == 0) {
+	if (psma != NULL) {
+		psma->hcmm_mgr = hcmm_mgr;	/* ref to parent */
+		psma->shm_base = dw_gpp_base_pa;	/* SM Base phys */
+		psma->ul_sm_size = ul_size;	/* SM segment size in bytes */
+		psma->dw_vm_base = dw_gpp_base_va;
+		psma->dw_dsp_phys_addr_offset = dwDSPAddrOffset;
+		psma->c_factor = c_factor;
+		psma->dw_dsp_base = dw_dsp_base;
+		psma->ul_dsp_size = ul_dsp_size;
+		if (psma->dw_vm_base == 0) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* return the actual segment identifier */
-			*pulSegId = (u32) nSlot + 1;
+			*pulSegId = (u32) slot_seg + 1;
 			/* create memory free list */
-			pSMA->pFreeListHead = MEM_Calloc(sizeof(struct
-				LST_LIST), MEM_NONPAGED);
-			if (pSMA->pFreeListHead == NULL) {
+			psma->free_list_head = mem_calloc(sizeof(struct
+								 lst_list),
+							  MEM_NONPAGED);
+			if (psma->free_list_head == NULL) {
 				status = DSP_EMEMORY;
 				goto func_end;
 			}
-			INIT_LIST_HEAD(&pSMA->pFreeListHead->head);
+			INIT_LIST_HEAD(&psma->free_list_head->head);
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* create memory in-use list */
-			pSMA->pInUseListHead = MEM_Calloc(sizeof(struct
-				LST_LIST), MEM_NONPAGED);
-			if (pSMA->pInUseListHead == NULL) {
+			psma->in_use_list_head = mem_calloc(sizeof(struct
+								   lst_list),
+							    MEM_NONPAGED);
+			if (psma->in_use_list_head == NULL) {
 				status = DSP_EMEMORY;
 				goto func_end;
 			}
-			INIT_LIST_HEAD(&pSMA->pInUseListHead->head);
+			INIT_LIST_HEAD(&psma->in_use_list_head->head);
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Get a mem node for this hunk-o-memory */
-			pNewNode = GetNode(pCmmMgr, dwGPPBasePA,
-					   pSMA->dwVmBase, ulSize);
+			new_node = get_node(cmm_mgr_obj, dw_gpp_base_pa,
+					    psma->dw_vm_base, ul_size);
 			/* Place node on the SM allocator's free list */
-			if (pNewNode) {
-				LST_PutTail(pSMA->pFreeListHead,
-					   (struct list_head *)pNewNode);
+			if (new_node) {
+				lst_put_tail(psma->free_list_head,
+					     (struct list_head *)new_node);
 			} else {
 				status = DSP_EMEMORY;
 				goto func_end;
@@ -631,56 +646,58 @@ DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 dwGPPBasePA,
 		}
 		if (DSP_FAILED(status)) {
 			/* Cleanup allocator */
-			UnRegisterGPPSMSeg(pSMA);
+			un_register_gppsm_seg(psma);
 		}
 	} else {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	 /* make entry */
+	/* make entry */
 	if (DSP_SUCCEEDED(status))
-		pCmmMgr->paGPPSMSegTab[nSlot] = pSMA;
+		cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] = psma;
 
 func_end:
-	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	mutex_unlock(&cmm_mgr_obj->cmm_lock);
 	return status;
 }
 
 /*
- *  ======== CMM_UnRegisterGPPSMSeg ========
+ *  ======== cmm_un_register_gppsm_seg ========
  *  Purpose:
  *      UnRegister GPP SM segments with the CMM.
  */
-DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 ulSegId)
+dsp_status cmm_un_register_gppsm_seg(struct cmm_object *hcmm_mgr,
+				     u32 ul_seg_id)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_ALLOCATOR *pSMA;
-	u32 ulId = ulSegId;
-
-	DBC_Require(ulSegId > 0);
-	if (MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
-		if (ulSegId == CMM_ALLSEGMENTS)
-			ulId = 1;
-
-		if ((ulId > 0) && (ulId <= CMM_MAXGPPSEGS)) {
-			while (ulId <= CMM_MAXGPPSEGS) {
-				SYNC_EnterCS(pCmmMgr->hCmmLock);
-				/* slot = segId-1 */
-				pSMA = pCmmMgr->paGPPSMSegTab[ulId - 1];
-				if (pSMA != NULL) {
-					UnRegisterGPPSMSeg(pSMA);
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	dsp_status status = DSP_SOK;
+	struct cmm_allocator *psma;
+	u32 ul_id = ul_seg_id;
+
+	DBC_REQUIRE(ul_seg_id > 0);
+	if (MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) {
+		if (ul_seg_id == CMM_ALLSEGMENTS)
+			ul_id = 1;
+
+		if ((ul_id > 0) && (ul_id <= CMM_MAXGPPSEGS)) {
+			while (ul_id <= CMM_MAXGPPSEGS) {
+				mutex_lock(&cmm_mgr_obj->cmm_lock);
+				/* slot = seg_id-1 */
+				psma = cmm_mgr_obj->pa_gppsm_seg_tab[ul_id - 1];
+				if (psma != NULL) {
+					un_register_gppsm_seg(psma);
 					/* Set alctr ptr to NULL for future
 					 * reuse */
-					pCmmMgr->paGPPSMSegTab[ulId - 1] = NULL;
-				} else if (ulSegId != CMM_ALLSEGMENTS) {
+					cmm_mgr_obj->pa_gppsm_seg_tab[ul_id -
+								      1] = NULL;
+				} else if (ul_seg_id != CMM_ALLSEGMENTS) {
 					status = DSP_EFAIL;
 				}
-				SYNC_LeaveCS(pCmmMgr->hCmmLock);
-				if (ulSegId != CMM_ALLSEGMENTS)
+				mutex_unlock(&cmm_mgr_obj->cmm_lock);
+				if (ul_seg_id != CMM_ALLSEGMENTS)
 					break;
 
-				ulId++;
+				ul_id++;
 			}	/* end while */
 		} else {
 			status = DSP_EINVALIDARG;
@@ -692,247 +709,254 @@ DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 ulSegId)
 }
 
 /*
- *  ======== UnRegisterGPPSMSeg ========
+ *  ======== un_register_gppsm_seg ========
  *  Purpose:
  *      UnRegister the SM allocator by freeing all its resources and
  *      nulling cmm mgr table entry.
  *  Note:
  *      This routine is always called within cmm lock crit sect.
  */
-static void UnRegisterGPPSMSeg(struct CMM_ALLOCATOR *pSMA)
+static void un_register_gppsm_seg(struct cmm_allocator *psma)
 {
-	struct CMM_MNODE *pCurNode = NULL;
-	struct CMM_MNODE *pNextNode = NULL;
+	struct cmm_mnode *mnode_obj = NULL;
+	struct cmm_mnode *next_node = NULL;
 
-	DBC_Require(pSMA != NULL);
-	if (pSMA->pFreeListHead != NULL) {
+	DBC_REQUIRE(psma != NULL);
+	if (psma->free_list_head != NULL) {
 		/* free nodes on free list */
-		pCurNode = (struct CMM_MNODE *)LST_First(pSMA->pFreeListHead);
-		while (pCurNode) {
-			pNextNode = (struct CMM_MNODE *)LST_Next(pSMA->
-				     pFreeListHead,
-				    (struct list_head *)pCurNode);
-			LST_RemoveElem(pSMA->pFreeListHead,
-				      (struct list_head *)pCurNode);
-			kfree((void *) pCurNode);
+		mnode_obj = (struct cmm_mnode *)lst_first(psma->free_list_head);
+		while (mnode_obj) {
+			next_node =
+			    (struct cmm_mnode *)lst_next(psma->free_list_head,
+							 (struct list_head *)
+							 mnode_obj);
+			lst_remove_elem(psma->free_list_head,
+					(struct list_head *)mnode_obj);
+			kfree((void *)mnode_obj);
 			/* next node. */
-			pCurNode = pNextNode;
+			mnode_obj = next_node;
 		}
-		kfree(pSMA->pFreeListHead);		/* delete freelist */
+		kfree(psma->free_list_head);	/* delete freelist */
 		/* free nodes on InUse list */
-		pCurNode = (struct CMM_MNODE *)LST_First(pSMA->pInUseListHead);
-		while (pCurNode) {
-			pNextNode = (struct CMM_MNODE *)LST_Next(pSMA->
-				    pInUseListHead,
-				    (struct list_head *)pCurNode);
-			LST_RemoveElem(pSMA->pInUseListHead,
-				      (struct list_head *)pCurNode);
-			kfree((void *) pCurNode);
+		mnode_obj =
+		    (struct cmm_mnode *)lst_first(psma->in_use_list_head);
+		while (mnode_obj) {
+			next_node =
+			    (struct cmm_mnode *)lst_next(psma->in_use_list_head,
+							 (struct list_head *)
+							 mnode_obj);
+			lst_remove_elem(psma->in_use_list_head,
+					(struct list_head *)mnode_obj);
+			kfree((void *)mnode_obj);
 			/* next node. */
-			pCurNode = pNextNode;
+			mnode_obj = next_node;
 		}
-		kfree(pSMA->pInUseListHead);		/* delete InUse list */
+		kfree(psma->in_use_list_head);	/* delete InUse list */
 	}
-	if ((void *) pSMA->dwVmBase != NULL)
-		MEM_UnmapLinearAddress((void *) pSMA->dwVmBase);
+	if ((void *)psma->dw_vm_base != NULL)
+		MEM_UNMAP_LINEAR_ADDRESS((void *)psma->dw_vm_base);
 
 	/* Free allocator itself */
-	MEM_FreeObject(pSMA);
+	MEM_FREE_OBJECT(psma);
 }
 
 /*
- *  ======== GetSlot ========
+ *  ======== get_slot ========
  *  Purpose:
  *      An available slot # is returned. Returns negative on failure.
  */
-static s32 GetSlot(struct CMM_OBJECT *pCmmMgr)
+static s32 get_slot(struct cmm_object *cmm_mgr_obj)
 {
-	s32 nSlot = -1;		/* neg on failure */
-	DBC_Require(pCmmMgr != NULL);
+	s32 slot_seg = -1;	/* neg on failure */
+	DBC_REQUIRE(cmm_mgr_obj != NULL);
 	/* get first available slot in cmm mgr SMSegTab[] */
-	for (nSlot = 0; nSlot < CMM_MAXGPPSEGS; nSlot++) {
-		if (pCmmMgr->paGPPSMSegTab[nSlot] == NULL)
+	for (slot_seg = 0; slot_seg < CMM_MAXGPPSEGS; slot_seg++) {
+		if (cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] == NULL)
 			break;
 
 	}
-	if (nSlot == CMM_MAXGPPSEGS)
-		nSlot = -1;	/* failed */
+	if (slot_seg == CMM_MAXGPPSEGS)
+		slot_seg = -1;	/* failed */
 
-	return nSlot;
+	return slot_seg;
 }
 
 /*
- *  ======== GetNode ========
+ *  ======== get_node ========
  *  Purpose:
  *      Get a memory node from freelist or create a new one.
  */
-static struct CMM_MNODE *GetNode(struct CMM_OBJECT *pCmmMgr, u32 dwPA,
-				 u32 dwVA, u32 ulSize)
+static struct cmm_mnode *get_node(struct cmm_object *cmm_mgr_obj, u32 dw_pa,
+				  u32 dw_va, u32 ul_size)
 {
-	struct CMM_MNODE *pNode = NULL;
+	struct cmm_mnode *pnode = NULL;
 
-	DBC_Require(pCmmMgr != NULL);
-	DBC_Require(dwPA != 0);
-	DBC_Require(dwVA != 0);
-	DBC_Require(ulSize != 0);
+	DBC_REQUIRE(cmm_mgr_obj != NULL);
+	DBC_REQUIRE(dw_pa != 0);
+	DBC_REQUIRE(dw_va != 0);
+	DBC_REQUIRE(ul_size != 0);
 	/* Check cmm mgr's node freelist */
-	if (LST_IsEmpty(pCmmMgr->pNodeFreeListHead)) {
-		pNode = (struct CMM_MNODE *)MEM_Calloc(sizeof(struct CMM_MNODE),
-			MEM_PAGED);
+	if (LST_IS_EMPTY(cmm_mgr_obj->node_free_list_head)) {
+		pnode = (struct cmm_mnode *)mem_calloc(sizeof(struct cmm_mnode),
+						       MEM_PAGED);
 	} else {
 		/* surely a valid element */
-		pNode = (struct CMM_MNODE *)LST_GetHead(pCmmMgr->
-			pNodeFreeListHead);
+		pnode = (struct cmm_mnode *)
+		    lst_get_head(cmm_mgr_obj->node_free_list_head);
 	}
-	if (pNode) {
-		LST_InitElem((struct list_head *) pNode);	/* set self */
-		pNode->dwPA = dwPA;	/* Physical addr of start of block */
-		pNode->dwVA = dwVA;	/* Virtual   "            "        */
-		pNode->ulSize = ulSize;	/* Size of block */
+	if (pnode) {
+		lst_init_elem((struct list_head *)pnode);	/* set self */
+		pnode->dw_pa = dw_pa;	/* Physical addr of start of block */
+		pnode->dw_va = dw_va;	/* Virtual   "            " */
+		pnode->ul_size = ul_size;	/* Size of block */
 	}
-	return pNode;
+	return pnode;
 }
 
 /*
- *  ======== DeleteNode ========
+ *  ======== delete_node ========
  *  Purpose:
  *      Put a memory node on the cmm nodelist for later use.
  *      Doesn't actually delete the node. Heap thrashing friendly.
  */
-static void DeleteNode(struct CMM_OBJECT *pCmmMgr, struct CMM_MNODE *pNode)
+static void delete_node(struct cmm_object *cmm_mgr_obj, struct cmm_mnode *pnode)
 {
-	DBC_Require(pNode != NULL);
-	LST_InitElem((struct list_head *) pNode);	/* init .self ptr */
-	LST_PutTail(pCmmMgr->pNodeFreeListHead, (struct list_head *) pNode);
+	DBC_REQUIRE(pnode != NULL);
+	lst_init_elem((struct list_head *)pnode);	/* init .self ptr */
+	lst_put_tail(cmm_mgr_obj->node_free_list_head,
+		     (struct list_head *)pnode);
 }
 
 /*
- * ====== GetFreeBlock ========
+ * ====== get_free_block ========
  *  Purpose:
  *      Scan the free block list and return the first block that satisfies
  *      the size.
  */
-static struct CMM_MNODE *GetFreeBlock(struct CMM_ALLOCATOR *pAllocator,
-				      u32 uSize)
+static struct cmm_mnode *get_free_block(struct cmm_allocator *allocator,
+					u32 usize)
 {
-	if (pAllocator) {
-		struct CMM_MNODE *pCurNode = (struct CMM_MNODE *)
-					LST_First(pAllocator->pFreeListHead);
-		while (pCurNode) {
-			if (uSize <= (u32) pCurNode->ulSize) {
-				LST_RemoveElem(pAllocator->pFreeListHead,
-					      (struct list_head *)pCurNode);
-				return pCurNode;
+	if (allocator) {
+		struct cmm_mnode *mnode_obj = (struct cmm_mnode *)
+		    lst_first(allocator->free_list_head);
+		while (mnode_obj) {
+			if (usize <= (u32) mnode_obj->ul_size) {
+				lst_remove_elem(allocator->free_list_head,
+						(struct list_head *)mnode_obj);
+				return mnode_obj;
 			}
 			/* next node. */
-			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-					pFreeListHead,
-					(struct list_head *)pCurNode);
+			mnode_obj = (struct cmm_mnode *)
+			    lst_next(allocator->free_list_head,
+				     (struct list_head *)mnode_obj);
 		}
 	}
 	return NULL;
 }
 
 /*
- *  ======== AddToFreeList ========
+ *  ======== add_to_free_list ========
  *  Purpose:
  *      Coelesce node into the freelist in ascending size order.
  */
-static void AddToFreeList(struct CMM_ALLOCATOR *pAllocator,
-			  struct CMM_MNODE *pNode)
+static void add_to_free_list(struct cmm_allocator *allocator,
+			     struct cmm_mnode *pnode)
 {
-	struct CMM_MNODE *pNodePrev = NULL;
-	struct CMM_MNODE *pNodeNext = NULL;
-	struct CMM_MNODE *pCurNode;
-	u32 dwThisPA;
-	u32 dwNextPA;
-
-	DBC_Require(pNode != NULL);
-	DBC_Require(pAllocator != NULL);
-	dwThisPA = pNode->dwPA;
-	dwNextPA = NEXT_PA(pNode);
-	pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->pFreeListHead);
-	while (pCurNode) {
-		if (dwThisPA == NEXT_PA(pCurNode)) {
+	struct cmm_mnode *node_prev = NULL;
+	struct cmm_mnode *node_next = NULL;
+	struct cmm_mnode *mnode_obj;
+	u32 dw_this_pa;
+	u32 dw_next_pa;
+
+	DBC_REQUIRE(pnode != NULL);
+	DBC_REQUIRE(allocator != NULL);
+	dw_this_pa = pnode->dw_pa;
+	dw_next_pa = NEXT_PA(pnode);
+	mnode_obj = (struct cmm_mnode *)lst_first(allocator->free_list_head);
+	while (mnode_obj) {
+		if (dw_this_pa == NEXT_PA(mnode_obj)) {
 			/* found the block ahead of this one */
-			pNodePrev = pCurNode;
-		} else if (dwNextPA == pCurNode->dwPA) {
-			pNodeNext = pCurNode;
+			node_prev = mnode_obj;
+		} else if (dw_next_pa == mnode_obj->dw_pa) {
+			node_next = mnode_obj;
 		}
-		if ((pNodePrev == NULL) || (pNodeNext == NULL)) {
+		if ((node_prev == NULL) || (node_next == NULL)) {
 			/* next node. */
-			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-					pFreeListHead,
-					(struct list_head *)pCurNode);
+			mnode_obj = (struct cmm_mnode *)
+			    lst_next(allocator->free_list_head,
+				     (struct list_head *)mnode_obj);
 		} else {
 			/* got 'em */
 			break;
 		}
 	}			/* while */
-	if (pNodePrev != NULL) {
+	if (node_prev != NULL) {
 		/* combine with previous block */
-		LST_RemoveElem(pAllocator->pFreeListHead,
-			      (struct list_head *)pNodePrev);
+		lst_remove_elem(allocator->free_list_head,
+				(struct list_head *)node_prev);
 		/* grow node to hold both */
-		pNode->ulSize += pNodePrev->ulSize;
-		pNode->dwPA = pNodePrev->dwPA;
-		pNode->dwVA = pNodePrev->dwVA;
+		pnode->ul_size += node_prev->ul_size;
+		pnode->dw_pa = node_prev->dw_pa;
+		pnode->dw_va = node_prev->dw_va;
 		/* place node on mgr nodeFreeList */
-		DeleteNode((struct CMM_OBJECT *)pAllocator->hCmmMgr, pNodePrev);
+		delete_node((struct cmm_object *)allocator->hcmm_mgr,
+			    node_prev);
 	}
-	if (pNodeNext != NULL) {
+	if (node_next != NULL) {
 		/* combine with next block */
-		LST_RemoveElem(pAllocator->pFreeListHead,
-			      (struct list_head *)pNodeNext);
+		lst_remove_elem(allocator->free_list_head,
+				(struct list_head *)node_next);
 		/* grow da node */
-		pNode->ulSize += pNodeNext->ulSize;
+		pnode->ul_size += node_next->ul_size;
 		/* place node on mgr nodeFreeList */
-		DeleteNode((struct CMM_OBJECT *)pAllocator->hCmmMgr, pNodeNext);
+		delete_node((struct cmm_object *)allocator->hcmm_mgr,
+			    node_next);
 	}
 	/* Now, let's add to freelist in increasing size order */
-	pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->pFreeListHead);
-	while (pCurNode) {
-		if (pNode->ulSize <= pCurNode->ulSize)
+	mnode_obj = (struct cmm_mnode *)lst_first(allocator->free_list_head);
+	while (mnode_obj) {
+		if (pnode->ul_size <= mnode_obj->ul_size)
 			break;
 
 		/* next node. */
-		pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-			   pFreeListHead, (struct list_head *)pCurNode);
+		mnode_obj =
+		    (struct cmm_mnode *)lst_next(allocator->free_list_head,
+						 (struct list_head *)mnode_obj);
 	}
-	/* if pCurNode is NULL then add our pNode to the end of the freelist */
-	if (pCurNode == NULL) {
-		LST_PutTail(pAllocator->pFreeListHead,
-			   (struct list_head *)pNode);
+	/* if mnode_obj is NULL then add our pnode to the end of the freelist */
+	if (mnode_obj == NULL) {
+		lst_put_tail(allocator->free_list_head,
+			     (struct list_head *)pnode);
 	} else {
 		/* insert our node before the current traversed node */
-		LST_InsertBefore(pAllocator->pFreeListHead,
-				(struct list_head *)pNode,
-				(struct list_head *)pCurNode);
+		lst_insert_before(allocator->free_list_head,
+				  (struct list_head *)pnode,
+				  (struct list_head *)mnode_obj);
 	}
 }
 
 /*
- * ======== GetAllocator ========
+ * ======== get_allocator ========
  *  Purpose:
  *      Return the allocator for the given SM Segid.
  *      SegIds:  1,2,3..max.
  */
-static struct CMM_ALLOCATOR *GetAllocator(struct CMM_OBJECT *pCmmMgr,
-					  u32 ulSegId)
+static struct cmm_allocator *get_allocator(struct cmm_object *cmm_mgr_obj,
+					   u32 ul_seg_id)
 {
-	struct CMM_ALLOCATOR *pAllocator = NULL;
+	struct cmm_allocator *allocator = NULL;
 
-	DBC_Require(pCmmMgr != NULL);
-	DBC_Require((ulSegId > 0) && (ulSegId <= CMM_MAXGPPSEGS));
-	pAllocator = pCmmMgr->paGPPSMSegTab[ulSegId - 1];
-	if (pAllocator != NULL) {
+	DBC_REQUIRE(cmm_mgr_obj != NULL);
+	DBC_REQUIRE((ul_seg_id > 0) && (ul_seg_id <= CMM_MAXGPPSEGS));
+	allocator = cmm_mgr_obj->pa_gppsm_seg_tab[ul_seg_id - 1];
+	if (allocator != NULL) {
 		/* make sure it's for real */
-		if (!MEM_IsValidHandle(pAllocator, SMEMSIGNATURE)) {
-			pAllocator = NULL;
-			DBC_Assert(false);
+		if (!MEM_IS_VALID_HANDLE(allocator, SMEMSIGNATURE)) {
+			allocator = NULL;
+			DBC_ASSERT(false);
 		}
 	}
-	return pAllocator;
+	return allocator;
 }
 
 /*
@@ -942,118 +966,121 @@ static struct CMM_ALLOCATOR *GetAllocator(struct CMM_OBJECT *pCmmMgr,
  */
 
 /*
- *  ======== CMM_XlatorCreate ========
+ *  ======== cmm_xlator_create ========
  *  Purpose:
  *      Create an address translator object.
  */
-DSP_STATUS CMM_XlatorCreate(OUT struct CMM_XLATOROBJECT **phXlator,
-				struct CMM_OBJECT *hCmmMgr,
-				struct CMM_XLATORATTRS *pXlatorAttrs)
+dsp_status cmm_xlator_create(OUT struct cmm_xlatorobject **phXlator,
+			     struct cmm_object *hcmm_mgr,
+			     struct cmm_xlatorattrs *pXlatorAttrs)
 {
-	struct CMM_XLATOR *pXlatorObject = NULL;
-	DSP_STATUS status = DSP_SOK;
+	struct cmm_xlator *xlator_object = NULL;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phXlator != NULL);
-	DBC_Require(hCmmMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phXlator != NULL);
+	DBC_REQUIRE(hcmm_mgr != NULL);
 
 	*phXlator = NULL;
 	if (pXlatorAttrs == NULL)
-		pXlatorAttrs = &CMM_DFLTXLATORATTRS;	/* set defaults */
+		pXlatorAttrs = &cmm_dfltxlatorattrs;	/* set defaults */
 
-	MEM_AllocObject(pXlatorObject, struct CMM_XLATOR, CMMXLATESIGNATURE);
-	if (pXlatorObject != NULL) {
-		pXlatorObject->hCmmMgr = hCmmMgr;	/* ref back to CMM */
-		pXlatorObject->ulSegId = pXlatorAttrs->ulSegId;	/* SM segId */
+	MEM_ALLOC_OBJECT(xlator_object, struct cmm_xlator, CMMXLATESIGNATURE);
+	if (xlator_object != NULL) {
+		xlator_object->hcmm_mgr = hcmm_mgr;	/* ref back to CMM */
+		/* SM seg_id */
+		xlator_object->ul_seg_id = pXlatorAttrs->ul_seg_id;
 	} else {
 		status = DSP_EMEMORY;
 	}
 	if (DSP_SUCCEEDED(status))
-		*phXlator = (struct CMM_XLATOROBJECT *) pXlatorObject;
+		*phXlator = (struct cmm_xlatorobject *)xlator_object;
 
 	return status;
 }
 
 /*
- *  ======== CMM_XlatorDelete ========
+ *  ======== cmm_xlator_delete ========
  *  Purpose:
  *      Free the Xlator resources.
  *      VM gets freed later.
  */
-DSP_STATUS CMM_XlatorDelete(struct CMM_XLATOROBJECT *hXlator, bool bForce)
+dsp_status cmm_xlator_delete(struct cmm_xlatorobject *xlator, bool bForce)
 {
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	DSP_STATUS status = DSP_SOK;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE))
-		MEM_FreeObject(pXlator);
-	else
+	if (MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE)) {
+		MEM_FREE_OBJECT(xlator_obj);
+	} else {
 		status = DSP_EHANDLE;
+	}
 
 	return status;
 }
 
 /*
- *  ======== CMM_XlatorAllocBuf ========
+ *  ======== cmm_xlator_alloc_buf ========
  */
-void *CMM_XlatorAllocBuf(struct CMM_XLATOROBJECT *hXlator, void *pVaBuf,
-			u32 uPaSize)
+void *cmm_xlator_alloc_buf(struct cmm_xlatorobject *xlator, void *pVaBuf,
+			   u32 uPaSize)
 {
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	void *pBuf = NULL;
-	struct CMM_ATTRS attrs;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(hXlator != NULL);
-	DBC_Require(pXlator->hCmmMgr != NULL);
-	DBC_Require(pVaBuf != NULL);
-	DBC_Require(uPaSize > 0);
-	DBC_Require(pXlator->ulSegId > 0);
-
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
-		attrs.ulSegId = pXlator->ulSegId;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	void *pbuf = NULL;
+	struct cmm_attrs attrs;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(xlator != NULL);
+	DBC_REQUIRE(xlator_obj->hcmm_mgr != NULL);
+	DBC_REQUIRE(pVaBuf != NULL);
+	DBC_REQUIRE(uPaSize > 0);
+	DBC_REQUIRE(xlator_obj->ul_seg_id > 0);
+
+	if (MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE)) {
+		attrs.ul_seg_id = xlator_obj->ul_seg_id;
 		*(volatile u32 *)pVaBuf = 0;
 		/* Alloc SM */
-		pBuf = CMM_CallocBuf(pXlator->hCmmMgr, uPaSize, &attrs,  NULL);
-		if (pBuf) {
+		pbuf =
+		    cmm_calloc_buf(xlator_obj->hcmm_mgr, uPaSize, &attrs, NULL);
+		if (pbuf) {
 			/* convert to translator(node/strm) process Virtual
 			 * address */
 			*(volatile u32 **)pVaBuf =
-				 (u32 *)CMM_XlatorTranslate(hXlator,
-							      pBuf, CMM_PA2VA);
+			    (u32 *) cmm_xlator_translate(xlator,
+							 pbuf, CMM_PA2VA);
 		}
 	}
-	return pBuf;
+	return pbuf;
 }
 
 /*
- *  ======== CMM_XlatorFreeBuf ========
+ *  ======== cmm_xlator_free_buf ========
  *  Purpose:
  *      Free the given SM buffer and descriptor.
  *      Does not free virtual memory.
  */
-DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator, void *pBufVa)
+dsp_status cmm_xlator_free_buf(struct cmm_xlatorobject *xlator, void *pBufVa)
 {
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	DSP_STATUS status = DSP_EFAIL;
-	void *pBufPa = NULL;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	dsp_status status = DSP_EFAIL;
+	void *buf_pa = NULL;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBufVa != NULL);
-	DBC_Require(pXlator->ulSegId > 0);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pBufVa != NULL);
+	DBC_REQUIRE(xlator_obj->ul_seg_id > 0);
 
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE)) {
 		/* convert Va to Pa so we can free it. */
-		pBufPa = CMM_XlatorTranslate(hXlator, pBufVa, CMM_VA2PA);
-		if (pBufPa) {
-			status = CMM_FreeBuf(pXlator->hCmmMgr, pBufPa,
-					     pXlator->ulSegId);
+		buf_pa = cmm_xlator_translate(xlator, pBufVa, CMM_VA2PA);
+		if (buf_pa) {
+			status = cmm_free_buf(xlator_obj->hcmm_mgr, buf_pa,
+					      xlator_obj->ul_seg_id);
 			if (DSP_FAILED(status)) {
 				/* Uh oh, this shouldn't happen. Descriptor
 				 * gone! */
-				DBC_Assert(false);   /* CMM is leaking mem! */
+				DBC_ASSERT(false);	/* CMM is leaking mem */
 			}
 		}
 	}
@@ -1061,27 +1088,27 @@ DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator, void *pBufVa)
 }
 
 /*
- *  ======== CMM_XlatorInfo ========
+ *  ======== cmm_xlator_info ========
  *  Purpose:
  *      Set/Get translator info.
  */
-DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator, IN OUT u8 **pAddr,
-			 u32 ulSize, u32 uSegId, bool bSetInfo)
+dsp_status cmm_xlator_info(struct cmm_xlatorobject *xlator, IN OUT u8 ** paddr,
+			   u32 ul_size, u32 uSegId, bool set_info)
 {
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	DSP_STATUS status = DSP_SOK;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAddr != NULL);
-	DBC_Require((uSegId > 0) && (uSegId <= CMM_MAXGPPSEGS));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(paddr != NULL);
+	DBC_REQUIRE((uSegId > 0) && (uSegId <= CMM_MAXGPPSEGS));
 
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
-		if (bSetInfo) {
+	if (MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE)) {
+		if (set_info) {
 			/* set translators virtual address range */
-			pXlator->dwVirtBase = (u32)*pAddr;
-			pXlator->ulVirtSize = ulSize;
+			xlator_obj->dw_virt_base = (u32) *paddr;
+			xlator_obj->ul_virt_size = ul_size;
 		} else {	/* return virt base address */
-			*pAddr = (u8 *)pXlator->dwVirtBase;
+			*paddr = (u8 *) xlator_obj->dw_virt_base;
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -1090,67 +1117,73 @@ DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator, IN OUT u8 **pAddr,
 }
 
 /*
- *  ======== CMM_XlatorTranslate ========
+ *  ======== cmm_xlator_translate ========
  */
-void *CMM_XlatorTranslate(struct CMM_XLATOROBJECT *hXlator, void *pAddr,
-			  enum CMM_XLATETYPE xType)
+void *cmm_xlator_translate(struct cmm_xlatorobject *xlator, void *paddr,
+			   enum cmm_xlatetype xType)
 {
-	u32 dwAddrXlate = 0;
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	struct CMM_OBJECT *pCmmMgr = NULL;
-	struct CMM_ALLOCATOR *pAlctr = NULL;
-	u32 dwOffset = 0;
+	u32 dw_addr_xlate = 0;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	struct cmm_object *cmm_mgr_obj = NULL;
+	struct cmm_allocator *allocator = NULL;
+	u32 dw_offset = 0;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAddr != NULL);
-	DBC_Require((xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(paddr != NULL);
+	DBC_REQUIRE((xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA));
 
-	if (!MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE))
 		goto loop_cont;
 
-	pCmmMgr = (struct CMM_OBJECT *)pXlator->hCmmMgr;
+	cmm_mgr_obj = (struct cmm_object *)xlator_obj->hcmm_mgr;
 	/* get this translator's default SM allocator */
-	DBC_Assert(pXlator->ulSegId > 0);
-	pAlctr = pCmmMgr->paGPPSMSegTab[pXlator->ulSegId - 1];
-	if (!MEM_IsValidHandle(pAlctr, SMEMSIGNATURE))
+	DBC_ASSERT(xlator_obj->ul_seg_id > 0);
+	allocator = cmm_mgr_obj->pa_gppsm_seg_tab[xlator_obj->ul_seg_id - 1];
+	if (!MEM_IS_VALID_HANDLE(allocator, SMEMSIGNATURE))
 		goto loop_cont;
 
 	if ((xType == CMM_VA2DSPPA) || (xType == CMM_VA2PA) ||
 	    (xType == CMM_PA2VA)) {
 		if (xType == CMM_PA2VA) {
 			/* Gpp Va = Va Base + offset */
-			dwOffset = (u8 *)pAddr - (u8 *)(pAlctr->dwSmBase -
-				    pAlctr->ulDSPSize);
-			dwAddrXlate = pXlator->dwVirtBase + dwOffset;
+			dw_offset = (u8 *) paddr - (u8 *) (allocator->shm_base -
+							   allocator->
+							   ul_dsp_size);
+			dw_addr_xlate = xlator_obj->dw_virt_base + dw_offset;
 			/* Check if translated Va base is in range */
-			if ((dwAddrXlate < pXlator->dwVirtBase) ||
-			   (dwAddrXlate >=
-			   (pXlator->dwVirtBase + pXlator->ulVirtSize))) {
-				dwAddrXlate = 0;	/* bad address */
+			if ((dw_addr_xlate < xlator_obj->dw_virt_base) ||
+			    (dw_addr_xlate >=
+			     (xlator_obj->dw_virt_base +
+			      xlator_obj->ul_virt_size))) {
+				dw_addr_xlate = 0;	/* bad address */
 			}
 		} else {
 			/* Gpp PA =  Gpp Base + offset */
-			dwOffset = (u8 *)pAddr - (u8 *)pXlator->dwVirtBase;
-			dwAddrXlate = pAlctr->dwSmBase - pAlctr->ulDSPSize +
-				      dwOffset;
+			dw_offset =
+			    (u8 *) paddr - (u8 *) xlator_obj->dw_virt_base;
+			dw_addr_xlate =
+			    allocator->shm_base - allocator->ul_dsp_size +
+			    dw_offset;
 		}
 	} else {
-		dwAddrXlate = (u32)pAddr;
+		dw_addr_xlate = (u32) paddr;
 	}
-	 /*Now convert address to proper target physical address if needed*/
+	/*Now convert address to proper target physical address if needed */
 	if ((xType == CMM_VA2DSPPA) || (xType == CMM_PA2DSPPA)) {
 		/* Got Gpp Pa now, convert to DSP Pa */
-		dwAddrXlate = GPPPA2DSPPA((pAlctr->dwSmBase - pAlctr->
-					 ulDSPSize), dwAddrXlate,
-					 pAlctr->dwDSPPhysAddrOffset *
-					 pAlctr->cFactor);
+		dw_addr_xlate =
+		    GPPPA2DSPPA((allocator->shm_base - allocator->ul_dsp_size),
+				dw_addr_xlate,
+				allocator->dw_dsp_phys_addr_offset *
+				allocator->c_factor);
 	} else if (xType == CMM_DSPPA2PA) {
 		/* Got DSP Pa, convert to GPP Pa */
-		dwAddrXlate = DSPPA2GPPPA(pAlctr->dwSmBase - pAlctr->ulDSPSize,
-					  dwAddrXlate,
-					  pAlctr->dwDSPPhysAddrOffset *
-					  pAlctr->cFactor);
+		dw_addr_xlate =
+		    DSPPA2GPPPA(allocator->shm_base - allocator->ul_dsp_size,
+				dw_addr_xlate,
+				allocator->dw_dsp_phys_addr_offset *
+				allocator->c_factor);
 	}
 loop_cont:
-	return (void *)dwAddrXlate;
+	return (void *)dw_addr_xlate;
 }
diff --git a/drivers/dsp/bridge/pmgr/cod.c b/drivers/dsp/bridge/pmgr/cod.c
index 1b535fd..548f1eb 100644
--- a/drivers/dsp/bridge/pmgr/cod.c
+++ b/drivers/dsp/bridge/pmgr/cod.c
@@ -48,168 +48,168 @@
 #define MAGIC	 0xc001beef
 
 /* macro to validate COD manager handles */
-#define IsValid(h)    ((h) != NULL && (h)->ulMagic == MAGIC)
+#define IS_VALID(h)    ((h) != NULL && (h)->ul_magic == MAGIC)
 
 /*
- *  ======== COD_MANAGER ========
+ *  ======== cod_manager ========
  */
-struct COD_MANAGER {
-	struct DBLL_TarObj *target;
-	struct DBLL_LibraryObj *baseLib;
-	bool fLoaded;		/* Base library loaded? */
-	u32 ulEntry;
-	struct LDR_MODULE *hDll;
-	struct DBLL_Fxns fxns;
-	struct DBLL_Attrs attrs;
-	char szZLFile[COD_MAXPATHLENGTH];
-	u32 ulMagic;
-} ;
+struct cod_manager {
+	struct dbll_tar_obj *target;
+	struct dbll_library_obj *base_lib;
+	bool loaded;		/* Base library loaded? */
+	u32 ul_entry;
+	struct ldr_module *dll_obj;
+	struct dbll_fxns fxns;
+	struct dbll_attrs attrs;
+	char sz_zl_file[COD_MAXPATHLENGTH];
+	u32 ul_magic;
+};
 
 /*
- *  ======== COD_LIBRARYOBJ ========
+ *  ======== cod_libraryobj ========
  */
-struct COD_LIBRARYOBJ {
-	struct DBLL_LibraryObj *dbllLib;
-	struct COD_MANAGER *hCodMgr;
-} ;
-
-static u32 cRefs = 0L;
-
-static struct DBLL_Fxns dbllFxns = {
-	(DBLL_CloseFxn) DBLL_close,
-	(DBLL_CreateFxn) DBLL_create,
-	(DBLL_DeleteFxn) DBLL_delete,
-	(DBLL_ExitFxn) DBLL_exit,
-	(DBLL_GetAttrsFxn) DBLL_getAttrs,
-	(DBLL_GetAddrFxn) DBLL_getAddr,
-	(DBLL_GetCAddrFxn) DBLL_getCAddr,
-	(DBLL_GetSectFxn) DBLL_getSect,
-	(DBLL_InitFxn) DBLL_init,
-	(DBLL_LoadFxn) DBLL_load,
-	(DBLL_LoadSectFxn) DBLL_loadSect,
-	(DBLL_OpenFxn) DBLL_open,
-	(DBLL_ReadSectFxn) DBLL_readSect,
-	(DBLL_SetAttrsFxn) DBLL_setAttrs,
-	(DBLL_UnloadFxn) DBLL_unload,
-	(DBLL_UnloadSectFxn) DBLL_unloadSect,
+struct cod_libraryobj {
+	struct dbll_library_obj *dbll_lib;
+	struct cod_manager *cod_mgr;
+};
+
+static u32 refs = 0L;
+
+static struct dbll_fxns ldr_fxns = {
+	(dbll_close_fxn) dbll_close,
+	(dbll_create_fxn) dbll_create,
+	(dbll_delete_fxn) dbll_delete,
+	(dbll_exit_fxn) dbll_exit,
+	(dbll_get_attrs_fxn) dbll_get_attrs,
+	(dbll_get_addr_fxn) dbll_get_addr,
+	(dbll_get_c_addr_fxn) dbll_get_c_addr,
+	(dbll_get_sect_fxn) dbll_get_sect,
+	(dbll_init_fxn) dbll_init,
+	(dbll_load_fxn) dbll_load,
+	(dbll_load_sect_fxn) dbll_load_sect,
+	(dbll_open_fxn) dbll_open,
+	(dbll_read_sect_fxn) dbll_read_sect,
+	(dbll_set_attrs_fxn) dbll_set_attrs,
+	(dbll_unload_fxn) dbll_unload,
+	(dbll_unload_sect_fxn) dbll_unload_sect,
 };
 
-static bool NoOp(void);
+static bool no_op(void);
 
 /*
  * File operations (originally were under kfile.c)
  */
-static s32 COD_fClose(struct file *hFile)
+static s32 cod_f_close(struct file *filp)
 {
 	/* Check for valid handle */
-	if (!hFile)
+	if (!filp)
 		return DSP_EHANDLE;
 
-	filp_close(hFile, NULL);
+	filp_close(filp, NULL);
 
 	/* we can't use DSP_SOK here */
 	return 0;
 }
 
-static struct file *COD_fOpen(CONST char *pszFileName, CONST char *pszMode)
+static struct file *cod_f_open(CONST char *psz_file_name, CONST char *pszMode)
 {
 	mm_segment_t fs;
-	struct file *hFile;
+	struct file *filp;
 
 	fs = get_fs();
 	set_fs(get_ds());
 
 	/* ignore given mode and open file as read-only */
-	hFile = filp_open(pszFileName, O_RDONLY, 0);
+	filp = filp_open(psz_file_name, O_RDONLY, 0);
 
-	if (IS_ERR(hFile))
-		hFile = NULL;
+	if (IS_ERR(filp))
+		filp = NULL;
 
 	set_fs(fs);
 
-	return hFile;
+	return filp;
 }
 
-static s32 COD_fRead(void __user *pBuffer, s32 cSize, s32 cCount,
-		     struct file *hFile)
+static s32 cod_f_read(void __user *pbuffer, s32 size, s32 cCount,
+		      struct file *filp)
 {
 	/* check for valid file handle */
-	if (!hFile)
+	if (!filp)
 		return DSP_EHANDLE;
 
-	if ((cSize > 0) && (cCount > 0) && pBuffer) {
-		u32 dwBytesRead;
+	if ((size > 0) && (cCount > 0) && pbuffer) {
+		u32 dw_bytes_read;
 		mm_segment_t fs;
 
 		/* read from file */
 		fs = get_fs();
 		set_fs(get_ds());
-		dwBytesRead = hFile->f_op->read(hFile, pBuffer, cSize * cCount,
-						&(hFile->f_pos));
+		dw_bytes_read = filp->f_op->read(filp, pbuffer, size * cCount,
+						 &(filp->f_pos));
 		set_fs(fs);
 
-		if (!dwBytesRead)
+		if (!dw_bytes_read)
 			return DSP_EFREAD;
 
-		return dwBytesRead / cSize;
+		return dw_bytes_read / size;
 	}
 
 	return DSP_EINVALIDARG;
 }
 
-static s32 COD_fSeek(struct file *hFile, s32 lOffset, s32 cOrigin)
+static s32 cod_f_seek(struct file *filp, s32 lOffset, s32 cOrigin)
 {
-	loff_t dwCurPos;
+	loff_t dw_cur_pos;
 
 	/* check for valid file handle */
-	if (!hFile)
+	if (!filp)
 		return DSP_EHANDLE;
 
 	/* based on the origin flag, move the internal pointer */
-	dwCurPos = hFile->f_op->llseek(hFile, lOffset, cOrigin);
+	dw_cur_pos = filp->f_op->llseek(filp, lOffset, cOrigin);
 
-	if ((s32)dwCurPos < 0)
+	if ((s32) dw_cur_pos < 0)
 		return DSP_EFAIL;
 
 	/* we can't use DSP_SOK here */
 	return 0;
 }
 
-static s32 COD_fTell(struct file *hFile)
+static s32 cod_f_tell(struct file *filp)
 {
-	loff_t dwCurPos;
+	loff_t dw_cur_pos;
 
-	if (!hFile)
+	if (!filp)
 		return DSP_EHANDLE;
 
 	/* Get current position */
-	dwCurPos = hFile->f_op->llseek(hFile, 0, SEEK_CUR);
+	dw_cur_pos = filp->f_op->llseek(filp, 0, SEEK_CUR);
 
-	if ((s32)dwCurPos < 0)
+	if ((s32) dw_cur_pos < 0)
 		return DSP_EFAIL;
 
-	return dwCurPos;
+	return dw_cur_pos;
 }
 
 /*
- *  ======== COD_Close ========
+ *  ======== cod_close ========
  */
-void COD_Close(struct COD_LIBRARYOBJ *lib)
+void cod_close(struct cod_libraryobj *lib)
 {
-	struct COD_MANAGER *hMgr;
+	struct cod_manager *hmgr;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(lib != NULL);
-	DBC_Require(IsValid(((struct COD_LIBRARYOBJ *)lib)->hCodMgr));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(lib != NULL);
+	DBC_REQUIRE(IS_VALID(((struct cod_libraryobj *)lib)->cod_mgr));
 
-	hMgr = lib->hCodMgr;
-	hMgr->fxns.closeFxn(lib->dbllLib);
+	hmgr = lib->cod_mgr;
+	hmgr->fxns.close_fxn(lib->dbll_lib);
 
 	kfree(lib);
 }
 
 /*
- *  ======== COD_Create ========
+ *  ======== cod_create ========
  *  Purpose:
  *      Create an object to manage code on a DSP system.
  *      This object can be used to load an initial program image with
@@ -217,15 +217,15 @@ void COD_Close(struct COD_LIBRARYOBJ *lib)
  *      dynamically loaded object files.
  *
  */
-DSP_STATUS COD_Create(OUT struct COD_MANAGER **phMgr, char *pstrDummyFile,
-		     IN OPTIONAL CONST struct COD_ATTRS *attrs)
+dsp_status cod_create(OUT struct cod_manager **phMgr, char *pstrDummyFile,
+		      IN OPTIONAL CONST struct cod_attrs *attrs)
 {
-	struct COD_MANAGER *hMgrNew;
-	struct DBLL_Attrs zlAttrs;
-	DSP_STATUS status = DSP_SOK;
+	struct cod_manager *mgr_new;
+	struct dbll_attrs zl_attrs;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMgr != NULL);
 
 	/* assume failure */
 	*phMgr = NULL;
@@ -234,122 +234,122 @@ DSP_STATUS COD_Create(OUT struct COD_MANAGER **phMgr, char *pstrDummyFile,
 	if (attrs != NULL)
 		return DSP_ENOTIMPL;
 
-	hMgrNew = MEM_Calloc(sizeof(struct COD_MANAGER), MEM_NONPAGED);
-	if (hMgrNew == NULL)
+	mgr_new = mem_calloc(sizeof(struct cod_manager), MEM_NONPAGED);
+	if (mgr_new == NULL)
 		return DSP_EMEMORY;
 
-	hMgrNew->ulMagic = MAGIC;
+	mgr_new->ul_magic = MAGIC;
 
 	/* Set up loader functions */
-	hMgrNew->fxns = dbllFxns;
+	mgr_new->fxns = ldr_fxns;
 
 	/* initialize the ZL module */
-	hMgrNew->fxns.initFxn();
-
-	zlAttrs.alloc = (DBLL_AllocFxn)NoOp;
-	zlAttrs.free = (DBLL_FreeFxn)NoOp;
-	zlAttrs.fread = (DBLL_ReadFxn)COD_fRead;
-	zlAttrs.fseek = (DBLL_SeekFxn)COD_fSeek;
-	zlAttrs.ftell = (DBLL_TellFxn)COD_fTell;
-	zlAttrs.fclose = (DBLL_FCloseFxn)COD_fClose;
-	zlAttrs.fopen = (DBLL_FOpenFxn)COD_fOpen;
-	zlAttrs.symLookup = NULL;
-	zlAttrs.baseImage = true;
-	zlAttrs.logWrite = NULL;
-	zlAttrs.logWriteHandle = NULL;
-	zlAttrs.write = NULL;
-	zlAttrs.rmmHandle = NULL;
-	zlAttrs.wHandle = NULL;
-	zlAttrs.symHandle = NULL;
-	zlAttrs.symArg = NULL;
-
-	hMgrNew->attrs = zlAttrs;
-
-	status = hMgrNew->fxns.createFxn(&hMgrNew->target, &zlAttrs);
+	mgr_new->fxns.init_fxn();
+
+	zl_attrs.alloc = (dbll_alloc_fxn) no_op;
+	zl_attrs.free = (dbll_free_fxn) no_op;
+	zl_attrs.fread = (dbll_read_fxn) cod_f_read;
+	zl_attrs.fseek = (dbll_seek_fxn) cod_f_seek;
+	zl_attrs.ftell = (dbll_tell_fxn) cod_f_tell;
+	zl_attrs.fclose = (dbll_f_close_fxn) cod_f_close;
+	zl_attrs.fopen = (dbll_f_open_fxn) cod_f_open;
+	zl_attrs.sym_lookup = NULL;
+	zl_attrs.base_image = true;
+	zl_attrs.log_write = NULL;
+	zl_attrs.log_write_handle = NULL;
+	zl_attrs.write = NULL;
+	zl_attrs.rmm_handle = NULL;
+	zl_attrs.input_params = NULL;
+	zl_attrs.sym_handle = NULL;
+	zl_attrs.sym_arg = NULL;
+
+	mgr_new->attrs = zl_attrs;
+
+	status = mgr_new->fxns.create_fxn(&mgr_new->target, &zl_attrs);
 
 	if (DSP_FAILED(status)) {
-		COD_Delete(hMgrNew);
+		cod_delete(mgr_new);
 		return COD_E_ZLCREATEFAILED;
 	}
 
 	/* return the new manager */
-	*phMgr = hMgrNew;
+	*phMgr = mgr_new;
 
 	return DSP_SOK;
 }
 
 /*
- *  ======== COD_Delete ========
+ *  ======== cod_delete ========
  *  Purpose:
  *      Delete a code manager object.
  */
-void COD_Delete(struct COD_MANAGER *hMgr)
+void cod_delete(struct cod_manager *hmgr)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
 
-	if (hMgr->baseLib) {
-		if (hMgr->fLoaded)
-			hMgr->fxns.unloadFxn(hMgr->baseLib, &hMgr->attrs);
+	if (hmgr->base_lib) {
+		if (hmgr->loaded)
+			hmgr->fxns.unload_fxn(hmgr->base_lib, &hmgr->attrs);
 
-		hMgr->fxns.closeFxn(hMgr->baseLib);
+		hmgr->fxns.close_fxn(hmgr->base_lib);
 	}
-	if (hMgr->target) {
-		hMgr->fxns.deleteFxn(hMgr->target);
-		hMgr->fxns.exitFxn();
+	if (hmgr->target) {
+		hmgr->fxns.delete_fxn(hmgr->target);
+		hmgr->fxns.exit_fxn();
 	}
-	hMgr->ulMagic = ~MAGIC;
-	kfree(hMgr);
+	hmgr->ul_magic = ~MAGIC;
+	kfree(hmgr);
 }
 
 /*
- *  ======== COD_Exit ========
+ *  ======== cod_exit ========
  *  Purpose:
  *      Discontinue usage of the COD module.
  *
  */
-void COD_Exit(void)
+void cod_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== COD_GetBaseLib ========
+ *  ======== cod_get_base_lib ========
  *  Purpose:
  *      Get handle to the base image DBL library.
  */
-DSP_STATUS COD_GetBaseLib(struct COD_MANAGER *hManager,
-				struct DBLL_LibraryObj **plib)
+dsp_status cod_get_base_lib(struct cod_manager *cod_mgr_obj,
+			    struct dbll_library_obj **plib)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hManager));
-	DBC_Require(plib != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
+	DBC_REQUIRE(plib != NULL);
 
-	*plib = (struct DBLL_LibraryObj *) hManager->baseLib;
+	*plib = (struct dbll_library_obj *)cod_mgr_obj->base_lib;
 
 	return status;
 }
 
 /*
- *  ======== COD_GetBaseName ========
+ *  ======== cod_get_base_name ========
  */
-DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager, char *pszName,
-				u32 uSize)
+dsp_status cod_get_base_name(struct cod_manager *cod_mgr_obj, char *pszName,
+			     u32 usize)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hManager));
-	DBC_Require(pszName != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
+	DBC_REQUIRE(pszName != NULL);
 
-	if (uSize <= COD_MAXPATHLENGTH)
-		strncpy(pszName, hManager->szZLFile, uSize);
+	if (usize <= COD_MAXPATHLENGTH)
+		strncpy(pszName, cod_mgr_obj->sz_zl_file, usize);
 	else
 		status = DSP_EFAIL;
 
@@ -357,131 +357,132 @@ DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager, char *pszName,
 }
 
 /*
- *  ======== COD_GetEntry ========
+ *  ======== cod_get_entry ========
  *  Purpose:
  *      Retrieve the entry point of a loaded DSP program image
  *
  */
-DSP_STATUS COD_GetEntry(struct COD_MANAGER *hManager, u32 *pulEntry)
+dsp_status cod_get_entry(struct cod_manager *cod_mgr_obj, u32 *pulEntry)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hManager));
-	DBC_Require(pulEntry != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
+	DBC_REQUIRE(pulEntry != NULL);
 
-	*pulEntry = hManager->ulEntry;
+	*pulEntry = cod_mgr_obj->ul_entry;
 
 	return DSP_SOK;
 }
 
 /*
- *  ======== COD_GetLoader ========
+ *  ======== cod_get_loader ========
  *  Purpose:
  *      Get handle to the DBLL loader.
  */
-DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
-				struct DBLL_TarObj **phLoader)
+dsp_status cod_get_loader(struct cod_manager *cod_mgr_obj,
+			  struct dbll_tar_obj **phLoader)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hManager));
-	DBC_Require(phLoader != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
+	DBC_REQUIRE(phLoader != NULL);
 
-	*phLoader = (struct DBLL_TarObj *)hManager->target;
+	*phLoader = (struct dbll_tar_obj *)cod_mgr_obj->target;
 
 	return status;
 }
 
 /*
- *  ======== COD_GetSection ========
+ *  ======== cod_get_section ========
  *  Purpose:
  *      Retrieve the starting address and length of a section in the COFF file
  *      given the section name.
  */
-DSP_STATUS COD_GetSection(struct COD_LIBRARYOBJ *lib, IN char *pstrSect,
-			  OUT u32 *puAddr, OUT u32 *puLen)
+dsp_status cod_get_section(struct cod_libraryobj *lib, IN char *pstrSect,
+			   OUT u32 *puAddr, OUT u32 *puLen)
 {
-	struct COD_MANAGER *hManager;
-	DSP_STATUS status = DSP_SOK;
+	struct cod_manager *cod_mgr_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(lib != NULL);
-	DBC_Require(IsValid(lib->hCodMgr));
-	DBC_Require(pstrSect != NULL);
-	DBC_Require(puAddr != NULL);
-	DBC_Require(puLen != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(lib != NULL);
+	DBC_REQUIRE(IS_VALID(lib->cod_mgr));
+	DBC_REQUIRE(pstrSect != NULL);
+	DBC_REQUIRE(puAddr != NULL);
+	DBC_REQUIRE(puLen != NULL);
 
 	*puAddr = 0;
 	*puLen = 0;
 	if (lib != NULL) {
-		hManager = lib->hCodMgr;
-		status = hManager->fxns.getSectFxn(lib->dbllLib, pstrSect,
-						   puAddr, puLen);
+		cod_mgr_obj = lib->cod_mgr;
+		status = cod_mgr_obj->fxns.get_sect_fxn(lib->dbll_lib, pstrSect,
+							puAddr, puLen);
 	} else {
 		status = COD_E_NOSYMBOLSLOADED;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((*puAddr == 0) && (*puLen == 0)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((*puAddr == 0) && (*puLen == 0)));
 
 	return status;
 }
 
 /*
- *  ======== COD_GetSymValue ========
+ *  ======== cod_get_sym_value ========
  *  Purpose:
  *      Retrieve the value for the specified symbol. The symbol is first
  *      searched for literally and then, if not found, searched for as a
  *      C symbol.
  *
  */
-DSP_STATUS COD_GetSymValue(struct COD_MANAGER *hMgr, char *pstrSym,
-			   u32 *pulValue)
+dsp_status cod_get_sym_value(struct cod_manager *hmgr, char *pstrSym,
+			     u32 *pul_value)
 {
-	struct DBLL_Symbol *pSym;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
-	DBC_Require(pstrSym != NULL);
-	DBC_Require(pulValue != NULL);
-
-	dev_dbg(bridge, "%s: hMgr: %p pstrSym: %s pulValue: %p\n",
-					__func__, hMgr, pstrSym, pulValue);
-	if (hMgr->baseLib) {
-		if (!hMgr->fxns.getAddrFxn(hMgr->baseLib, pstrSym, &pSym)) {
-			if (!hMgr->fxns.getCAddrFxn(hMgr->baseLib, pstrSym,
-			    &pSym))
+	struct dbll_sym_val *dbll_sym;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
+	DBC_REQUIRE(pstrSym != NULL);
+	DBC_REQUIRE(pul_value != NULL);
+
+	dev_dbg(bridge, "%s: hmgr: %p pstrSym: %s pul_value: %p\n",
+		__func__, hmgr, pstrSym, pul_value);
+	if (hmgr->base_lib) {
+		if (!hmgr->fxns.
+		    get_addr_fxn(hmgr->base_lib, pstrSym, &dbll_sym)) {
+			if (!hmgr->fxns.
+			    get_c_addr_fxn(hmgr->base_lib, pstrSym, &dbll_sym))
 				return COD_E_SYMBOLNOTFOUND;
 		}
 	} else {
 		return COD_E_NOSYMBOLSLOADED;
 	}
 
-	*pulValue = pSym->value;
+	*pul_value = dbll_sym->value;
 
 	return DSP_SOK;
 }
 
 /*
- *  ======== COD_Init ========
+ *  ======== cod_init ========
  *  Purpose:
  *      Initialize the COD module's private state.
  *
  */
-bool COD_Init(void)
+bool cod_init(void)
 {
-	bool fRetVal = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (fRetVal)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetVal && cRefs > 0) || (!fRetVal && cRefs >= 0));
-	return fRetVal;
+	DBC_ENSURE((ret && refs > 0) || (!ret && refs >= 0));
+	return ret;
 }
 
 /*
- *  ======== COD_LoadBase ========
+ *  ======== cod_load_base ========
  *  Purpose:
  *      Load the initial program image, optionally with command-line arguments,
  *      on the DSP system managed by the supplied handle. The program to be
@@ -493,22 +494,22 @@ bool COD_Init(void)
  *      recalculated to reflect this.  In this way, we can support NULL
  *      terminating aArgs arrays, if nArgc is very large.
  */
-DSP_STATUS COD_LoadBase(struct COD_MANAGER *hMgr, u32 nArgc, char *aArgs[],
-			COD_WRITEFXN pfnWrite, void *pArb, char *envp[])
+dsp_status cod_load_base(struct cod_manager *hmgr, u32 nArgc, char *aArgs[],
+			 cod_writefxn pfn_write, void *pArb, char *envp[])
 {
-	DBLL_Flags flags;
-	struct DBLL_Attrs saveAttrs;
-	struct DBLL_Attrs newAttrs;
-	DSP_STATUS status;
+	dbll_flags flags;
+	struct dbll_attrs save_attrs;
+	struct dbll_attrs new_attrs;
+	dsp_status status;
 	u32 i;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
-	DBC_Require(nArgc > 0);
-	DBC_Require(aArgs != NULL);
-	DBC_Require(aArgs[0] != NULL);
-	DBC_Require(pfnWrite != NULL);
-	DBC_Require(hMgr->baseLib != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
+	DBC_REQUIRE(nArgc > 0);
+	DBC_REQUIRE(aArgs != NULL);
+	DBC_REQUIRE(aArgs[0] != NULL);
+	DBC_REQUIRE(pfn_write != NULL);
+	DBC_REQUIRE(hmgr->base_lib != NULL);
 
 	/*
 	 *  Make sure every argv[] stated in argc has a value, or change argc to
@@ -522,125 +523,125 @@ DSP_STATUS COD_LoadBase(struct COD_MANAGER *hMgr, u32 nArgc, char *aArgs[],
 	}
 
 	/* set the write function for this operation */
-	hMgr->fxns.getAttrsFxn(hMgr->target, &saveAttrs);
+	hmgr->fxns.get_attrs_fxn(hmgr->target, &save_attrs);
 
-	newAttrs = saveAttrs;
-	newAttrs.write = (DBLL_WriteFxn)pfnWrite;
-	newAttrs.wHandle = pArb;
-	newAttrs.alloc = (DBLL_AllocFxn)NoOp;
-	newAttrs.free = (DBLL_FreeFxn)NoOp;
-	newAttrs.logWrite = NULL;
-	newAttrs.logWriteHandle = NULL;
+	new_attrs = save_attrs;
+	new_attrs.write = (dbll_write_fxn) pfn_write;
+	new_attrs.input_params = pArb;
+	new_attrs.alloc = (dbll_alloc_fxn) no_op;
+	new_attrs.free = (dbll_free_fxn) no_op;
+	new_attrs.log_write = NULL;
+	new_attrs.log_write_handle = NULL;
 
 	/* Load the image */
 	flags = DBLL_CODE | DBLL_DATA | DBLL_SYMB;
-	status = hMgr->fxns.loadFxn(hMgr->baseLib, flags, &newAttrs,
-		 &hMgr->ulEntry);
+	status = hmgr->fxns.load_fxn(hmgr->base_lib, flags, &new_attrs,
+				     &hmgr->ul_entry);
 	if (DSP_FAILED(status))
-		hMgr->fxns.closeFxn(hMgr->baseLib);
+		hmgr->fxns.close_fxn(hmgr->base_lib);
 
 	if (DSP_SUCCEEDED(status))
-		hMgr->fLoaded = true;
+		hmgr->loaded = true;
 	else
-		hMgr->baseLib = NULL;
+		hmgr->base_lib = NULL;
 
 	return status;
 }
 
 /*
- *  ======== COD_Open ========
+ *  ======== cod_open ========
  *      Open library for reading sections.
  */
-DSP_STATUS COD_Open(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
-		    COD_FLAGS flags, struct COD_LIBRARYOBJ **pLib)
+dsp_status cod_open(struct cod_manager *hmgr, IN char *pszCoffPath,
+		    cod_flags flags, struct cod_libraryobj **pLib)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct COD_LIBRARYOBJ *lib = NULL;
+	dsp_status status = DSP_SOK;
+	struct cod_libraryobj *lib = NULL;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
-	DBC_Require(pszCoffPath != NULL);
-	DBC_Require(flags == COD_NOLOAD || flags == COD_SYMB);
-	DBC_Require(pLib != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
+	DBC_REQUIRE(pszCoffPath != NULL);
+	DBC_REQUIRE(flags == COD_NOLOAD || flags == COD_SYMB);
+	DBC_REQUIRE(pLib != NULL);
 
 	*pLib = NULL;
 
-	lib = MEM_Calloc(sizeof(struct COD_LIBRARYOBJ), MEM_NONPAGED);
+	lib = mem_calloc(sizeof(struct cod_libraryobj), MEM_NONPAGED);
 	if (lib == NULL)
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status)) {
-		lib->hCodMgr = hMgr;
-		status = hMgr->fxns.openFxn(hMgr->target, pszCoffPath, flags,
-					   &lib->dbllLib);
+		lib->cod_mgr = hmgr;
+		status = hmgr->fxns.open_fxn(hmgr->target, pszCoffPath, flags,
+					     &lib->dbll_lib);
 		if (DSP_SUCCEEDED(status))
 			*pLib = lib;
 	}
 
 	if (DSP_FAILED(status))
 		pr_err("%s: error status 0x%x, pszCoffPath: %s flags: 0x%x\n",
-					__func__, status, pszCoffPath, flags);
+		       __func__, status, pszCoffPath, flags);
 	return status;
 }
 
 /*
- *  ======== COD_OpenBase ========
+ *  ======== cod_open_base ========
  *  Purpose:
  *      Open base image for reading sections.
  */
-DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
-			DBLL_Flags flags)
+dsp_status cod_open_base(struct cod_manager *hmgr, IN char *pszCoffPath,
+			 dbll_flags flags)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DBLL_LibraryObj *lib;
+	dsp_status status = DSP_SOK;
+	struct dbll_library_obj *lib;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
-	DBC_Require(pszCoffPath != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
+	DBC_REQUIRE(pszCoffPath != NULL);
 
 	/* if we previously opened a base image, close it now */
-	if (hMgr->baseLib) {
-		if (hMgr->fLoaded) {
-			hMgr->fxns.unloadFxn(hMgr->baseLib, &hMgr->attrs);
-			hMgr->fLoaded = false;
+	if (hmgr->base_lib) {
+		if (hmgr->loaded) {
+			hmgr->fxns.unload_fxn(hmgr->base_lib, &hmgr->attrs);
+			hmgr->loaded = false;
 		}
-		hMgr->fxns.closeFxn(hMgr->baseLib);
-		hMgr->baseLib = NULL;
+		hmgr->fxns.close_fxn(hmgr->base_lib);
+		hmgr->base_lib = NULL;
 	}
-	status = hMgr->fxns.openFxn(hMgr->target, pszCoffPath, flags, &lib);
+	status = hmgr->fxns.open_fxn(hmgr->target, pszCoffPath, flags, &lib);
 	if (DSP_SUCCEEDED(status)) {
 		/* hang onto the library for subsequent sym table usage */
-		hMgr->baseLib = lib;
-		strncpy(hMgr->szZLFile, pszCoffPath, COD_MAXPATHLENGTH - 1);
-		hMgr->szZLFile[COD_MAXPATHLENGTH - 1] = '\0';
+		hmgr->base_lib = lib;
+		strncpy(hmgr->sz_zl_file, pszCoffPath, COD_MAXPATHLENGTH - 1);
+		hmgr->sz_zl_file[COD_MAXPATHLENGTH - 1] = '\0';
 	}
 
 	if (DSP_FAILED(status))
 		pr_err("%s: error status 0x%x pszCoffPath: %s\n", __func__,
-							status, pszCoffPath);
+		       status, pszCoffPath);
 	return status;
 }
 
 /*
- *  ======== COD_ReadSection ========
+ *  ======== cod_read_section ========
  *  Purpose:
  *      Retrieve the content of a code section given the section name.
  */
-DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib, IN char *pstrSect,
-			   OUT char *pstrContent, IN u32 cContentSize)
+dsp_status cod_read_section(struct cod_libraryobj *lib, IN char *pstrSect,
+			    OUT char *pstrContent, IN u32 cContentSize)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(lib != NULL);
-	DBC_Require(IsValid(lib->hCodMgr));
-	DBC_Require(pstrSect != NULL);
-	DBC_Require(pstrContent != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(lib != NULL);
+	DBC_REQUIRE(IS_VALID(lib->cod_mgr));
+	DBC_REQUIRE(pstrSect != NULL);
+	DBC_REQUIRE(pstrContent != NULL);
 
 	if (lib != NULL)
-		status = lib->hCodMgr->fxns.readSectFxn(lib->dbllLib, pstrSect,
-							pstrContent,
-							cContentSize);
+		status =
+		    lib->cod_mgr->fxns.read_sect_fxn(lib->dbll_lib, pstrSect,
+						     pstrContent, cContentSize);
 	else
 		status = COD_E_NOSYMBOLSLOADED;
 
@@ -648,13 +649,12 @@ DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib, IN char *pstrSect,
 }
 
 /*
- *  ======== NoOp ========
+ *  ======== no_op ========
  *  Purpose:
  *      No Operation.
  *
  */
-static bool NoOp(void)
+static bool no_op(void)
 {
 	return true;
 }
-
diff --git a/drivers/dsp/bridge/pmgr/dbll.c b/drivers/dsp/bridge/pmgr/dbll.c
index 904e03d..9ac1f6b 100644
--- a/drivers/dsp/bridge/pmgr/dbll.c
+++ b/drivers/dsp/bridge/pmgr/dbll.c
@@ -52,325 +52,328 @@
 #define DOFF_ALIGN(x) (((x) + 3) & ~UINT32_C(3))
 
 /*
- *  ======== struct DBLL_TarObj* ========
+ *  ======== struct dbll_tar_obj* ========
  *  A target may have one or more libraries of symbols/code/data loaded
  *  onto it, where a library is simply the symbols/code/data contained
  *  in a DOFF file.
  */
 /*
- *  ======== DBLL_TarObj ========
+ *  ======== dbll_tar_obj ========
  */
-struct DBLL_TarObj {
-	u32 dwSignature; 	/* For object validation */
-	struct DBLL_Attrs attrs;
-	struct DBLL_LibraryObj *head; 	/* List of all opened libraries */
-} ;
+struct dbll_tar_obj {
+	u32 dw_signature;	/* For object validation */
+	struct dbll_attrs attrs;
+	struct dbll_library_obj *head;	/* List of all opened libraries */
+};
 
 /*
  *  The following 4 typedefs are "super classes" of the dynamic loader
  *  library types used in dynamic loader functions (dynamic_loader.h).
  */
 /*
- *  ======== DBLLStream ========
- *  Contains Dynamic_Loader_Stream
+ *  ======== dbll_stream ========
+ *  Contains dynamic_loader_stream
  */
-struct DBLLStream {
-	struct Dynamic_Loader_Stream dlStream;
-	struct DBLL_LibraryObj *lib;
-} ;
+struct dbll_stream {
+	struct dynamic_loader_stream dl_stream;
+	struct dbll_library_obj *lib;
+};
 
 /*
- *  ======== DBLLSymbol ========
+ *  ======== ldr_symbol ========
  */
-struct DBLLSymbol {
-	struct Dynamic_Loader_Sym dlSymbol;
-	struct DBLL_LibraryObj *lib;
-} ;
+struct ldr_symbol {
+	struct dynamic_loader_sym dl_symbol;
+	struct dbll_library_obj *lib;
+};
 
 /*
- *  ======== DBLLAlloc ========
+ *  ======== dbll_alloc ========
  */
- struct DBLLAlloc {
-	struct Dynamic_Loader_Allocate dlAlloc;
-	struct DBLL_LibraryObj *lib;
-} ;
+struct dbll_alloc {
+	struct dynamic_loader_allocate dl_alloc;
+	struct dbll_library_obj *lib;
+};
 
 /*
- *  ======== DBLLInit ========
+ *  ======== dbll_init_obj ========
  */
-struct DBLLInit {
-	struct Dynamic_Loader_Initialize dlInit;
-	struct DBLL_LibraryObj *lib;
+struct dbll_init_obj {
+	struct dynamic_loader_initialize dl_init;
+	struct dbll_library_obj *lib;
 };
 
 /*
  *  ======== DBLL_Library ========
- *  A library handle is returned by DBLL_Open() and is passed to DBLL_load()
- *  to load symbols/code/data, and to DBLL_unload(), to remove the
- *  symbols/code/data loaded by DBLL_load().
+ *  A library handle is returned by DBLL_Open() and is passed to dbll_load()
+ *  to load symbols/code/data, and to dbll_unload(), to remove the
+ *  symbols/code/data loaded by dbll_load().
  */
 
 /*
- *  ======== DBLL_LibraryObj ========
+ *  ======== dbll_library_obj ========
  */
- struct DBLL_LibraryObj {
-	u32 dwSignature; 	/* For object validation */
-	struct DBLL_LibraryObj *next; 	/* Next library in target's list */
-	struct DBLL_LibraryObj *prev; 	/* Previous in the list */
-	struct DBLL_TarObj *pTarget; 	/* target for this library */
+struct dbll_library_obj {
+	u32 dw_signature;	/* For object validation */
+	struct dbll_library_obj *next;	/* Next library in target's list */
+	struct dbll_library_obj *prev;	/* Previous in the list */
+	struct dbll_tar_obj *target_obj;	/* target for this library */
 
 	/* Objects needed by dynamic loader */
-	struct DBLLStream stream;
-	struct DBLLSymbol symbol;
-	struct DBLLAlloc allocate;
-	struct DBLLInit init;
-	DLOAD_mhandle mHandle;
-
-	char *fileName; 	/* COFF file name */
-	void *fp; 		/* Opaque file handle */
-	u32 entry; 		/* Entry point */
-	DLOAD_mhandle desc; 	/* desc of DOFF file loaded */
-	u32 openRef; 		/* Number of times opened */
-	u32 loadRef; 		/* Number of times loaded */
-	struct GH_THashTab *symTab; 	/* Hash table of symbols */
-	u32 ulPos;
-} ;
+	struct dbll_stream stream;
+	struct ldr_symbol symbol;
+	struct dbll_alloc allocate;
+	struct dbll_init_obj init;
+	dload_mhandle dload_mod_obj;
+
+	char *file_name;	/* COFF file name */
+	void *fp;		/* Opaque file handle */
+	u32 entry;		/* Entry point */
+	dload_mhandle desc;	/* desc of DOFF file loaded */
+	u32 open_ref;		/* Number of times opened */
+	u32 load_ref;		/* Number of times loaded */
+	struct gh_t_hash_tab *sym_tab;	/* Hash table of symbols */
+	u32 ul_pos;
+};
 
 /*
- *  ======== Symbol ========
+ *  ======== dbll_symbol ========
  */
-struct Symbol {
-	struct DBLL_Symbol value;
+struct dbll_symbol {
+	struct dbll_sym_val value;
 	char *name;
-} ;
-extern bool bSymbolsReloaded;
+};
+extern bool symbols_reloaded;
 
-static void dofClose(struct DBLL_LibraryObj *zlLib);
-static DSP_STATUS dofOpen(struct DBLL_LibraryObj *zlLib);
-static s32 NoOp(struct Dynamic_Loader_Initialize *thisptr, void *bufr,
-		LDR_ADDR locn, struct LDR_SECTION_INFO *info, unsigned bytsiz);
+static void dof_close(struct dbll_library_obj *zl_lib);
+static dsp_status dof_open(struct dbll_library_obj *zl_lib);
+static s32 no_op(struct dynamic_loader_initialize *thisptr, void *bufr,
+		 ldr_addr locn, struct ldr_section_info *info, unsigned bytsiz);
 
 /*
  *  Functions called by dynamic loader
  *
  */
-/* Dynamic_Loader_Stream */
-static int readBuffer(struct Dynamic_Loader_Stream *this, void *buffer,
-		     unsigned bufsize);
-static int setFilePosn(struct Dynamic_Loader_Stream *this, unsigned int pos);
-/* Dynamic_Loader_Sym */
-static struct dynload_symbol *findSymbol(struct Dynamic_Loader_Sym *this,
-					const char *name);
-static struct dynload_symbol *addToSymbolTable(struct Dynamic_Loader_Sym *this,
-					      const char *name,
-					      unsigned moduleId);
-static struct dynload_symbol *findInSymbolTable(struct Dynamic_Loader_Sym *this,
-						const char *name,
-						unsigned moduleid);
-static void purgeSymbolTable(struct Dynamic_Loader_Sym *this,
-			    unsigned moduleId);
-static void *allocate(struct Dynamic_Loader_Sym *this, unsigned memsize);
-static void deallocate(struct Dynamic_Loader_Sym *this, void *memPtr);
-static void errorReport(struct Dynamic_Loader_Sym *this, const char *errstr,
-			va_list args);
-/* Dynamic_Loader_Allocate */
-static int rmmAlloc(struct Dynamic_Loader_Allocate *this,
-		   struct LDR_SECTION_INFO *info, unsigned align);
-static void rmmDealloc(struct Dynamic_Loader_Allocate *this,
-		      struct LDR_SECTION_INFO *info);
-
-/* Dynamic_Loader_Initialize */
-static int connect(struct Dynamic_Loader_Initialize *this);
-static int readMem(struct Dynamic_Loader_Initialize *this, void *buf,
-		  LDR_ADDR addr, struct LDR_SECTION_INFO *info,
-		  unsigned nbytes);
-static int writeMem(struct Dynamic_Loader_Initialize *this, void *buf,
-		   LDR_ADDR addr, struct LDR_SECTION_INFO *info,
-		   unsigned nbytes);
-static int fillMem(struct Dynamic_Loader_Initialize *this, LDR_ADDR addr,
-		   struct LDR_SECTION_INFO *info, unsigned nbytes,
-		   unsigned val);
-static int execute(struct Dynamic_Loader_Initialize *this, LDR_ADDR start);
-static void release(struct Dynamic_Loader_Initialize *this);
+/* dynamic_loader_stream */
+static int dbll_read_buffer(struct dynamic_loader_stream *this, void *buffer,
+			    unsigned bufsize);
+static int dbll_set_file_posn(struct dynamic_loader_stream *this,
+			      unsigned int pos);
+/* dynamic_loader_sym */
+static struct dynload_symbol *dbll_find_symbol(struct dynamic_loader_sym *this,
+					       const char *name);
+static struct dynload_symbol *dbll_add_to_symbol_table(struct dynamic_loader_sym
+						       *this, const char *name,
+						       unsigned moduleId);
+static struct dynload_symbol *find_in_symbol_table(struct dynamic_loader_sym
+						   *this, const char *name,
+						   unsigned moduleid);
+static void dbll_purge_symbol_table(struct dynamic_loader_sym *this,
+				    unsigned moduleId);
+static void *allocate(struct dynamic_loader_sym *this, unsigned memsize);
+static void deallocate(struct dynamic_loader_sym *this, void *memPtr);
+static void dbll_err_report(struct dynamic_loader_sym *this, const char *errstr,
+			    va_list args);
+/* dynamic_loader_allocate */
+static int dbll_rmm_alloc(struct dynamic_loader_allocate *this,
+			  struct ldr_section_info *info, unsigned align);
+static void rmm_dealloc(struct dynamic_loader_allocate *this,
+			struct ldr_section_info *info);
+
+/* dynamic_loader_initialize */
+static int connect(struct dynamic_loader_initialize *this);
+static int read_mem(struct dynamic_loader_initialize *this, void *buf,
+		    ldr_addr addr, struct ldr_section_info *info,
+		    unsigned nbytes);
+static int write_mem(struct dynamic_loader_initialize *this, void *buf,
+		     ldr_addr addr, struct ldr_section_info *info,
+		     unsigned nbytes);
+static int fill_mem(struct dynamic_loader_initialize *this, ldr_addr addr,
+		    struct ldr_section_info *info, unsigned nbytes,
+		    unsigned val);
+static int execute(struct dynamic_loader_initialize *this, ldr_addr start);
+static void release(struct dynamic_loader_initialize *this);
 
 /* symbol table hash functions */
-static u16 nameHash(void *name, u16 maxBucket);
-static bool nameMatch(void *name, void *sp);
-static void symDelete(void *sp);
+static u16 name_hash(void *name, u16 max_bucket);
+static bool name_match(void *name, void *sp);
+static void sym_delete(void *sp);
 
-static u32 cRefs; 		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /* Symbol Redefinition */
-static int bRedefinedSymbol;
-static int bGblSearch = 1;
+static int redefined_symbol;
+static int gbl_search = 1;
 
 /*
- *  ======== DBLL_close ========
+ *  ======== dbll_close ========
  */
-void DBLL_close(struct DBLL_LibraryObj *zlLib)
+void dbll_close(struct dbll_library_obj *zl_lib)
 {
-	struct DBLL_TarObj *zlTarget;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(zlLib->openRef > 0);
-	zlTarget = zlLib->pTarget;
-	zlLib->openRef--;
-	if (zlLib->openRef == 0) {
+	struct dbll_tar_obj *zl_target;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(zl_lib->open_ref > 0);
+	zl_target = zl_lib->target_obj;
+	zl_lib->open_ref--;
+	if (zl_lib->open_ref == 0) {
 		/* Remove library from list */
-		if (zlTarget->head == zlLib)
-			zlTarget->head = zlLib->next;
+		if (zl_target->head == zl_lib)
+			zl_target->head = zl_lib->next;
 
-		if (zlLib->prev)
-			(zlLib->prev)->next = zlLib->next;
+		if (zl_lib->prev)
+			(zl_lib->prev)->next = zl_lib->next;
 
-		if (zlLib->next)
-			(zlLib->next)->prev = zlLib->prev;
+		if (zl_lib->next)
+			(zl_lib->next)->prev = zl_lib->prev;
 
 		/* Free DOF resources */
-		dofClose(zlLib);
-		kfree(zlLib->fileName);
+		dof_close(zl_lib);
+		kfree(zl_lib->file_name);
 
 		/* remove symbols from symbol table */
-		if (zlLib->symTab)
-			GH_delete(zlLib->symTab);
+		if (zl_lib->sym_tab)
+			gh_delete(zl_lib->sym_tab);
 
 		/* remove the library object itself */
-		MEM_FreeObject(zlLib);
-		zlLib = NULL;
+		MEM_FREE_OBJECT(zl_lib);
+		zl_lib = NULL;
 	}
 }
 
 /*
- *  ======== DBLL_create ========
+ *  ======== dbll_create ========
  */
-DSP_STATUS DBLL_create(struct DBLL_TarObj **pTarget, struct DBLL_Attrs *pAttrs)
+dsp_status dbll_create(struct dbll_tar_obj **target_obj,
+		       struct dbll_attrs *pattrs)
 {
-	struct DBLL_TarObj *pzlTarget;
-	DSP_STATUS status = DSP_SOK;
+	struct dbll_tar_obj *pzl_target;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAttrs != NULL);
-	DBC_Require(pTarget != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pattrs != NULL);
+	DBC_REQUIRE(target_obj != NULL);
 
 	/* Allocate DBL target object */
-	MEM_AllocObject(pzlTarget, struct DBLL_TarObj, DBLL_TARGSIGNATURE);
-	if (pTarget != NULL) {
-		if (pzlTarget == NULL) {
-			*pTarget = NULL;
+	MEM_ALLOC_OBJECT(pzl_target, struct dbll_tar_obj, DBLL_TARGSIGNATURE);
+	if (target_obj != NULL) {
+		if (pzl_target == NULL) {
+			*target_obj = NULL;
 			status = DSP_EMEMORY;
 		} else {
-			pzlTarget->attrs = *pAttrs;
-			*pTarget = (struct DBLL_TarObj *)pzlTarget;
+			pzl_target->attrs = *pattrs;
+			*target_obj = (struct dbll_tar_obj *)pzl_target;
 		}
-		DBC_Ensure((DSP_SUCCEEDED(status) &&
-			  MEM_IsValidHandle(((struct DBLL_TarObj *)(*pTarget)),
-			  DBLL_TARGSIGNATURE)) || (DSP_FAILED(status) &&
-			  *pTarget == NULL));
+		DBC_ENSURE((DSP_SUCCEEDED(status) &&
+			    MEM_IS_VALID_HANDLE(((struct dbll_tar_obj
+						  *)(*target_obj)),
+						DBLL_TARGSIGNATURE))
+			   || (DSP_FAILED(status) && *target_obj == NULL));
 	}
 
 	return status;
 }
 
 /*
- *  ======== DBLL_delete ========
+ *  ======== dbll_delete ========
  */
-void DBLL_delete(struct DBLL_TarObj *target)
+void dbll_delete(struct dbll_tar_obj *target)
 {
-	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
+	struct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_target, DBLL_TARGSIGNATURE));
 
-	if (zlTarget != NULL)
-		MEM_FreeObject(zlTarget);
+	if (zl_target != NULL)
+		MEM_FREE_OBJECT(zl_target);
 
 }
 
 /*
- *  ======== DBLL_exit ========
+ *  ======== dbll_exit ========
  *  Discontinue usage of DBL module.
  */
-void DBLL_exit(void)
+void dbll_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	if (cRefs == 0)
-		GH_exit();
+	if (refs == 0)
+		gh_exit();
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== DBLL_getAddr ========
+ *  ======== dbll_get_addr ========
  *  Get address of name in the specified library.
  */
-bool DBLL_getAddr(struct DBLL_LibraryObj *zlLib, char *name,
-		  struct DBLL_Symbol **ppSym)
+bool dbll_get_addr(struct dbll_library_obj *zl_lib, char *name,
+		   struct dbll_sym_val **ppSym)
 {
-	struct Symbol *sym;
+	struct dbll_symbol *sym;
 	bool status = false;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(ppSym != NULL);
-	DBC_Require(zlLib->symTab != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(name != NULL);
+	DBC_REQUIRE(ppSym != NULL);
+	DBC_REQUIRE(zl_lib->sym_tab != NULL);
 
-	sym = (struct Symbol *)GH_find(zlLib->symTab, name);
+	sym = (struct dbll_symbol *)gh_find(zl_lib->sym_tab, name);
 	if (sym != NULL) {
 		*ppSym = &sym->value;
 		status = true;
 	}
 
-	dev_dbg(bridge, "%s: lib: %p name: %s pAddr: %p, status 0x%x\n",
-					 __func__, zlLib, name, ppSym, status);
+	dev_dbg(bridge, "%s: lib: %p name: %s paddr: %p, status 0x%x\n",
+		__func__, zl_lib, name, ppSym, status);
 	return status;
 }
 
 /*
- *  ======== DBLL_getAttrs ========
+ *  ======== dbll_get_attrs ========
  *  Retrieve the attributes of the target.
  */
-void DBLL_getAttrs(struct DBLL_TarObj *target, struct DBLL_Attrs *pAttrs)
+void dbll_get_attrs(struct dbll_tar_obj *target, struct dbll_attrs *pattrs)
 {
-	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
+	struct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
-	DBC_Require(pAttrs != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_target, DBLL_TARGSIGNATURE));
+	DBC_REQUIRE(pattrs != NULL);
 
-	if ((pAttrs != NULL) && (zlTarget != NULL))
-		*pAttrs = zlTarget->attrs;
+	if ((pattrs != NULL) && (zl_target != NULL))
+		*pattrs = zl_target->attrs;
 
 }
 
 /*
- *  ======== DBLL_getCAddr ========
+ *  ======== dbll_get_c_addr ========
  *  Get address of a "C" name in the specified library.
  */
-bool DBLL_getCAddr(struct DBLL_LibraryObj *zlLib, char *name,
-		   struct DBLL_Symbol **ppSym)
+bool dbll_get_c_addr(struct dbll_library_obj *zl_lib, char *name,
+		     struct dbll_sym_val **ppSym)
 {
-	struct Symbol *sym;
+	struct dbll_symbol *sym;
 	char cname[MAXEXPR + 1];
 	bool status = false;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(ppSym != NULL);
-	DBC_Require(zlLib->symTab != NULL);
-	DBC_Require(name != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(ppSym != NULL);
+	DBC_REQUIRE(zl_lib->sym_tab != NULL);
+	DBC_REQUIRE(name != NULL);
 
 	cname[0] = '_';
 
-       strncpy(cname + 1, name, sizeof(cname) - 2);
-	cname[MAXEXPR] = '\0'; 	/* insure '\0' string termination */
+	strncpy(cname + 1, name, sizeof(cname) - 2);
+	cname[MAXEXPR] = '\0';	/* insure '\0' string termination */
 
 	/* Check for C name, if not found */
-	sym = (struct Symbol *)GH_find(zlLib->symTab, cname);
+	sym = (struct dbll_symbol *)gh_find(zl_lib->sym_tab, cname);
 
 	if (sym != NULL) {
 		*ppSym = &sym->value;
@@ -381,110 +384,111 @@ bool DBLL_getCAddr(struct DBLL_LibraryObj *zlLib, char *name,
 }
 
 /*
- *  ======== DBLL_getSect ========
+ *  ======== dbll_get_sect ========
  *  Get the base address and size (in bytes) of a COFF section.
  */
-DSP_STATUS DBLL_getSect(struct DBLL_LibraryObj *lib, char *name, u32 *pAddr,
-			u32 *pSize)
+dsp_status dbll_get_sect(struct dbll_library_obj *lib, char *name, u32 *paddr,
+			 u32 *psize)
 {
-	u32 uByteSize;
-	bool fOpenedDoff = false;
-	const struct LDR_SECTION_INFO *sect = NULL;
-	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(name != NULL);
-	DBC_Require(pAddr != NULL);
-	DBC_Require(pSize != NULL);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	u32 byte_size;
+	bool opened_doff = false;
+	const struct ldr_section_info *sect = NULL;
+	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(name != NULL);
+	DBC_REQUIRE(paddr != NULL);
+	DBC_REQUIRE(psize != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
 
 	/* If DOFF file is not open, we open it. */
-	if (zlLib != NULL) {
-		if (zlLib->fp == NULL) {
-			status = dofOpen(zlLib);
+	if (zl_lib != NULL) {
+		if (zl_lib->fp == NULL) {
+			status = dof_open(zl_lib);
 			if (DSP_SUCCEEDED(status))
-				fOpenedDoff = true;
+				opened_doff = true;
 
 		} else {
-			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp,
-			 zlLib->ulPos, SEEK_SET);
+			(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,
+							      zl_lib->ul_pos,
+							      SEEK_SET);
 		}
 	} else {
 		status = DSP_EHANDLE;
 	}
 	if (DSP_SUCCEEDED(status)) {
-		uByteSize = 1;
-		if (DLOAD_GetSectionInfo(zlLib->desc, name, &sect)) {
-			*pAddr = sect->load_addr;
-			*pSize = sect->size * uByteSize;
+		byte_size = 1;
+		if (dload_get_section_info(zl_lib->desc, name, &sect)) {
+			*paddr = sect->load_addr;
+			*psize = sect->size * byte_size;
 			/* Make sure size is even for good swap */
-			if (*pSize % 2)
-				(*pSize)++;
+			if (*psize % 2)
+				(*psize)++;
 
 			/* Align size */
-			*pSize = DOFF_ALIGN(*pSize);
+			*psize = DOFF_ALIGN(*psize);
 		} else {
 			status = DSP_ENOSECT;
 		}
 	}
-	if (fOpenedDoff) {
-		dofClose(zlLib);
-		fOpenedDoff = false;
+	if (opened_doff) {
+		dof_close(zl_lib);
+		opened_doff = false;
 	}
 
-	dev_dbg(bridge, "%s: lib: %p name: %s pAddr: %p pSize: %p, "
-		"status 0x%x\n", __func__, lib, name, pAddr, pSize, status);
+	dev_dbg(bridge, "%s: lib: %p name: %s paddr: %p psize: %p, "
+		"status 0x%x\n", __func__, lib, name, paddr, psize, status);
 
 	return status;
 }
 
 /*
- *  ======== DBLL_init ========
+ *  ======== dbll_init ========
  */
-bool DBLL_init(void)
+bool dbll_init(void)
 {
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0)
-		GH_init();
+	if (refs == 0)
+		gh_init();
 
-	cRefs++;
+	refs++;
 
 	return true;
 }
 
 /*
- *  ======== DBLL_load ========
+ *  ======== dbll_load ========
  */
-DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib, DBLL_Flags flags,
-		     struct DBLL_Attrs *attrs, u32 *pEntry)
+dsp_status dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
+		     struct dbll_attrs *attrs, u32 *pEntry)
 {
-	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
-	struct DBLL_TarObj *dbzl;
-	bool gotSymbols = true;
+	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
+	struct dbll_tar_obj *dbzl;
+	bool got_symbols = true;
 	s32 err;
-	DSP_STATUS status = DSP_SOK;
-	bool fOpenedDoff = false;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(pEntry != NULL);
-	DBC_Require(attrs != NULL);
+	dsp_status status = DSP_SOK;
+	bool opened_doff = false;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(pEntry != NULL);
+	DBC_REQUIRE(attrs != NULL);
 
 	/*
 	 *  Load if not already loaded.
 	 */
-	if (zlLib->loadRef == 0 || !(flags & DBLL_DYNAMIC)) {
-		dbzl = zlLib->pTarget;
+	if (zl_lib->load_ref == 0 || !(flags & DBLL_DYNAMIC)) {
+		dbzl = zl_lib->target_obj;
 		dbzl->attrs = *attrs;
 		/* Create a hash table for symbols if not already created */
-		if (zlLib->symTab == NULL) {
-			gotSymbols = false;
-			zlLib->symTab = GH_create(MAXBUCKETS,
-						 sizeof(struct Symbol),
-						 nameHash,
-						 nameMatch, symDelete);
-			if (zlLib->symTab == NULL)
+		if (zl_lib->sym_tab == NULL) {
+			got_symbols = false;
+			zl_lib->sym_tab = gh_create(MAXBUCKETS,
+						    sizeof(struct dbll_symbol),
+						    name_hash,
+						    name_match, sym_delete);
+			if (zl_lib->sym_tab == NULL)
 				status = DSP_EMEMORY;
 
 		}
@@ -492,145 +496,150 @@ DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib, DBLL_Flags flags,
 		 *  Set up objects needed by the dynamic loader
 		 */
 		/* Stream */
-		zlLib->stream.dlStream.read_buffer = readBuffer;
-		zlLib->stream.dlStream.set_file_posn = setFilePosn;
-		zlLib->stream.lib = zlLib;
+		zl_lib->stream.dl_stream.read_buffer = dbll_read_buffer;
+		zl_lib->stream.dl_stream.set_file_posn = dbll_set_file_posn;
+		zl_lib->stream.lib = zl_lib;
 		/* Symbol */
-		zlLib->symbol.dlSymbol.Find_Matching_Symbol = findSymbol;
-		if (gotSymbols) {
-			zlLib->symbol.dlSymbol.Add_To_Symbol_Table =
-							findInSymbolTable;
+		zl_lib->symbol.dl_symbol.find_matching_symbol =
+		    dbll_find_symbol;
+		if (got_symbols) {
+			zl_lib->symbol.dl_symbol.add_to_symbol_table =
+			    find_in_symbol_table;
 		} else {
-			zlLib->symbol.dlSymbol.Add_To_Symbol_Table =
-							addToSymbolTable;
+			zl_lib->symbol.dl_symbol.add_to_symbol_table =
+			    dbll_add_to_symbol_table;
 		}
-		zlLib->symbol.dlSymbol.Purge_Symbol_Table = purgeSymbolTable;
-		zlLib->symbol.dlSymbol.Allocate = allocate;
-		zlLib->symbol.dlSymbol.Deallocate = deallocate;
-		zlLib->symbol.dlSymbol.Error_Report = errorReport;
-		zlLib->symbol.lib = zlLib;
+		zl_lib->symbol.dl_symbol.purge_symbol_table =
+		    dbll_purge_symbol_table;
+		zl_lib->symbol.dl_symbol.dload_allocate = allocate;
+		zl_lib->symbol.dl_symbol.dload_deallocate = deallocate;
+		zl_lib->symbol.dl_symbol.error_report = dbll_err_report;
+		zl_lib->symbol.lib = zl_lib;
 		/* Allocate */
-		zlLib->allocate.dlAlloc.Allocate = rmmAlloc;
-		zlLib->allocate.dlAlloc.Deallocate = rmmDealloc;
-		zlLib->allocate.lib = zlLib;
+		zl_lib->allocate.dl_alloc.dload_allocate = dbll_rmm_alloc;
+		zl_lib->allocate.dl_alloc.dload_deallocate = rmm_dealloc;
+		zl_lib->allocate.lib = zl_lib;
 		/* Init */
-		zlLib->init.dlInit.connect = connect;
-		zlLib->init.dlInit.readmem = readMem;
-		zlLib->init.dlInit.writemem = writeMem;
-		zlLib->init.dlInit.fillmem = fillMem;
-		zlLib->init.dlInit.execute = execute;
-		zlLib->init.dlInit.release = release;
-		zlLib->init.lib = zlLib;
+		zl_lib->init.dl_init.connect = connect;
+		zl_lib->init.dl_init.readmem = read_mem;
+		zl_lib->init.dl_init.writemem = write_mem;
+		zl_lib->init.dl_init.fillmem = fill_mem;
+		zl_lib->init.dl_init.execute = execute;
+		zl_lib->init.dl_init.release = release;
+		zl_lib->init.lib = zl_lib;
 		/* If COFF file is not open, we open it. */
-		if (zlLib->fp == NULL) {
-			status = dofOpen(zlLib);
+		if (zl_lib->fp == NULL) {
+			status = dof_open(zl_lib);
 			if (DSP_SUCCEEDED(status))
-				fOpenedDoff = true;
+				opened_doff = true;
 
 		}
 		if (DSP_SUCCEEDED(status)) {
-			zlLib->ulPos = (*(zlLib->pTarget->attrs.ftell))
-					(zlLib->fp);
+			zl_lib->ul_pos = (*(zl_lib->target_obj->attrs.ftell))
+			    (zl_lib->fp);
 			/* Reset file cursor */
-			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long)0,
-				 SEEK_SET);
-			bSymbolsReloaded = true;
+			(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,
+							      (long)0,
+							      SEEK_SET);
+			symbols_reloaded = true;
 			/* The 5th argument, DLOAD_INITBSS, tells the DLL
 			 * module to zero-init all BSS sections.  In general,
 			 * this is not necessary and also increases load time.
 			 * We may want to make this configurable by the user */
-			err = Dynamic_Load_Module(&zlLib->stream.dlStream,
-			      &zlLib->symbol.dlSymbol, &zlLib->allocate.dlAlloc,
-			      &zlLib->init.dlInit, DLOAD_INITBSS,
-			      &zlLib->mHandle);
+			err = dynamic_load_module(&zl_lib->stream.dl_stream,
+						  &zl_lib->symbol.dl_symbol,
+						  &zl_lib->allocate.dl_alloc,
+						  &zl_lib->init.dl_init,
+						  DLOAD_INITBSS,
+						  &zl_lib->dload_mod_obj);
 
 			if (err != 0) {
 				status = DSP_EDYNLOAD;
-			} else if (bRedefinedSymbol) {
-				zlLib->loadRef++;
-				DBLL_unload(zlLib, (struct DBLL_Attrs *) attrs);
-				bRedefinedSymbol = false;
+			} else if (redefined_symbol) {
+				zl_lib->load_ref++;
+				dbll_unload(zl_lib, (struct dbll_attrs *)attrs);
+				redefined_symbol = false;
 				status = DSP_EDYNLOAD;
 			} else {
-				*pEntry = zlLib->entry;
+				*pEntry = zl_lib->entry;
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status))
-		zlLib->loadRef++;
+		zl_lib->load_ref++;
 
 	/* Clean up DOFF resources */
-	if (fOpenedDoff)
-		dofClose(zlLib);
+	if (opened_doff)
+		dof_close(zl_lib);
 
-	DBC_Ensure(DSP_FAILED(status) || zlLib->loadRef > 0);
+	DBC_ENSURE(DSP_FAILED(status) || zl_lib->load_ref > 0);
 
 	dev_dbg(bridge, "%s: lib: %p flags: 0x%x pEntry: %p, status 0x%x\n",
-			__func__, lib, flags, pEntry, status);
+		__func__, lib, flags, pEntry, status);
 
 	return status;
 }
 
 /*
- *  ======== DBLL_loadSect ========
+ *  ======== dbll_load_sect ========
  *  Not supported for COFF.
  */
-DSP_STATUS DBLL_loadSect(struct DBLL_LibraryObj *zlLib, char *sectName,
-			struct DBLL_Attrs *attrs)
+dsp_status dbll_load_sect(struct dbll_library_obj *zl_lib, char *sectName,
+			  struct dbll_attrs *attrs)
 {
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
 
 	return DSP_ENOTIMPL;
 }
 
 /*
- *  ======== DBLL_open ========
+ *  ======== dbll_open ========
  */
-DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file, DBLL_Flags flags,
-		    struct DBLL_LibraryObj **pLib)
+dsp_status dbll_open(struct dbll_tar_obj *target, char *file, dbll_flags flags,
+		     struct dbll_library_obj **pLib)
 {
-	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
-	struct DBLL_LibraryObj *zlLib = NULL;
+	struct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;
+	struct dbll_library_obj *zl_lib = NULL;
 	s32 err;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
-	DBC_Require(zlTarget->attrs.fopen != NULL);
-	DBC_Require(file != NULL);
-	DBC_Require(pLib != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_target, DBLL_TARGSIGNATURE));
+	DBC_REQUIRE(zl_target->attrs.fopen != NULL);
+	DBC_REQUIRE(file != NULL);
+	DBC_REQUIRE(pLib != NULL);
 
-	zlLib = zlTarget->head;
-	while (zlLib != NULL) {
-		if (strcmp(zlLib->fileName, file) == 0) {
+	zl_lib = zl_target->head;
+	while (zl_lib != NULL) {
+		if (strcmp(zl_lib->file_name, file) == 0) {
 			/* Library is already opened */
-			zlLib->openRef++;
+			zl_lib->open_ref++;
 			break;
 		}
-		zlLib = zlLib->next;
+		zl_lib = zl_lib->next;
 	}
-	if (zlLib == NULL) {
+	if (zl_lib == NULL) {
 		/* Allocate DBL library object */
-		MEM_AllocObject(zlLib, struct DBLL_LibraryObj,
-				DBLL_LIBSIGNATURE);
-		if (zlLib == NULL) {
+		MEM_ALLOC_OBJECT(zl_lib, struct dbll_library_obj,
+				 DBLL_LIBSIGNATURE);
+		if (zl_lib == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			zlLib->ulPos = 0;
+			zl_lib->ul_pos = 0;
 			/* Increment ref count to allow close on failure
 			 * later on */
-			zlLib->openRef++;
-			zlLib->pTarget = zlTarget;
+			zl_lib->open_ref++;
+			zl_lib->target_obj = zl_target;
 			/* Keep a copy of the file name */
-			zlLib->fileName = MEM_Calloc(strlen(file) + 1,
-							MEM_PAGED);
-			if (zlLib->fileName == NULL) {
+			zl_lib->file_name = mem_calloc(strlen(file) + 1,
+						       MEM_PAGED);
+			if (zl_lib->file_name == NULL) {
 				status = DSP_EMEMORY;
 			} else {
-				strncpy(zlLib->fileName, file,
+				strncpy(zl_lib->file_name, file,
 					strlen(file) + 1);
 			}
-			zlLib->symTab = NULL;
+			zl_lib->sym_tab = NULL;
 		}
 	}
 	/*
@@ -640,122 +649,125 @@ DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file, DBLL_Flags flags,
 		goto func_cont;
 
 	/* Stream */
-	zlLib->stream.dlStream.read_buffer = readBuffer;
-	zlLib->stream.dlStream.set_file_posn = setFilePosn;
-	zlLib->stream.lib = zlLib;
+	zl_lib->stream.dl_stream.read_buffer = dbll_read_buffer;
+	zl_lib->stream.dl_stream.set_file_posn = dbll_set_file_posn;
+	zl_lib->stream.lib = zl_lib;
 	/* Symbol */
-	zlLib->symbol.dlSymbol.Add_To_Symbol_Table = addToSymbolTable;
-	zlLib->symbol.dlSymbol.Find_Matching_Symbol = findSymbol;
-	zlLib->symbol.dlSymbol.Purge_Symbol_Table = purgeSymbolTable;
-	zlLib->symbol.dlSymbol.Allocate = allocate;
-	zlLib->symbol.dlSymbol.Deallocate = deallocate;
-	zlLib->symbol.dlSymbol.Error_Report = errorReport;
-	zlLib->symbol.lib = zlLib;
+	zl_lib->symbol.dl_symbol.add_to_symbol_table = dbll_add_to_symbol_table;
+	zl_lib->symbol.dl_symbol.find_matching_symbol = dbll_find_symbol;
+	zl_lib->symbol.dl_symbol.purge_symbol_table = dbll_purge_symbol_table;
+	zl_lib->symbol.dl_symbol.dload_allocate = allocate;
+	zl_lib->symbol.dl_symbol.dload_deallocate = deallocate;
+	zl_lib->symbol.dl_symbol.error_report = dbll_err_report;
+	zl_lib->symbol.lib = zl_lib;
 	/* Allocate */
-	zlLib->allocate.dlAlloc.Allocate = rmmAlloc;
-	zlLib->allocate.dlAlloc.Deallocate = rmmDealloc;
-	zlLib->allocate.lib = zlLib;
+	zl_lib->allocate.dl_alloc.dload_allocate = dbll_rmm_alloc;
+	zl_lib->allocate.dl_alloc.dload_deallocate = rmm_dealloc;
+	zl_lib->allocate.lib = zl_lib;
 	/* Init */
-	zlLib->init.dlInit.connect = connect;
-	zlLib->init.dlInit.readmem = readMem;
-	zlLib->init.dlInit.writemem = writeMem;
-	zlLib->init.dlInit.fillmem = fillMem;
-	zlLib->init.dlInit.execute = execute;
-	zlLib->init.dlInit.release = release;
-	zlLib->init.lib = zlLib;
-	if (DSP_SUCCEEDED(status) && zlLib->fp == NULL)
-		status = dofOpen(zlLib);
-
-	zlLib->ulPos = (*(zlLib->pTarget->attrs.ftell)) (zlLib->fp);
-	(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long) 0, SEEK_SET);
+	zl_lib->init.dl_init.connect = connect;
+	zl_lib->init.dl_init.readmem = read_mem;
+	zl_lib->init.dl_init.writemem = write_mem;
+	zl_lib->init.dl_init.fillmem = fill_mem;
+	zl_lib->init.dl_init.execute = execute;
+	zl_lib->init.dl_init.release = release;
+	zl_lib->init.lib = zl_lib;
+	if (DSP_SUCCEEDED(status) && zl_lib->fp == NULL)
+		status = dof_open(zl_lib);
+
+	zl_lib->ul_pos = (*(zl_lib->target_obj->attrs.ftell)) (zl_lib->fp);
+	(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp, (long)0, SEEK_SET);
 	/* Create a hash table for symbols if flag is set */
-	if (zlLib->symTab != NULL || !(flags & DBLL_SYMB))
+	if (zl_lib->sym_tab != NULL || !(flags & DBLL_SYMB))
 		goto func_cont;
 
-	zlLib->symTab = GH_create(MAXBUCKETS, sizeof(struct Symbol), nameHash,
-				 nameMatch, symDelete);
-	if (zlLib->symTab == NULL) {
+	zl_lib->sym_tab =
+	    gh_create(MAXBUCKETS, sizeof(struct dbll_symbol), name_hash,
+		      name_match, sym_delete);
+	if (zl_lib->sym_tab == NULL) {
 		status = DSP_EMEMORY;
 	} else {
-		/* Do a fake load to get symbols - set write function to NoOp */
-		zlLib->init.dlInit.writemem = NoOp;
-		err = Dynamic_Open_Module(&zlLib->stream.dlStream,
-					&zlLib->symbol.dlSymbol,
-					&zlLib->allocate.dlAlloc,
-					&zlLib->init.dlInit, 0,
-					&zlLib->mHandle);
+		/* Do a fake load to get symbols - set write func to no_op */
+		zl_lib->init.dl_init.writemem = no_op;
+		err = dynamic_open_module(&zl_lib->stream.dl_stream,
+					  &zl_lib->symbol.dl_symbol,
+					  &zl_lib->allocate.dl_alloc,
+					  &zl_lib->init.dl_init, 0,
+					  &zl_lib->dload_mod_obj);
 		if (err != 0) {
 			status = DSP_EDYNLOAD;
 		} else {
 			/* Now that we have the symbol table, we can unload */
-			err = Dynamic_Unload_Module(zlLib->mHandle,
-						   &zlLib->symbol.dlSymbol,
-						   &zlLib->allocate.dlAlloc,
-						   &zlLib->init.dlInit);
+			err = dynamic_unload_module(zl_lib->dload_mod_obj,
+						    &zl_lib->symbol.dl_symbol,
+						    &zl_lib->allocate.dl_alloc,
+						    &zl_lib->init.dl_init);
 			if (err != 0)
 				status = DSP_EDYNLOAD;
 
-			zlLib->mHandle = NULL;
+			zl_lib->dload_mod_obj = NULL;
 		}
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status)) {
-		if (zlLib->openRef == 1) {
+		if (zl_lib->open_ref == 1) {
 			/* First time opened - insert in list */
-			if (zlTarget->head)
-				(zlTarget->head)->prev = zlLib;
+			if (zl_target->head)
+				(zl_target->head)->prev = zl_lib;
 
-			zlLib->prev = NULL;
-			zlLib->next = zlTarget->head;
-			zlTarget->head = zlLib;
+			zl_lib->prev = NULL;
+			zl_lib->next = zl_target->head;
+			zl_target->head = zl_lib;
 		}
-		*pLib = (struct DBLL_LibraryObj *)zlLib;
+		*pLib = (struct dbll_library_obj *)zl_lib;
 	} else {
 		*pLib = NULL;
-		if (zlLib != NULL)
-			DBLL_close((struct DBLL_LibraryObj *)zlLib);
+		if (zl_lib != NULL)
+			dbll_close((struct dbll_library_obj *)zl_lib);
 
 	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && (zlLib->openRef > 0) &&
-		  MEM_IsValidHandle(((struct DBLL_LibraryObj *)(*pLib)),
-		  DBLL_LIBSIGNATURE)) || (DSP_FAILED(status) && *pLib == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && (zl_lib->open_ref > 0) &&
+		    MEM_IS_VALID_HANDLE(((struct dbll_library_obj *)(*pLib)),
+					DBLL_LIBSIGNATURE))
+		   || (DSP_FAILED(status) && *pLib == NULL));
 
 	dev_dbg(bridge, "%s: target: %p file: %s pLib: %p, status 0x%x\n",
-					 __func__, target, file, pLib, status);
+		__func__, target, file, pLib, status);
 
 	return status;
 }
 
 /*
- *  ======== DBLL_readSect ========
+ *  ======== dbll_read_sect ========
  *  Get the content of a COFF section.
  */
-DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib, char *name,
-			 char *pContent, u32 size)
+dsp_status dbll_read_sect(struct dbll_library_obj *lib, char *name,
+			  char *pContent, u32 size)
 {
-	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
-	bool fOpenedDoff = false;
-	u32 uByteSize; 		/* size of bytes */
-	u32 ulSectSize; 		/* size of section */
-	const struct LDR_SECTION_INFO *sect = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(pContent != NULL);
-	DBC_Require(size != 0);
+	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
+	bool opened_doff = false;
+	u32 byte_size;		/* size of bytes */
+	u32 ul_sect_size;	/* size of section */
+	const struct ldr_section_info *sect = NULL;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(name != NULL);
+	DBC_REQUIRE(pContent != NULL);
+	DBC_REQUIRE(size != 0);
 
 	/* If DOFF file is not open, we open it. */
-	if (zlLib != NULL) {
-		if (zlLib->fp == NULL) {
-			status = dofOpen(zlLib);
+	if (zl_lib != NULL) {
+		if (zl_lib->fp == NULL) {
+			status = dof_open(zl_lib);
 			if (DSP_SUCCEEDED(status))
-				fOpenedDoff = true;
+				opened_doff = true;
 
 		} else {
-			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp,
-				zlLib->ulPos, SEEK_SET);
+			(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,
+							      zl_lib->ul_pos,
+							      SEEK_SET);
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -763,8 +775,8 @@ DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib, char *name,
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	uByteSize = 1;
-	if (!DLOAD_GetSectionInfo(zlLib->desc, name, &sect)) {
+	byte_size = 1;
+	if (!dload_get_section_info(zl_lib->desc, name, &sect)) {
 		status = DSP_ENOSECT;
 		goto func_cont;
 	}
@@ -772,24 +784,24 @@ DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib, char *name,
 	 * Ensure the supplied buffer size is sufficient to store
 	 * the section content to be read.
 	 */
-	ulSectSize = sect->size * uByteSize;
+	ul_sect_size = sect->size * byte_size;
 	/* Make sure size is even for good swap */
-	if (ulSectSize % 2)
-		ulSectSize++;
+	if (ul_sect_size % 2)
+		ul_sect_size++;
 
 	/* Align size */
-	ulSectSize = DOFF_ALIGN(ulSectSize);
-	if (ulSectSize > size) {
+	ul_sect_size = DOFF_ALIGN(ul_sect_size);
+	if (ul_sect_size > size) {
 		status = DSP_EFAIL;
 	} else {
-		if (!DLOAD_GetSection(zlLib->desc, sect, pContent))
+		if (!dload_get_section(zl_lib->desc, sect, pContent))
 			status = DSP_EFREAD;
 
 	}
 func_cont:
-	if (fOpenedDoff) {
-		dofClose(zlLib);
-		fOpenedDoff = false;
+	if (opened_doff) {
+		dof_close(zl_lib);
+		opened_doff = false;
 	}
 
 	dev_dbg(bridge, "%s: lib: %p name: %s pContent: %p size: 0x%x, "
@@ -798,107 +810,111 @@ func_cont:
 }
 
 /*
- *  ======== DBLL_setAttrs ========
+ *  ======== dbll_set_attrs ========
  *  Set the attributes of the target.
  */
-void DBLL_setAttrs(struct DBLL_TarObj *target, struct DBLL_Attrs *pAttrs)
+void dbll_set_attrs(struct dbll_tar_obj *target, struct dbll_attrs *pattrs)
 {
-	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
-	DBC_Require(pAttrs != NULL);
+	struct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_target, DBLL_TARGSIGNATURE));
+	DBC_REQUIRE(pattrs != NULL);
 
-	if ((pAttrs != NULL) && (zlTarget != NULL))
-		zlTarget->attrs = *pAttrs;
+	if ((pattrs != NULL) && (zl_target != NULL))
+		zl_target->attrs = *pattrs;
 
 }
 
 /*
- *  ======== DBLL_unload ========
+ *  ======== dbll_unload ========
  */
-void DBLL_unload(struct DBLL_LibraryObj *lib, struct DBLL_Attrs *attrs)
+void dbll_unload(struct dbll_library_obj *lib, struct dbll_attrs *attrs)
 {
-	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
+	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
 	s32 err = 0;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(zlLib->loadRef > 0);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(zl_lib->load_ref > 0);
 	dev_dbg(bridge, "%s: lib: %p\n", __func__, lib);
-	zlLib->loadRef--;
+	zl_lib->load_ref--;
 	/* Unload only if reference count is 0 */
-	if (zlLib->loadRef != 0)
+	if (zl_lib->load_ref != 0)
 		goto func_end;
 
-	zlLib->pTarget->attrs = *attrs;
-	if (zlLib->mHandle) {
-		err = Dynamic_Unload_Module(zlLib->mHandle,
-			&zlLib->symbol.dlSymbol,
-			&zlLib->allocate.dlAlloc, &zlLib->init.dlInit);
+	zl_lib->target_obj->attrs = *attrs;
+	if (zl_lib->dload_mod_obj) {
+		err = dynamic_unload_module(zl_lib->dload_mod_obj,
+					    &zl_lib->symbol.dl_symbol,
+					    &zl_lib->allocate.dl_alloc,
+					    &zl_lib->init.dl_init);
 		if (err != 0) {
 			dev_dbg(bridge, "%s: failed: 0x%x\n", __func__, err);
 		}
 	}
 	/* remove symbols from symbol table */
-	if (zlLib->symTab != NULL) {
-		GH_delete(zlLib->symTab);
-		zlLib->symTab = NULL;
+	if (zl_lib->sym_tab != NULL) {
+		gh_delete(zl_lib->sym_tab);
+		zl_lib->sym_tab = NULL;
 	}
 	/* delete DOFF desc since it holds *lots* of host OS
 	 * resources */
-	dofClose(zlLib);
+	dof_close(zl_lib);
 func_end:
-	DBC_Ensure(zlLib->loadRef >= 0);
+	DBC_ENSURE(zl_lib->load_ref >= 0);
 }
 
 /*
- *  ======== DBLL_unloadSect ========
+ *  ======== dbll_unload_sect ========
  *  Not supported for COFF.
  */
-DSP_STATUS DBLL_unloadSect(struct DBLL_LibraryObj *lib, char *sectName,
-			  struct DBLL_Attrs *attrs)
+dsp_status dbll_unload_sect(struct dbll_library_obj *lib, char *sectName,
+			    struct dbll_attrs *attrs)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(sectName != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(sectName != NULL);
 
 	return DSP_ENOTIMPL;
 }
 
 /*
- *  ======== dofClose ========
+ *  ======== dof_close ========
  */
-static void dofClose(struct DBLL_LibraryObj *zlLib)
+static void dof_close(struct dbll_library_obj *zl_lib)
 {
-	if (zlLib->desc) {
-		DLOAD_module_close(zlLib->desc);
-		zlLib->desc = NULL;
+	if (zl_lib->desc) {
+		dload_module_close(zl_lib->desc);
+		zl_lib->desc = NULL;
 	}
 	/* close file */
-	if (zlLib->fp) {
-		(zlLib->pTarget->attrs.fclose) (zlLib->fp);
-		zlLib->fp = NULL;
+	if (zl_lib->fp) {
+		(zl_lib->target_obj->attrs.fclose) (zl_lib->fp);
+		zl_lib->fp = NULL;
 	}
 }
 
 /*
- *  ======== dofOpen ========
+ *  ======== dof_open ========
  */
-static DSP_STATUS dofOpen(struct DBLL_LibraryObj *zlLib)
+static dsp_status dof_open(struct dbll_library_obj *zl_lib)
 {
-	void *open = *(zlLib->pTarget->attrs.fopen);
-	DSP_STATUS status = DSP_SOK;
+	void *open = *(zl_lib->target_obj->attrs.fopen);
+	dsp_status status = DSP_SOK;
 
 	/* First open the file for the dynamic loader, then open COF */
-	zlLib->fp = (void *)((DBLL_FOpenFxn)(open))(zlLib->fileName, "rb");
+	zl_lib->fp =
+	    (void *)((dbll_f_open_fxn) (open)) (zl_lib->file_name, "rb");
 
 	/* Open DOFF module */
-	if (zlLib->fp && zlLib->desc == NULL) {
-		(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long)0, SEEK_SET);
-		zlLib->desc = DLOAD_module_open(&zlLib->stream.dlStream,
-						&zlLib->symbol.dlSymbol);
-		if (zlLib->desc == NULL) {
-			(zlLib->pTarget->attrs.fclose)(zlLib->fp);
-			zlLib->fp = NULL;
+	if (zl_lib->fp && zl_lib->desc == NULL) {
+		(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp, (long)0,
+						      SEEK_SET);
+		zl_lib->desc =
+		    dload_module_open(&zl_lib->stream.dl_stream,
+				      &zl_lib->symbol.dl_symbol);
+		if (zl_lib->desc == NULL) {
+			(zl_lib->target_obj->attrs.fclose) (zl_lib->fp);
+			zl_lib->fp = NULL;
 			status = DSP_EFOPEN;
 		}
 	} else {
@@ -909,15 +925,15 @@ static DSP_STATUS dofOpen(struct DBLL_LibraryObj *zlLib)
 }
 
 /*
- *  ======== nameHash ========
+ *  ======== name_hash ========
  */
-static u16 nameHash(void *key, u16 maxBucket)
+static u16 name_hash(void *key, u16 max_bucket)
 {
 	u16 ret;
 	u16 hash;
 	char *name = (char *)key;
 
-	DBC_Require(name != NULL);
+	DBC_REQUIRE(name != NULL);
 
 	hash = 0;
 
@@ -926,41 +942,42 @@ static u16 nameHash(void *key, u16 maxBucket)
 		hash ^= *name++;
 	}
 
-	ret = hash % maxBucket;
+	ret = hash % max_bucket;
 
 	return ret;
 }
 
 /*
- *  ======== nameMatch ========
+ *  ======== name_match ========
  */
-static bool nameMatch(void *key, void *value)
+static bool name_match(void *key, void *value)
 {
-	DBC_Require(key != NULL);
-	DBC_Require(value != NULL);
+	DBC_REQUIRE(key != NULL);
+	DBC_REQUIRE(value != NULL);
 
 	if ((key != NULL) && (value != NULL)) {
-		if (strcmp((char *)key, ((struct Symbol *)value)->name) == 0)
+		if (strcmp((char *)key, ((struct dbll_symbol *)value)->name) ==
+		    0)
 			return true;
 	}
 	return false;
 }
 
 /*
- *  ======== NoOp ========
+ *  ======== no_op ========
  */
-static int NoOp(struct Dynamic_Loader_Initialize *thisptr, void *bufr,
-		LDR_ADDR locn, struct LDR_SECTION_INFO *info, unsigned bytsize)
+static int no_op(struct dynamic_loader_initialize *thisptr, void *bufr,
+		 ldr_addr locn, struct ldr_section_info *info, unsigned bytsize)
 {
 	return 1;
 }
 
 /*
- *  ======== symDelete ========
+ *  ======== sym_delete ========
  */
-static void symDelete(void *value)
+static void sym_delete(void *value)
 {
-	struct Symbol *sp = (struct Symbol *)value;
+	struct dbll_symbol *sp = (struct dbll_symbol *)value;
 
 	kfree(sp->name);
 }
@@ -969,154 +986,159 @@ static void symDelete(void *value)
  *  Dynamic Loader Functions
  */
 
-/* Dynamic_Loader_Stream */
+/* dynamic_loader_stream */
 /*
- *  ======== readBuffer ========
+ *  ======== dbll_read_buffer ========
  */
-static int readBuffer(struct Dynamic_Loader_Stream *this, void *buffer,
-		     unsigned bufsize)
+static int dbll_read_buffer(struct dynamic_loader_stream *this, void *buffer,
+			    unsigned bufsize)
 {
-	struct DBLLStream *pStream = (struct DBLLStream *)this;
-	struct DBLL_LibraryObj *lib;
-	int bytesRead = 0;
+	struct dbll_stream *pstream = (struct dbll_stream *)this;
+	struct dbll_library_obj *lib;
+	int bytes_read = 0;
 
-	DBC_Require(this != NULL);
-	lib = pStream->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = pstream->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	if (lib != NULL) {
-		bytesRead = (*(lib->pTarget->attrs.fread))(buffer, 1, bufsize,
-			    lib->fp);
+		bytes_read =
+		    (*(lib->target_obj->attrs.fread)) (buffer, 1, bufsize,
+						       lib->fp);
 	}
-	return bytesRead;
+	return bytes_read;
 }
 
 /*
- *  ======== setFilePosn ========
+ *  ======== dbll_set_file_posn ========
  */
-static int setFilePosn(struct Dynamic_Loader_Stream *this, unsigned int pos)
+static int dbll_set_file_posn(struct dynamic_loader_stream *this,
+			      unsigned int pos)
 {
-	struct DBLLStream *pStream = (struct DBLLStream *)this;
-	struct DBLL_LibraryObj *lib;
-	int status = 0; 		/* Success */
+	struct dbll_stream *pstream = (struct dbll_stream *)this;
+	struct dbll_library_obj *lib;
+	int status = 0;		/* Success */
 
-	DBC_Require(this != NULL);
-	lib = pStream->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = pstream->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	if (lib != NULL) {
-		status = (*(lib->pTarget->attrs.fseek))(lib->fp, (long)pos,
-			 SEEK_SET);
+		status = (*(lib->target_obj->attrs.fseek)) (lib->fp, (long)pos,
+							    SEEK_SET);
 	}
 
 	return status;
 }
 
-/* Dynamic_Loader_Sym */
+/* dynamic_loader_sym */
 
 /*
- *  ======== findSymbol ========
+ *  ======== dbll_find_symbol ========
  */
-static struct dynload_symbol *findSymbol(struct Dynamic_Loader_Sym *this,
-					const char *name)
+static struct dynload_symbol *dbll_find_symbol(struct dynamic_loader_sym *this,
+					       const char *name)
 {
-	struct dynload_symbol *retSym;
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
-	struct DBLL_Symbol *pSym = NULL;
-	bool status = false; 	/* Symbol not found yet */
+	struct dynload_symbol *ret_sym;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
+	struct dbll_sym_val *dbll_sym = NULL;
+	bool status = false;	/* Symbol not found yet */
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	if (lib != NULL) {
-		if (lib->pTarget->attrs.symLookup) {
+		if (lib->target_obj->attrs.sym_lookup) {
 			/* Check current lib + base lib + dep lib +
 			 * persistent lib */
-			status = (*(lib->pTarget->attrs.symLookup))
-				 (lib->pTarget->attrs.symHandle,
-				 lib->pTarget->attrs.symArg,
-				 lib->pTarget->attrs.rmmHandle, name, &pSym);
+			status = (*(lib->target_obj->attrs.sym_lookup))
+			    (lib->target_obj->attrs.sym_handle,
+			     lib->target_obj->attrs.sym_arg,
+			     lib->target_obj->attrs.rmm_handle, name,
+			     &dbll_sym);
 		} else {
 			/* Just check current lib for symbol */
-			status = DBLL_getAddr((struct DBLL_LibraryObj *)lib,
-				 (char *)name, &pSym);
+			status = dbll_get_addr((struct dbll_library_obj *)lib,
+					       (char *)name, &dbll_sym);
 			if (!status) {
 				status =
-				   DBLL_getCAddr((struct DBLL_LibraryObj *)lib,
-				   (char *)name, &pSym);
+				    dbll_get_c_addr((struct dbll_library_obj *)
+						    lib, (char *)name,
+						    &dbll_sym);
 			}
 		}
 	}
 
-	if (!status && bGblSearch) {
+	if (!status && gbl_search) {
 		dev_dbg(bridge, "%s: Symbol not found: %s\n", __func__, name);
 	}
 
-	DBC_Assert((status && (pSym != NULL)) || (!status && (pSym == NULL)));
+	DBC_ASSERT((status && (dbll_sym != NULL))
+		   || (!status && (dbll_sym == NULL)));
 
-	retSym = (struct dynload_symbol *)pSym;
-	return retSym;
+	ret_sym = (struct dynload_symbol *)dbll_sym;
+	return ret_sym;
 }
 
 /*
- *  ======== findInSymbolTable ========
+ *  ======== find_in_symbol_table ========
  */
-static struct dynload_symbol *findInSymbolTable(struct Dynamic_Loader_Sym *this,
-						const char *name,
-						unsigned moduleid)
+static struct dynload_symbol *find_in_symbol_table(struct dynamic_loader_sym
+						   *this, const char *name,
+						   unsigned moduleid)
 {
-	struct dynload_symbol *retSym;
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
-	struct Symbol *sym;
+	struct dynload_symbol *ret_sym;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
+	struct dbll_symbol *sym;
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
-	DBC_Require(lib->symTab != NULL);
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(lib->sym_tab != NULL);
 
-	sym = (struct Symbol *)GH_find(lib->symTab, (char *) name);
+	sym = (struct dbll_symbol *)gh_find(lib->sym_tab, (char *)name);
 
-	retSym = (struct dynload_symbol *)&sym->value;
-	return retSym;
+	ret_sym = (struct dynload_symbol *)&sym->value;
+	return ret_sym;
 }
 
 /*
- *  ======== addToSymbolTable ========
+ *  ======== dbll_add_to_symbol_table ========
  */
-static struct dynload_symbol *addToSymbolTable(struct Dynamic_Loader_Sym *this,
-					      const char *name,
-					      unsigned moduleId)
+static struct dynload_symbol *dbll_add_to_symbol_table(struct dynamic_loader_sym
+						       *this, const char *name,
+						       unsigned moduleId)
 {
-	struct Symbol *symPtr = NULL;
-	struct Symbol symbol;
-	struct dynload_symbol *pSym = NULL;
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
-	struct dynload_symbol *retVal;
-
-	DBC_Require(this != NULL);
-	DBC_Require(name);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	struct dbll_symbol *sym_ptr = NULL;
+	struct dbll_symbol symbol;
+	struct dynload_symbol *dbll_sym = NULL;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
+	struct dynload_symbol *ret;
+
+	DBC_REQUIRE(this != NULL);
+	DBC_REQUIRE(name);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	/* Check to see if symbol is already defined in symbol table */
-	if (!(lib->pTarget->attrs.baseImage)) {
-		bGblSearch = false;
-		pSym = findSymbol(this, name);
-		bGblSearch = true;
-		if (pSym) {
-			bRedefinedSymbol = true;
+	if (!(lib->target_obj->attrs.base_image)) {
+		gbl_search = false;
+		dbll_sym = dbll_find_symbol(this, name);
+		gbl_search = true;
+		if (dbll_sym) {
+			redefined_symbol = true;
 			dev_dbg(bridge, "%s already defined in symbol table\n",
-									name);
+				name);
 			return NULL;
 		}
 	}
 	/* Allocate string to copy symbol name */
-	symbol.name = (char *)MEM_Calloc(strlen((char *const)name) + 1,
-							MEM_PAGED);
+	symbol.name = (char *)mem_calloc(strlen((char *const)name) + 1,
+					 MEM_PAGED);
 	if (symbol.name == NULL)
 		return NULL;
 
@@ -1126,31 +1148,33 @@ static struct dynload_symbol *addToSymbolTable(struct Dynamic_Loader_Sym *this,
 			strlen((char *const)name) + 1);
 
 		/* Add symbol to symbol table */
-		symPtr = (struct Symbol *)GH_insert(lib->symTab, (void *)name,
-			 (void *)&symbol);
-		if (symPtr == NULL)
+		sym_ptr =
+		    (struct dbll_symbol *)gh_insert(lib->sym_tab, (void *)name,
+						    (void *)&symbol);
+		if (sym_ptr == NULL)
 			kfree(symbol.name);
 
 	}
-	if (symPtr != NULL)
-		retVal = (struct dynload_symbol *)&symPtr->value;
+	if (sym_ptr != NULL)
+		ret = (struct dynload_symbol *)&sym_ptr->value;
 	else
-		retVal = NULL;
+		ret = NULL;
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== purgeSymbolTable ========
+ *  ======== dbll_purge_symbol_table ========
  */
-static void purgeSymbolTable(struct Dynamic_Loader_Sym *this, unsigned moduleId)
+static void dbll_purge_symbol_table(struct dynamic_loader_sym *this,
+				    unsigned moduleId)
 {
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	/* May not need to do anything */
 }
@@ -1158,17 +1182,17 @@ static void purgeSymbolTable(struct Dynamic_Loader_Sym *this, unsigned moduleId)
 /*
  *  ======== allocate ========
  */
-static void *allocate(struct Dynamic_Loader_Sym *this, unsigned memsize)
+static void *allocate(struct dynamic_loader_sym *this, unsigned memsize)
 {
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
 	void *buf;
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
-	buf = MEM_Calloc(memsize, MEM_PAGED);
+	buf = mem_calloc(memsize, MEM_PAGED);
 
 	return buf;
 }
@@ -1176,306 +1200,319 @@ static void *allocate(struct Dynamic_Loader_Sym *this, unsigned memsize)
 /*
  *  ======== deallocate ========
  */
-static void deallocate(struct Dynamic_Loader_Sym *this, void *memPtr)
+static void deallocate(struct dynamic_loader_sym *this, void *memPtr)
 {
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	kfree(memPtr);
 }
 
 /*
- *  ======== errorReport ========
+ *  ======== dbll_err_report ========
  */
-static void errorReport(struct Dynamic_Loader_Sym *this, const char *errstr,
-			va_list args)
+static void dbll_err_report(struct dynamic_loader_sym *this, const char *errstr,
+			    va_list args)
 {
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
-	char tempBuf[MAXEXPR];
-
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
-	vsnprintf((char *)tempBuf, MAXEXPR, (char *)errstr, args);
-	dev_dbg(bridge, "%s\n", tempBuf);
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
+	char temp_buf[MAXEXPR];
+
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
+	vsnprintf((char *)temp_buf, MAXEXPR, (char *)errstr, args);
+	dev_dbg(bridge, "%s\n", temp_buf);
 }
 
-/* Dynamic_Loader_Allocate */
+/* dynamic_loader_allocate */
 
 /*
- *  ======== rmmAlloc ========
+ *  ======== dbll_rmm_alloc ========
  */
-static int rmmAlloc(struct Dynamic_Loader_Allocate *this,
-		   struct LDR_SECTION_INFO *info, unsigned align)
+static int dbll_rmm_alloc(struct dynamic_loader_allocate *this,
+			  struct ldr_section_info *info, unsigned align)
 {
-	struct DBLLAlloc *pAlloc = (struct DBLLAlloc *)this;
-	struct DBLL_LibraryObj *lib;
-	DSP_STATUS status = DSP_SOK;
-	u32 memType;
-	struct RMM_Addr rmmAddr;
-	s32 retVal = TRUE;
+	struct dbll_alloc *dbll_alloc_obj = (struct dbll_alloc *)this;
+	struct dbll_library_obj *lib;
+	dsp_status status = DSP_SOK;
+	u32 mem_sect_type;
+	struct rmm_addr rmm_addr_obj;
+	s32 ret = TRUE;
 	unsigned stype = DLOAD_SECTION_TYPE(info->type);
-	char *pToken = NULL;
-	char *szSecLastToken = NULL;
-	char *szLastToken = NULL;
-	char *szSectName = NULL;
-	char *pszCur;
-	s32 tokenLen = 0;
-	s32 segId = -1;
+	char *token = NULL;
+	char *sz_sec_last_token = NULL;
+	char *sz_last_token = NULL;
+	char *sz_sect_name = NULL;
+	char *psz_cur;
+	s32 token_len = 0;
+	s32 seg_id = -1;
 	s32 req = -1;
 	s32 count = 0;
-	u32 allocSize = 0;
-	u32 runAddrFlag = 0;
+	u32 alloc_size = 0;
+	u32 run_addr_flag = 0;
 
-	DBC_Require(this != NULL);
-	lib = pAlloc->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = dbll_alloc_obj->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
-	memType = (stype == DLOAD_TEXT) ? DBLL_CODE : (stype == DLOAD_BSS) ?
-		   DBLL_BSS : DBLL_DATA;
+	mem_sect_type =
+	    (stype == DLOAD_TEXT) ? DBLL_CODE : (stype ==
+						 DLOAD_BSS) ? DBLL_BSS :
+	    DBLL_DATA;
 
 	/* Attempt to extract the segment ID and requirement information from
-	 the name of the section */
-	DBC_Require(info->name);
-	tokenLen = strlen((char *)(info->name)) + 1;
+	   the name of the section */
+	DBC_REQUIRE(info->name);
+	token_len = strlen((char *)(info->name)) + 1;
 
-	szSectName = MEM_Calloc(tokenLen, MEM_PAGED);
-	szLastToken = MEM_Calloc(tokenLen, MEM_PAGED);
-	szSecLastToken = MEM_Calloc(tokenLen, MEM_PAGED);
+	sz_sect_name = mem_calloc(token_len, MEM_PAGED);
+	sz_last_token = mem_calloc(token_len, MEM_PAGED);
+	sz_sec_last_token = mem_calloc(token_len, MEM_PAGED);
 
-	if (szSectName == NULL || szSecLastToken == NULL ||
-	   szLastToken == NULL) {
+	if (sz_sect_name == NULL || sz_sec_last_token == NULL ||
+	    sz_last_token == NULL) {
 		status = DSP_EMEMORY;
 		goto func_cont;
 	}
-	strncpy(szSectName, (char *)(info->name), tokenLen);
-	pszCur = szSectName;
-	while ((pToken = strsep(&pszCur, ":")) && *pToken != '\0') {
-		strncpy(szSecLastToken, szLastToken, strlen(szLastToken) + 1);
-		strncpy(szLastToken, pToken, strlen(pToken) + 1);
-		pToken = strsep(&pszCur, ":");
-		count++; 	/* optimizes processing*/
+	strncpy(sz_sect_name, (char *)(info->name), token_len);
+	psz_cur = sz_sect_name;
+	while ((token = strsep(&psz_cur, ":")) && *token != '\0') {
+		strncpy(sz_sec_last_token, sz_last_token,
+			strlen(sz_last_token) + 1);
+		strncpy(sz_last_token, token, strlen(token) + 1);
+		token = strsep(&psz_cur, ":");
+		count++;	/* optimizes processing */
 	}
-	/* If pToken is 0 or 1, and szSecLastToken is DYN_DARAM or DYN_SARAM,
-	 or DYN_EXTERNAL, then mem granularity information is present
-	 within the section name - only process if there are at least three
-	 tokens within the section name (just a minor optimization)*/
+	/* If token is 0 or 1, and sz_sec_last_token is DYN_DARAM or DYN_SARAM,
+	   or DYN_EXTERNAL, then mem granularity information is present
+	   within the section name - only process if there are at least three
+	   tokens within the section name (just a minor optimization) */
 	if (count >= 3)
-		strict_strtol(szLastToken, 10, (long *)&req);
+		strict_strtol(sz_last_token, 10, (long *)&req);
 
 	if ((req == 0) || (req == 1)) {
-		if (strcmp(szSecLastToken, "DYN_DARAM") == 0) {
-			segId = 0;
+		if (strcmp(sz_sec_last_token, "DYN_DARAM") == 0) {
+			seg_id = 0;
 		} else {
-			if (strcmp(szSecLastToken, "DYN_SARAM") == 0) {
-				segId = 1;
+			if (strcmp(sz_sec_last_token, "DYN_SARAM") == 0) {
+				seg_id = 1;
 			} else {
-				if (strcmp(szSecLastToken,
-				   "DYN_EXTERNAL") == 0)
-					segId = 2;
+				if (strcmp(sz_sec_last_token,
+					   "DYN_EXTERNAL") == 0)
+					seg_id = 2;
 			}
 		}
 	}
 func_cont:
-	kfree(szSectName);
-	szSectName = NULL;
-	kfree(szLastToken);
-	szLastToken = NULL;
-	kfree(szSecLastToken);
-	szSecLastToken = NULL;
-
-	if (memType == DBLL_CODE)
-		allocSize = info->size + GEM_L1P_PREFETCH_SIZE;
+	kfree(sz_sect_name);
+	sz_sect_name = NULL;
+	kfree(sz_last_token);
+	sz_last_token = NULL;
+	kfree(sz_sec_last_token);
+	sz_sec_last_token = NULL;
+
+	if (mem_sect_type == DBLL_CODE)
+		alloc_size = info->size + GEM_L1P_PREFETCH_SIZE;
 	else
-		allocSize = info->size;
+		alloc_size = info->size;
 
 	if (info->load_addr != info->run_addr)
-		runAddrFlag = 1;
+		run_addr_flag = 1;
 	/* TODO - ideally, we can pass the alignment requirement also
 	 * from here */
 	if (lib != NULL) {
-		status = (lib->pTarget->attrs.alloc)(lib->pTarget->
-			 attrs.rmmHandle, memType, allocSize, align,
-			 (u32 *)&rmmAddr, segId, req, FALSE);
+		status =
+		    (lib->target_obj->attrs.alloc) (lib->target_obj->attrs.
+						    rmm_handle, mem_sect_type,
+						    alloc_size, align,
+						    (u32 *) &rmm_addr_obj,
+						    seg_id, req, FALSE);
 	}
 	if (DSP_FAILED(status)) {
-		retVal = false;
+		ret = false;
 	} else {
 		/* RMM gives word address. Need to convert to byte address */
-		info->load_addr = rmmAddr.addr * DSPWORDSIZE;
-		if (!runAddrFlag)
+		info->load_addr = rmm_addr_obj.addr * DSPWORDSIZE;
+		if (!run_addr_flag)
 			info->run_addr = info->load_addr;
-		info->context = (u32)rmmAddr.segid;
+		info->context = (u32) rmm_addr_obj.segid;
 		dev_dbg(bridge, "%s: %s base = 0x%x len = 0x%x, "
 			"info->run_addr 0x%x, info->load_addr 0x%x\n",
 			__func__, info->name, info->load_addr / DSPWORDSIZE,
 			info->size / DSPWORDSIZE, info->run_addr,
 			info->load_addr);
 	}
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== rmmDealloc ========
+ *  ======== rmm_dealloc ========
  */
-static void rmmDealloc(struct Dynamic_Loader_Allocate *this,
-			struct LDR_SECTION_INFO *info)
+static void rmm_dealloc(struct dynamic_loader_allocate *this,
+			struct ldr_section_info *info)
 {
-	struct DBLLAlloc *pAlloc = (struct DBLLAlloc *)this;
-	struct DBLL_LibraryObj *lib;
+	struct dbll_alloc *dbll_alloc_obj = (struct dbll_alloc *)this;
+	struct dbll_library_obj *lib;
 	u32 segid;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	unsigned stype = DLOAD_SECTION_TYPE(info->type);
-	u32 memType;
-	u32 freeSize = 0;
-
-	memType = (stype == DLOAD_TEXT) ? DBLL_CODE : (stype == DLOAD_BSS) ?
-		  DBLL_BSS : DBLL_DATA;
-	DBC_Require(this != NULL);
-	lib = pAlloc->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	u32 mem_sect_type;
+	u32 free_size = 0;
+
+	mem_sect_type =
+	    (stype == DLOAD_TEXT) ? DBLL_CODE : (stype ==
+						 DLOAD_BSS) ? DBLL_BSS :
+	    DBLL_DATA;
+	DBC_REQUIRE(this != NULL);
+	lib = dbll_alloc_obj->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 	/* segid was set by alloc function */
-	segid = (u32)info->context;
-	if (memType == DBLL_CODE)
-		freeSize = info->size + GEM_L1P_PREFETCH_SIZE;
+	segid = (u32) info->context;
+	if (mem_sect_type == DBLL_CODE)
+		free_size = info->size + GEM_L1P_PREFETCH_SIZE;
 	else
-		freeSize = info->size;
+		free_size = info->size;
 	if (lib != NULL) {
-		status = (lib->pTarget->attrs.free)(lib->pTarget->
-			 attrs.symHandle, segid, info->load_addr / DSPWORDSIZE,
-			 freeSize, false);
+		status =
+		    (lib->target_obj->attrs.free) (lib->target_obj->attrs.
+						   sym_handle, segid,
+						   info->load_addr /
+						   DSPWORDSIZE, free_size,
+						   false);
 	}
 }
 
-/* Dynamic_Loader_Initialize */
+/* dynamic_loader_initialize */
 /*
  *  ======== connect ========
  */
-static int connect(struct Dynamic_Loader_Initialize *this)
+static int connect(struct dynamic_loader_initialize *this)
 {
 	return true;
 }
 
 /*
- *  ======== readMem ========
+ *  ======== read_mem ========
  *  This function does not need to be implemented.
  */
-static int readMem(struct Dynamic_Loader_Initialize *this, void *buf,
-		  LDR_ADDR addr, struct LDR_SECTION_INFO *info,
-		  unsigned nbytes)
+static int read_mem(struct dynamic_loader_initialize *this, void *buf,
+		    ldr_addr addr, struct ldr_section_info *info,
+		    unsigned nbytes)
 {
-	struct DBLLInit *pInit = (struct DBLLInit *)this;
-	struct DBLL_LibraryObj *lib;
-	int bytesRead = 0;
-
-	DBC_Require(this != NULL);
-	lib = pInit->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
-	/* Need WMD_BRD_Read function */
-	return bytesRead;
+	struct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;
+	struct dbll_library_obj *lib;
+	int bytes_read = 0;
+
+	DBC_REQUIRE(this != NULL);
+	lib = init_obj->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
+	/* Need bridge_brd_read function */
+	return bytes_read;
 }
 
 /*
- *  ======== writeMem ========
+ *  ======== write_mem ========
  */
-static int writeMem(struct Dynamic_Loader_Initialize *this, void *buf,
-		   LDR_ADDR addr, struct LDR_SECTION_INFO *info,
-		   unsigned nBytes)
+static int write_mem(struct dynamic_loader_initialize *this, void *buf,
+		     ldr_addr addr, struct ldr_section_info *info,
+		     unsigned bytes)
 {
-	struct DBLLInit *pInit = (struct DBLLInit *)this;
-	struct DBLL_LibraryObj *lib;
-	struct DBLL_TarObj *pTarget;
-	struct DBLL_SectInfo sectInfo;
-	u32 memType;
-	bool retVal = true;
-
-	DBC_Require(this != NULL);
-	lib = pInit->lib;
-	if (!MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE))
+	struct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;
+	struct dbll_library_obj *lib;
+	struct dbll_tar_obj *target_obj;
+	struct dbll_sect_info sect_info;
+	u32 mem_sect_type;
+	bool ret = true;
+
+	DBC_REQUIRE(this != NULL);
+	lib = init_obj->lib;
+	if (!MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE))
 		return false;
 
-	pTarget = lib->pTarget;
-
-	memType = (DLOAD_SECTION_TYPE(info->type) == DLOAD_TEXT) ? DBLL_CODE :
-		  DBLL_DATA;
-	if (pTarget && pTarget->attrs.write) {
-		retVal = (*pTarget->attrs.write)(pTarget->attrs.wHandle,
-						 addr, buf, nBytes, memType);
-
-		if (pTarget->attrs.logWrite) {
-			sectInfo.name = info->name;
-			sectInfo.runAddr = info->run_addr;
-			sectInfo.loadAddr = info->load_addr;
-			sectInfo.size = info->size;
-			sectInfo.type = memType;
+	target_obj = lib->target_obj;
+
+	mem_sect_type =
+	    (DLOAD_SECTION_TYPE(info->type) ==
+	     DLOAD_TEXT) ? DBLL_CODE : DBLL_DATA;
+	if (target_obj && target_obj->attrs.write) {
+		ret =
+		    (*target_obj->attrs.write) (target_obj->attrs.input_params,
+						addr, buf, bytes,
+						mem_sect_type);
+
+		if (target_obj->attrs.log_write) {
+			sect_info.name = info->name;
+			sect_info.sect_run_addr = info->run_addr;
+			sect_info.sect_load_addr = info->load_addr;
+			sect_info.size = info->size;
+			sect_info.type = mem_sect_type;
 			/* Pass the information about what we've written to
 			 * another module */
-			(*pTarget->attrs.logWrite)(
-				pTarget->attrs.logWriteHandle,
-				&sectInfo, addr, nBytes);
+			(*target_obj->attrs.log_write) (target_obj->attrs.
+							log_write_handle,
+							&sect_info, addr,
+							bytes);
 		}
 	}
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== fillMem ========
- *  Fill nBytes of memory at a given address with a given value by
+ *  ======== fill_mem ========
+ *  Fill bytes of memory at a given address with a given value by
  *  writing from a buffer containing the given value.  Write in
  *  sets of MAXEXPR (128) bytes to avoid large stack buffer issues.
  */
-static int fillMem(struct Dynamic_Loader_Initialize *this, LDR_ADDR addr,
-		   struct LDR_SECTION_INFO *info, unsigned nBytes,
-		   unsigned val)
+static int fill_mem(struct dynamic_loader_initialize *this, ldr_addr addr,
+		    struct ldr_section_info *info, unsigned bytes, unsigned val)
 {
-	bool retVal = true;
-	char *pBuf;
-	struct DBLL_LibraryObj *lib;
-	struct DBLLInit *pInit = (struct DBLLInit *)this;
-
-	DBC_Require(this != NULL);
-	lib = pInit->lib;
-	pBuf = NULL;
-	/* Pass the NULL pointer to writeMem to get the start address of Shared
-	    memory. This is a trick to just get the start address, there is no
-	    writing taking place with this Writemem
-	*/
-	if ((lib->pTarget->attrs.write) != (DBLL_WriteFxn)NoOp)
-		writeMem(this, &pBuf, addr, info, 0);
-	if (pBuf)
-		memset(pBuf, val, nBytes);
-
-	return retVal;
+	bool ret = true;
+	char *pbuf;
+	struct dbll_library_obj *lib;
+	struct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;
+
+	DBC_REQUIRE(this != NULL);
+	lib = init_obj->lib;
+	pbuf = NULL;
+	/* Pass the NULL pointer to write_mem to get the start address of Shared
+	   memory. This is a trick to just get the start address, there is no
+	   writing taking place with this Writemem
+	 */
+	if ((lib->target_obj->attrs.write) != (dbll_write_fxn) no_op)
+		write_mem(this, &pbuf, addr, info, 0);
+	if (pbuf)
+		memset(pbuf, val, bytes);
+
+	return ret;
 }
 
 /*
  *  ======== execute ========
  */
-static int execute(struct Dynamic_Loader_Initialize *this, LDR_ADDR start)
+static int execute(struct dynamic_loader_initialize *this, ldr_addr start)
 {
-	struct DBLLInit *pInit = (struct DBLLInit *)this;
-	struct DBLL_LibraryObj *lib;
-	bool retVal = true;
+	struct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;
+	struct dbll_library_obj *lib;
+	bool ret = true;
 
-	DBC_Require(this != NULL);
-	lib = pInit->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = init_obj->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 	/* Save entry point */
 	if (lib != NULL)
-		lib->entry = (u32)start;
+		lib->entry = (u32) start;
 
-	return retVal;
+	return ret;
 }
 
 /*
  *  ======== release ========
  */
-static void release(struct Dynamic_Loader_Initialize *this)
+static void release(struct dynamic_loader_initialize *this)
 {
 }
-
diff --git a/drivers/dsp/bridge/pmgr/dev.c b/drivers/dsp/bridge/pmgr/dev.c
index fefed75..6994da5 100644
--- a/drivers/dsp/bridge/pmgr/dev.c
+++ b/drivers/dsp/bridge/pmgr/dev.c
@@ -44,7 +44,7 @@
 #include <dspbridge/node.h>
 
 /*  ----------------------------------- Others */
-#include <dspbridge/wcd.h>		/* WCD version info. */
+#include <dspbridge/wcd.h>	/* WCD version info. */
 
 #include <dspbridge/chnl.h>
 #include <dspbridge/io.h>
@@ -61,346 +61,348 @@
 #define WCDVERSION          MAKEVERSION(WCD_MAJOR_VERSION, WCD_MINOR_VERSION)
 
 /* The WMD device object: */
-struct DEV_OBJECT {
-	/* LST requires "link" to be first field!                        */
-	struct list_head link;		/* Link to next DEV_OBJECT.      */
-	u32 devType;		/* Device Type */
-	u32 dwSignature;	/* Used for object validation.   */
-	struct CFG_DEVNODE *hDevNode;	/* Platform specific device id   */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle        */
-	struct WMD_DRV_INTERFACE intfFxns;	/* Function interface to WMD. */
-	struct BRD_OBJECT *lockOwner;	/* Client with exclusive access. */
-	struct COD_MANAGER *hCodMgr;	/* Code manager handle.          */
-	struct CHNL_MGR *hChnlMgr;	/* Channel manager.              */
-	struct DEH_MGR *hDehMgr;	/* DEH manager.                  */
-	struct MSG_MGR *hMsgMgr;	/* Message manager.              */
-	struct IO_MGR *hIOMgr;		/* IO manager (CHNL, MSG)        */
-	struct CMM_OBJECT *hCmmMgr;	/* SM memory manager.            */
-	struct DMM_OBJECT *hDmmMgr;	/* Dynamic memory manager.       */
-	struct LDR_MODULE *hModule;	/* WMD Module handle.            */
-	u32 uWordSize;	/* DSP word size: quick access.  */
-	struct DRV_OBJECT *hDrvObject;	/* Driver Object                 */
-	struct LST_LIST *procList;	/* List of Proceeosr attached to
-				 * this device  */
-	struct NODE_MGR *hNodeMgr;
-} ;
+struct dev_object {
+	/* LST requires "link" to be first field! */
+	struct list_head link;	/* Link to next dev_object. */
+	u32 dev_type;		/* Device Type */
+	u32 dw_signature;	/* Used for object validation. */
+	struct cfg_devnode *dev_node_obj;	/* Platform specific dev id */
+	struct wmd_dev_context *hwmd_context;	/* WMD Context Handle */
+	struct bridge_drv_interface wmd_interface;	/* Function interface to WMD. */
+	struct brd_object *lock_owner;	/* Client with exclusive access. */
+	struct cod_manager *cod_mgr;	/* Code manager handle. */
+	struct chnl_mgr *hchnl_mgr;	/* Channel manager. */
+	struct deh_mgr *hdeh_mgr;	/* DEH manager. */
+	struct msg_mgr *hmsg_mgr;	/* Message manager. */
+	struct io_mgr *hio_mgr;	/* IO manager (CHNL, msg_ctrl) */
+	struct cmm_object *hcmm_mgr;	/* SM memory manager. */
+	struct dmm_object *dmm_mgr;	/* Dynamic memory manager. */
+	struct ldr_module *module_obj;	/* WMD Module handle. */
+	u32 word_size;		/* DSP word size: quick access. */
+	struct drv_object *hdrv_obj;	/* Driver Object */
+	struct lst_list *proc_list;	/* List of Proceeosr attached to
+					 * this device */
+	struct node_mgr *hnode_mgr;
+};
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;		/* Module reference count */
+static u32 refs;		/* Module reference count */
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS FxnNotImplemented(int arg, ...);
-static DSP_STATUS InitCodMgr(struct DEV_OBJECT *pDevObject);
-static bool IsValidHandle(struct DEV_OBJECT *hObj);
-static void StoreInterfaceFxns(struct WMD_DRV_INTERFACE *pDrvFxns,
-			       OUT struct WMD_DRV_INTERFACE *pIntfFxns);
+static dsp_status fxn_not_implemented(int arg, ...);
+static dsp_status init_cod_mgr(struct dev_object *dev_obj);
+static bool IS_VALID_HANDLE(struct dev_object *hObj);
+static void store_interface_fxns(struct bridge_drv_interface *drv_fxns,
+				 OUT struct bridge_drv_interface *intf_fxns);
 /*
- *  ======== DEV_BrdWriteFxn ========
+ *  ======== dev_brd_write_fxn ========
  *  Purpose:
  *      Exported function to be used as the COD write function.  This function
  *      is passed a handle to a DEV_hObject, then calls the
- *      device's WMD_BRD_Write() function.
+ *      device's bridge_brd_write() function.
  */
-u32 DEV_BrdWriteFxn(void *pArb, u32 ulDspAddr, void *pHostBuf,
-		      u32 ulNumBytes, u32 nMemSpace)
+u32 dev_brd_write_fxn(void *pArb, u32 ulDspAddr, void *pHostBuf,
+		      u32 ul_num_bytes, u32 nMemSpace)
 {
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)pArb;
-	u32 ulWritten = 0;
-	DSP_STATUS status;
+	struct dev_object *dev_obj = (struct dev_object *)pArb;
+	u32 ul_written = 0;
+	dsp_status status;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pHostBuf != NULL);	/* Required of BrdWrite(). */
-	if (IsValidHandle(pDevObject)) {
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pHostBuf != NULL);	/* Required of BrdWrite(). */
+	if (IS_VALID_HANDLE(dev_obj)) {
 		/* Require of BrdWrite() */
-		DBC_Assert(pDevObject->hWmdContext != NULL);
-		status = (*pDevObject->intfFxns.pfnBrdWrite)(pDevObject->
-			 hWmdContext, pHostBuf, ulDspAddr, ulNumBytes,
-			 nMemSpace);
-		 /* Special case of getting the address only */
-		if (ulNumBytes == 0)
-			ulNumBytes = 1;
+		DBC_ASSERT(dev_obj->hwmd_context != NULL);
+		status =
+		    (*dev_obj->wmd_interface.
+		     pfn_brd_write) (dev_obj->hwmd_context, pHostBuf, ulDspAddr,
+				     ul_num_bytes, nMemSpace);
+		/* Special case of getting the address only */
+		if (ul_num_bytes == 0)
+			ul_num_bytes = 1;
 		if (DSP_SUCCEEDED(status))
-			ulWritten = ulNumBytes;
+			ul_written = ul_num_bytes;
 
 	}
-	return ulWritten;
+	return ul_written;
 }
 
 /*
- *  ======== DEV_CreateDevice ========
+ *  ======== dev_create_device ========
  *  Purpose:
  *      Called by the operating system to load the PM Mini Driver for a
  *      PM board (device).
  */
-DSP_STATUS DEV_CreateDevice(OUT struct DEV_OBJECT **phDevObject,
-			    IN CONST char *pstrWMDFileName,
-			    IN CONST struct CFG_HOSTRES *pHostConfig,
-			    IN CONST struct CFG_DSPRES *pDspConfig,
-			    struct CFG_DEVNODE *hDevNode)
+dsp_status dev_create_device(OUT struct dev_object **phDevObject,
+			     IN CONST char *pstrWMDFileName,
+			     IN CONST struct cfg_hostres *pHostConfig,
+			     IN CONST struct cfg_dspres *pDspConfig,
+			     struct cfg_devnode *dev_node_obj)
 {
-	struct LDR_MODULE *hModule = NULL;
-	struct WMD_DRV_INTERFACE *pDrvFxns = NULL;
-	struct DEV_OBJECT *pDevObject = NULL;
-	struct CHNL_MGRATTRS mgrAttrs;
-	struct IO_ATTRS ioMgrAttrs;
-	u32 uNumWindows;
-	struct DRV_OBJECT *hDrvObject = NULL;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDevObject != NULL);
-	DBC_Require(pstrWMDFileName != NULL);
-	DBC_Require(pHostConfig != NULL);
-	DBC_Require(pDspConfig != NULL);
-
-	/*  Get the WMD interface functions*/
-	WMD_DRV_Entry(&pDrvFxns, pstrWMDFileName);
-	if (DSP_FAILED(CFG_GetObject((u32 *) &hDrvObject, REG_DRV_OBJECT))) {
+	struct ldr_module *module_obj = NULL;
+	struct bridge_drv_interface *drv_fxns = NULL;
+	struct dev_object *dev_obj = NULL;
+	struct chnl_mgrattrs mgr_attrs;
+	struct io_attrs io_mgr_attrs;
+	u32 num_windows;
+	struct drv_object *hdrv_obj = NULL;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDevObject != NULL);
+	DBC_REQUIRE(pstrWMDFileName != NULL);
+	DBC_REQUIRE(pHostConfig != NULL);
+	DBC_REQUIRE(pDspConfig != NULL);
+
+	/*  Get the WMD interface functions */
+	bridge_drv_entry(&drv_fxns, pstrWMDFileName);
+	if (DSP_FAILED(cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT))) {
 		/* don't propogate CFG errors from this PROC function */
 		status = DSP_EFAIL;
 	}
 	/* Create the device object, and pass a handle to the WMD for
 	 * storage. */
 	if (DSP_SUCCEEDED(status)) {
-		DBC_Assert(pDrvFxns);
-		MEM_AllocObject(pDevObject, struct DEV_OBJECT, SIGNATURE);
-		if (pDevObject) {
+		DBC_ASSERT(drv_fxns);
+		MEM_ALLOC_OBJECT(dev_obj, struct dev_object, SIGNATURE);
+		if (dev_obj) {
 			/* Fill out the rest of the Dev Object structure: */
-			pDevObject->hDevNode = hDevNode;
-			pDevObject->hModule = hModule;
-			pDevObject->hCodMgr = NULL;
-			pDevObject->hChnlMgr = NULL;
-			pDevObject->hDehMgr = NULL;
-			pDevObject->lockOwner = NULL;
-			pDevObject->uWordSize = pDspConfig->uWordSize;
-			pDevObject->hDrvObject = hDrvObject;
-			pDevObject->devType = DSP_UNIT;
+			dev_obj->dev_node_obj = dev_node_obj;
+			dev_obj->module_obj = module_obj;
+			dev_obj->cod_mgr = NULL;
+			dev_obj->hchnl_mgr = NULL;
+			dev_obj->hdeh_mgr = NULL;
+			dev_obj->lock_owner = NULL;
+			dev_obj->word_size = pDspConfig->word_size;
+			dev_obj->hdrv_obj = hdrv_obj;
+			dev_obj->dev_type = DSP_UNIT;
 			/* Store this WMD's interface functions, based on its
 			 * version. */
-			StoreInterfaceFxns(pDrvFxns, &pDevObject->intfFxns);
-			/* Call WMD_DEV_CREATE() to get the WMD's device
+			store_interface_fxns(drv_fxns, &dev_obj->wmd_interface);
+			/* Call fxn_dev_create() to get the WMD's device
 			 * context handle. */
-			status = (pDevObject->intfFxns.pfnDevCreate)
-				 (&pDevObject->hWmdContext, pDevObject,
-				 pHostConfig, pDspConfig);
-			/* Assert WMD_DEV_Create()'s ensure clause: */
-			DBC_Assert(DSP_FAILED(status) || (pDevObject->
-				   hWmdContext != NULL));
+			status = (dev_obj->wmd_interface.pfn_dev_create)
+			    (&dev_obj->hwmd_context, dev_obj,
+			     pHostConfig, pDspConfig);
+			/* Assert bridge_dev_create()'s ensure clause: */
+			DBC_ASSERT(DSP_FAILED(status)
+				   || (dev_obj->hwmd_context != NULL));
 		} else {
 			status = DSP_EMEMORY;
 		}
 	}
 	/* Attempt to create the COD manager for this device: */
 	if (DSP_SUCCEEDED(status))
-		status = InitCodMgr(pDevObject);
+		status = init_cod_mgr(dev_obj);
 
 	/* Attempt to create the channel manager for this device: */
 	if (DSP_SUCCEEDED(status)) {
-		mgrAttrs.cChannels = CHNL_MAXCHANNELS;
-		ioMgrAttrs.bIRQ = pHostConfig->bIRQRegisters;
-		ioMgrAttrs.fShared = (pHostConfig->bIRQAttrib & CFG_IRQSHARED);
-		ioMgrAttrs.uWordSize = pDspConfig->uWordSize;
-		mgrAttrs.uWordSize = pDspConfig->uWordSize;
-		uNumWindows = pHostConfig->wNumMemWindows;
-		if (uNumWindows) {
+		mgr_attrs.max_channels = CHNL_MAXCHANNELS;
+		io_mgr_attrs.birq = pHostConfig->birq_registers;
+		io_mgr_attrs.irq_shared =
+		    (pHostConfig->birq_attrib & CFG_IRQSHARED);
+		io_mgr_attrs.word_size = pDspConfig->word_size;
+		mgr_attrs.word_size = pDspConfig->word_size;
+		num_windows = pHostConfig->num_mem_windows;
+		if (num_windows) {
 			/* Assume last memory window is for CHNL */
-			ioMgrAttrs.dwSMBase = pHostConfig->dwMemBase[1] +
-					      pHostConfig->dwOffsetForMonitor;
-			ioMgrAttrs.uSMLength = pHostConfig->dwMemLength[1] -
-					       pHostConfig->dwOffsetForMonitor;
+			io_mgr_attrs.shm_base = pHostConfig->dw_mem_base[1] +
+			    pHostConfig->dw_offset_for_monitor;
+			io_mgr_attrs.usm_length =
+			    pHostConfig->dw_mem_length[1] -
+			    pHostConfig->dw_offset_for_monitor;
 		} else {
-			ioMgrAttrs.dwSMBase = 0;
-			ioMgrAttrs.uSMLength = 0;
+			io_mgr_attrs.shm_base = 0;
+			io_mgr_attrs.usm_length = 0;
 			pr_err("%s: No memory reserved for shared structures\n",
-								__func__);
+			       __func__);
 		}
-		status = CHNL_Create(&pDevObject->hChnlMgr, pDevObject,
-				    &mgrAttrs);
+		status = chnl_create(&dev_obj->hchnl_mgr, dev_obj, &mgr_attrs);
 		if (status == DSP_ENOTIMPL) {
 			/* It's OK for a device not to have a channel
 			 * manager: */
 			status = DSP_SOK;
 		}
-		/* Create CMM mgr even if Msg Mgr not impl.  */
-		status = CMM_Create(&pDevObject->hCmmMgr,
-				   (struct DEV_OBJECT *)pDevObject, NULL);
+		/* Create CMM mgr even if Msg Mgr not impl. */
+		status = cmm_create(&dev_obj->hcmm_mgr,
+				    (struct dev_object *)dev_obj, NULL);
 		/* Only create IO manager if we have a channel manager */
-		if (DSP_SUCCEEDED(status) && pDevObject->hChnlMgr) {
-			status = IO_Create(&pDevObject->hIOMgr, pDevObject,
-					   &ioMgrAttrs);
+		if (DSP_SUCCEEDED(status) && dev_obj->hchnl_mgr) {
+			status = io_create(&dev_obj->hio_mgr, dev_obj,
+					   &io_mgr_attrs);
 		}
 		/* Only create DEH manager if we have an IO manager */
 		if (DSP_SUCCEEDED(status)) {
 			/* Instantiate the DEH module */
-			status = (*pDevObject->intfFxns.pfnDehCreate)
-				 (&pDevObject->hDehMgr, 	pDevObject);
+			status = (*dev_obj->wmd_interface.pfn_deh_create)
+			    (&dev_obj->hdeh_mgr, dev_obj);
 		}
-		/* Create DMM mgr .  */
-		status = DMM_Create(&pDevObject->hDmmMgr,
-				   (struct DEV_OBJECT *)pDevObject, NULL);
+		/* Create DMM mgr . */
+		status = dmm_create(&dev_obj->dmm_mgr,
+				    (struct dev_object *)dev_obj, NULL);
 	}
 	/* Add the new DEV_Object to the global list: */
 	if (DSP_SUCCEEDED(status)) {
-		LST_InitElem(&pDevObject->link);
-		status = DRV_InsertDevObject(hDrvObject, pDevObject);
+		lst_init_elem(&dev_obj->link);
+		status = drv_insert_dev_object(hdrv_obj, dev_obj);
 	}
 	/* Create the Processor List */
 	if (DSP_SUCCEEDED(status)) {
-		pDevObject->procList = MEM_Calloc(sizeof(struct LST_LIST),
-			MEM_NONPAGED);
-		if (!(pDevObject->procList))
+		dev_obj->proc_list = mem_calloc(sizeof(struct lst_list),
+						MEM_NONPAGED);
+		if (!(dev_obj->proc_list))
 			status = DSP_EFAIL;
 		else
-			INIT_LIST_HEAD(&pDevObject->procList->head);
+			INIT_LIST_HEAD(&dev_obj->proc_list->head);
 	}
-	 /*  If all went well, return a handle to the dev object;
-	 *  else, cleanup and return NULL in the OUT parameter.  */
+	/*  If all went well, return a handle to the dev object;
+	 *  else, cleanup and return NULL in the OUT parameter. */
 	if (DSP_SUCCEEDED(status)) {
-		*phDevObject = pDevObject;
+		*phDevObject = dev_obj;
 	} else {
-		kfree(pDevObject->procList);
+		kfree(dev_obj->proc_list);
 
-		if (pDevObject && pDevObject->hCodMgr)
-			COD_Delete(pDevObject->hCodMgr);
+		if (dev_obj && dev_obj->cod_mgr)
+			cod_delete(dev_obj->cod_mgr);
 
-		if (pDevObject && pDevObject->hDmmMgr)
-			DMM_Destroy(pDevObject->hDmmMgr);
+		if (dev_obj && dev_obj->dmm_mgr)
+			dmm_destroy(dev_obj->dmm_mgr);
 
-		if (pDevObject)
-			MEM_FreeObject(pDevObject);
+		if (dev_obj)
+			MEM_FREE_OBJECT(dev_obj);
 
 		*phDevObject = NULL;
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && IsValidHandle(*phDevObject)) ||
-		  (DSP_FAILED(status) && !*phDevObject));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && IS_VALID_HANDLE(*phDevObject)) ||
+		   (DSP_FAILED(status) && !*phDevObject));
 	return status;
 }
 
 /*
- *  ======== DEV_Create2 ========
+ *  ======== dev_create2 ========
  *  Purpose:
- *      After successful loading of the image from WCD_InitComplete2
- *      (PROC Auto_Start) or PROC_Load this fxn is called. This creates
+ *      After successful loading of the image from wcd_init_complete2
+ *      (PROC Auto_Start) or proc_load this fxn is called. This creates
  *      the Node Manager and updates the DEV Object.
  */
-DSP_STATUS DEV_Create2(struct DEV_OBJECT *hDevObject)
+dsp_status dev_create2(struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDevObject));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdev_obj));
 
 	/* There can be only one Node Manager per DEV object */
-	DBC_Assert(!pDevObject->hNodeMgr);
-	status = NODE_CreateMgr(&pDevObject->hNodeMgr, hDevObject);
+	DBC_ASSERT(!dev_obj->hnode_mgr);
+	status = node_create_mgr(&dev_obj->hnode_mgr, hdev_obj);
 	if (DSP_FAILED(status))
-		pDevObject->hNodeMgr = NULL;
+		dev_obj->hnode_mgr = NULL;
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && pDevObject->hNodeMgr != NULL)
-		   || (DSP_FAILED(status) && pDevObject->hNodeMgr == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && dev_obj->hnode_mgr != NULL)
+		   || (DSP_FAILED(status) && dev_obj->hnode_mgr == NULL));
 	return status;
 }
 
 /*
- *  ======== DEV_Destroy2 ========
+ *  ======== dev_destroy2 ========
  *  Purpose:
  *      Destroys the Node manager for this device.
  */
-DSP_STATUS DEV_Destroy2(struct DEV_OBJECT *hDevObject)
+dsp_status dev_destroy2(struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDevObject));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdev_obj));
 
-	if (pDevObject->hNodeMgr) {
-		if (DSP_FAILED(NODE_DeleteMgr(pDevObject->hNodeMgr)))
+	if (dev_obj->hnode_mgr) {
+		if (DSP_FAILED(node_delete_mgr(dev_obj->hnode_mgr)))
 			status = DSP_EFAIL;
 		else
-			pDevObject->hNodeMgr = NULL;
+			dev_obj->hnode_mgr = NULL;
 
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && pDevObject->hNodeMgr == NULL) ||
-		  DSP_FAILED(status));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && dev_obj->hnode_mgr == NULL) ||
+		   DSP_FAILED(status));
 	return status;
 }
 
 /*
- *  ======== DEV_DestroyDevice ========
+ *  ======== dev_destroy_device ========
  *  Purpose:
  *      Destroys the channel manager for this device, if any, calls
- *      WMD_DEV_Destroy(), and then attempts to unload the WMD module.
+ *      bridge_dev_destroy(), and then attempts to unload the WMD module.
  */
-DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT *hDevObject)
+dsp_status dev_destroy_device(struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (IsValidHandle(hDevObject)) {
-		if (pDevObject->hCodMgr) {
-			COD_Delete(pDevObject->hCodMgr);
-			pDevObject->hCodMgr = NULL;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		if (dev_obj->cod_mgr) {
+			cod_delete(dev_obj->cod_mgr);
+			dev_obj->cod_mgr = NULL;
 		}
 
-		if (pDevObject->hNodeMgr) {
-			NODE_DeleteMgr(pDevObject->hNodeMgr);
-			pDevObject->hNodeMgr = NULL;
+		if (dev_obj->hnode_mgr) {
+			node_delete_mgr(dev_obj->hnode_mgr);
+			dev_obj->hnode_mgr = NULL;
 		}
 
 		/* Free the io, channel, and message managers for this board: */
-		if (pDevObject->hIOMgr) {
-			IO_Destroy(pDevObject->hIOMgr);
-			pDevObject->hIOMgr = NULL;
+		if (dev_obj->hio_mgr) {
+			io_destroy(dev_obj->hio_mgr);
+			dev_obj->hio_mgr = NULL;
 		}
-		if (pDevObject->hChnlMgr) {
-			CHNL_Destroy(pDevObject->hChnlMgr);
-			pDevObject->hChnlMgr = NULL;
+		if (dev_obj->hchnl_mgr) {
+			chnl_destroy(dev_obj->hchnl_mgr);
+			dev_obj->hchnl_mgr = NULL;
 		}
-		if (pDevObject->hMsgMgr) {
-			MSG_Delete(pDevObject->hMsgMgr);
-			pDevObject->hMsgMgr = NULL;
+		if (dev_obj->hmsg_mgr) {
+			msg_delete(dev_obj->hmsg_mgr);
+			dev_obj->hmsg_mgr = NULL;
 		}
 
-		if (pDevObject->hDehMgr) {
+		if (dev_obj->hdeh_mgr) {
 			/* Uninitialize DEH module. */
-			(*pDevObject->intfFxns.pfnDehDestroy)
-			(pDevObject->hDehMgr);
-			pDevObject->hDehMgr = NULL;
+			(*dev_obj->wmd_interface.pfn_deh_destroy)
+			    (dev_obj->hdeh_mgr);
+			dev_obj->hdeh_mgr = NULL;
 		}
-		if (pDevObject->hCmmMgr) {
-			CMM_Destroy(pDevObject->hCmmMgr, true);
-			pDevObject->hCmmMgr = NULL;
+		if (dev_obj->hcmm_mgr) {
+			cmm_destroy(dev_obj->hcmm_mgr, true);
+			dev_obj->hcmm_mgr = NULL;
 		}
 
-		if (pDevObject->hDmmMgr) {
-			DMM_Destroy(pDevObject->hDmmMgr);
-			pDevObject->hDmmMgr = NULL;
+		if (dev_obj->dmm_mgr) {
+			dmm_destroy(dev_obj->dmm_mgr);
+			dev_obj->dmm_mgr = NULL;
 		}
 
-		/* Call the driver's WMD_DEV_Destroy() function: */
+		/* Call the driver's bridge_dev_destroy() function: */
 		/* Require of DevDestroy */
-		if (pDevObject->hWmdContext) {
-			status = (*pDevObject->intfFxns.pfnDevDestroy)
-				(pDevObject->hWmdContext);
-			pDevObject->hWmdContext = NULL;
+		if (dev_obj->hwmd_context) {
+			status = (*dev_obj->wmd_interface.pfn_dev_destroy)
+			    (dev_obj->hwmd_context);
+			dev_obj->hwmd_context = NULL;
 		} else
 			status = DSP_EFAIL;
 		if (DSP_SUCCEEDED(status)) {
-			kfree(pDevObject->procList);
-			pDevObject->procList = NULL;
+			kfree(dev_obj->proc_list);
+			dev_obj->proc_list = NULL;
 
 			/* Remove this DEV_Object from the global list: */
-			DRV_RemoveDevObject(pDevObject->hDrvObject, pDevObject);
+			drv_remove_dev_object(dev_obj->hdrv_obj, dev_obj);
 			/* Free The library * LDR_FreeModule
-			 * (pDevObject->hModule);*/
+			 * (dev_obj->module_obj); */
 			/* Free this dev object: */
-			MEM_FreeObject(pDevObject);
-			pDevObject = NULL;
+			MEM_FREE_OBJECT(dev_obj);
+			dev_obj = NULL;
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -410,125 +412,125 @@ DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT *hDevObject)
 }
 
 /*
- *  ======== DEV_GetChnlMgr ========
+ *  ======== dev_get_chnl_mgr ========
  *  Purpose:
  *      Retrieve the handle to the channel manager handle created for this
  *      device.
  */
-DSP_STATUS DEV_GetChnlMgr(struct DEV_OBJECT *hDevObject,
-			 OUT struct CHNL_MGR **phMgr)
+dsp_status dev_get_chnl_mgr(struct dev_object *hdev_obj,
+			    OUT struct chnl_mgr **phMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMgr != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		*phMgr = pDevObject->hChnlMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phMgr = dev_obj->hchnl_mgr;
 	} else {
 		*phMgr = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-		  (*phMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+					     (*phMgr == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetCmmMgr ========
+ *  ======== dev_get_cmm_mgr ========
  *  Purpose:
  *      Retrieve the handle to the shared memory manager created for this
  *      device.
  */
-DSP_STATUS DEV_GetCmmMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct CMM_OBJECT **phMgr)
+dsp_status dev_get_cmm_mgr(struct dev_object *hdev_obj,
+			   OUT struct cmm_object **phMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMgr != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		*phMgr = pDevObject->hCmmMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phMgr = dev_obj->hcmm_mgr;
 	} else {
 		*phMgr = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-		  (*phMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+					     (*phMgr == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetDmmMgr ========
+ *  ======== dev_get_dmm_mgr ========
  *  Purpose:
  *      Retrieve the handle to the dynamic memory manager created for this
  *      device.
  */
-DSP_STATUS DEV_GetDmmMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct DMM_OBJECT **phMgr)
+dsp_status dev_get_dmm_mgr(struct dev_object *hdev_obj,
+			   OUT struct dmm_object **phMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMgr != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		*phMgr = pDevObject->hDmmMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phMgr = dev_obj->dmm_mgr;
 	} else {
 		*phMgr = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-		  (*phMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+					     (*phMgr == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetCodMgr ========
+ *  ======== dev_get_cod_mgr ========
  *  Purpose:
  *      Retrieve the COD manager create for this device.
  */
-DSP_STATUS DEV_GetCodMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct COD_MANAGER **phCodMgr)
+dsp_status dev_get_cod_mgr(struct dev_object *hdev_obj,
+			   OUT struct cod_manager **phCodMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phCodMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phCodMgr != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		*phCodMgr = pDevObject->hCodMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phCodMgr = dev_obj->cod_mgr;
 	} else {
 		*phCodMgr = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phCodMgr != NULL) &&
-		  (*phCodMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phCodMgr != NULL) &&
+					     (*phCodMgr == NULL)));
 	return status;
 }
 
 /*
- *  ========= DEV_GetDehMgr ========
+ *  ========= dev_get_deh_mgr ========
  */
-DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct DEH_MGR **phDehMgr)
+dsp_status dev_get_deh_mgr(struct dev_object *hdev_obj,
+			   OUT struct deh_mgr **phDehMgr)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDehMgr != NULL);
-	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
-	if (IsValidHandle(hDevObject)) {
-		*phDehMgr = hDevObject->hDehMgr;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDehMgr != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hdev_obj, SIGNATURE));
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phDehMgr = hdev_obj->hdeh_mgr;
 	} else {
 		*phDehMgr = NULL;
 		status = DSP_EHANDLE;
@@ -537,89 +539,89 @@ DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
 }
 
 /*
- *  ======== DEV_GetDevNode ========
+ *  ======== dev_get_dev_node ========
  *  Purpose:
  *      Retrieve the platform specific device ID for this device.
  */
-DSP_STATUS DEV_GetDevNode(struct DEV_OBJECT *hDevObject,
-			 OUT struct CFG_DEVNODE **phDevNode)
+dsp_status dev_get_dev_node(struct dev_object *hdev_obj,
+			    OUT struct cfg_devnode **phDevNode)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDevNode != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDevNode != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		*phDevNode = pDevObject->hDevNode;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phDevNode = dev_obj->dev_node_obj;
 	} else {
 		*phDevNode = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phDevNode != NULL) &&
-		  (*phDevNode == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phDevNode != NULL) &&
+					     (*phDevNode == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetFirst ========
+ *  ======== dev_get_first ========
  *  Purpose:
  *      Retrieve the first Device Object handle from an internal linked list
  *      DEV_OBJECTs maintained by DEV.
  */
-struct DEV_OBJECT *DEV_GetFirst(void)
+struct dev_object *dev_get_first(void)
 {
-	struct DEV_OBJECT *pDevObject = NULL;
+	struct dev_object *dev_obj = NULL;
 
-	pDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
+	dev_obj = (struct dev_object *)drv_get_first_dev_object();
 
-	DBC_Ensure((pDevObject == NULL) || IsValidHandle(pDevObject));
+	DBC_ENSURE((dev_obj == NULL) || IS_VALID_HANDLE(dev_obj));
 
-	return pDevObject;
+	return dev_obj;
 }
 
 /*
- *  ======== DEV_GetIntfFxns ========
+ *  ======== dev_get_intf_fxns ========
  *  Purpose:
  *      Retrieve the WMD interface function structure for the loaded WMD.
  *      ppIntfFxns != NULL.
  */
-DSP_STATUS DEV_GetIntfFxns(struct DEV_OBJECT *hDevObject,
-			  OUT struct WMD_DRV_INTERFACE **ppIntfFxns)
+dsp_status dev_get_intf_fxns(struct dev_object *hdev_obj,
+			     OUT struct bridge_drv_interface **ppIntfFxns)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(ppIntfFxns != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ppIntfFxns != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		*ppIntfFxns = &pDevObject->intfFxns;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*ppIntfFxns = &dev_obj->wmd_interface;
 	} else {
 		*ppIntfFxns = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((ppIntfFxns != NULL) &&
-		  (*ppIntfFxns == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((ppIntfFxns != NULL) &&
+					     (*ppIntfFxns == NULL)));
 	return status;
 }
 
 /*
- *  ========= DEV_GetIOMgr ========
+ *  ========= dev_get_io_mgr ========
  */
-DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct IO_MGR **phIOMgr)
+dsp_status dev_get_io_mgr(struct dev_object *hdev_obj,
+			  OUT struct io_mgr **phIOMgr)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phIOMgr != NULL);
-	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phIOMgr != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hdev_obj, SIGNATURE));
 
-	if (IsValidHandle(hDevObject)) {
-		*phIOMgr = hDevObject->hIOMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phIOMgr = hdev_obj->hio_mgr;
 	} else {
 		*phIOMgr = NULL;
 		status = DSP_EHANDLE;
@@ -629,80 +631,80 @@ DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
 }
 
 /*
- *  ======== DEV_GetNext ========
+ *  ======== dev_get_next ========
  *  Purpose:
  *      Retrieve the next Device Object handle from an internal linked list
  *      of DEV_OBJECTs maintained by DEV, after having previously called
- *      DEV_GetFirst() and zero or more DEV_GetNext
+ *      dev_get_first() and zero or more dev_get_next
  */
-struct DEV_OBJECT *DEV_GetNext(struct DEV_OBJECT *hDevObject)
+struct dev_object *dev_get_next(struct dev_object *hdev_obj)
 {
-	struct DEV_OBJECT *pNextDevObject = NULL;
+	struct dev_object *next_dev_object = NULL;
 
-	if (IsValidHandle(hDevObject)) {
-		pNextDevObject = (struct DEV_OBJECT *)
-				 DRV_GetNextDevObject((u32)hDevObject);
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		next_dev_object = (struct dev_object *)
+		    drv_get_next_dev_object((u32) hdev_obj);
 	}
-	DBC_Ensure((pNextDevObject == NULL) || IsValidHandle(pNextDevObject));
-	return pNextDevObject;
+	DBC_ENSURE((next_dev_object == NULL)
+		   || IS_VALID_HANDLE(next_dev_object));
+	return next_dev_object;
 }
 
 /*
- *  ========= DEV_GetMsgMgr ========
+ *  ========= dev_get_msg_mgr ========
  */
-void DEV_GetMsgMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct MSG_MGR **phMsgMgr)
+void dev_get_msg_mgr(struct dev_object *hdev_obj, OUT struct msg_mgr **phMsgMgr)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMsgMgr != NULL);
-	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMsgMgr != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hdev_obj, SIGNATURE));
 
-	*phMsgMgr = hDevObject->hMsgMgr;
+	*phMsgMgr = hdev_obj->hmsg_mgr;
 }
 
 /*
- *  ======== DEV_GetNodeManager ========
+ *  ======== dev_get_node_manager ========
  *  Purpose:
  *      Retrieve the Node Manager Handle
  */
-DSP_STATUS DEV_GetNodeManager(struct DEV_OBJECT *hDevObject,
-				   OUT struct NODE_MGR **phNodeMgr)
+dsp_status dev_get_node_manager(struct dev_object *hdev_obj,
+				OUT struct node_mgr **phNodeMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phNodeMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phNodeMgr != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		*phNodeMgr = pDevObject->hNodeMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phNodeMgr = dev_obj->hnode_mgr;
 	} else {
 		*phNodeMgr = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phNodeMgr != NULL) &&
-		  (*phNodeMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phNodeMgr != NULL) &&
+					     (*phNodeMgr == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetSymbol ========
+ *  ======== dev_get_symbol ========
  */
-DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
-			      IN CONST char *pstrSym, OUT u32 *pulValue)
+dsp_status dev_get_symbol(struct dev_object *hdev_obj,
+			  IN CONST char *pstrSym, OUT u32 * pul_value)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct COD_MANAGER *hCodMgr;
+	dsp_status status = DSP_SOK;
+	struct cod_manager *cod_mgr;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pstrSym != NULL && pulValue != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pstrSym != NULL && pul_value != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		DEV_GetCodMgr(hDevObject, &hCodMgr);
-		if (hCodMgr)
-			status = COD_GetSymValue(hCodMgr, (char *)pstrSym,
-							pulValue);
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		dev_get_cod_mgr(hdev_obj, &cod_mgr);
+		if (cod_mgr)
+			status = cod_get_sym_value(cod_mgr, (char *)pstrSym,
+							pul_value);
 		else
 			status = DSP_EHANDLE;
 	} else {
@@ -713,216 +715,219 @@ DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
 }
 
 /*
- *  ======== DEV_GetWMDContext ========
+ *  ======== dev_get_wmd_context ========
  *  Purpose:
  *      Retrieve the WMD Context handle, as returned by the WMD_Create fxn.
  */
-DSP_STATUS DEV_GetWMDContext(struct DEV_OBJECT *hDevObject,
-			    OUT struct WMD_DEV_CONTEXT **phWmdContext)
+dsp_status dev_get_wmd_context(struct dev_object *hdev_obj,
+			       OUT struct wmd_dev_context **phWmdContext)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phWmdContext != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phWmdContext != NULL);
 
-	if (IsValidHandle(hDevObject)) {
-		*phWmdContext = pDevObject->hWmdContext;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phWmdContext = dev_obj->hwmd_context;
 	} else {
 		*phWmdContext = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phWmdContext != NULL) &&
-		  (*phWmdContext == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phWmdContext != NULL) &&
+					     (*phWmdContext == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_Exit ========
+ *  ======== dev_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
  */
-void DEV_Exit(void)
+void dev_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	if (cRefs == 0) {
-		CMM_Exit();
-		DMM_Exit();
+	if (refs == 0) {
+		cmm_exit();
+		dmm_exit();
 	}
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== DEV_Init ========
+ *  ======== dev_init ========
  *  Purpose:
  *      Initialize DEV's private state, keeping a reference count on each call.
  */
-bool DEV_Init(void)
+bool dev_init(void)
 {
-	bool fCmm, fDmm, fRetval = true;
+	bool cmm_ret, dmm_ret, ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0) {
-		fCmm = CMM_Init();
-		fDmm = DMM_Init();
+	if (refs == 0) {
+		cmm_ret = cmm_init();
+		dmm_ret = dmm_init();
 
-		fRetval = fCmm && fDmm;
+		ret = cmm_ret && dmm_ret;
 
-		if (!fRetval) {
-			if (fCmm)
-				CMM_Exit();
+		if (!ret) {
+			if (cmm_ret)
+				cmm_exit();
 
-
-			if (fDmm)
-				DMM_Exit();
+			if (dmm_ret)
+				dmm_exit();
 
 		}
 	}
 
-	if (fRetval)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== DEV_NotifyClients ========
+ *  ======== dev_notify_clients ========
  *  Purpose:
  *      Notify all clients of this device of a change in device status.
  */
-DSP_STATUS DEV_NotifyClients(struct DEV_OBJECT *hDevObject, u32 ulStatus)
+dsp_status dev_notify_clients(struct dev_object *hdev_obj, u32 ulStatus)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	struct DEV_OBJECT *pDevObject = hDevObject;
-	void *hProcObject;
+	struct dev_object *dev_obj = hdev_obj;
+	void *proc_obj;
 
-	for (hProcObject = (void *)LST_First(pDevObject->procList);
-		hProcObject != NULL;
-		hProcObject = (void *)LST_Next(pDevObject->procList,
-					(struct list_head *)hProcObject))
-		PROC_NotifyClients(hProcObject, (u32) ulStatus);
+	for (proc_obj = (void *)lst_first(dev_obj->proc_list);
+	     proc_obj != NULL;
+	     proc_obj = (void *)lst_next(dev_obj->proc_list,
+					 (struct list_head *)proc_obj))
+		proc_notify_clients(proc_obj, (u32) ulStatus);
 
 	return status;
 }
 
 /*
- *  ======== DEV_RemoveDevice ========
+ *  ======== dev_remove_device ========
  */
-DSP_STATUS DEV_RemoveDevice(struct CFG_DEVNODE *hDevNode)
+dsp_status dev_remove_device(struct cfg_devnode *dev_node_obj)
 {
-	struct DEV_OBJECT *hDevObject;	/* handle to device object */
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject;
+	struct dev_object *hdev_obj;	/* handle to device object */
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj;
 
 	/* Retrieve the device object handle originaly stored with
-	 * the DevNode: */
-	status = CFG_GetDevObject(hDevNode, (u32 *)&hDevObject);
+	 * the dev_node: */
+	status = cfg_get_dev_object(dev_node_obj, (u32 *) &hdev_obj);
 	if (DSP_SUCCEEDED(status)) {
 		/* Remove the Processor List */
-		pDevObject = (struct DEV_OBJECT *)hDevObject;
+		dev_obj = (struct dev_object *)hdev_obj;
 		/* Destroy the device object. */
-		status = DEV_DestroyDevice(hDevObject);
+		status = dev_destroy_device(hdev_obj);
 	}
 
 	return status;
 }
 
 /*
- *  ======== DEV_SetChnlMgr ========
+ *  ======== dev_set_chnl_mgr ========
  *  Purpose:
  *      Set the channel manager for this device.
  */
-DSP_STATUS DEV_SetChnlMgr(struct DEV_OBJECT *hDevObject, struct CHNL_MGR *hMgr)
+dsp_status dev_set_chnl_mgr(struct dev_object *hdev_obj,
+			    struct chnl_mgr *hmgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (IsValidHandle(hDevObject))
-		pDevObject->hChnlMgr = hMgr;
+	if (IS_VALID_HANDLE(hdev_obj))
+		dev_obj->hchnl_mgr = hmgr;
 	else
 		status = DSP_EHANDLE;
 
-	DBC_Ensure(DSP_FAILED(status) || (pDevObject->hChnlMgr == hMgr));
+	DBC_ENSURE(DSP_FAILED(status) || (dev_obj->hchnl_mgr == hmgr));
 	return status;
 }
 
 /*
- *  ======== DEV_SetMsgMgr ========
+ *  ======== dev_set_msg_mgr ========
  *  Purpose:
  *      Set the message manager for this device.
  */
-void DEV_SetMsgMgr(struct DEV_OBJECT *hDevObject, struct MSG_MGR *hMgr)
+void dev_set_msg_mgr(struct dev_object *hdev_obj, struct msg_mgr *hmgr)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDevObject));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdev_obj));
 
-	hDevObject->hMsgMgr = hMgr;
+	hdev_obj->hmsg_mgr = hmgr;
 }
 
 /*
- *  ======== DEV_StartDevice ========
+ *  ======== dev_start_device ========
  *  Purpose:
  *      Initializes the new device with the BRIDGE environment.
  */
-DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode)
+dsp_status dev_start_device(struct cfg_devnode *dev_node_obj)
 {
-	struct DEV_OBJECT *hDevObject = NULL;	/* handle to 'Bridge Device */
-	struct CFG_HOSTRES hostRes;	/* resources struct. */
-	struct CFG_DSPRES dspRes;	/* DSP resources struct */
-	char szWMDFileName[CFG_MAXSEARCHPATHLEN] = "UMA"; /* wmd filename */
-	DSP_STATUS status;
-	struct MGR_OBJECT *hMgrObject = NULL;
+	struct dev_object *hdev_obj = NULL;	/* handle to 'Bridge Device */
+	struct cfg_hostres host_res;	/* resources struct. */
+	struct cfg_dspres dsp_res;	/* DSP resources struct */
+	/* wmd filename */
+	char sz_wmd_file_name[CFG_MAXSEARCHPATHLEN] = "UMA";
+	dsp_status status;
+	struct mgr_object *hmgr_obj = NULL;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-		status = CFG_GetHostResources(hDevNode, &hostRes);
-		if (DSP_SUCCEEDED(status)) {
-			/* Get DSP resources of device from Registry: */
-			status = CFG_GetDSPResources(hDevNode, &dspRes);
-		}
+	status = cfg_get_host_resources(dev_node_obj, &host_res);
+	if (DSP_SUCCEEDED(status)) {
+		/* Get DSP resources of device from Registry: */
+		status = cfg_get_dsp_resources(dev_node_obj, &dsp_res);
+	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Given all resources, create a device object. */
-		status = DEV_CreateDevice(&hDevObject, szWMDFileName, &hostRes,
-					 &dspRes, hDevNode);
+		status =
+		    dev_create_device(&hdev_obj, sz_wmd_file_name, &host_res,
+				      &dsp_res, dev_node_obj);
 		if (DSP_SUCCEEDED(status)) {
-			/* Store away the hDevObject with the DEVNODE */
-			status = CFG_SetDevObject(hDevNode, (u32)hDevObject);
+			/* Store away the hdev_obj with the DEVNODE */
+			status =
+			    cfg_set_dev_object(dev_node_obj, (u32) hdev_obj);
 			if (DSP_FAILED(status)) {
 				/* Clean up */
-				DEV_DestroyDevice(hDevObject);
-				hDevObject = NULL;
+				dev_destroy_device(hdev_obj);
+				hdev_obj = NULL;
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Create the Manager Object */
-		status = MGR_Create(&hMgrObject, hDevNode);
+		status = mgr_create(&hmgr_obj, dev_node_obj);
 	}
 	if (DSP_FAILED(status)) {
-		if (hDevObject)
-			DEV_DestroyDevice(hDevObject);
+		if (hdev_obj)
+			dev_destroy_device(hdev_obj);
 
 		/* Ensure the device extension is NULL */
-		CFG_SetDevObject(hDevNode, 0L);
+		cfg_set_dev_object(dev_node_obj, 0L);
 	}
 
 	return status;
 }
 
 /*
- *  ======== FxnNotImplemented ========
+ *  ======== fxn_not_implemented ========
  *  Purpose:
  *      Takes the place of a WMD Null Function.
  *  Parameters:
@@ -930,138 +935,135 @@ DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode)
  *  Returns:
  *      DSP_ENOTIMPL:   Always.
  */
-static DSP_STATUS FxnNotImplemented(int arg, ...)
+static dsp_status fxn_not_implemented(int arg, ...)
 {
 	return DSP_ENOTIMPL;
 }
 
 /*
- *  ======== IsValidHandle ========
+ *  ======== IS_VALID_HANDLE ========
  *  Purpose:
  *      Validate the device object handle.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *  Returns:
  *      true if handle is valid; false otherwise.
  *  Requires:
  *  Ensures:
  */
-static bool IsValidHandle(struct DEV_OBJECT *hObj)
+static bool IS_VALID_HANDLE(struct dev_object *hObj)
 {
-	bool retVal;
+	bool ret;
 
-	retVal = (hObj != NULL) && (hObj->dwSignature == SIGNATURE);
+	ret = (hObj != NULL) && (hObj->dw_signature == SIGNATURE);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== InitCodMgr ========
+ *  ======== init_cod_mgr ========
  *  Purpose:
  *      Create a COD manager for this device.
  *  Parameters:
- *      pDevObject:             Pointer to device object created with
- *                              DEV_CreateDevice()
+ *      dev_obj:             Pointer to device object created with
+ *                              dev_create_device()
  *  Returns:
  *      DSP_SOK:                Success.
- *      DSP_EHANDLE:            Invalid hDevObject.
+ *      DSP_EHANDLE:            Invalid hdev_obj.
  *  Requires:
- *      Should only be called once by DEV_CreateDevice() for a given DevObject.
+ *      Should only be called once by dev_create_device() for a given DevObject.
  *  Ensures:
  */
-static DSP_STATUS InitCodMgr(struct DEV_OBJECT *pDevObject)
+static dsp_status init_cod_mgr(struct dev_object *dev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	char *szDummyFile = "dummy";
+	dsp_status status = DSP_SOK;
+	char *sz_dummy_file = "dummy";
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(!IsValidHandle(pDevObject) ||
-		   (pDevObject->hCodMgr == NULL));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(!IS_VALID_HANDLE(dev_obj) || (dev_obj->cod_mgr == NULL));
 
-	status = COD_Create(&pDevObject->hCodMgr, szDummyFile, NULL);
+	status = cod_create(&dev_obj->cod_mgr, sz_dummy_file, NULL);
 
 	return status;
 }
 
 /*
- *  ======== DEV_InsertProcObject ========
+ *  ======== dev_insert_proc_object ========
  *  Purpose:
  *      Insert a ProcObject into the list maintained by DEV.
  *  Parameters:
- *      pProcObject:        Ptr to ProcObject to insert.
- *      pDevObject:         Ptr to Dev Object where the list is.
+ *      p_proc_object:        Ptr to ProcObject to insert.
+ *      dev_obj:         Ptr to Dev Object where the list is.
   *     pbAlreadyAttached:  Ptr to return the bool
  *  Returns:
  *      DSP_SOK:           If successful.
  *  Requires:
  *      List Exists
- *      hDevObject is Valid handle
+ *      hdev_obj is Valid handle
  *      DEV Initialized
  *      pbAlreadyAttached != NULL
- *      hProcObject != 0
+ *      proc_obj != 0
  *  Ensures:
  *      DSP_SOK and List is not Empty.
  */
-DSP_STATUS DEV_InsertProcObject(struct DEV_OBJECT *hDevObject,
-				     u32 hProcObject,
-				     OUT bool *pbAlreadyAttached)
+dsp_status dev_insert_proc_object(struct dev_object *hdev_obj,
+				  u32 proc_obj, OUT bool *pbAlreadyAttached)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hDevObject;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(pDevObject));
-	DBC_Require(hProcObject != 0);
-	DBC_Require(pDevObject->procList != NULL);
-	DBC_Require(pbAlreadyAttached != NULL);
-	if (!LST_IsEmpty(pDevObject->procList))
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = (struct dev_object *)hdev_obj;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(dev_obj));
+	DBC_REQUIRE(proc_obj != 0);
+	DBC_REQUIRE(dev_obj->proc_list != NULL);
+	DBC_REQUIRE(pbAlreadyAttached != NULL);
+	if (!LST_IS_EMPTY(dev_obj->proc_list))
 		*pbAlreadyAttached = true;
 
 	/* Add DevObject to tail. */
-	LST_PutTail(pDevObject->procList, (struct list_head *)hProcObject);
+	lst_put_tail(dev_obj->proc_list, (struct list_head *)proc_obj);
 
-	DBC_Ensure(DSP_SUCCEEDED(status) && !LST_IsEmpty(pDevObject->procList));
+	DBC_ENSURE(DSP_SUCCEEDED(status) && !LST_IS_EMPTY(dev_obj->proc_list));
 
 	return status;
 }
 
 /*
- *  ======== DEV_RemoveProcObject ========
+ *  ======== dev_remove_proc_object ========
  *  Purpose:
  *      Search for and remove a Proc object from the given list maintained
  *      by the DEV
  *  Parameters:
- *      pProcObject:        Ptr to ProcObject to insert.
- *      pDevObject          Ptr to Dev Object where the list is.
+ *      p_proc_object:        Ptr to ProcObject to insert.
+ *      dev_obj          Ptr to Dev Object where the list is.
  *  Returns:
  *      DSP_SOK:            If successful.
  *  Requires:
  *      List exists and is not empty
- *      hProcObject != 0
- *      hDevObject is a valid Dev handle.
+ *      proc_obj != 0
+ *      hdev_obj is a valid Dev handle.
  *  Ensures:
  *  Details:
  *      List will be deleted when the DEV is destroyed.
  */
-DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT *hDevObject,
-				     u32 hProcObject)
+dsp_status dev_remove_proc_object(struct dev_object *hdev_obj, u32 proc_obj)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct list_head *pCurElem;
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hDevObject;
-
-	DBC_Require(IsValidHandle(pDevObject));
-	DBC_Require(hProcObject != 0);
-	DBC_Require(pDevObject->procList != NULL);
-	DBC_Require(!LST_IsEmpty(pDevObject->procList));
-
-	/* Search list for pDevObject: */
-	for (pCurElem = LST_First(pDevObject->procList); pCurElem != NULL;
-	    pCurElem = LST_Next(pDevObject->procList, pCurElem)) {
+	dsp_status status = DSP_EFAIL;
+	struct list_head *cur_elem;
+	struct dev_object *dev_obj = (struct dev_object *)hdev_obj;
+
+	DBC_REQUIRE(IS_VALID_HANDLE(dev_obj));
+	DBC_REQUIRE(proc_obj != 0);
+	DBC_REQUIRE(dev_obj->proc_list != NULL);
+	DBC_REQUIRE(!LST_IS_EMPTY(dev_obj->proc_list));
+
+	/* Search list for dev_obj: */
+	for (cur_elem = lst_first(dev_obj->proc_list); cur_elem != NULL;
+	     cur_elem = lst_next(dev_obj->proc_list, cur_elem)) {
 		/* If found, remove it. */
-		if ((u32)pCurElem == hProcObject) {
-			LST_RemoveElem(pDevObject->procList, pCurElem);
+		if ((u32) cur_elem == proc_obj) {
+			lst_remove_elem(dev_obj->proc_list, cur_elem);
 			status = DSP_SOK;
 			break;
 		}
@@ -1070,134 +1072,133 @@ DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT *hDevObject,
 	return status;
 }
 
-DSP_STATUS DEV_GetDevType(struct DEV_OBJECT *hdevObject, u32 *devType)
+dsp_status dev_get_dev_type(struct dev_object *hdevObject, u32 *dev_type)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hdevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = (struct dev_object *)hdevObject;
 
-	*devType = pDevObject->devType;
+	*dev_type = dev_obj->dev_type;
 
 	return status;
 }
 
 /*
- *  ======== StoreInterfaceFxns ========
+ *  ======== store_interface_fxns ========
  *  Purpose:
  *      Copy the WMD's interface functions into the device object,
- *      ensuring that FxnNotImplemented() is set for:
+ *      ensuring that fxn_not_implemented() is set for:
  *
  *      1. All WMD function pointers which are NULL; and
- *      2. All function slots in the struct DEV_OBJECT structure which have no
+ *      2. All function slots in the struct dev_object structure which have no
  *         corresponding slots in the the WMD's interface, because the WMD
  *         is of an *older* version.
  *  Parameters:
- *      pIntfFxns:      Interface Fxn Structure of the WCD's Dev Object.
- *      pDrvFxns:       Interface Fxns offered by the WMD during DEV_Create().
+ *      intf_fxns:      Interface fxn Structure of the WCD's Dev Object.
+ *      drv_fxns:       Interface Fxns offered by the WMD during DEV_Create().
  *  Returns:
  *  Requires:
  *      Input pointers are valid.
  *      WMD is *not* written for a newer WCD.
  *  Ensures:
- *      All function pointers in the dev object's Fxn interface are not NULL.
+ *      All function pointers in the dev object's fxn interface are not NULL.
  */
-static void StoreInterfaceFxns(struct WMD_DRV_INTERFACE *pDrvFxns,
-			      OUT struct WMD_DRV_INTERFACE *pIntfFxns)
+static void store_interface_fxns(struct bridge_drv_interface *drv_fxns,
+				 OUT struct bridge_drv_interface *intf_fxns)
 {
-	u32 dwWMDVersion;
+	u32 dw_wmd_version;
 
 	/* Local helper macro: */
-#define  StoreFxn(cast, pfn) \
-    (pIntfFxns->pfn = ((pDrvFxns->pfn != NULL) ? pDrvFxns->pfn : \
-    (cast)FxnNotImplemented))
-
-	DBC_Require(pIntfFxns != NULL);
-	DBC_Require(pDrvFxns != NULL);
-	DBC_Require(MAKEVERSION(pDrvFxns->dwWCDMajorVersion,
-		   pDrvFxns->dwWCDMinorVersion) <= WCDVERSION);
-	dwWMDVersion = MAKEVERSION(pDrvFxns->dwWCDMajorVersion,
-				  pDrvFxns->dwWCDMinorVersion);
-	pIntfFxns->dwWCDMajorVersion = pDrvFxns->dwWCDMajorVersion;
-	pIntfFxns->dwWCDMinorVersion = pDrvFxns->dwWCDMinorVersion;
+#define  STORE_FXN(cast, pfn) \
+    (intf_fxns->pfn = ((drv_fxns->pfn != NULL) ? drv_fxns->pfn : \
+    (cast)fxn_not_implemented))
+
+	DBC_REQUIRE(intf_fxns != NULL);
+	DBC_REQUIRE(drv_fxns != NULL);
+	DBC_REQUIRE(MAKEVERSION(drv_fxns->dw_wcd_major_version,
+				drv_fxns->dw_wcd_minor_version) <= WCDVERSION);
+	dw_wmd_version = MAKEVERSION(drv_fxns->dw_wcd_major_version,
+				     drv_fxns->dw_wcd_minor_version);
+	intf_fxns->dw_wcd_major_version = drv_fxns->dw_wcd_major_version;
+	intf_fxns->dw_wcd_minor_version = drv_fxns->dw_wcd_minor_version;
 	/* Install functions up to WCD version .80 (first alpha): */
-	if (dwWMDVersion > 0) {
-		StoreFxn(WMD_DEV_CREATE, pfnDevCreate);
-		StoreFxn(WMD_DEV_DESTROY, pfnDevDestroy);
-		StoreFxn(WMD_DEV_CTRL, pfnDevCntrl);
-		StoreFxn(WMD_BRD_MONITOR, pfnBrdMonitor);
-		StoreFxn(WMD_BRD_START, pfnBrdStart);
-		StoreFxn(WMD_BRD_STOP, pfnBrdStop);
-		StoreFxn(WMD_BRD_STATUS, pfnBrdStatus);
-		StoreFxn(WMD_BRD_READ, pfnBrdRead);
-		StoreFxn(WMD_BRD_WRITE, pfnBrdWrite);
-		StoreFxn(WMD_BRD_SETSTATE, pfnBrdSetState);
-		StoreFxn(WMD_BRD_MEMCOPY, pfnBrdMemCopy);
-		StoreFxn(WMD_BRD_MEMWRITE, pfnBrdMemWrite);
-		StoreFxn(WMD_BRD_MEMMAP, pfnBrdMemMap);
-		StoreFxn(WMD_BRD_MEMUNMAP, pfnBrdMemUnMap);
-		StoreFxn(WMD_CHNL_CREATE, pfnChnlCreate);
-		StoreFxn(WMD_CHNL_DESTROY, pfnChnlDestroy);
-		StoreFxn(WMD_CHNL_OPEN, pfnChnlOpen);
-		StoreFxn(WMD_CHNL_CLOSE, pfnChnlClose);
-		StoreFxn(WMD_CHNL_ADDIOREQ, pfnChnlAddIOReq);
-		StoreFxn(WMD_CHNL_GETIOC, pfnChnlGetIOC);
-		StoreFxn(WMD_CHNL_CANCELIO, pfnChnlCancelIO);
-		StoreFxn(WMD_CHNL_FLUSHIO, pfnChnlFlushIO);
-		StoreFxn(WMD_CHNL_GETINFO, pfnChnlGetInfo);
-		StoreFxn(WMD_CHNL_GETMGRINFO, pfnChnlGetMgrInfo);
-		StoreFxn(WMD_CHNL_IDLE, pfnChnlIdle);
-		StoreFxn(WMD_CHNL_REGISTERNOTIFY, pfnChnlRegisterNotify);
-		StoreFxn(WMD_DEH_CREATE, pfnDehCreate);
-		StoreFxn(WMD_DEH_DESTROY, pfnDehDestroy);
-		StoreFxn(WMD_DEH_NOTIFY, pfnDehNotify);
-		StoreFxn(WMD_DEH_REGISTERNOTIFY, pfnDehRegisterNotify);
-		StoreFxn(WMD_DEH_GETINFO, pfnDehGetInfo);
-		StoreFxn(WMD_IO_CREATE, pfnIOCreate);
-		StoreFxn(WMD_IO_DESTROY, pfnIODestroy);
-		StoreFxn(WMD_IO_ONLOADED, pfnIOOnLoaded);
-		StoreFxn(WMD_IO_GETPROCLOAD, pfnIOGetProcLoad);
-		StoreFxn(WMD_MSG_CREATE, pfnMsgCreate);
-		StoreFxn(WMD_MSG_CREATEQUEUE, pfnMsgCreateQueue);
-		StoreFxn(WMD_MSG_DELETE, pfnMsgDelete);
-		StoreFxn(WMD_MSG_DELETEQUEUE, pfnMsgDeleteQueue);
-		StoreFxn(WMD_MSG_GET, pfnMsgGet);
-		StoreFxn(WMD_MSG_PUT, pfnMsgPut);
-		StoreFxn(WMD_MSG_REGISTERNOTIFY, pfnMsgRegisterNotify);
-		StoreFxn(WMD_MSG_SETQUEUEID, pfnMsgSetQueueId);
+	if (dw_wmd_version > 0) {
+		STORE_FXN(fxn_dev_create, pfn_dev_create);
+		STORE_FXN(fxn_dev_destroy, pfn_dev_destroy);
+		STORE_FXN(fxn_dev_ctrl, pfn_dev_cntrl);
+		STORE_FXN(fxn_brd_monitor, pfn_brd_monitor);
+		STORE_FXN(fxn_brd_start, pfn_brd_start);
+		STORE_FXN(fxn_brd_stop, pfn_brd_stop);
+		STORE_FXN(fxn_brd_status, pfn_brd_status);
+		STORE_FXN(fxn_brd_read, pfn_brd_read);
+		STORE_FXN(fxn_brd_write, pfn_brd_write);
+		STORE_FXN(fxn_brd_setstate, pfn_brd_set_state);
+		STORE_FXN(fxn_brd_memcopy, pfn_brd_mem_copy);
+		STORE_FXN(fxn_brd_memwrite, pfn_brd_mem_write);
+		STORE_FXN(fxn_brd_memmap, pfn_brd_mem_map);
+		STORE_FXN(fxn_brd_memunmap, pfn_brd_mem_un_map);
+		STORE_FXN(fxn_chnl_create, pfn_chnl_create);
+		STORE_FXN(fxn_chnl_destroy, pfn_chnl_destroy);
+		STORE_FXN(fxn_chnl_open, pfn_chnl_open);
+		STORE_FXN(fxn_chnl_close, pfn_chnl_close);
+		STORE_FXN(fxn_chnl_addioreq, pfn_chnl_add_io_req);
+		STORE_FXN(fxn_chnl_getioc, pfn_chnl_get_ioc);
+		STORE_FXN(fxn_chnl_cancelio, pfn_chnl_cancel_io);
+		STORE_FXN(fxn_chnl_flushio, pfn_chnl_flush_io);
+		STORE_FXN(fxn_chnl_getinfo, pfn_chnl_get_info);
+		STORE_FXN(fxn_chnl_getmgrinfo, pfn_chnl_get_mgr_info);
+		STORE_FXN(fxn_chnl_idle, pfn_chnl_idle);
+		STORE_FXN(fxn_chnl_registernotify, pfn_chnl_register_notify);
+		STORE_FXN(fxn_deh_create, pfn_deh_create);
+		STORE_FXN(fxn_deh_destroy, pfn_deh_destroy);
+		STORE_FXN(fxn_deh_notify, pfn_deh_notify);
+		STORE_FXN(fxn_deh_registernotify, pfn_deh_register_notify);
+		STORE_FXN(fxn_deh_getinfo, pfn_deh_get_info);
+		STORE_FXN(fxn_io_create, pfn_io_create);
+		STORE_FXN(fxn_io_destroy, pfn_io_destroy);
+		STORE_FXN(fxn_io_onloaded, pfn_io_on_loaded);
+		STORE_FXN(fxn_io_getprocload, pfn_io_get_proc_load);
+		STORE_FXN(fxn_msg_create, pfn_msg_create);
+		STORE_FXN(fxn_msg_createqueue, pfn_msg_create_queue);
+		STORE_FXN(fxn_msg_delete, pfn_msg_delete);
+		STORE_FXN(fxn_msg_deletequeue, pfn_msg_delete_queue);
+		STORE_FXN(fxn_msg_get, pfn_msg_get);
+		STORE_FXN(fxn_msg_put, pfn_msg_put);
+		STORE_FXN(fxn_msg_registernotify, pfn_msg_register_notify);
+		STORE_FXN(fxn_msg_setqueueid, pfn_msg_set_queue_id);
 	}
 	/* Add code for any additional functions in newer WMD versions here: */
 	/* Ensure postcondition: */
-	DBC_Ensure(pIntfFxns->pfnDevCreate != NULL);
-	DBC_Ensure(pIntfFxns->pfnDevDestroy != NULL);
-	DBC_Ensure(pIntfFxns->pfnDevCntrl != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdMonitor != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdStart != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdStop != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdStatus != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdRead != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdWrite != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlCreate != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlDestroy != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlOpen != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlClose != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlAddIOReq != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlGetIOC != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlCancelIO != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlFlushIO != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlGetInfo != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlGetMgrInfo != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlIdle != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlRegisterNotify != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehCreate != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehDestroy != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehNotify != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehRegisterNotify != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehGetInfo != NULL);
-	DBC_Ensure(pIntfFxns->pfnIOCreate != NULL);
-	DBC_Ensure(pIntfFxns->pfnIODestroy != NULL);
-	DBC_Ensure(pIntfFxns->pfnIOOnLoaded != NULL);
-	DBC_Ensure(pIntfFxns->pfnIOGetProcLoad != NULL);
-	DBC_Ensure(pIntfFxns->pfnMsgSetQueueId != NULL);
-
-#undef  StoreFxn
+	DBC_ENSURE(intf_fxns->pfn_dev_create != NULL);
+	DBC_ENSURE(intf_fxns->pfn_dev_destroy != NULL);
+	DBC_ENSURE(intf_fxns->pfn_dev_cntrl != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_monitor != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_start != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_stop != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_status != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_read != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_write != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_create != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_destroy != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_open != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_close != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_add_io_req != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_get_ioc != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_cancel_io != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_flush_io != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_get_info != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_get_mgr_info != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_idle != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_register_notify != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_create != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_destroy != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_notify != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_register_notify != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_get_info != NULL);
+	DBC_ENSURE(intf_fxns->pfn_io_create != NULL);
+	DBC_ENSURE(intf_fxns->pfn_io_destroy != NULL);
+	DBC_ENSURE(intf_fxns->pfn_io_on_loaded != NULL);
+	DBC_ENSURE(intf_fxns->pfn_io_get_proc_load != NULL);
+	DBC_ENSURE(intf_fxns->pfn_msg_set_queue_id != NULL);
+
+#undef  STORE_FXN
 }
-
diff --git a/drivers/dsp/bridge/pmgr/dmm.c b/drivers/dsp/bridge/pmgr/dmm.c
index 53c6b11..80a944e 100644
--- a/drivers/dsp/bridge/pmgr/dmm.c
+++ b/drivers/dsp/bridge/pmgr/dmm.c
@@ -48,73 +48,70 @@
 #define DMMSIGNATURE       0x004d4d44	/* "DMM"   (in reverse) */
 
 #define DMM_ADDR_VIRTUAL(a) \
-	(((struct MapPage *)(a) - pVirtualMappingTable) * PG_SIZE_4K +\
-	dynMemMapBeg)
-#define DMM_ADDR_TO_INDEX(a) (((a) - dynMemMapBeg) / PG_SIZE_4K)
+	(((struct map_page *)(a) - virtual_mapping_table) * PG_SIZE4K +\
+	dyn_mem_map_beg)
+#define DMM_ADDR_TO_INDEX(a) (((a) - dyn_mem_map_beg) / PG_SIZE4K)
 
 /* DMM Mgr */
-struct DMM_OBJECT {
-	u32 dwSignature;	/* Used for object validation */
+struct dmm_object {
+	u32 dw_signature;	/* Used for object validation */
 	/* Dmm Lock is used to serialize access mem manager for
 	 * multi-threads. */
-	struct SYNC_CSOBJECT *hDmmLock;	/* Lock to access dmm mgr */
+	spinlock_t dmm_lock;	/* Lock to access dmm mgr */
 };
 
-
 /*  ----------------------------------- Globals */
-static u32 cRefs;		/* module reference count */
-struct MapPage {
-	u32   RegionSize:15;
-	u32   MappedSize:15;
-	u32   bReserved:1;
-	u32   bMapped:1;
+static u32 refs;		/* module reference count */
+struct map_page {
+	u32 region_size:31;
+	u32 reserved:1;
+	u32 mapped_size:31;
+	u32 mapped:1;
 };
 
 /*  Create the free list */
-static struct MapPage *pVirtualMappingTable;
-static u32  iFreeRegion;	/* The index of free region */
-static u32  iFreeSize;
-static u32  dynMemMapBeg;	/* The Beginning of dynamic memory mapping */
-static u32  TableSize;/* The size of virtual and physical pages tables */
+static struct map_page *virtual_mapping_table;
+static u32 free_region;		/* The index of free region */
+static u32 free_size;
+static u32 dyn_mem_map_beg;	/* The Beginning of dynamic memory mapping */
+static u32 table_size;		/* The size of virt and phys pages tables */
 
 /*  ----------------------------------- Function Prototypes */
-static struct MapPage *GetRegion(u32 addr);
-static struct MapPage *GetFreeRegion(u32 aSize);
-static struct MapPage *GetMappedRegion(u32 aAddr);
+static struct map_page *get_region(u32 addr);
+static struct map_page *get_free_region(u32 aSize);
+static struct map_page *get_mapped_region(u32 aAddr);
 #ifdef DSP_DMM_DEBUG
-u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr);
+u32 dmm_mem_map_dump(struct dmm_object *dmm_mgr);
 #endif
 
-/*  ======== DMM_CreateTables ========
+/*  ======== dmm_create_tables ========
  *  Purpose:
  *      Create table to hold the information of physical address
  *      the buffer pages that is passed by the user, and the table
  *      to hold the information of the virtual memory that is reserved
  *      for DSP.
  */
-DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 size)
+dsp_status dmm_create_tables(struct dmm_object *dmm_mgr, u32 addr, u32 size)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	dsp_status status = DSP_SOK;
 
-	status = DMM_DeleteTables(pDmmObj);
+	status = dmm_delete_tables(dmm_obj);
 	if (DSP_SUCCEEDED(status)) {
-		SYNC_EnterCS(pDmmObj->hDmmLock);
-		dynMemMapBeg = addr;
-		TableSize = PG_ALIGN_HIGH(size, PG_SIZE_4K)/PG_SIZE_4K;
+		dyn_mem_map_beg = addr;
+		table_size = PG_ALIGN_HIGH(size, PG_SIZE4K) / PG_SIZE4K;
 		/*  Create the free list */
-		pVirtualMappingTable = (struct MapPage *) MEM_Calloc
-			(TableSize * sizeof(struct MapPage), MEM_LARGEVIRTMEM);
-		if (pVirtualMappingTable == NULL)
+		virtual_mapping_table = (struct map_page *)mem_calloc
+		    (table_size * sizeof(struct map_page), MEM_LARGEVIRTMEM);
+		if (virtual_mapping_table == NULL)
 			status = DSP_EMEMORY;
 		else {
 			/* On successful allocation,
-			* all entries are zero ('free') */
-			iFreeRegion = 0;
-			iFreeSize = TableSize*PG_SIZE_4K;
-			pVirtualMappingTable[0].RegionSize = TableSize;
+			 * all entries are zero ('free') */
+			free_region = 0;
+			free_size = table_size * PG_SIZE4K;
+			virtual_mapping_table[0].region_size = table_size;
 		}
-		SYNC_LeaveCS(pDmmObj->hDmmLock);
 	}
 
 	if (DSP_FAILED(status))
@@ -124,28 +121,25 @@ DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 size)
 }
 
 /*
- *  ======== DMM_Create ========
+ *  ======== dmm_create ========
  *  Purpose:
  *      Create a dynamic memory manager object.
  */
-DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
-		     struct DEV_OBJECT *hDevObject,
-		     IN CONST struct DMM_MGRATTRS *pMgrAttrs)
+dsp_status dmm_create(OUT struct dmm_object **phDmmMgr,
+		      struct dev_object *hdev_obj,
+		      IN CONST struct dmm_mgrattrs *pMgrAttrs)
 {
-	struct DMM_OBJECT *pDmmObject = NULL;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDmmMgr != NULL);
+	struct dmm_object *dmm_obj = NULL;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDmmMgr != NULL);
 
 	*phDmmMgr = NULL;
 	/* create, zero, and tag a cmm mgr object */
-	MEM_AllocObject(pDmmObject, struct DMM_OBJECT, DMMSIGNATURE);
-	if (pDmmObject != NULL) {
-		status = SYNC_InitializeCS(&pDmmObject->hDmmLock);
-		if (DSP_SUCCEEDED(status))
-			*phDmmMgr = pDmmObject;
-		else
-			DMM_Destroy(pDmmObject);
+	MEM_ALLOC_OBJECT(dmm_obj, struct dmm_object, DMMSIGNATURE);
+	if (dmm_obj != NULL) {
+		spin_lock_init(&dmm_obj->dmm_lock);
+		*phDmmMgr = dmm_obj;
 	} else {
 		status = DSP_EMEMORY;
 	}
@@ -154,90 +148,77 @@ DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
 }
 
 /*
- *  ======== DMM_Destroy ========
+ *  ======== dmm_destroy ========
  *  Purpose:
  *      Release the communication memory manager resources.
  */
-DSP_STATUS DMM_Destroy(struct DMM_OBJECT *hDmmMgr)
+dsp_status dmm_destroy(struct dmm_object *dmm_mgr)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	if (MEM_IsValidHandle(hDmmMgr, DMMSIGNATURE)) {
-		status = DMM_DeleteTables(pDmmObj);
-		if (DSP_SUCCEEDED(status)) {
-			/* Delete CS & dmm mgr object */
-			SYNC_DeleteCS(pDmmObj->hDmmLock);
-			MEM_FreeObject(pDmmObj);
-		}
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	if (MEM_IS_VALID_HANDLE(dmm_mgr, DMMSIGNATURE)) {
+		status = dmm_delete_tables(dmm_obj);
+		if (DSP_SUCCEEDED(status))
+			MEM_FREE_OBJECT(dmm_obj);
 	} else
 		status = DSP_EHANDLE;
 
 	return status;
 }
 
-
 /*
- *  ======== DMM_DeleteTables ========
+ *  ======== dmm_delete_tables ========
  *  Purpose:
  *      Delete DMM Tables.
  */
-DSP_STATUS DMM_DeleteTables(struct DMM_OBJECT *hDmmMgr)
+dsp_status dmm_delete_tables(struct dmm_object *dmm_mgr)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	if (MEM_IsValidHandle(hDmmMgr, DMMSIGNATURE)) {
-		/* Delete all DMM tables */
-		SYNC_EnterCS(pDmmObj->hDmmLock);
+	dsp_status status = DSP_SOK;
 
-		vfree(pVirtualMappingTable);
-
-		SYNC_LeaveCS(pDmmObj->hDmmLock);
-	} else
+	DBC_REQUIRE(refs > 0);
+	/* Delete all DMM tables */
+	if (MEM_IS_VALID_HANDLE(dmm_mgr, DMMSIGNATURE))
+		vfree(virtual_mapping_table);
+	else
 		status = DSP_EHANDLE;
 	return status;
 }
 
-
-
-
 /*
- *  ======== DMM_Exit ========
+ *  ======== dmm_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
  */
-void DMM_Exit(void)
+void dmm_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 }
 
 /*
- *  ======== DMM_GetHandle ========
+ *  ======== dmm_get_handle ========
  *  Purpose:
  *      Return the dynamic memory manager object for this device.
  *      This is typically called from the client process.
  */
-DSP_STATUS DMM_GetHandle(void *hProcessor,
-			OUT struct DMM_OBJECT **phDmmMgr)
+dsp_status dmm_get_handle(void *hprocessor, OUT struct dmm_object **phDmmMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDmmMgr != NULL);
-	if (hProcessor != NULL)
-		status = PROC_GetDevObject(hProcessor, &hDevObject);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDmmMgr != NULL);
+	if (hprocessor != NULL)
+		status = proc_get_dev_object(hprocessor, &hdev_obj);
 	else
-		hDevObject = DEV_GetFirst();	/* default */
+		hdev_obj = dev_get_first();	/* default */
 
 	if (DSP_SUCCEEDED(status))
-		status = DEV_GetDmmMgr(hDevObject, phDmmMgr);
+		status = dev_get_dmm_mgr(hdev_obj, phDmmMgr);
 	else
 		*phDmmMgr = NULL;
 
@@ -245,317 +226,317 @@ DSP_STATUS DMM_GetHandle(void *hProcessor,
 }
 
 /*
- *  ======== DMM_Init ========
+ *  ======== dmm_init ========
  *  Purpose:
  *      Initializes private state of DMM module.
  */
-bool DMM_Init(void)
+bool dmm_init(void)
 {
-	bool fRetval = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (fRetval)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	pVirtualMappingTable = NULL ;
-	TableSize = 0;
+	virtual_mapping_table = NULL;
+	table_size = 0;
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== DMM_MapMemory ========
+ *  ======== dmm_map_memory ========
  *  Purpose:
  *      Add a mapping block to the reserved chunk. DMM assumes that this block
  *  will be mapped in the DSP/IVA's address space. DMM returns an error if a
  *  mapping overlaps another one. This function stores the info that will be
  *  required later while unmapping the block.
  */
-DSP_STATUS DMM_MapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 size)
+dsp_status dmm_map_memory(struct dmm_object *dmm_mgr, u32 addr, u32 size)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	struct MapPage *chunk;
-	DSP_STATUS status = DSP_SOK;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	struct map_page *chunk;
+	dsp_status status = DSP_SOK;
 
-	SYNC_EnterCS(pDmmObj->hDmmLock);
+	spin_lock(&dmm_obj->dmm_lock);
 	/* Find the Reserved memory chunk containing the DSP block to
 	 * be mapped */
-	chunk = (struct MapPage *)GetRegion(addr);
+	chunk = (struct map_page *)get_region(addr);
 	if (chunk != NULL) {
 		/* Mark the region 'mapped', leave the 'reserved' info as-is */
-		chunk->bMapped = true;
-		chunk->MappedSize = (size/PG_SIZE_4K);
+		chunk->mapped = true;
+		chunk->mapped_size = (size / PG_SIZE4K);
 	} else
 		status = DSP_ENOTFOUND;
-	SYNC_LeaveCS(pDmmObj->hDmmLock);
+	spin_unlock(&dmm_obj->dmm_lock);
 
-	dev_dbg(bridge, "%s hDmmMgr %p, addr %x, size %x\n\tstatus %x, "
-		"chunk %p", __func__, hDmmMgr, addr, size, status, chunk);
+	dev_dbg(bridge, "%s dmm_mgr %p, addr %x, size %x\n\tstatus %x, "
+		"chunk %p", __func__, dmm_mgr, addr, size, status, chunk);
 
 	return status;
 }
 
 /*
- *  ======== DMM_ReserveMemory ========
+ *  ======== dmm_reserve_memory ========
  *  Purpose:
  *      Reserve a chunk of virtually contiguous DSP/IVA address space.
  */
-DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr, u32 size,
-							u32 *pRsvAddr)
+dsp_status dmm_reserve_memory(struct dmm_object *dmm_mgr, u32 size,
+			      u32 *prsv_addr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	struct MapPage *node;
-	u32 rsvAddr = 0;
-	u32 rsvSize = 0;
+	dsp_status status = DSP_SOK;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	struct map_page *node;
+	u32 rsv_addr = 0;
+	u32 rsv_size = 0;
 
-	SYNC_EnterCS(pDmmObj->hDmmLock);
+	spin_lock(&dmm_obj->dmm_lock);
 
 	/* Try to get a DSP chunk from the free list */
-	node = GetFreeRegion(size);
+	node = get_free_region(size);
 	if (node != NULL) {
 		/*  DSP chunk of given size is available. */
-		rsvAddr = DMM_ADDR_VIRTUAL(node);
+		rsv_addr = DMM_ADDR_VIRTUAL(node);
 		/* Calculate the number entries to use */
-		rsvSize = size/PG_SIZE_4K;
-		if (rsvSize < node->RegionSize) {
+		rsv_size = size / PG_SIZE4K;
+		if (rsv_size < node->region_size) {
 			/* Mark remainder of free region */
-			node[rsvSize].bMapped = false;
-			node[rsvSize].bReserved = false;
-			node[rsvSize].RegionSize = node->RegionSize - rsvSize;
-			node[rsvSize].MappedSize = 0;
+			node[rsv_size].mapped = false;
+			node[rsv_size].reserved = false;
+			node[rsv_size].region_size =
+			    node->region_size - rsv_size;
+			node[rsv_size].mapped_size = 0;
 		}
-		/*  GetRegion will return first fit chunk. But we only use what
-			is requested. */
-		node->bMapped = false;
-		node->bReserved = true;
-		node->RegionSize = rsvSize;
-		node->MappedSize = 0;
+		/*  get_region will return first fit chunk. But we only use what
+		   is requested. */
+		node->mapped = false;
+		node->reserved = true;
+		node->region_size = rsv_size;
+		node->mapped_size = 0;
 		/* Return the chunk's starting address */
-		*pRsvAddr = rsvAddr;
+		*prsv_addr = rsv_addr;
 	} else
 		/*dSP chunk of given size is not available */
 		status = DSP_EMEMORY;
 
-	SYNC_LeaveCS(pDmmObj->hDmmLock);
+	spin_unlock(&dmm_obj->dmm_lock);
 
-	dev_dbg(bridge, "%s hDmmMgr %p, size %x, pRsvAddr %p\n\tstatus %x, "
-			"rsvAddr %x, rsvSize %x\n", __func__, hDmmMgr, size,
-			pRsvAddr, status, rsvAddr, rsvSize);
+	dev_dbg(bridge, "%s dmm_mgr %p, size %x, prsv_addr %p\n\tstatus %x, "
+		"rsv_addr %x, rsv_size %x\n", __func__, dmm_mgr, size,
+		prsv_addr, status, rsv_addr, rsv_size);
 
 	return status;
 }
 
-
 /*
- *  ======== DMM_UnMapMemory ========
+ *  ======== dmm_un_map_memory ========
  *  Purpose:
  *      Remove the mapped block from the reserved chunk.
  */
-DSP_STATUS DMM_UnMapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 *pSize)
+dsp_status dmm_un_map_memory(struct dmm_object *dmm_mgr, u32 addr, u32 *psize)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	struct MapPage *chunk;
-	DSP_STATUS status = DSP_SOK;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	struct map_page *chunk;
+	dsp_status status = DSP_SOK;
 
-	SYNC_EnterCS(pDmmObj->hDmmLock);
-	chunk = GetMappedRegion(addr) ;
+	spin_lock(&dmm_obj->dmm_lock);
+	chunk = get_mapped_region(addr);
 	if (chunk == NULL)
-		status = DSP_ENOTFOUND ;
+		status = DSP_ENOTFOUND;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Unmap the region */
-		*pSize = chunk->MappedSize * PG_SIZE_4K;
-		chunk->bMapped = false;
-		chunk->MappedSize = 0;
+		*psize = chunk->mapped_size * PG_SIZE4K;
+		chunk->mapped = false;
+		chunk->mapped_size = 0;
 	}
-	SYNC_LeaveCS(pDmmObj->hDmmLock);
+	spin_unlock(&dmm_obj->dmm_lock);
 
-	dev_dbg(bridge, "%s: hDmmMgr %p, addr %x, pSize %p\n\tstatus %x, "
-		"chunk %p\n", __func__, hDmmMgr, addr, pSize, status, chunk);
+	dev_dbg(bridge, "%s: dmm_mgr %p, addr %x, psize %p\n\tstatus %x, "
+		"chunk %p\n", __func__, dmm_mgr, addr, psize, status, chunk);
 
 	return status;
 }
 
 /*
- *  ======== DMM_UnReserveMemory ========
+ *  ======== dmm_un_reserve_memory ========
  *  Purpose:
  *      Free a chunk of reserved DSP/IVA address space.
  */
-DSP_STATUS DMM_UnReserveMemory(struct DMM_OBJECT *hDmmMgr, u32 rsvAddr)
+dsp_status dmm_un_reserve_memory(struct dmm_object *dmm_mgr, u32 rsv_addr)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	struct MapPage *chunk;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	struct map_page *chunk;
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
-	u32 chunkSize;
+	dsp_status status = DSP_SOK;
+	u32 chunk_size;
 
-	SYNC_EnterCS(pDmmObj->hDmmLock);
+	spin_lock(&dmm_obj->dmm_lock);
 
 	/* Find the chunk containing the reserved address */
-	chunk = GetMappedRegion(rsvAddr);
+	chunk = get_mapped_region(rsv_addr);
 	if (chunk == NULL)
 		status = DSP_ENOTFOUND;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Free all the mapped pages for this reserved region */
 		i = 0;
-		while (i < chunk->RegionSize) {
-			if (chunk[i].bMapped) {
+		while (i < chunk->region_size) {
+			if (chunk[i].mapped) {
 				/* Remove mapping from the page tables. */
-				chunkSize = chunk[i].MappedSize;
+				chunk_size = chunk[i].mapped_size;
 				/* Clear the mapping flags */
-				chunk[i].bMapped = false;
-				chunk[i].MappedSize = 0;
-				i += chunkSize;
+				chunk[i].mapped = false;
+				chunk[i].mapped_size = 0;
+				i += chunk_size;
 			} else
 				i++;
 		}
 		/* Clear the flags (mark the region 'free') */
-		chunk->bReserved = false;
+		chunk->reserved = false;
 		/* NOTE: We do NOT coalesce free regions here.
-		 * Free regions are coalesced in GetRegion(), as it traverses
+		 * Free regions are coalesced in get_region(), as it traverses
 		 *the whole mapping table
 		 */
 	}
-	SYNC_LeaveCS(pDmmObj->hDmmLock);
+	spin_unlock(&dmm_obj->dmm_lock);
 
-	dev_dbg(bridge, "%s: hDmmMgr %p, rsvAddr %x\n\tstatus %x chunk %p",
-			__func__, hDmmMgr, rsvAddr, status, chunk);
+	dev_dbg(bridge, "%s: dmm_mgr %p, rsv_addr %x\n\tstatus %x chunk %p",
+		__func__, dmm_mgr, rsv_addr, status, chunk);
 
 	return status;
 }
 
-
 /*
- *  ======== GetRegion ========
+ *  ======== get_region ========
  *  Purpose:
  *      Returns a region containing the specified memory region
  */
-static struct MapPage *GetRegion(u32 aAddr)
+static struct map_page *get_region(u32 aAddr)
 {
-	struct MapPage *currRegion = NULL;
-	u32   i = 0;
+	struct map_page *curr_region = NULL;
+	u32 i = 0;
 
-	if (pVirtualMappingTable != NULL) {
+	if (virtual_mapping_table != NULL) {
 		/* find page mapped by this address */
 		i = DMM_ADDR_TO_INDEX(aAddr);
-		if (i < TableSize)
-			currRegion = pVirtualMappingTable + i;
+		if (i < table_size)
+			curr_region = virtual_mapping_table + i;
 	}
 
-	dev_dbg(bridge, "%s: currRegion %p, iFreeRegion %d, iFreeSize %d\n",
-			__func__, currRegion, iFreeRegion, iFreeSize);
-	return currRegion;
+	dev_dbg(bridge, "%s: curr_region %p, free_region %d, free_size %d\n",
+		__func__, curr_region, free_region, free_size);
+	return curr_region;
 }
 
 /*
- *  ======== GetFreeRegion ========
+ *  ======== get_free_region ========
  *  Purpose:
  *  Returns the requested free region
  */
-static struct MapPage *GetFreeRegion(u32 aSize)
+static struct map_page *get_free_region(u32 aSize)
 {
-	struct MapPage *currRegion = NULL;
-	u32   i = 0;
-	u32   RegionSize = 0;
-	u32   nextI = 0;
-
-	if (pVirtualMappingTable == NULL)
-		return currRegion;
-	if (aSize > iFreeSize) {
+	struct map_page *curr_region = NULL;
+	u32 i = 0;
+	u32 region_size = 0;
+	u32 next_i = 0;
+
+	if (virtual_mapping_table == NULL)
+		return curr_region;
+	if (aSize > free_size) {
 		/* Find the largest free region
-		* (coalesce during the traversal) */
-		while (i < TableSize) {
-			RegionSize = pVirtualMappingTable[i].RegionSize;
-			nextI = i+RegionSize;
-			if (pVirtualMappingTable[i].bReserved == false) {
+		 * (coalesce during the traversal) */
+		while (i < table_size) {
+			region_size = virtual_mapping_table[i].region_size;
+			next_i = i + region_size;
+			if (virtual_mapping_table[i].reserved == false) {
 				/* Coalesce, if possible */
-				if (nextI < TableSize &&
-				pVirtualMappingTable[nextI].bReserved
-							== false) {
-					pVirtualMappingTable[i].RegionSize +=
-					pVirtualMappingTable[nextI].RegionSize;
+				if (next_i < table_size &&
+				    virtual_mapping_table[next_i].reserved
+				    == false) {
+					virtual_mapping_table[i].region_size +=
+					    virtual_mapping_table
+					    [next_i].region_size;
 					continue;
 				}
-				RegionSize *= PG_SIZE_4K;
-				if (RegionSize > iFreeSize) 	{
-					iFreeRegion = i;
-					iFreeSize = RegionSize;
+				region_size *= PG_SIZE4K;
+				if (region_size > free_size) {
+					free_region = i;
+					free_size = region_size;
 				}
 			}
-			i = nextI;
+			i = next_i;
 		}
 	}
-	if (aSize <= iFreeSize) {
-		currRegion = pVirtualMappingTable + iFreeRegion;
-		iFreeRegion += (aSize / PG_SIZE_4K);
-		iFreeSize -= aSize;
+	if (aSize <= free_size) {
+		curr_region = virtual_mapping_table + free_region;
+		free_region += (aSize / PG_SIZE4K);
+		free_size -= aSize;
 	}
-	return currRegion;
+	return curr_region;
 }
 
 /*
- *  ======== GetMappedRegion ========
+ *  ======== get_mapped_region ========
  *  Purpose:
  *  Returns the requestedmapped region
  */
-static struct MapPage *GetMappedRegion(u32 aAddr)
+static struct map_page *get_mapped_region(u32 aAddr)
 {
-	u32   i = 0;
-	struct MapPage *currRegion = NULL;
+	u32 i = 0;
+	struct map_page *curr_region = NULL;
 
-	if (pVirtualMappingTable == NULL)
-		return currRegion;
+	if (virtual_mapping_table == NULL)
+		return curr_region;
 
 	i = DMM_ADDR_TO_INDEX(aAddr);
-	if (i < TableSize && (pVirtualMappingTable[i].bMapped ||
-			pVirtualMappingTable[i].bReserved))
-		currRegion = pVirtualMappingTable + i;
-	return currRegion;
+	if (i < table_size && (virtual_mapping_table[i].mapped ||
+			       virtual_mapping_table[i].reserved))
+		curr_region = virtual_mapping_table + i;
+	return curr_region;
 }
 
 #ifdef DSP_DMM_DEBUG
-u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr)
+u32 dmm_mem_map_dump(struct dmm_object *dmm_mgr)
 {
-	struct MapPage *curNode = NULL;
+	struct map_page *curr_node = NULL;
 	u32 i;
 	u32 freemem = 0;
 	u32 bigsize = 0;
 
-	SYNC_EnterCS(hDmmMgr->hDmmLock);
+	spin_lock(&dmm_mgr->dmm_lock);
 
-	if (pVirtualMappingTable != NULL) {
-		for (i = 0; i < TableSize; i +=
-				pVirtualMappingTable[i].RegionSize) {
-			curNode = pVirtualMappingTable + i;
-			if (curNode->bReserved == TRUE)	{
+	if (virtual_mapping_table != NULL) {
+		for (i = 0; i < table_size; i +=
+		     virtual_mapping_table[i].region_size) {
+			curr_node = virtual_mapping_table + i;
+			if (curr_node->reserved == TRUE) {
 				/*printk("RESERVED size = 0x%x, "
-					"Map size = 0x%x\n",
-					(curNode->RegionSize * PG_SIZE_4K),
-					(curNode->bMapped == false) ? 0 :
-					(curNode->MappedSize * PG_SIZE_4K));
-*/
+				   "Map size = 0x%x\n",
+				   (curr_node->region_size * PG_SIZE4K),
+				   (curr_node->mapped == false) ? 0 :
+				   (curr_node->mapped_size * PG_SIZE4K));
+				 */
 			} else {
 /*				printk("UNRESERVED size = 0x%x\n",
-					(curNode->RegionSize * PG_SIZE_4K));
-*/
-				freemem += (curNode->RegionSize * PG_SIZE_4K);
-				if (curNode->RegionSize > bigsize)
-					bigsize = curNode->RegionSize;
+					(curr_node->region_size * PG_SIZE4K));
+ */
+				freemem += (curr_node->region_size * PG_SIZE4K);
+				if (curr_node->region_size > bigsize)
+					bigsize = curr_node->region_size;
 			}
 		}
 	}
+	spin_unlock(&dmm_mgr->dmm_lock);
 	printk(KERN_INFO "Total DSP VA FREE memory = %d Mbytes\n",
-			freemem/(1024*1024));
+	       freemem / (1024 * 1024));
 	printk(KERN_INFO "Total DSP VA USED memory= %d Mbytes \n",
-			(((TableSize * PG_SIZE_4K)-freemem))/(1024*1024));
+	       (((table_size * PG_SIZE4K) - freemem)) / (1024 * 1024));
 	printk(KERN_INFO "DSP VA - Biggest FREE block = %d Mbytes \n\n",
-			(bigsize*PG_SIZE_4K/(1024*1024)));
-	SYNC_LeaveCS(hDmmMgr->hDmmLock);
+	       (bigsize * PG_SIZE4K / (1024 * 1024)));
 
 	return 0;
 }
diff --git a/drivers/dsp/bridge/pmgr/io.c b/drivers/dsp/bridge/pmgr/io.c
index 0462ea0..fd6430e 100644
--- a/drivers/dsp/bridge/pmgr/io.c
+++ b/drivers/dsp/bridge/pmgr/io.c
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * IO manager interface: Manages IO between CHNL and MSG.
+ * IO manager interface: Manages IO between CHNL and msg_ctrl.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
@@ -40,51 +40,51 @@
 #include <dspbridge/io.h>
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;
+static u32 refs;
 
 /*
- *  ======== IO_Create ========
+ *  ======== io_create ========
  *  Purpose:
  *      Create an IO manager object, responsible for managing IO between
- *      CHNL and MSG
+ *      CHNL and msg_ctrl
  */
-DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr, struct DEV_OBJECT *hDevObject,
-		    IN CONST struct IO_ATTRS *pMgrAttrs)
+dsp_status io_create(OUT struct io_mgr **phIOMgr, struct dev_object *hdev_obj,
+		     IN CONST struct io_attrs *pMgrAttrs)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct IO_MGR *hIOMgr = NULL;
-	struct IO_MGR_ *pIOMgr = NULL;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	struct io_mgr *hio_mgr = NULL;
+	struct io_mgr_ *pio_mgr = NULL;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phIOMgr != NULL);
-	DBC_Require(pMgrAttrs != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phIOMgr != NULL);
+	DBC_REQUIRE(pMgrAttrs != NULL);
 
 	*phIOMgr = NULL;
 
-	/* A memory base of 0 implies no memory base:  */
-	if ((pMgrAttrs->dwSMBase != 0) && (pMgrAttrs->uSMLength == 0))
+	/* A memory base of 0 implies no memory base: */
+	if ((pMgrAttrs->shm_base != 0) && (pMgrAttrs->usm_length == 0))
 		status = CHNL_E_INVALIDMEMBASE;
 
-	if (pMgrAttrs->uWordSize == 0)
+	if (pMgrAttrs->word_size == 0)
 		status = CHNL_E_INVALIDWORDSIZE;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetIntfFxns(hDevObject, &pIntfFxns);
-
-		if (pIntfFxns) {
+		status = dev_get_intf_fxns(hdev_obj, &intf_fxns);
+ 
+		if (intf_fxns) {
 			/* Let WMD channel module finish the create */
-			status = (*pIntfFxns->pfnIOCreate)(&hIOMgr, hDevObject,
+			status = (*intf_fxns->pfn_io_create)(&hio_mgr, hdev_obj,
 					pMgrAttrs);
 		}
 
 		if (DSP_SUCCEEDED(status)) {
-			pIOMgr = (struct IO_MGR_ *) hIOMgr;
-			pIOMgr->pIntfFxns = pIntfFxns;
-			pIOMgr->hDevObject = hDevObject;
+			pio_mgr = (struct io_mgr_ *)hio_mgr;
+			pio_mgr->intf_fxns = intf_fxns;
+			pio_mgr->hdev_obj = hdev_obj;
 
 			/* Return the new channel manager handle: */
-			*phIOMgr = hIOMgr;
+			*phIOMgr = hio_mgr;
 		}
 	}
 
@@ -92,55 +92,55 @@ DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr, struct DEV_OBJECT *hDevObject,
 }
 
 /*
- *  ======== IO_Destroy ========
+ *  ======== io_destroy ========
  *  Purpose:
  *      Delete IO manager.
  */
-DSP_STATUS IO_Destroy(struct IO_MGR *hIOMgr)
+dsp_status io_destroy(struct io_mgr *hio_mgr)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct IO_MGR_ *pIOMgr = (struct IO_MGR_ *)hIOMgr;
-	DSP_STATUS status;
+	struct bridge_drv_interface *intf_fxns;
+	struct io_mgr_ *pio_mgr = (struct io_mgr_ *)hio_mgr;
+	dsp_status status;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	pIntfFxns = pIOMgr->pIntfFxns;
+	intf_fxns = pio_mgr->intf_fxns;
 
-	/* Let WMD channel module destroy the IO_MGR: */
-	status = (*pIntfFxns->pfnIODestroy) (hIOMgr);
+	/* Let WMD channel module destroy the io_mgr: */
+	status = (*intf_fxns->pfn_io_destroy) (hio_mgr);
 
 	return status;
 }
 
 /*
- *  ======== IO_Exit ========
+ *  ======== io_exit ========
  *  Purpose:
  *      Discontinue usage of the IO module.
  */
-void IO_Exit(void)
+void io_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== IO_Init ========
+ *  ======== io_init ========
  *  Purpose:
  *      Initialize the IO module's private state.
  */
-bool IO_Init(void)
+bool io_init(void)
 {
-	bool fRetval = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (fRetval)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
diff --git a/drivers/dsp/bridge/pmgr/ioobj.h b/drivers/dsp/bridge/pmgr/ioobj.h
index 4e3bd56..298d1a2 100644
--- a/drivers/dsp/bridge/pmgr/ioobj.h
+++ b/drivers/dsp/bridge/pmgr/ioobj.h
@@ -24,16 +24,16 @@
 #include <dspbridge/wmd.h>
 
 /*
- *  This struct is the first field in a IO_MGR struct, as implemented in
+ *  This struct is the first field in a io_mgr struct, as implemented in
  *  a WMD channel class library.  Other, implementation specific fields
  *  follow this structure in memory.
  */
-struct IO_MGR_ {
-	/* These must be the first fields in a IO_MGR struct: */
-	u32 dwSignature;	/* Used for object validation.   */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD device context.  */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
-	struct DEV_OBJECT *hDevObject;	/* Device this board represents. */
-} ;
+struct io_mgr_ {
+	/* These must be the first fields in a io_mgr struct: */
+	u32 dw_signature;	/* Used for object validation. */
+	struct wmd_dev_context *hwmd_context;	/* WMD device context. */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD. */
+	struct dev_object *hdev_obj;	/* Device this board represents. */
+};
 
-#endif				/* IOOBJ_ */
+#endif /* IOOBJ_ */
diff --git a/drivers/dsp/bridge/pmgr/msg.c b/drivers/dsp/bridge/pmgr/msg.c
index 1191b7a..775023d 100644
--- a/drivers/dsp/bridge/pmgr/msg.c
+++ b/drivers/dsp/bridge/pmgr/msg.c
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * DSP/BIOS Bridge MSG Module.
+ * DSP/BIOS Bridge msg_ctrl Module.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
@@ -41,45 +41,45 @@
 #include <dspbridge/msg.h>
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /*
- *  ======== MSG_Create ========
+ *  ======== msg_create ========
  *  Purpose:
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  */
-DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-		      struct DEV_OBJECT *hDevObject, MSG_ONEXIT msgCallback)
+dsp_status msg_create(OUT struct msg_mgr **phMsgMgr,
+		      struct dev_object *hdev_obj, msg_onexit msgCallback)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct MSG_MGR_ *pMsgMgr;
-	struct MSG_MGR *hMsgMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	struct msg_mgr_ *msg_mgr_obj;
+	struct msg_mgr *hmsg_mgr;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMsgMgr != NULL);
-	DBC_Require(msgCallback != NULL);
-	DBC_Require(hDevObject != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMsgMgr != NULL);
+	DBC_REQUIRE(msgCallback != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
 
 	*phMsgMgr = NULL;
 
-	status = DEV_GetIntfFxns(hDevObject, &pIntfFxns);
-
-	if (pIntfFxns) {
+	status = dev_get_intf_fxns(hdev_obj, &intf_fxns);
+ 
+	if (intf_fxns) {
 		/* Let WMD message module finish the create */
-		status = (*pIntfFxns->pfnMsgCreate)(&hMsgMgr,
-				hDevObject, msgCallback);
+		status = (*intf_fxns->pfn_msg_create)(&hmsg_mgr,
+				hdev_obj, msgCallback);
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		/* Fill in WCD message module's fields of the MSG_MGR
+		/* Fill in WCD message module's fields of the msg_mgr
 		 * structure */
-		pMsgMgr = (struct MSG_MGR_ *)hMsgMgr;
-		pMsgMgr->pIntfFxns = pIntfFxns;
+		msg_mgr_obj = (struct msg_mgr_ *)hmsg_mgr;
+		msg_mgr_obj->intf_fxns = intf_fxns;
 
 		/* Finally, return the new message manager handle: */
-		*phMsgMgr = hMsgMgr;
+		*phMsgMgr = hmsg_mgr;
 	} else {
 		status = DSP_EFAIL;
 	}
@@ -87,50 +87,49 @@ DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
 }
 
 /*
- *  ======== MSG_Delete ========
+ *  ======== msg_delete ========
  *  Purpose:
- *      Delete a MSG manager allocated in MSG_Create().
+ *      Delete a msg_ctrl manager allocated in msg_create().
  */
-void MSG_Delete(struct MSG_MGR *hMsgMgr)
+void msg_delete(struct msg_mgr *hmsg_mgr)
 {
-	struct MSG_MGR_ *pMsgMgr = (struct MSG_MGR_ *)hMsgMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct msg_mgr_ *msg_mgr_obj = (struct msg_mgr_ *)hmsg_mgr;
+	struct bridge_drv_interface *intf_fxns;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE)) {
-		pIntfFxns = pMsgMgr->pIntfFxns;
+	if (MEM_IS_VALID_HANDLE(msg_mgr_obj, MSGMGR_SIGNATURE)) {
+		intf_fxns = msg_mgr_obj->intf_fxns;
 
-		/* Let WMD message module destroy the MSG_MGR: */
-		(*pIntfFxns->pfnMsgDelete)(hMsgMgr);
+		/* Let WMD message module destroy the msg_mgr: */
+		(*intf_fxns->pfn_msg_delete) (hmsg_mgr);
 	} else {
-		dev_dbg(bridge, "%s: Error hMsgMgr handle: %p\n",
-						__func__, hMsgMgr);
+		dev_dbg(bridge, "%s: Error hmsg_mgr handle: %p\n",
+			__func__, hmsg_mgr);
 	}
 }
 
 /*
- *  ======== MSG_Exit ========
+ *  ======== msg_exit ========
  */
-void MSG_Exit(void)
+void msg_exit(void)
 {
-	DBC_Require(cRefs > 0);
-	cRefs--;
+	DBC_REQUIRE(refs > 0);
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== MSG_Init ========
+ *  ======== msg_mod_init ========
  */
-bool MSG_Init(void)
+bool msg_mod_init(void)
 {
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	cRefs++;
+	refs++;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 
 	return true;
 }
-
diff --git a/drivers/dsp/bridge/pmgr/msgobj.h b/drivers/dsp/bridge/pmgr/msgobj.h
index 5fd048c..420ba00 100644
--- a/drivers/dsp/bridge/pmgr/msgobj.h
+++ b/drivers/dsp/bridge/pmgr/msgobj.h
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * Structure subcomponents of channel class library MSG objects which
+ * Structure subcomponents of channel class library msg_ctrl objects which
  * are exposed to class driver from mini-driver.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
@@ -25,15 +25,14 @@
 #include <dspbridge/msgdefs.h>
 
 /*
- *  This struct is the first field in a MSG_MGR struct, as implemented in
+ *  This struct is the first field in a msg_mgr struct, as implemented in
  *  a WMD channel class library.  Other, implementation specific fields
  *  follow this structure in memory.
  */
-struct MSG_MGR_ {
+struct msg_mgr_ {
 	/* The first two fields must match those in msgobj.h */
-	u32 dwSignature;
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
+	u32 dw_signature;
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD. */
 };
 
-#endif				/* MSGOBJ_ */
-
+#endif /* MSGOBJ_ */
diff --git a/drivers/dsp/bridge/pmgr/wcd.c b/drivers/dsp/bridge/pmgr/wcd.c
index a33c61c..7aee75c 100644
--- a/drivers/dsp/bridge/pmgr/wcd.c
+++ b/drivers/dsp/bridge/pmgr/wcd.c
@@ -48,7 +48,6 @@
 #include <dspbridge/node.h>
 #include <dspbridge/rmm.h>
 
-
 /*  ----------------------------------- Others */
 #include <dspbridge/msg.h>
 #include <dspbridge/cmm.h>
@@ -71,13 +70,13 @@
 #define DB_GET_IOC_TABLE(cmd)	(DB_GET_MODULE(cmd) >> DB_MODULE_SHIFT)
 
 /* Device IOCtl function pointer */
-struct WCD_Cmd {
-	u32(*fxn)(union Trapped_Args *args, void *pr_ctxt);
-	u32 dwIndex;
-} ;
+struct wcd_cmd {
+	u32(*fxn) (union Trapped_Args *args, void *pr_ctxt);
+	u32 dw_index;
+};
 
 /*  ----------------------------------- Globals */
-static u32 WCD_cRefs;
+static u32 wcd_c_refs;
 
 /*
  *  Function tables.
@@ -87,76 +86,76 @@ static u32 WCD_cRefs;
  */
 
 /* MGR wrapper functions */
-static struct WCD_Cmd mgr_cmd[] = {
-	{MGRWRAP_EnumNode_Info},		/* MGR_ENUMNODE_INFO */
-	{MGRWRAP_EnumProc_Info},		/* MGR_ENUMPROC_INFO */
-	{MGRWRAP_RegisterObject},		/* MGR_REGISTEROBJECT */
-	{MGRWRAP_UnregisterObject},		/* MGR_UNREGISTEROBJECT */
-	{MGRWRAP_WaitForBridgeEvents},		/* MGR_WAIT */
-	{MGRWRAP_GetProcessResourcesInfo},	/* MGR_GET_PROC_RES */
+static struct wcd_cmd mgr_cmd[] = {
+	{mgrwrap_enum_node_info},	/* MGR_ENUMNODE_INFO */
+	{mgrwrap_enum_proc_info},	/* MGR_ENUMPROC_INFO */
+	{mgrwrap_register_object},	/* MGR_REGISTEROBJECT */
+	{mgrwrap_unregister_object},	/* MGR_UNREGISTEROBJECT */
+	{mgrwrap_wait_for_bridge_events},	/* MGR_WAIT */
+	{mgrwrap_get_process_resources_info},	/* MGR_GET_PROC_RES */
 };
 
 /* PROC wrapper functions */
-static struct WCD_Cmd proc_cmd[] = {
-	{PROCWRAP_Attach},			/* PROC_ATTACH */
-	{PROCWRAP_Ctrl},			/* PROC_CTRL */
-	{PROCWRAP_Detach},			/* PROC_DETACH */
-	{PROCWRAP_EnumNode_Info},		/* PROC_ENUMNODE */
-	{PROCWRAP_EnumResources},		/* PROC_ENUMRESOURCES */
-	{PROCWRAP_GetState},			/* PROC_GET_STATE */
-	{PROCWRAP_GetTrace},			/* PROC_GET_TRACE */
-	{PROCWRAP_Load},			/* PROC_LOAD */
-	{PROCWRAP_RegisterNotify},		/* PROC_REGISTERNOTIFY */
-	{PROCWRAP_Start},			/* PROC_START */
-	{PROCWRAP_ReserveMemory},		/* PROC_RSVMEM */
-	{PROCWRAP_UnReserveMemory},		/* PROC_UNRSVMEM */
-	{PROCWRAP_Map},				/* PROC_MAPMEM */
-	{PROCWRAP_UnMap},			/* PROC_UNMAPMEM */
-	{PROCWRAP_FlushMemory},			/* PROC_FLUSHMEMORY */
-	{PROCWRAP_Stop},			/* PROC_STOP */
-	{PROCWRAP_InvalidateMemory},		/* PROC_INVALIDATEMEMORY */
+static struct wcd_cmd proc_cmd[] = {
+	{procwrap_attach},	/* PROC_ATTACH */
+	{procwrap_ctrl},	/* PROC_CTRL */
+	{procwrap_detach},	/* PROC_DETACH */
+	{procwrap_enum_node_info},	/* PROC_ENUMNODE */
+	{procwrap_enum_resources},	/* PROC_ENUMRESOURCES */
+	{procwrap_get_state},	/* PROC_GET_STATE */
+	{procwrap_get_trace},	/* PROC_GET_TRACE */
+	{procwrap_load},	/* PROC_LOAD */
+	{procwrap_register_notify},	/* PROC_REGISTERNOTIFY */
+	{procwrap_start},	/* PROC_START */
+	{procwrap_reserve_memory},	/* PROC_RSVMEM */
+	{procwrap_un_reserve_memory},	/* PROC_UNRSVMEM */
+	{procwrap_map},		/* PROC_MAPMEM */
+	{procwrap_un_map},	/* PROC_UNMAPMEM */
+	{procwrap_flush_memory},	/* PROC_FLUSHMEMORY */
+	{procwrap_stop},	/* PROC_STOP */
+	{procwrap_invalidate_memory},	/* PROC_INVALIDATEMEMORY */
 };
 
 /* NODE wrapper functions */
-static struct WCD_Cmd node_cmd[] = {
-	{NODEWRAP_Allocate},			/* NODE_ALLOCATE */
-	{NODEWRAP_AllocMsgBuf},			/* NODE_ALLOCMSGBUF */
-	{NODEWRAP_ChangePriority},		/* NODE_CHANGEPRIORITY */
-	{NODEWRAP_Connect},			/* NODE_CONNECT */
-	{NODEWRAP_Create},			/* NODE_CREATE */
-	{NODEWRAP_Delete},			/* NODE_DELETE */
-	{NODEWRAP_FreeMsgBuf},			/* NODE_FREEMSGBUF */
-	{NODEWRAP_GetAttr},			/* NODE_GETATTR */
-	{NODEWRAP_GetMessage},			/* NODE_GETMESSAGE */
-	{NODEWRAP_Pause},			/* NODE_PAUSE */
-	{NODEWRAP_PutMessage},			/* NODE_PUTMESSAGE */
-	{NODEWRAP_RegisterNotify},		/* NODE_REGISTERNOTIFY */
-	{NODEWRAP_Run},				/* NODE_RUN */
-	{NODEWRAP_Terminate},			/* NODE_TERMINATE */
-	{NODEWRAP_GetUUIDProps},		/* NODE_GETUUIDPROPS */
+static struct wcd_cmd node_cmd[] = {
+	{nodewrap_allocate},	/* NODE_ALLOCATE */
+	{nodewrap_alloc_msg_buf},	/* NODE_ALLOCMSGBUF */
+	{nodewrap_change_priority},	/* NODE_CHANGEPRIORITY */
+	{nodewrap_connect},	/* NODE_CONNECT */
+	{nodewrap_create},	/* NODE_CREATE */
+	{nodewrap_delete},	/* NODE_DELETE */
+	{nodewrap_free_msg_buf},	/* NODE_FREEMSGBUF */
+	{nodewrap_get_attr},	/* NODE_GETATTR */
+	{nodewrap_get_message},	/* NODE_GETMESSAGE */
+	{nodewrap_pause},	/* NODE_PAUSE */
+	{nodewrap_put_message},	/* NODE_PUTMESSAGE */
+	{nodewrap_register_notify},	/* NODE_REGISTERNOTIFY */
+	{nodewrap_run},		/* NODE_RUN */
+	{nodewrap_terminate},	/* NODE_TERMINATE */
+	{nodewrap_get_uuid_props},	/* NODE_GETUUIDPROPS */
 };
 
 /* STRM wrapper functions */
-static struct WCD_Cmd strm_cmd[] = {
-	{STRMWRAP_AllocateBuffer},		/* STRM_ALLOCATEBUFFER */
-	{STRMWRAP_Close},			/* STRM_CLOSE */
-	{STRMWRAP_FreeBuffer},			/* STRM_FREEBUFFER */
-	{STRMWRAP_GetEventHandle},		/* STRM_GETEVENTHANDLE */
-	{STRMWRAP_GetInfo},			/* STRM_GETINFO */
-	{STRMWRAP_Idle},			/* STRM_IDLE */
-	{STRMWRAP_Issue},			/* STRM_ISSUE */
-	{STRMWRAP_Open},			/* STRM_OPEN */
-	{STRMWRAP_Reclaim},			/* STRM_RECLAIM */
-	{STRMWRAP_RegisterNotify},		/* STRM_REGISTERNOTIFY */
-	{STRMWRAP_Select},			/* STRM_SELECT */
+static struct wcd_cmd strm_cmd[] = {
+	{strmwrap_allocate_buffer},	/* STRM_ALLOCATEBUFFER */
+	{strmwrap_close},	/* STRM_CLOSE */
+	{strmwrap_free_buffer},	/* STRM_FREEBUFFER */
+	{strmwrap_get_event_handle},	/* STRM_GETEVENTHANDLE */
+	{strmwrap_get_info},	/* STRM_GETINFO */
+	{strmwrap_idle},	/* STRM_IDLE */
+	{strmwrap_issue},	/* STRM_ISSUE */
+	{strmwrap_open},	/* STRM_OPEN */
+	{strmwrap_reclaim},	/* STRM_RECLAIM */
+	{strmwrap_register_notify},	/* STRM_REGISTERNOTIFY */
+	{strmwrap_select},	/* STRM_SELECT */
 };
 
 /* CMM wrapper functions */
-static struct WCD_Cmd cmm_cmd[] = {
-	{CMMWRAP_CallocBuf},			/* CMM_ALLOCBUF */
-	{CMMWRAP_FreeBuf},			/* CMM_FREEBUF */
-	{CMMWRAP_GetHandle},			/* CMM_GETHANDLE */
-	{CMMWRAP_GetInfo},			/* CMM_GETINFO */
+static struct wcd_cmd cmm_cmd[] = {
+	{cmmwrap_calloc_buf},	/* CMM_ALLOCBUF */
+	{cmmwrap_free_buf},	/* CMM_FREEBUF */
+	{cmmwrap_get_handle},	/* CMM_GETHANDLE */
+	{cmmwrap_get_info},	/* CMM_GETINFO */
 };
 
 /* Array used to store ioctl table sizes. It can hold up to 8 entries */
@@ -168,8 +167,8 @@ static u8 size_cmd[] = {
 	ARRAY_SIZE(cmm_cmd),
 };
 
-static inline void __cp_fm_usr(void *to, const void __user *from,
-			       DSP_STATUS *err, unsigned long bytes)
+static inline void _cp_fm_usr(void *to, const void __user * from,
+			      dsp_status *err, unsigned long bytes)
 {
 	if (DSP_FAILED(*err))
 		return;
@@ -182,11 +181,12 @@ static inline void __cp_fm_usr(void *to, const void __user *from,
 	if (unlikely(copy_from_user(to, from, bytes)))
 		*err = DSP_EPOINTER;
 }
-#define cp_fm_usr(to, from, err, n)				\
-	__cp_fm_usr(to, from, &(err), (n) * sizeof(*(to)))
 
-static inline void __cp_to_usr(void __user *to, const void *from,
-			       DSP_STATUS *err, unsigned long bytes)
+#define CP_FM_USR(to, from, err, n)				\
+	_cp_fm_usr(to, from, &(err), (n) * sizeof(*(to)))
+
+static inline void _cp_to_usr(void __user *to, const void *from,
+			      dsp_status *err, unsigned long bytes)
 {
 	if (DSP_FAILED(*err))
 		return;
@@ -199,18 +199,19 @@ static inline void __cp_to_usr(void __user *to, const void *from,
 	if (unlikely(copy_to_user(to, from, bytes)))
 		*err = DSP_EPOINTER;
 }
-#define cp_to_usr(to, from, err, n)				\
-	__cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
+
+#define CP_TO_USR(to, from, err, n)				\
+	_cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
 
 /*
- *  ======== WCD_CallDevIOCtl ========
+ *  ======== wcd_call_dev_io_ctl ========
  *  Purpose:
  *      Call the (wrapper) function for the corresponding WCD IOCTL.
  */
-inline DSP_STATUS WCD_CallDevIOCtl(u32 cmd, union Trapped_Args *args,
-				    u32 *result, void *pr_ctxt)
+inline dsp_status wcd_call_dev_io_ctl(u32 cmd, union Trapped_Args *args,
+				      u32 *result, void *pr_ctxt)
 {
-	u32 (*ioctl_cmd)(union Trapped_Args *args, void *pr_ctxt) = NULL;
+	u32(*ioctl_cmd) (union Trapped_Args *args, void *pr_ctxt) = NULL;
 	int i;
 
 	if (_IOC_TYPE(cmd) != DB) {
@@ -227,7 +228,7 @@ inline DSP_STATUS WCD_CallDevIOCtl(u32 cmd, union Trapped_Args *args,
 	i = DB_GET_IOC(cmd);
 	if (i > size_cmd[DB_GET_IOC_TABLE(cmd)]) {
 		pr_err("%s: requested ioctl %d out of bounds for table %d\n",
-					__func__, i, DB_GET_IOC_TABLE(cmd));
+		       __func__, i, DB_GET_IOC_TABLE(cmd));
 		goto err;
 	}
 
@@ -253,7 +254,7 @@ inline DSP_STATUS WCD_CallDevIOCtl(u32 cmd, union Trapped_Args *args,
 		pr_err("%s: requested ioctl not defined\n", __func__);
 		goto err;
 	} else {
-		*result = (*ioctl_cmd)(args, pr_ctxt);
+		*result = (*ioctl_cmd) (args, pr_ctxt);
 	}
 
 	return DSP_SOK;
@@ -263,109 +264,108 @@ err:
 }
 
 /*
- *  ======== WCD_Exit ========
+ *  ======== wcd_exit ========
  */
-void WCD_Exit(void)
+void wcd_exit(void)
 {
-	DBC_Require(WCD_cRefs > 0);
-	WCD_cRefs--;
-
-	if (WCD_cRefs == 0) {
-		/* Release all WCD modules initialized in WCD_Init(). */
-		COD_Exit();
-		DEV_Exit();
-		CHNL_Exit();
-		MSG_Exit();
-		IO_Exit();
-		STRM_Exit();
-		DISP_Exit();
-		NODE_Exit();
-		PROC_Exit();
-		MGR_Exit();
-		RMM_exit();
-		DRV_Exit();
+	DBC_REQUIRE(wcd_c_refs > 0);
+	wcd_c_refs--;
+
+	if (wcd_c_refs == 0) {
+		/* Release all WCD modules initialized in wcd_init(). */
+		cod_exit();
+		dev_exit();
+		chnl_exit();
+		msg_exit();
+		io_exit();
+		strm_exit();
+		disp_exit();
+		node_exit();
+		proc_exit();
+		mgr_exit();
+		rmm_exit();
+		drv_exit();
 	}
-	DBC_Ensure(WCD_cRefs >= 0);
+	DBC_ENSURE(wcd_c_refs >= 0);
 }
 
 /*
- *  ======== WCD_Init ========
+ *  ======== wcd_init ========
  *  Purpose:
  *      Module initialization is done by SERVICES Init.
  */
-bool WCD_Init(void)
+bool wcd_init(void)
 {
-	bool fInit = true;
-	bool fDRV, fDEV, fCOD, fCHNL, fMSG, fIO;
-	bool fMGR, fPROC, fNODE, fDISP, fSTRM, fRMM;
+	bool ret = true;
+	bool fdrv, fdev, fcod, fchnl, fmsg, fio;
+	bool fmgr, fproc, fnode, fdisp, fstrm, frmm;
 
-	if (WCD_cRefs == 0) {
+	if (wcd_c_refs == 0) {
 		/* initialize class driver and other modules */
-		fDRV = DRV_Init();
-		fMGR = MGR_Init();
-		fPROC = PROC_Init();
-		fNODE = NODE_Init();
-		fDISP = DISP_Init();
-		fSTRM = STRM_Init();
-		fRMM = RMM_init();
-		fCHNL = CHNL_Init();
-		fMSG = MSG_Init();
-		fIO = IO_Init();
-		fDEV = DEV_Init();
-		fCOD = COD_Init();
-		fInit = fDRV && fDEV && fCHNL && fCOD &&
-			fMSG && fIO;
-		fInit = fInit && fMGR && fPROC && fRMM;
-		if (!fInit) {
-			if (fDRV)
-				DRV_Exit();
-
-			if (fMGR)
-				MGR_Exit();
-
-			if (fSTRM)
-				STRM_Exit();
-
-			if (fPROC)
-				PROC_Exit();
-
-			if (fNODE)
-				NODE_Exit();
-
-			if (fDISP)
-				DISP_Exit();
-
-			if (fCHNL)
-				CHNL_Exit();
-
-			if (fMSG)
-				MSG_Exit();
-
-			if (fIO)
-				IO_Exit();
-
-			if (fDEV)
-				DEV_Exit();
-
-			if (fCOD)
-				COD_Exit();
-
-			if (fRMM)
-				RMM_exit();
+		fdrv = drv_init();
+		fmgr = mgr_init();
+		fproc = proc_init();
+		fnode = node_init();
+		fdisp = disp_init();
+		fstrm = strm_init();
+		frmm = rmm_init();
+		fchnl = chnl_init();
+		fmsg = msg_mod_init();
+		fio = io_init();
+		fdev = dev_init();
+		fcod = cod_init();
+		ret = fdrv && fdev && fchnl && fcod && fmsg && fio;
+		ret = ret && fmgr && fproc && frmm;
+		if (!ret) {
+			if (fdrv)
+				drv_exit();
+
+			if (fmgr)
+				mgr_exit();
+
+			if (fstrm)
+				strm_exit();
+
+			if (fproc)
+				proc_exit();
+
+			if (fnode)
+				node_exit();
+
+			if (fdisp)
+				disp_exit();
+
+			if (fchnl)
+				chnl_exit();
+
+			if (fmsg)
+				msg_exit();
+
+			if (fio)
+				io_exit();
+
+			if (fdev)
+				dev_exit();
+
+			if (fcod)
+				cod_exit();
+
+			if (frmm)
+				rmm_exit();
 
 		}
 	}
-	if (fInit)
-		WCD_cRefs++;
+	if (ret)
+		wcd_c_refs++;
 
-	return fInit;
+	return ret;
 }
 
 /*
- *  ======== WCD_InitComplete2 ========
+ *  ======== wcd_init_complete2 ========
  *  Purpose:
  *      Perform any required WCD, and WMD initialization which
- *      cannot not be performed in WCD_Init() or DEV_StartDevice() due
+ *      cannot not be performed in wcd_init() or dev_start_device() due
  *      to the fact that some services are not yet
  *      completely initialized.
  *  Parameters:
@@ -376,29 +376,29 @@ bool WCD_Init(void)
  *      WCD initialized.
  *  Ensures:
  */
-DSP_STATUS WCD_InitComplete2(void)
+dsp_status wcd_init_complete2(void)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_DEVNODE *DevNode;
-	struct DEV_OBJECT *hDevObject;
-	u32 devType, tmp;
+	dsp_status status = DSP_SOK;
+	struct cfg_devnode *dev_node;
+	struct dev_object *hdev_obj;
+	u32 dev_type, tmp;
 
-	DBC_Require(WCD_cRefs > 0);
+	DBC_REQUIRE(wcd_c_refs > 0);
 
-	 /*  Walk the list of DevObjects, get each devnode, and attempting to
+	/*  Walk the list of DevObjects, get each devnode, and attempting to
 	 *  autostart the board. Note that this requires COF loading, which
-	 *  requires KFILE.  */
-	for (hDevObject = DEV_GetFirst(); hDevObject != NULL;
-	     hDevObject = DEV_GetNext(hDevObject)) {
-		if (DSP_FAILED(DEV_GetDevNode(hDevObject, &DevNode)))
+	 *  requires KFILE. */
+	for (hdev_obj = dev_get_first(); hdev_obj != NULL;
+	     hdev_obj = dev_get_next(hdev_obj)) {
+		if (DSP_FAILED(dev_get_dev_node(hdev_obj, &dev_node)))
 			continue;
 
-		if (DSP_FAILED(DEV_GetDevType(hDevObject, &devType)))
+		if (DSP_FAILED(dev_get_dev_type(hdev_obj, &dev_type)))
 			continue;
 
-		if ((devType == DSP_UNIT) || (devType == IVA_UNIT)) {
-			if (CFG_GetAutoStart(DevNode, &tmp) == DSP_SOK && tmp)
-				PROC_AutoStart(DevNode, hDevObject);
+		if ((dev_type == DSP_UNIT) || (dev_type == IVA_UNIT)) {
+			if (cfg_get_auto_start(dev_node, &tmp) == DSP_SOK && tmp)
+				proc_auto_start(dev_node, hdev_obj);
 		}
 	}			/* End For Loop */
 
@@ -408,382 +408,389 @@ DSP_STATUS WCD_InitComplete2(void)
 /* TODO: Remove deprecated and not implemented ioctl wrappers */
 
 /*
- * ======== MGRWRAP_EnumNode_Info ========
+ * ======== mgrwrap_enum_node_info ========
  */
-u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	u8 *pNDBProps;
-	u32 uNumNodes;
-	DSP_STATUS status = DSP_SOK;
-	u32 size = args->ARGS_MGR_ENUMNODE_INFO.uNDBPropsSize;
+	u8 *pndb_props;
+	u32 num_nodes;
+	dsp_status status = DSP_SOK;
+	u32 size = args->args_mgr_enumnode_info.undb_props_size;
 
-	if (size < sizeof(struct DSP_NDBPROPS))
+	if (size < sizeof(struct dsp_ndbprops))
 		return DSP_ESIZE;
 
-	pNDBProps = MEM_Alloc(size, MEM_NONPAGED);
-	if (pNDBProps == NULL)
+	pndb_props = mem_alloc(size, MEM_NONPAGED);
+	if (pndb_props == NULL)
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = MGR_EnumNodeInfo(args->ARGS_MGR_ENUMNODE_INFO.uNode,
-					 (struct DSP_NDBPROPS *)pNDBProps,
-					 size, &uNumNodes);
+		status =
+		    mgr_enum_node_info(args->args_mgr_enumnode_info.node_id,
+				       (struct dsp_ndbprops *)pndb_props, size,
+				       &num_nodes);
 	}
-	cp_to_usr(args->ARGS_MGR_ENUMNODE_INFO.pNDBProps, pNDBProps, status,
-		 size);
-	cp_to_usr(args->ARGS_MGR_ENUMNODE_INFO.puNumNodes, &uNumNodes, status,
-		 1);
-	kfree(pNDBProps);
+	CP_TO_USR(args->args_mgr_enumnode_info.pndb_props, pndb_props, status,
+		  size);
+	CP_TO_USR(args->args_mgr_enumnode_info.pu_num_nodes, &num_nodes, status,
+		  1);
+	kfree(pndb_props);
 
 	return status;
 }
 
 /*
- * ======== MGRWRAP_EnumProc_Info ========
+ * ======== mgrwrap_enum_proc_info ========
  */
-u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_enum_proc_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	u8 *pProcessorInfo;
-	u32 uNumProcs;
-	DSP_STATUS status = DSP_SOK;
-	u32 size = args->ARGS_MGR_ENUMPROC_INFO.uProcessorInfoSize;
+	u8 *processor_info;
+	u32 num_procs;
+	dsp_status status = DSP_SOK;
+	u32 size = args->args_mgr_enumproc_info.processor_info_size;
 
-	if (size < sizeof(struct DSP_PROCESSORINFO))
+	if (size < sizeof(struct dsp_processorinfo))
 		return DSP_ESIZE;
 
-	pProcessorInfo = MEM_Alloc(size, MEM_NONPAGED);
-	if (pProcessorInfo == NULL)
+	processor_info = mem_alloc(size, MEM_NONPAGED);
+	if (processor_info == NULL)
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = MGR_EnumProcessorInfo(args->
-				ARGS_MGR_ENUMPROC_INFO.uProcessor,
-				(struct DSP_PROCESSORINFO *)pProcessorInfo,
-				size, &uNumProcs);
+		status =
+		    mgr_enum_processor_info(args->args_mgr_enumproc_info.
+					    processor_id,
+					    (struct dsp_processorinfo *)
+					    processor_info, size, &num_procs);
 	}
-	cp_to_usr(args->ARGS_MGR_ENUMPROC_INFO.pProcessorInfo, pProcessorInfo,
-		 status, size);
-	cp_to_usr(args->ARGS_MGR_ENUMPROC_INFO.puNumProcs, &uNumProcs,
-		 status, 1);
-	kfree(pProcessorInfo);
+	CP_TO_USR(args->args_mgr_enumproc_info.processor_info, processor_info,
+		  status, size);
+	CP_TO_USR(args->args_mgr_enumproc_info.pu_num_procs, &num_procs,
+		  status, 1);
+	kfree(processor_info);
 
 	return status;
 }
 
 #define WRAP_MAP2CALLER(x) x
 /*
- * ======== MGRWRAP_RegisterObject ========
+ * ======== mgrwrap_register_object ========
  */
-u32 MGRWRAP_RegisterObject(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_register_object(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
-	struct DSP_UUID pUuid;
-	u32 pathSize = 0;
-	char *pszPathName = NULL;
-	DSP_STATUS status = DSP_SOK;
+	u32 ret;
+	struct dsp_uuid uuid_obj;
+	u32 path_size = 0;
+	char *psz_path_name = NULL;
+	dsp_status status = DSP_SOK;
 
-	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
+	CP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);
 	if (DSP_FAILED(status))
 		goto func_end;
-	/* pathSize is increased by 1 to accommodate NULL */
-	pathSize = strlen_user((char *)
-			args->ARGS_MGR_REGISTEROBJECT.pszPathName) + 1;
-	pszPathName = MEM_Alloc(pathSize, MEM_NONPAGED);
-	if (!pszPathName)
+	/* path_size is increased by 1 to accommodate NULL */
+	path_size = strlen_user((char *)
+				args->args_mgr_registerobject.psz_path_name) +
+	    1;
+	psz_path_name = mem_alloc(path_size, MEM_NONPAGED);
+	if (!psz_path_name)
 		goto func_end;
-	retVal = strncpy_from_user(pszPathName,
-			(char *)args->ARGS_MGR_REGISTEROBJECT.pszPathName,
-			pathSize);
-	if (!retVal) {
+	ret = strncpy_from_user(psz_path_name,
+				(char *)args->args_mgr_registerobject.
+				psz_path_name, path_size);
+	if (!ret) {
 		status = DSP_EPOINTER;
 		goto func_end;
 	}
 
-	if (args->ARGS_MGR_REGISTEROBJECT.objType >= DSP_DCDMAXOBJTYPE)
+	if (args->args_mgr_registerobject.obj_type >= DSP_DCDMAXOBJTYPE)
 		return DSP_EINVALIDARG;
 
-	status = DCD_RegisterObject(&pUuid,
-				args->ARGS_MGR_REGISTEROBJECT.objType,
-				(char *)pszPathName);
+	status = dcd_register_object(&uuid_obj,
+				     args->args_mgr_registerobject.obj_type,
+				     (char *)psz_path_name);
 func_end:
-	kfree(pszPathName);
+	kfree(psz_path_name);
 	return status;
 }
 
 /*
- * ======== MGRWRAP_UnregisterObject ========
+ * ======== mgrwrap_unregister_object ========
  */
-u32 MGRWRAP_UnregisterObject(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_unregister_object(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_UUID pUuid;
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid uuid_obj;
 
-	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
+	CP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	status = DCD_UnregisterObject(&pUuid,
-			args->ARGS_MGR_UNREGISTEROBJECT.objType);
+	status = dcd_unregister_object(&uuid_obj,
+				       args->args_mgr_unregisterobject.
+				       obj_type);
 func_end:
 	return status;
 
 }
 
 /*
- * ======== MGRWRAP_WaitForBridgeEvents ========
+ * ======== mgrwrap_wait_for_bridge_events ========
  */
-u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_wait_for_bridge_events(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK, real_status = DSP_SOK;
-	struct DSP_NOTIFICATION *aNotifications[MAX_EVENTS];
-	struct DSP_NOTIFICATION notifications[MAX_EVENTS];
-	u32 uIndex, i;
-	u32 uCount = args->ARGS_MGR_WAIT.uCount;
+	dsp_status status = DSP_SOK, real_status = DSP_SOK;
+	struct dsp_notification *anotifications[MAX_EVENTS];
+	struct dsp_notification notifications[MAX_EVENTS];
+	u32 index, i;
+	u32 count = args->args_mgr_wait.count;
 
-	if (uCount > MAX_EVENTS)
+	if (count > MAX_EVENTS)
 		status = DSP_EINVALIDARG;
 
 	/* get the array of pointers to user structures */
-	cp_fm_usr(aNotifications, args->ARGS_MGR_WAIT.aNotifications,
-	 status, uCount);
+	CP_FM_USR(anotifications, args->args_mgr_wait.anotifications,
+		  status, count);
 	/* get the events */
-	for (i = 0; i < uCount; i++) {
-		cp_fm_usr(&notifications[i], aNotifications[i], status, 1);
+	for (i = 0; i < count; i++) {
+		CP_FM_USR(&notifications[i], anotifications[i], status, 1);
 		if (DSP_SUCCEEDED(status)) {
-			/* set the array of pointers to kernel structures*/
-			aNotifications[i] = &notifications[i];
+			/* set the array of pointers to kernel structures */
+			anotifications[i] = &notifications[i];
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		real_status = MGR_WaitForBridgeEvents(aNotifications, uCount,
-			 &uIndex, args->ARGS_MGR_WAIT.uTimeout);
+		real_status = mgr_wait_for_bridge_events(anotifications, count,
+							 &index,
+							 args->args_mgr_wait.
+							 utimeout);
 	}
-	cp_to_usr(args->ARGS_MGR_WAIT.puIndex, &uIndex, status, 1);
+	CP_TO_USR(args->args_mgr_wait.pu_index, &index, status, 1);
 	return real_status;
 }
 
-
 /*
  * ======== MGRWRAP_GetProcessResourceInfo ========
  */
-u32 __deprecated MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args,
-						void *pr_ctxt)
+u32 __deprecated mgrwrap_get_process_resources_info(union Trapped_Args * args,
+						    void *pr_ctxt)
 {
 	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_SOK;
 }
 
-
 /*
- * ======== PROCWRAP_Attach ========
+ * ======== procwrap_attach ========
  */
-u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_attach(union Trapped_Args *args, void *pr_ctxt)
 {
 	void *processor;
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_PROCESSORATTRIN attrIn, *pAttrIn = NULL;
+	dsp_status status = DSP_SOK;
+	struct dsp_processorattrin proc_attr_in, *attr_in = NULL;
 
 	/* Optional argument */
-	if (args->ARGS_PROC_ATTACH.pAttrIn) {
-		cp_fm_usr(&attrIn, args->ARGS_PROC_ATTACH.pAttrIn, status, 1);
+	if (args->args_proc_attach.attr_in) {
+		CP_FM_USR(&proc_attr_in, args->args_proc_attach.attr_in, status,
+			  1);
 		if (DSP_SUCCEEDED(status))
-			pAttrIn = &attrIn;
+			attr_in = &proc_attr_in;
 		else
 			goto func_end;
 
-
 	}
-	status = PROC_Attach(args->ARGS_PROC_ATTACH.uProcessor, pAttrIn,
-			    &processor, pr_ctxt);
-	cp_to_usr(args->ARGS_PROC_ATTACH.phProcessor, &processor, status, 1);
+	status = proc_attach(args->args_proc_attach.processor_id, attr_in,
+			     &processor, pr_ctxt);
+	CP_TO_USR(args->args_proc_attach.ph_processor, &processor, status, 1);
 func_end:
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Ctrl ========
+ * ======== procwrap_ctrl ========
  */
-u32 PROCWRAP_Ctrl(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_ctrl(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 cbDataSize, __user *pSize = (u32 __user *)
-			args->ARGS_PROC_CTRL.pArgs;
-	u8 *pArgs = NULL;
-	DSP_STATUS status = DSP_SOK;
+	u32 cb_data_size, __user * psize = (u32 __user *)
+	    args->args_proc_ctrl.pargs;
+	u8 *pargs = NULL;
+	dsp_status status = DSP_SOK;
 
-	if (pSize) {
-		if (get_user(cbDataSize, pSize)) {
+	if (psize) {
+		if (get_user(cb_data_size, psize)) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
-		cbDataSize += sizeof(u32);
-		pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
-		if (pArgs == NULL) {
+		cb_data_size += sizeof(u32);
+		pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
+		if (pargs == NULL) {
 			status = DSP_EMEMORY;
 			goto func_end;
 		}
 
-		cp_fm_usr(pArgs, args->ARGS_PROC_CTRL.pArgs, status,
-			 cbDataSize);
+		CP_FM_USR(pargs, args->args_proc_ctrl.pargs, status,
+			  cb_data_size);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = PROC_Ctrl(args->ARGS_PROC_CTRL.hProcessor,
-				  args->ARGS_PROC_CTRL.dwCmd,
-				  (struct DSP_CBDATA *)pArgs);
+		status = proc_ctrl(args->args_proc_ctrl.hprocessor,
+				   args->args_proc_ctrl.dw_cmd,
+				   (struct dsp_cbdata *)pargs);
 	}
 
-	/* cp_to_usr(args->ARGS_PROC_CTRL.pArgs, pArgs, status, 1);*/
-	kfree(pArgs);
+	/* CP_TO_USR(args->args_proc_ctrl.pargs, pargs, status, 1); */
+	kfree(pargs);
 func_end:
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Detach ========
+ * ======== procwrap_detach ========
  */
-u32 __deprecated PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated procwrap_detach(union Trapped_Args * args, void *pr_ctxt)
 {
-	/* PROC_Detach called at bridge_release only */
+	/* proc_detach called at bridge_release only */
 	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_SOK;
 }
 
 /*
- * ======== PROCWRAP_EnumNode_Info ========
+ * ======== procwrap_enum_node_info ========
  */
-u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	void *aNodeTab[MAX_NODES];
-	u32 uNumNodes;
-	u32 uAllocated;
+	dsp_status status;
+	void *node_tab[MAX_NODES];
+	u32 num_nodes;
+	u32 alloc_cnt;
 
-	if (!args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize)
+	if (!args->args_proc_enumnode_info.node_tab_size)
 		return DSP_ESIZE;
 
-	status = PROC_EnumNodes(args->ARGS_PROC_ENUMNODE_INFO.hProcessor,
-				aNodeTab,
-				args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize,
-				&uNumNodes, &uAllocated);
-	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.aNodeTab, aNodeTab, status,
-		 uNumNodes);
-	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.puNumNodes, &uNumNodes,
-		 status, 1);
-	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.puAllocated, &uAllocated,
-		 status, 1);
+	status = proc_enum_nodes(args->args_proc_enumnode_info.hprocessor,
+				 node_tab,
+				 args->args_proc_enumnode_info.node_tab_size,
+				 &num_nodes, &alloc_cnt);
+	CP_TO_USR(args->args_proc_enumnode_info.node_tab, node_tab, status,
+		  num_nodes);
+	CP_TO_USR(args->args_proc_enumnode_info.pu_num_nodes, &num_nodes,
+		  status, 1);
+	CP_TO_USR(args->args_proc_enumnode_info.pu_allocated, &alloc_cnt,
+		  status, 1);
 	return status;
 }
 
 /*
- * ======== PROCWRAP_FlushMemory ========
+ * ======== procwrap_flush_memory ========
  */
-u32 PROCWRAP_FlushMemory(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_flush_memory(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	if (args->ARGS_PROC_FLUSHMEMORY.ulFlags >
-					 PROC_WRBK_INV_ALL)
+	if (args->args_proc_flushmemory.ul_flags >
+	    PROC_WRITEBACK_INVALIDATE_MEM)
 		return DSP_EINVALIDARG;
 
-	status = PROC_FlushMemory(args->ARGS_PROC_FLUSHMEMORY.hProcessor,
-				 args->ARGS_PROC_FLUSHMEMORY.pMpuAddr,
-				 args->ARGS_PROC_FLUSHMEMORY.ulSize,
-				 args->ARGS_PROC_FLUSHMEMORY.ulFlags);
+	status = proc_flush_memory(args->args_proc_flushmemory.hprocessor,
+				   args->args_proc_flushmemory.pmpu_addr,
+				   args->args_proc_flushmemory.ul_size,
+				   args->args_proc_flushmemory.ul_flags);
 	return status;
 }
 
-
 /*
- * ======== PROCWRAP_InvalidateMemory ========
+ * ======== procwrap_invalidate_memory ========
  */
-u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_invalidate_memory(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	status = PROC_InvalidateMemory(
-				  args->ARGS_PROC_INVALIDATEMEMORY.hProcessor,
-				  args->ARGS_PROC_INVALIDATEMEMORY.pMpuAddr,
-				  args->ARGS_PROC_INVALIDATEMEMORY.ulSize);
+	status =
+	    proc_invalidate_memory(args->args_proc_invalidatememory.hprocessor,
+				   args->args_proc_invalidatememory.pmpu_addr,
+				   args->args_proc_invalidatememory.ul_size);
 	return status;
 }
 
-
 /*
- * ======== PROCWRAP_EnumResources ========
+ * ======== procwrap_enum_resources ========
  */
-u32 PROCWRAP_EnumResources(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_enum_resources(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_RESOURCEINFO pResourceInfo;
+	dsp_status status = DSP_SOK;
+	struct dsp_resourceinfo resource_info;
 
-	if (args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize <
-		sizeof(struct DSP_RESOURCEINFO))
+	if (args->args_proc_enumresources.resource_info_size <
+	    sizeof(struct dsp_resourceinfo))
 		return DSP_ESIZE;
 
-	status = PROC_GetResourceInfo(args->ARGS_PROC_ENUMRESOURCES.hProcessor,
-			args->ARGS_PROC_ENUMRESOURCES.uResourceType,
-			&pResourceInfo,
-			args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize);
+	status =
+	    proc_get_resource_info(args->args_proc_enumresources.hprocessor,
+				   args->args_proc_enumresources.resource_type,
+				   &resource_info,
+				   args->args_proc_enumresources.
+				   resource_info_size);
 
-	cp_to_usr(args->ARGS_PROC_ENUMRESOURCES.pResourceInfo, &pResourceInfo,
-						status, 1);
+	CP_TO_USR(args->args_proc_enumresources.resource_info, &resource_info,
+		  status, 1);
 
 	return status;
 
 }
 
 /*
- * ======== PROCWRAP_GetState ========
+ * ======== procwrap_get_state ========
  */
-u32 PROCWRAP_GetState(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_get_state(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	struct DSP_PROCESSORSTATE procStatus;
+	dsp_status status;
+	struct dsp_processorstate proc_state;
 
-	if (args->ARGS_PROC_GETSTATE.uStateInfoSize <
-		sizeof(struct DSP_PROCESSORSTATE))
+	if (args->args_proc_getstate.state_info_size <
+	    sizeof(struct dsp_processorstate))
 		return DSP_ESIZE;
 
-	status = PROC_GetState(args->ARGS_PROC_GETSTATE.hProcessor, &procStatus,
-			      args->ARGS_PROC_GETSTATE.uStateInfoSize);
-	cp_to_usr(args->ARGS_PROC_GETSTATE.pProcStatus, &procStatus, status, 1);
+	status =
+	    proc_get_state(args->args_proc_getstate.hprocessor, &proc_state,
+			   args->args_proc_getstate.state_info_size);
+	CP_TO_USR(args->args_proc_getstate.proc_state_obj, &proc_state, status,
+		  1);
 	return status;
 
 }
 
 /*
- * ======== PROCWRAP_GetTrace ========
+ * ======== procwrap_get_trace ========
  */
-u32 PROCWRAP_GetTrace(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_get_trace(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	u8 *pBuf;
+	dsp_status status;
+	u8 *pbuf;
 
-	if (args->ARGS_PROC_GETTRACE.uMaxSize > MAX_TRACEBUFLEN)
+	if (args->args_proc_gettrace.max_size > MAX_TRACEBUFLEN)
 		return DSP_ESIZE;
 
-	pBuf = MEM_Calloc(args->ARGS_PROC_GETTRACE.uMaxSize, MEM_NONPAGED);
-	if (pBuf != NULL) {
-		status = PROC_GetTrace(args->ARGS_PROC_GETTRACE.hProcessor,
-				      pBuf, args->ARGS_PROC_GETTRACE.uMaxSize);
+	pbuf = mem_calloc(args->args_proc_gettrace.max_size, MEM_NONPAGED);
+	if (pbuf != NULL) {
+		status = proc_get_trace(args->args_proc_gettrace.hprocessor,
+					pbuf,
+					args->args_proc_gettrace.max_size);
 	} else {
 		status = DSP_EMEMORY;
 	}
-	cp_to_usr(args->ARGS_PROC_GETTRACE.pBuf, pBuf, status,
-		 args->ARGS_PROC_GETTRACE.uMaxSize);
-	kfree(pBuf);
+	CP_TO_USR(args->args_proc_gettrace.pbuf, pbuf, status,
+		  args->args_proc_gettrace.max_size);
+	kfree(pbuf);
 
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Load ========
+ * ======== procwrap_load ========
  */
-u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt)
 {
 	s32 i, len;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	char *temp;
-	s32 count = args->ARGS_PROC_LOAD.iArgc;
+	s32 count = args->args_proc_load.argc_index;
 	u8 **argv = NULL, **envp = NULL;
 
 	if (count <= 0 || count > MAX_LOADARGS) {
@@ -791,13 +798,13 @@ u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
 		goto func_cont;
 	}
 
-	argv = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
+	argv = mem_alloc(count * sizeof(u8 *), MEM_NONPAGED);
 	if (!argv) {
 		status = DSP_EMEMORY;
 		goto func_cont;
 	}
 
-	cp_fm_usr(argv, args->ARGS_PROC_LOAD.aArgv, status, count);
+	CP_FM_USR(argv, args->args_proc_load.user_args, status, count);
 	if (DSP_FAILED(status)) {
 		kfree(argv);
 		argv = NULL;
@@ -807,13 +814,13 @@ u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
 	for (i = 0; i < count; i++) {
 		if (argv[i]) {
 			/* User space pointer to argument */
-			temp = (char *) argv[i];
+			temp = (char *)argv[i];
 			/* len is increased by 1 to accommodate NULL */
 			len = strlen_user((char *)temp) + 1;
 			/* Kernel space pointer to argument */
-			argv[i] = MEM_Alloc(len, MEM_NONPAGED);
+			argv[i] = mem_alloc(len, MEM_NONPAGED);
 			if (argv[i]) {
-				cp_fm_usr(argv[i], temp, status, len);
+				CP_FM_USR(argv[i], temp, status, len);
 				if (DSP_FAILED(status)) {
 					kfree(argv[i]);
 					argv[i] = NULL;
@@ -826,20 +833,20 @@ u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
 		}
 	}
 	/* TODO: validate this */
-	if (args->ARGS_PROC_LOAD.aEnvp) {
+	if (args->args_proc_load.user_envp) {
 		/* number of elements in the envp array including NULL */
 		count = 0;
 		do {
-			get_user(temp, args->ARGS_PROC_LOAD.aEnvp + count);
+			get_user(temp, args->args_proc_load.user_envp + count);
 			count++;
 		} while (temp);
-		envp = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
+		envp = mem_alloc(count * sizeof(u8 *), MEM_NONPAGED);
 		if (!envp) {
 			status = DSP_EMEMORY;
 			goto func_cont;
 		}
 
-		cp_fm_usr(envp, args->ARGS_PROC_LOAD.aEnvp, status, count);
+		CP_FM_USR(envp, args->args_proc_load.user_envp, status, count);
 		if (DSP_FAILED(status)) {
 			kfree(envp);
 			envp = NULL;
@@ -851,9 +858,9 @@ u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
 			/* len is increased by 1 to accommodate NULL */
 			len = strlen_user((char *)temp) + 1;
 			/* Kernel space pointer to argument */
-			envp[i] = MEM_Alloc(len, MEM_NONPAGED);
+			envp[i] = mem_alloc(len, MEM_NONPAGED);
 			if (envp[i]) {
-				cp_fm_usr(envp[i], temp, status, len);
+				CP_FM_USR(envp[i], temp, status, len);
 				if (DSP_FAILED(status)) {
 					kfree(envp[i]);
 					envp[i] = NULL;
@@ -867,9 +874,9 @@ u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		status = PROC_Load(args->ARGS_PROC_LOAD.hProcessor,
-				args->ARGS_PROC_LOAD.iArgc,
-				(CONST char **)argv, (CONST char **)envp);
+		status = proc_load(args->args_proc_load.hprocessor,
+				   args->args_proc_load.argc_index,
+				   (CONST char **)argv, (CONST char **)envp);
 	}
 func_cont:
 	if (envp) {
@@ -881,7 +888,7 @@ func_cont:
 	}
 
 	if (argv) {
-		count = args->ARGS_PROC_LOAD.iArgc;
+		count = args->args_proc_load.argc_index;
 		for (i = 0; (i < count) && argv[i]; i++)
 			kfree(argv[i]);
 
@@ -892,26 +899,26 @@ func_cont:
 }
 
 /*
- * ======== PROCWRAP_Map ========
+ * ======== procwrap_map ========
  */
-u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_map(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	void *pMapAddr;
+	dsp_status status;
+	void *map_addr;
 
-	if (!args->ARGS_PROC_MAPMEM.ulSize)
+	if (!args->args_proc_mapmem.ul_size)
 		return DSP_ESIZE;
 
-	status = PROC_Map(args->ARGS_PROC_MAPMEM.hProcessor,
-			 args->ARGS_PROC_MAPMEM.pMpuAddr,
-			 args->ARGS_PROC_MAPMEM.ulSize,
-			 args->ARGS_PROC_MAPMEM.pReqAddr, &pMapAddr,
-			 args->ARGS_PROC_MAPMEM.ulMapAttr, pr_ctxt);
+	status = proc_map(args->args_proc_mapmem.hprocessor,
+			  args->args_proc_mapmem.pmpu_addr,
+			  args->args_proc_mapmem.ul_size,
+			  args->args_proc_mapmem.req_addr, &map_addr,
+			  args->args_proc_mapmem.ul_map_attr, pr_ctxt);
 	if (DSP_SUCCEEDED(status)) {
-		if (put_user(pMapAddr, args->ARGS_PROC_MAPMEM.ppMapAddr)) {
+		if (put_user(map_addr, args->args_proc_mapmem.pp_map_addr)) {
 			status = DSP_EINVALIDARG;
-			PROC_UnMap(args->ARGS_PROC_MAPMEM.hProcessor,
-				pMapAddr, pr_ctxt);
+			proc_un_map(args->args_proc_mapmem.hprocessor,
+				    map_addr, pr_ctxt);
 		}
 
 	}
@@ -919,683 +926,688 @@ u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt)
 }
 
 /*
- * ======== PROCWRAP_RegisterNotify ========
+ * ======== procwrap_register_notify ========
  */
-u32 PROCWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	struct DSP_NOTIFICATION notification;
+	dsp_status status;
+	struct dsp_notification notification;
 
-	/* Initialize the notification data structure  */
-	notification.psName = NULL;
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
 	notification.handle = NULL;
 
-	status = PROC_RegisterNotify(args->ARGS_PROC_REGISTER_NOTIFY.hProcessor,
-				    args->ARGS_PROC_REGISTER_NOTIFY.uEventMask,
-				    args->ARGS_PROC_REGISTER_NOTIFY.uNotifyType,
-				    &notification);
-	cp_to_usr(args->ARGS_PROC_REGISTER_NOTIFY.hNotification, &notification,
-		 status, 1);
+	status =
+	    proc_register_notify(args->args_proc_register_notify.hprocessor,
+				 args->args_proc_register_notify.event_mask,
+				 args->args_proc_register_notify.notify_type,
+				 &notification);
+	CP_TO_USR(args->args_proc_register_notify.hnotification, &notification,
+		  status, 1);
 	return status;
 }
 
 /*
- * ======== PROCWRAP_ReserveMemory ========
+ * ======== procwrap_reserve_memory ========
  */
-u32 PROCWRAP_ReserveMemory(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	void *pRsvAddr;
+	dsp_status status;
+	void *prsv_addr;
 
-	if ((args->ARGS_PROC_RSVMEM.ulSize <= 0) ||
-		(args->ARGS_PROC_RSVMEM.ulSize & (PG_SIZE_4K - 1)) != 0)
+	if ((args->args_proc_rsvmem.ul_size <= 0) ||
+	    (args->args_proc_rsvmem.ul_size & (PG_SIZE4K - 1)) != 0)
 		return DSP_ESIZE;
 
-	status = PROC_ReserveMemory(args->ARGS_PROC_RSVMEM.hProcessor,
-				   args->ARGS_PROC_RSVMEM.ulSize, &pRsvAddr,
-				   pr_ctxt);
+	status = proc_reserve_memory(args->args_proc_rsvmem.hprocessor,
+				     args->args_proc_rsvmem.ul_size, &prsv_addr,
+				     pr_ctxt);
 	if (DSP_SUCCEEDED(status)) {
-		if (put_user(pRsvAddr, args->ARGS_PROC_RSVMEM.ppRsvAddr)) {
+		if (put_user(prsv_addr, args->args_proc_rsvmem.pp_rsv_addr)) {
 			status = DSP_EINVALIDARG;
-			PROC_UnReserveMemory(args->ARGS_PROC_RSVMEM.hProcessor,
-				pRsvAddr, pr_ctxt);
+			proc_un_reserve_memory(args->args_proc_rsvmem.
+					       hprocessor, prsv_addr, pr_ctxt);
 		}
 	}
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Start ========
+ * ======== procwrap_start ========
  */
-u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_start(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = PROC_Start(args->ARGS_PROC_START.hProcessor);
-	return retVal;
+	ret = proc_start(args->args_proc_start.hprocessor);
+	return ret;
 }
 
 /*
- * ======== PROCWRAP_UnMap ========
+ * ======== procwrap_un_map ========
  */
-u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_un_map(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	status = PROC_UnMap(args->ARGS_PROC_UNMAPMEM.hProcessor,
-			   args->ARGS_PROC_UNMAPMEM.pMapAddr, pr_ctxt);
+	status = proc_un_map(args->args_proc_unmapmem.hprocessor,
+			     args->args_proc_unmapmem.map_addr, pr_ctxt);
 	return status;
 }
 
 /*
- * ======== PROCWRAP_UnReserveMemory ========
+ * ======== procwrap_un_reserve_memory ========
  */
-u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_un_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	status = PROC_UnReserveMemory(args->ARGS_PROC_UNRSVMEM.hProcessor,
-			     args->ARGS_PROC_UNRSVMEM.pRsvAddr, pr_ctxt);
+	status = proc_un_reserve_memory(args->args_proc_unrsvmem.hprocessor,
+					args->args_proc_unrsvmem.prsv_addr,
+					pr_ctxt);
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Stop ========
+ * ======== procwrap_stop ========
  */
-u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_stop(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = PROC_Stop(args->ARGS_PROC_STOP.hProcessor);
+	ret = proc_stop(args->args_proc_stop.hprocessor);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_Allocate ========
+ * ======== nodewrap_allocate ========
  */
-u32 NODEWRAP_Allocate(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_UUID nodeId;
-	u32 cbDataSize = 0;
-	u32 __user *pSize = (u32 __user *)args->ARGS_NODE_ALLOCATE.pArgs;
-	u8 *pArgs = NULL;
-	struct DSP_NODEATTRIN attrIn, *pAttrIn = NULL;
-	struct NODE_OBJECT *hNode;
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid node_uuid;
+	u32 cb_data_size = 0;
+	u32 __user *psize = (u32 __user *) args->args_node_allocate.pargs;
+	u8 *pargs = NULL;
+	struct dsp_nodeattrin proc_attr_in, *attr_in = NULL;
+	struct node_object *hnode;
 
 	/* Optional argument */
-	if (pSize) {
-		if (get_user(cbDataSize, pSize))
+	if (psize) {
+		if (get_user(cb_data_size, psize))
 			status = DSP_EFAIL;
 
-		cbDataSize += sizeof(u32);
+		cb_data_size += sizeof(u32);
 		if (DSP_SUCCEEDED(status)) {
-			pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
-			if (pArgs == NULL)
+			pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
+			if (pargs == NULL)
 				status = DSP_EMEMORY;
 
 		}
-		cp_fm_usr(pArgs, args->ARGS_NODE_ALLOCATE.pArgs, status,
-			 cbDataSize);
+		CP_FM_USR(pargs, args->args_node_allocate.pargs, status,
+			  cb_data_size);
 	}
-	cp_fm_usr(&nodeId, args->ARGS_NODE_ALLOCATE.pNodeID, status, 1);
+	CP_FM_USR(&node_uuid, args->args_node_allocate.node_id_ptr, status, 1);
 	if (DSP_FAILED(status))
 		goto func_cont;
 	/* Optional argument */
-	if (args->ARGS_NODE_ALLOCATE.pAttrIn) {
-		cp_fm_usr(&attrIn, args->ARGS_NODE_ALLOCATE.pAttrIn, status, 1);
+	if (args->args_node_allocate.attr_in) {
+		CP_FM_USR(&proc_attr_in, args->args_node_allocate.attr_in,
+			  status, 1);
 		if (DSP_SUCCEEDED(status))
-			pAttrIn = &attrIn;
+			attr_in = &proc_attr_in;
 		else
 			status = DSP_EMEMORY;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_Allocate(args->ARGS_NODE_ALLOCATE.hProcessor,
-				      &nodeId, (struct DSP_CBDATA *)pArgs,
-				      pAttrIn, &hNode, pr_ctxt);
+		status = node_allocate(args->args_node_allocate.hprocessor,
+				       &node_uuid, (struct dsp_cbdata *)pargs,
+				       attr_in, &hnode, pr_ctxt);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		cp_to_usr(args->ARGS_NODE_ALLOCATE.phNode, &hNode, status, 1);
+		CP_TO_USR(args->args_node_allocate.ph_node, &hnode, status, 1);
 		if (DSP_FAILED(status)) {
 			status = DSP_EPOINTER;
-			NODE_Delete(hNode, pr_ctxt);
+			node_delete(hnode, pr_ctxt);
 		}
 	}
 func_cont:
-	kfree(pArgs);
+	kfree(pargs);
 
 	return status;
 }
 
 /*
- *  ======== NODEWRAP_AllocMsgBuf ========
+ *  ======== nodewrap_alloc_msg_buf ========
  */
-u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_alloc_msg_buf(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_BUFFERATTR *pAttr = NULL;
-	struct DSP_BUFFERATTR attr;
-	u8 *pBuffer = NULL;
+	dsp_status status = DSP_SOK;
+	struct dsp_bufferattr *pattr = NULL;
+	struct dsp_bufferattr attr;
+	u8 *pbuffer = NULL;
 
-	if (!args->ARGS_NODE_ALLOCMSGBUF.uSize)
+	if (!args->args_node_allocmsgbuf.usize)
 		return DSP_ESIZE;
 
-	if (args->ARGS_NODE_ALLOCMSGBUF.pAttr) {	/* Optional argument */
-		cp_fm_usr(&attr, args->ARGS_NODE_ALLOCMSGBUF.pAttr, status, 1);
+	if (args->args_node_allocmsgbuf.pattr) {	/* Optional argument */
+		CP_FM_USR(&attr, args->args_node_allocmsgbuf.pattr, status, 1);
 		if (DSP_SUCCEEDED(status))
-			pAttr = &attr;
+			pattr = &attr;
 
 	}
 	/* IN OUT argument */
-	cp_fm_usr(&pBuffer, args->ARGS_NODE_ALLOCMSGBUF.pBuffer, status, 1);
+	CP_FM_USR(&pbuffer, args->args_node_allocmsgbuf.pbuffer, status, 1);
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_AllocMsgBuf(args->ARGS_NODE_ALLOCMSGBUF.hNode,
-					 args->ARGS_NODE_ALLOCMSGBUF.uSize,
-					 pAttr, &pBuffer);
+		status = node_alloc_msg_buf(args->args_node_allocmsgbuf.hnode,
+					    args->args_node_allocmsgbuf.usize,
+					    pattr, &pbuffer);
 	}
-	cp_to_usr(args->ARGS_NODE_ALLOCMSGBUF.pBuffer, &pBuffer, status, 1);
+	CP_TO_USR(args->args_node_allocmsgbuf.pbuffer, &pbuffer, status, 1);
 	return status;
 }
 
 /*
- * ======== NODEWRAP_ChangePriority ========
+ * ======== nodewrap_change_priority ========
  */
-u32 NODEWRAP_ChangePriority(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_change_priority(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = NODE_ChangePriority(args->ARGS_NODE_CHANGEPRIORITY.hNode,
-			args->ARGS_NODE_CHANGEPRIORITY.iPriority);
+	ret = node_change_priority(args->args_node_changepriority.hnode,
+				   args->args_node_changepriority.prio);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_Connect ========
+ * ======== nodewrap_connect ========
  */
-u32 NODEWRAP_Connect(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_connect(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_STRMATTR attrs;
-	struct DSP_STRMATTR *pAttrs = NULL;
-	u32 cbDataSize;
-	u32 __user *pSize = (u32 __user *)args->ARGS_NODE_CONNECT.pConnParam;
-	u8 *pArgs = NULL;
+	dsp_status status = DSP_SOK;
+	struct dsp_strmattr attrs;
+	struct dsp_strmattr *pattrs = NULL;
+	u32 cb_data_size;
+	u32 __user *psize = (u32 __user *) args->args_node_connect.conn_param;
+	u8 *pargs = NULL;
 
 	/* Optional argument */
-	if (pSize) {
-		if (get_user(cbDataSize, pSize))
+	if (psize) {
+		if (get_user(cb_data_size, psize))
 			status = DSP_EFAIL;
 
-		cbDataSize += sizeof(u32);
+		cb_data_size += sizeof(u32);
 		if (DSP_SUCCEEDED(status)) {
-			pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
-			if (pArgs == NULL) {
+			pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
+			if (pargs == NULL) {
 				status = DSP_EMEMORY;
 				goto func_cont;
 			}
 
 		}
-		cp_fm_usr(pArgs, args->ARGS_NODE_CONNECT.pConnParam, status,
-			 cbDataSize);
+		CP_FM_USR(pargs, args->args_node_connect.conn_param, status,
+			  cb_data_size);
 		if (DSP_FAILED(status))
 			goto func_cont;
 	}
-	if (args->ARGS_NODE_CONNECT.pAttrs) {	/* Optional argument */
-		cp_fm_usr(&attrs, args->ARGS_NODE_CONNECT.pAttrs, status, 1);
+	if (args->args_node_connect.pattrs) {	/* Optional argument */
+		CP_FM_USR(&attrs, args->args_node_connect.pattrs, status, 1);
 		if (DSP_SUCCEEDED(status))
-			pAttrs = &attrs;
+			pattrs = &attrs;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_Connect(args->ARGS_NODE_CONNECT.hNode,
-				     args->ARGS_NODE_CONNECT.uStream,
-				     args->ARGS_NODE_CONNECT.hOtherNode,
-				     args->ARGS_NODE_CONNECT.uOtherStream,
-				     pAttrs, (struct DSP_CBDATA *)pArgs);
+		status = node_connect(args->args_node_connect.hnode,
+				      args->args_node_connect.stream_id,
+				      args->args_node_connect.other_node,
+				      args->args_node_connect.other_stream,
+				      pattrs, (struct dsp_cbdata *)pargs);
 	}
 func_cont:
-	kfree(pArgs);
+	kfree(pargs);
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_Create ========
+ * ======== nodewrap_create ========
  */
-u32 NODEWRAP_Create(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_create(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = NODE_Create(args->ARGS_NODE_CREATE.hNode);
+	ret = node_create(args->args_node_create.hnode);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_Delete ========
+ * ======== nodewrap_delete ========
  */
-u32 NODEWRAP_Delete(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_delete(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = NODE_Delete(args->ARGS_NODE_DELETE.hNode, pr_ctxt);
+	ret = node_delete(args->args_node_delete.hnode, pr_ctxt);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== NODEWRAP_FreeMsgBuf ========
+ *  ======== nodewrap_free_msg_buf ========
  */
-u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_free_msg_buf(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_BUFFERATTR *pAttr = NULL;
-	struct DSP_BUFFERATTR attr;
-	if (args->ARGS_NODE_FREEMSGBUF.pAttr) {	/* Optional argument */
-		cp_fm_usr(&attr, args->ARGS_NODE_FREEMSGBUF.pAttr, status, 1);
+	dsp_status status = DSP_SOK;
+	struct dsp_bufferattr *pattr = NULL;
+	struct dsp_bufferattr attr;
+	if (args->args_node_freemsgbuf.pattr) {	/* Optional argument */
+		CP_FM_USR(&attr, args->args_node_freemsgbuf.pattr, status, 1);
 		if (DSP_SUCCEEDED(status))
-			pAttr = &attr;
+			pattr = &attr;
 
 	}
 
-	if (!args->ARGS_NODE_FREEMSGBUF.pBuffer)
+	if (!args->args_node_freemsgbuf.pbuffer)
 		return DSP_EPOINTER;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_FreeMsgBuf(args->ARGS_NODE_FREEMSGBUF.hNode,
-					args->ARGS_NODE_FREEMSGBUF.pBuffer,
-					pAttr);
+		status = node_free_msg_buf(args->args_node_freemsgbuf.hnode,
+					   args->args_node_freemsgbuf.pbuffer,
+					   pattr);
 	}
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_GetAttr ========
+ * ======== nodewrap_get_attr ========
  */
-u32 NODEWRAP_GetAttr(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_get_attr(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_NODEATTR attr;
+	dsp_status status = DSP_SOK;
+	struct dsp_nodeattr attr;
 
-	status = NODE_GetAttr(args->ARGS_NODE_GETATTR.hNode, &attr,
-			     args->ARGS_NODE_GETATTR.uAttrSize);
-	cp_to_usr(args->ARGS_NODE_GETATTR.pAttr, &attr, status, 1);
+	status = node_get_attr(args->args_node_getattr.hnode, &attr,
+			       args->args_node_getattr.attr_size);
+	CP_TO_USR(args->args_node_getattr.pattr, &attr, status, 1);
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_GetMessage ========
+ * ======== nodewrap_get_message ========
  */
-u32 NODEWRAP_GetMessage(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_get_message(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	struct DSP_MSG msg;
+	dsp_status status;
+	struct dsp_msg msg;
 
-	status = NODE_GetMessage(args->ARGS_NODE_GETMESSAGE.hNode, &msg,
-				args->ARGS_NODE_GETMESSAGE.uTimeout);
+	status = node_get_message(args->args_node_getmessage.hnode, &msg,
+				  args->args_node_getmessage.utimeout);
 
-	cp_to_usr(args->ARGS_NODE_GETMESSAGE.pMessage, &msg, status, 1);
+	CP_TO_USR(args->args_node_getmessage.message, &msg, status, 1);
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_Pause ========
+ * ======== nodewrap_pause ========
  */
-u32 NODEWRAP_Pause(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_pause(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = NODE_Pause(args->ARGS_NODE_PAUSE.hNode);
+	ret = node_pause(args->args_node_pause.hnode);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_PutMessage ========
+ * ======== nodewrap_put_message ========
  */
-u32 NODEWRAP_PutMessage(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_put_message(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_MSG msg;
+	dsp_status status = DSP_SOK;
+	struct dsp_msg msg;
 
-	cp_fm_usr(&msg, args->ARGS_NODE_PUTMESSAGE.pMessage, status, 1);
+	CP_FM_USR(&msg, args->args_node_putmessage.message, status, 1);
 
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_PutMessage(args->ARGS_NODE_PUTMESSAGE.hNode, &msg,
-					args->ARGS_NODE_PUTMESSAGE.uTimeout);
+		status =
+		    node_put_message(args->args_node_putmessage.hnode, &msg,
+				     args->args_node_putmessage.utimeout);
 	}
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_RegisterNotify ========
+ * ======== nodewrap_register_notify ========
  */
-u32 NODEWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_NOTIFICATION notification;
+	dsp_status status = DSP_SOK;
+	struct dsp_notification notification;
 
-	/* Initialize the notification data structure  */
-	notification.psName = NULL;
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
 	notification.handle = NULL;
 
-	if (!args->ARGS_PROC_REGISTER_NOTIFY.uEventMask)
-		cp_fm_usr(&notification,
-			args->ARGS_PROC_REGISTER_NOTIFY.hNotification,
-			status, 1);
-
-	status = NODE_RegisterNotify(args->ARGS_NODE_REGISTERNOTIFY.hNode,
-				    args->ARGS_NODE_REGISTERNOTIFY.uEventMask,
-				    args->ARGS_NODE_REGISTERNOTIFY.uNotifyType,
-				    &notification);
-	cp_to_usr(args->ARGS_NODE_REGISTERNOTIFY.hNotification, &notification,
-		 status, 1);
+	if (!args->args_proc_register_notify.event_mask)
+		CP_FM_USR(&notification,
+			  args->args_proc_register_notify.hnotification,
+			  status, 1);
+
+	status = node_register_notify(args->args_node_registernotify.hnode,
+				      args->args_node_registernotify.event_mask,
+				      args->args_node_registernotify.
+				      notify_type, &notification);
+	CP_TO_USR(args->args_node_registernotify.hnotification, &notification,
+		  status, 1);
 	return status;
 }
 
 /*
- * ======== NODEWRAP_Run ========
+ * ======== nodewrap_run ========
  */
-u32 NODEWRAP_Run(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_run(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = NODE_Run(args->ARGS_NODE_RUN.hNode);
+	ret = node_run(args->args_node_run.hnode);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_Terminate ========
+ * ======== nodewrap_terminate ========
  */
-u32 NODEWRAP_Terminate(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_terminate(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	DSP_STATUS tempstatus;
+	dsp_status status;
+	dsp_status tempstatus;
 
-	status = NODE_Terminate(args->ARGS_NODE_TERMINATE.hNode, &tempstatus);
+	status = node_terminate(args->args_node_terminate.hnode, &tempstatus);
 
-	cp_to_usr(args->ARGS_NODE_TERMINATE.pStatus, &tempstatus, status, 1);
+	CP_TO_USR(args->args_node_terminate.pstatus, &tempstatus, status, 1);
 
 	return status;
 }
 
-
 /*
- * ======== NODEWRAP_GetUUIDProps ========
+ * ======== nodewrap_get_uuid_props ========
  */
-u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_get_uuid_props(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_UUID nodeId;
-	struct DSP_NDBPROPS    *pnodeProps = NULL;
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid node_uuid;
+	struct dsp_ndbprops *pnode_props = NULL;
 
-	cp_fm_usr(&nodeId, args->ARGS_NODE_GETUUIDPROPS.pNodeID, status, 1);
+	CP_FM_USR(&node_uuid, args->args_node_getuuidprops.node_id_ptr, status,
+		  1);
 	if (DSP_FAILED(status))
 		goto func_cont;
-	pnodeProps = MEM_Alloc(sizeof(struct DSP_NDBPROPS), MEM_NONPAGED);
-	if (pnodeProps != NULL) {
-		status = NODE_GetUUIDProps(args->
-					  ARGS_NODE_GETUUIDPROPS.hProcessor,
-					  &nodeId, pnodeProps);
-		cp_to_usr(args->ARGS_NODE_GETUUIDPROPS.pNodeProps, pnodeProps,
-			 status, 1);
+	pnode_props = mem_alloc(sizeof(struct dsp_ndbprops), MEM_NONPAGED);
+	if (pnode_props != NULL) {
+		status =
+		    node_get_uuid_props(args->args_node_getuuidprops.hprocessor,
+					&node_uuid, pnode_props);
+		CP_TO_USR(args->args_node_getuuidprops.node_props, pnode_props,
+			  status, 1);
 	} else
 		status = DSP_EMEMORY;
 func_cont:
-	kfree(pnodeProps);
+	kfree(pnode_props);
 	return status;
 }
 
 /*
- * ======== STRMWRAP_AllocateBuffer ========
+ * ======== strmwrap_allocate_buffer ========
  */
-u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_allocate_buffer(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	u8 **apBuffer = NULL;
-	u32 uNumBufs = args->ARGS_STRM_ALLOCATEBUFFER.uNumBufs;
+	dsp_status status;
+	u8 **ap_buffer = NULL;
+	u32 num_bufs = args->args_strm_allocatebuffer.num_bufs;
 
-	if (uNumBufs > MAX_BUFS)
+	if (num_bufs > MAX_BUFS)
 		return DSP_EINVALIDARG;
 
-	apBuffer = MEM_Alloc((uNumBufs * sizeof(u8 *)), MEM_NONPAGED);
+	ap_buffer = mem_alloc((num_bufs * sizeof(u8 *)), MEM_NONPAGED);
 
-	status = STRM_AllocateBuffer(args->ARGS_STRM_ALLOCATEBUFFER.hStream,
-				     args->ARGS_STRM_ALLOCATEBUFFER.uSize,
-				     apBuffer, uNumBufs, pr_ctxt);
+	status = strm_allocate_buffer(args->args_strm_allocatebuffer.hstream,
+				      args->args_strm_allocatebuffer.usize,
+				      ap_buffer, num_bufs, pr_ctxt);
 	if (DSP_SUCCEEDED(status)) {
-		cp_to_usr(args->ARGS_STRM_ALLOCATEBUFFER.apBuffer, apBuffer,
-			status, uNumBufs);
+		CP_TO_USR(args->args_strm_allocatebuffer.ap_buffer, ap_buffer,
+			  status, num_bufs);
 		if (DSP_FAILED(status)) {
 			status = DSP_EPOINTER;
-			STRM_FreeBuffer(
-				args->ARGS_STRM_ALLOCATEBUFFER.hStream,
-				apBuffer, uNumBufs, pr_ctxt);
+			strm_free_buffer(args->args_strm_allocatebuffer.hstream,
+					 ap_buffer, num_bufs, pr_ctxt);
 		}
 	}
-	kfree(apBuffer);
+	kfree(ap_buffer);
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Close ========
+ * ======== strmwrap_close ========
  */
-u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_close(union Trapped_Args *args, void *pr_ctxt)
 {
-	return STRM_Close(args->ARGS_STRM_CLOSE.hStream, pr_ctxt);
+	return strm_close(args->args_strm_close.hstream, pr_ctxt);
 }
 
 /*
- * ======== STRMWRAP_FreeBuffer ========
+ * ======== strmwrap_free_buffer ========
  */
-u32 STRMWRAP_FreeBuffer(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_free_buffer(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	u8 **apBuffer = NULL;
-	u32 uNumBufs = args->ARGS_STRM_FREEBUFFER.uNumBufs;
+	dsp_status status = DSP_SOK;
+	u8 **ap_buffer = NULL;
+	u32 num_bufs = args->args_strm_freebuffer.num_bufs;
 
-	if (uNumBufs > MAX_BUFS)
+	if (num_bufs > MAX_BUFS)
 		return DSP_EINVALIDARG;
 
-	apBuffer = MEM_Alloc((uNumBufs * sizeof(u8 *)), MEM_NONPAGED);
+	ap_buffer = mem_alloc((num_bufs * sizeof(u8 *)), MEM_NONPAGED);
 
-	cp_fm_usr(apBuffer, args->ARGS_STRM_FREEBUFFER.apBuffer, status,
-		 uNumBufs);
+	CP_FM_USR(ap_buffer, args->args_strm_freebuffer.ap_buffer, status,
+		  num_bufs);
 
 	if (DSP_SUCCEEDED(status)) {
-		status = STRM_FreeBuffer(args->ARGS_STRM_FREEBUFFER.hStream,
-					 apBuffer, uNumBufs, pr_ctxt);
+		status = strm_free_buffer(args->args_strm_freebuffer.hstream,
+					  ap_buffer, num_bufs, pr_ctxt);
 	}
-	cp_to_usr(args->ARGS_STRM_FREEBUFFER.apBuffer, apBuffer, status,
-		 uNumBufs);
-	kfree(apBuffer);
+	CP_TO_USR(args->args_strm_freebuffer.ap_buffer, ap_buffer, status,
+		  num_bufs);
+	kfree(ap_buffer);
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_GetEventHandle ========
+ * ======== strmwrap_get_event_handle ========
  */
-u32 __deprecated STRMWRAP_GetEventHandle(union Trapped_Args *args,
-					void *pr_ctxt)
+u32 __deprecated strmwrap_get_event_handle(union Trapped_Args * args,
+					   void *pr_ctxt)
 {
 	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_ENOTIMPL;
 }
 
 /*
- * ======== STRMWRAP_GetInfo ========
+ * ======== strmwrap_get_info ========
  */
-u32 STRMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_get_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_INFO strmInfo;
-	struct DSP_STREAMINFO user;
-	struct DSP_STREAMINFO *temp;
+	dsp_status status = DSP_SOK;
+	struct stream_info strm_info;
+	struct dsp_streaminfo user;
+	struct dsp_streaminfo *temp;
 
-	cp_fm_usr(&strmInfo, args->ARGS_STRM_GETINFO.pStreamInfo, status, 1);
-	temp = strmInfo.pUser;
+	CP_FM_USR(&strm_info, args->args_strm_getinfo.stream_info, status, 1);
+	temp = strm_info.user_strm;
 
-	strmInfo.pUser = &user;
+	strm_info.user_strm = &user;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = STRM_GetInfo(args->ARGS_STRM_GETINFO.hStream,
-			 &strmInfo, args->ARGS_STRM_GETINFO.uStreamInfoSize);
+		status = strm_get_info(args->args_strm_getinfo.hstream,
+				       &strm_info,
+				       args->args_strm_getinfo.
+				       stream_info_size);
 	}
-	cp_to_usr(temp, strmInfo.pUser, status, 1);
-	strmInfo.pUser = temp;
-	cp_to_usr(args->ARGS_STRM_GETINFO.pStreamInfo, &strmInfo, status, 1);
+	CP_TO_USR(temp, strm_info.user_strm, status, 1);
+	strm_info.user_strm = temp;
+	CP_TO_USR(args->args_strm_getinfo.stream_info, &strm_info, status, 1);
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Idle ========
+ * ======== strmwrap_idle ========
  */
-u32 STRMWRAP_Idle(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_idle(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = STRM_Idle(args->ARGS_STRM_IDLE.hStream,
-			args->ARGS_STRM_IDLE.bFlush);
+	ret = strm_idle(args->args_strm_idle.hstream,
+			args->args_strm_idle.flush_flag);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== STRMWRAP_Issue ========
+ * ======== strmwrap_issue ========
  */
-u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_issue(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	if (!args->ARGS_STRM_ISSUE.pBuffer)
+	if (!args->args_strm_issue.pbuffer)
 		return DSP_EPOINTER;
 
-	/* No need of doing cp_fm_usr for the user buffer (pBuffer)
-	as this is done in Bridge internal function WMD_CHNL_AddIOReq
-	in chnl_sm.c */
-	status = STRM_Issue(args->ARGS_STRM_ISSUE.hStream,
-			args->ARGS_STRM_ISSUE.pBuffer,
-			args->ARGS_STRM_ISSUE.dwBytes,
-			args->ARGS_STRM_ISSUE.dwBufSize,
-			args->ARGS_STRM_ISSUE.dwArg);
+	/* No need of doing CP_FM_USR for the user buffer (pbuffer)
+	   as this is done in Bridge internal function bridge_chnl_add_io_req
+	   in chnl_sm.c */
+	status = strm_issue(args->args_strm_issue.hstream,
+			    args->args_strm_issue.pbuffer,
+			    args->args_strm_issue.dw_bytes,
+			    args->args_strm_issue.dw_buf_size,
+			    args->args_strm_issue.dw_arg);
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Open ========
+ * ======== strmwrap_open ========
  */
-u32 STRMWRAP_Open(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_open(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_ATTR attr;
-	struct STRM_OBJECT *pStrm;
-	struct DSP_STREAMATTRIN strmAttrIn;
+	dsp_status status = DSP_SOK;
+	struct strm_attr attr;
+	struct strm_object *strm_obj;
+	struct dsp_streamattrin strm_attr_in;
 
-	cp_fm_usr(&attr, args->ARGS_STRM_OPEN.pAttrIn, status, 1);
+	CP_FM_USR(&attr, args->args_strm_open.attr_in, status, 1);
 
-	if (attr.pStreamAttrIn != NULL) {	/* Optional argument */
-		cp_fm_usr(&strmAttrIn, attr.pStreamAttrIn, status, 1);
+	if (attr.stream_attr_in != NULL) {	/* Optional argument */
+		CP_FM_USR(&strm_attr_in, attr.stream_attr_in, status, 1);
 		if (DSP_SUCCEEDED(status)) {
-			attr.pStreamAttrIn = &strmAttrIn;
-			if (attr.pStreamAttrIn->lMode == STRMMODE_LDMA)
+			attr.stream_attr_in = &strm_attr_in;
+			if (attr.stream_attr_in->strm_mode == STRMMODE_LDMA)
 				return DSP_ENOTIMPL;
 		}
 
 	}
-	status = STRM_Open(args->ARGS_STRM_OPEN.hNode,
-			  args->ARGS_STRM_OPEN.uDirection,
-			  args->ARGS_STRM_OPEN.uIndex, &attr, &pStrm,
-			  pr_ctxt);
-	cp_to_usr(args->ARGS_STRM_OPEN.phStream, &pStrm, status, 1);
+	status = strm_open(args->args_strm_open.hnode,
+			   args->args_strm_open.direction,
+			   args->args_strm_open.index, &attr, &strm_obj,
+			   pr_ctxt);
+	CP_TO_USR(args->args_strm_open.ph_stream, &strm_obj, status, 1);
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Reclaim ========
+ * ======== strmwrap_reclaim ========
  */
-u32 STRMWRAP_Reclaim(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_reclaim(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	u8 *pBufPtr;
-	u32 ulBytes;
-	u32 dwArg;
-	u32 ulBufSize;
-
-	status = STRM_Reclaim(args->ARGS_STRM_RECLAIM.hStream, &pBufPtr,
-			     &ulBytes, &ulBufSize, &dwArg);
-	cp_to_usr(args->ARGS_STRM_RECLAIM.pBufPtr, &pBufPtr, status, 1);
-	cp_to_usr(args->ARGS_STRM_RECLAIM.pBytes, &ulBytes, status, 1);
-	cp_to_usr(args->ARGS_STRM_RECLAIM.pdwArg, &dwArg, status, 1);
-
-	if (args->ARGS_STRM_RECLAIM.pBufSize != NULL) {
-		cp_to_usr(args->ARGS_STRM_RECLAIM.pBufSize, &ulBufSize,
-			 status, 1);
+	dsp_status status = DSP_SOK;
+	u8 *buf_ptr;
+	u32 ul_bytes;
+	u32 dw_arg;
+	u32 ul_buf_size;
+
+	status = strm_reclaim(args->args_strm_reclaim.hstream, &buf_ptr,
+			      &ul_bytes, &ul_buf_size, &dw_arg);
+	CP_TO_USR(args->args_strm_reclaim.buf_ptr, &buf_ptr, status, 1);
+	CP_TO_USR(args->args_strm_reclaim.bytes, &ul_bytes, status, 1);
+	CP_TO_USR(args->args_strm_reclaim.pdw_arg, &dw_arg, status, 1);
+
+	if (args->args_strm_reclaim.buf_size_ptr != NULL) {
+		CP_TO_USR(args->args_strm_reclaim.buf_size_ptr, &ul_buf_size,
+			  status, 1);
 	}
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_RegisterNotify ========
+ * ======== strmwrap_register_notify ========
  */
-u32 STRMWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_NOTIFICATION notification;
+	dsp_status status = DSP_SOK;
+	struct dsp_notification notification;
 
-	/* Initialize the notification data structure  */
-	notification.psName = NULL;
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
 	notification.handle = NULL;
 
-	status = STRM_RegisterNotify(args->ARGS_STRM_REGISTERNOTIFY.hStream,
-				    args->ARGS_STRM_REGISTERNOTIFY.uEventMask,
-				    args->ARGS_STRM_REGISTERNOTIFY.uNotifyType,
-				    &notification);
-	cp_to_usr(args->ARGS_STRM_REGISTERNOTIFY.hNotification, &notification,
-		 status, 1);
+	status = strm_register_notify(args->args_strm_registernotify.hstream,
+				      args->args_strm_registernotify.event_mask,
+				      args->args_strm_registernotify.
+				      notify_type, &notification);
+	CP_TO_USR(args->args_strm_registernotify.hnotification, &notification,
+		  status, 1);
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Select ========
+ * ======== strmwrap_select ========
  */
-u32 STRMWRAP_Select(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_select(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 mask;
-	struct STRM_OBJECT *aStrmTab[MAX_STREAMS];
-	DSP_STATUS status = DSP_SOK;
+	struct strm_object *strm_tab[MAX_STREAMS];
+	dsp_status status = DSP_SOK;
 
-	if (args->ARGS_STRM_SELECT.nStreams > MAX_STREAMS)
+	if (args->args_strm_select.strm_num > MAX_STREAMS)
 		return DSP_EINVALIDARG;
 
-	cp_fm_usr(aStrmTab, args->ARGS_STRM_SELECT.aStreamTab, status,
-		 args->ARGS_STRM_SELECT.nStreams);
+	CP_FM_USR(strm_tab, args->args_strm_select.stream_tab, status,
+		  args->args_strm_select.strm_num);
 	if (DSP_SUCCEEDED(status)) {
-		status = STRM_Select(aStrmTab, args->ARGS_STRM_SELECT.nStreams,
-				    &mask, args->ARGS_STRM_SELECT.uTimeout);
+		status = strm_select(strm_tab, args->args_strm_select.strm_num,
+				     &mask, args->args_strm_select.utimeout);
 	}
-	cp_to_usr(args->ARGS_STRM_SELECT.pMask, &mask, status, 1);
+	CP_TO_USR(args->args_strm_select.pmask, &mask, status, 1);
 	return status;
 }
 
 /* CMM */
 
 /*
- * ======== CMMWRAP_CallocBuf ========
+ * ======== cmmwrap_calloc_buf ========
  */
-u32 __deprecated CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated cmmwrap_calloc_buf(union Trapped_Args * args, void *pr_ctxt)
 {
 	/* This operation is done in kernel */
 	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
@@ -1603,9 +1615,9 @@ u32 __deprecated CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt)
 }
 
 /*
- * ======== CMMWRAP_FreeBuf ========
+ * ======== cmmwrap_free_buf ========
  */
-u32 __deprecated CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated cmmwrap_free_buf(union Trapped_Args * args, void *pr_ctxt)
 {
 	/* This operation is done in kernel */
 	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
@@ -1613,31 +1625,32 @@ u32 __deprecated CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt)
 }
 
 /*
- * ======== CMMWRAP_GetHandle ========
+ * ======== cmmwrap_get_handle ========
  */
-u32 CMMWRAP_GetHandle(union Trapped_Args *args, void *pr_ctxt)
+u32 cmmwrap_get_handle(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_OBJECT *hCmmMgr;
+	dsp_status status = DSP_SOK;
+	struct cmm_object *hcmm_mgr;
 
-	status = CMM_GetHandle(args->ARGS_CMM_GETHANDLE.hProcessor, &hCmmMgr);
+	status = cmm_get_handle(args->args_cmm_gethandle.hprocessor, &hcmm_mgr);
 
-	cp_to_usr(args->ARGS_CMM_GETHANDLE.phCmmMgr, &hCmmMgr, status, 1);
+	CP_TO_USR(args->args_cmm_gethandle.ph_cmm_mgr, &hcmm_mgr, status, 1);
 
 	return status;
 }
 
 /*
- * ======== CMMWRAP_GetInfo ========
+ * ======== cmmwrap_get_info ========
  */
-u32 CMMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt)
+u32 cmmwrap_get_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_INFO cmmInfo;
+	dsp_status status = DSP_SOK;
+	struct cmm_info cmm_info_obj;
 
-	status = CMM_GetInfo(args->ARGS_CMM_GETINFO.hCmmMgr, &cmmInfo);
+	status = cmm_get_info(args->args_cmm_getinfo.hcmm_mgr, &cmm_info_obj);
 
-	cp_to_usr(args->ARGS_CMM_GETINFO.pCmmInfo, &cmmInfo, status, 1);
+	CP_TO_USR(args->args_cmm_getinfo.cmm_info_obj, &cmm_info_obj, status,
+		  1);
 
 	return status;
 }
diff --git a/drivers/dsp/bridge/rmgr/dbdcd.c b/drivers/dsp/bridge/rmgr/dbdcd.c
index aae9351..69c383b 100644
--- a/drivers/dsp/bridge/rmgr/dbdcd.c
+++ b/drivers/dsp/bridge/rmgr/dbdcd.c
@@ -7,10 +7,10 @@
  * Configuration Database (DCD).
  *
  * Notes:
- *   The fxn DCD_GetObjects can apply a callback fxn to each DCD object
+ *   The fxn dcd_get_objects can apply a callback fxn to each DCD object
  *   that is located in a specified COFF file.  At the moment,
- *   DCD_AutoRegister, DCD_AutoUnregister, and NLDR module all use
- *   DCD_GetObjects.
+ *   dcd_auto_register, dcd_auto_unregister, and NLDR module all use
+ *   dcd_get_objects.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
@@ -49,54 +49,54 @@
 /*  ----------------------------------- Global defines. */
 #define SIGNATURE       0x5f444344	/* "DCD_" (in reverse). */
 
-#define IsValidHandle(h)	(((h) != NULL) && (h->dwSignature == SIGNATURE))
+#define IS_VALID_HANDLE(h) (((h) != NULL) && (h->dw_signature == SIGNATURE))
 
-#define MAX_INT2CHAR_LENGTH     16   /* Maximum int2char len of 32 bit int. */
+#define MAX_INT2CHAR_LENGTH     16	/* Max int2char len of 32 bit int */
 
 /* Name of section containing dependent libraries */
 #define DEPLIBSECT		".dspbridge_deplibs"
 
 /* DCD specific structures. */
-struct DCD_MANAGER {
-	u32 dwSignature;	/* Used for object validation.   */
-	struct COD_MANAGER *hCodMgr;	/* Handle to COD manager object. */
+struct dcd_manager {
+	u32 dw_signature;	/* Used for object validation. */
+	struct cod_manager *cod_mgr;	/* Handle to COD manager object. */
 };
 
 /* Global reference variables. */
-static u32 cRefs;
-static u32 cEnumRefs;
+static u32 refs;
+static u32 enum_refs;
 
 /* Helper function prototypes. */
-static s32 Atoi(char *pszBuf);
-static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
-				  enum DSP_DCDOBJTYPE objType,
-				  struct DCD_GENERICOBJ *pGenObj);
-static void CompressBuf(char *pszBuf, u32 ulBufSize, s32 cCharSize);
-static char DspChar2GppChar(char *pWord, s32 cDspCharSize);
-static DSP_STATUS GetDepLibInfo(IN struct DCD_MANAGER *hDcdMgr,
-				IN struct DSP_UUID *pUuid,
-				IN OUT u16 *pNumLibs,
-				OPTIONAL OUT u16 *pNumPersLibs,
-				OPTIONAL OUT struct DSP_UUID *pDepLibUuids,
-				OPTIONAL OUT bool *pPersistentDepLibs,
-				IN enum NLDR_PHASE phase);
+static s32 atoi(char *psz_buf);
+static dsp_status get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
+				     enum dsp_dcdobjtype obj_type,
+				     struct dcd_genericobj *pGenObj);
+static void compress_buf(char *psz_buf, u32 ul_buf_size, s32 cCharSize);
+static char dsp_char2_gpp_char(char *pWord, s32 cDspCharSize);
+static dsp_status get_dep_lib_info(IN struct dcd_manager *hdcd_mgr,
+				   IN struct dsp_uuid *uuid_obj,
+				   IN OUT u16 *pNumLibs,
+				   OPTIONAL OUT u16 *pNumPersLibs,
+				   OPTIONAL OUT struct dsp_uuid *pDepLibUuids,
+				   OPTIONAL OUT bool *pPersistentDepLibs,
+				   IN enum nldr_phase phase);
 
 /*
- *  ======== DCD_AutoRegister ========
+ *  ======== dcd_auto_register ========
  *  Purpose:
  *      Parses the supplied image and resigsters with DCD.
  */
-DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
-				IN char *pszCoffPath)
+dsp_status dcd_auto_register(IN struct dcd_manager *hdcd_mgr,
+			     IN char *pszCoffPath)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (IsValidHandle(hDcdMgr))
-		status = DCD_GetObjects(hDcdMgr, pszCoffPath,
-					(DCD_REGISTERFXN)DCD_RegisterObject,
-					(void *)pszCoffPath);
+	if (IS_VALID_HANDLE(hdcd_mgr))
+		status = dcd_get_objects(hdcd_mgr, pszCoffPath,
+					 (dcd_registerfxn) dcd_register_object,
+					 (void *)pszCoffPath);
 	else
 		status = DSP_EHANDLE;
 
@@ -104,20 +104,21 @@ DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
 }
 
 /*
- *  ======== DCD_AutoUnregister ========
+ *  ======== dcd_auto_unregister ========
  *  Purpose:
  *      Parses the supplied DSP image and unresiters from DCD.
  */
-DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
-				IN char *pszCoffPath)
+dsp_status dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
+			       IN char *pszCoffPath)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (IsValidHandle(hDcdMgr))
-		status = DCD_GetObjects(hDcdMgr, pszCoffPath,
-				(DCD_REGISTERFXN)DCD_RegisterObject, NULL);
+	if (IS_VALID_HANDLE(hdcd_mgr))
+		status = dcd_get_objects(hdcd_mgr, pszCoffPath,
+					 (dcd_registerfxn) dcd_register_object,
+					 NULL);
 	else
 		status = DSP_EHANDLE;
 
@@ -125,32 +126,32 @@ DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
 }
 
 /*
- *  ======== DCD_CreateManager ========
+ *  ======== dcd_create_manager ========
  *  Purpose:
  *      Creates DCD manager.
  */
-DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
-				OUT struct DCD_MANAGER **phDcdMgr)
+dsp_status dcd_create_manager(IN char *pszZlDllName,
+			      OUT struct dcd_manager **phDcdMgr)
 {
-	struct COD_MANAGER *hCodMgr;		/* COD manager handle */
-	struct DCD_MANAGER *pDcdMgr = NULL;	/* DCD Manager pointer */
-	DSP_STATUS status = DSP_SOK;
+	struct cod_manager *cod_mgr;	/* COD manager handle */
+	struct dcd_manager *dcd_mgr_obj = NULL;	/* DCD Manager pointer */
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs >= 0);
-	DBC_Require(phDcdMgr);
+	DBC_REQUIRE(refs >= 0);
+	DBC_REQUIRE(phDcdMgr);
 
-	status = COD_Create(&hCodMgr, pszZlDllName, NULL);
+	status = cod_create(&cod_mgr, pszZlDllName, NULL);
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* Create a DCD object. */
-	MEM_AllocObject(pDcdMgr, struct DCD_MANAGER, SIGNATURE);
-	if (pDcdMgr != NULL) {
+	MEM_ALLOC_OBJECT(dcd_mgr_obj, struct dcd_manager, SIGNATURE);
+	if (dcd_mgr_obj != NULL) {
 		/* Fill out the object. */
-		pDcdMgr->hCodMgr = hCodMgr;
+		dcd_mgr_obj->cod_mgr = cod_mgr;
 
 		/* Return handle to this DCD interface. */
-		*phDcdMgr = pDcdMgr;
+		*phDcdMgr = dcd_mgr_obj;
 	} else {
 		status = DSP_EMEMORY;
 
@@ -158,35 +159,35 @@ DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
 		 * If allocation of DcdManager object failed, delete the
 		 * COD manager.
 		 */
-		COD_Delete(hCodMgr);
+		cod_delete(cod_mgr);
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status)) || ((hCodMgr == NULL) &&
-			(status == DSP_EFAIL)) || ((pDcdMgr == NULL) &&
-			(status == DSP_EMEMORY)));
+	DBC_ENSURE((DSP_SUCCEEDED(status)) || ((cod_mgr == NULL) &&
+					       (status == DSP_EFAIL))
+		   || ((dcd_mgr_obj == NULL) && (status == DSP_EMEMORY)));
 
 func_end:
 	return status;
 }
 
 /*
- *  ======== DCD_DestroyManager ========
+ *  ======== dcd_destroy_manager ========
  *  Purpose:
  *      Frees DCD Manager object.
  */
-DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr)
+dsp_status dcd_destroy_manager(IN struct dcd_manager *hdcd_mgr)
 {
-	struct DCD_MANAGER *pDcdMgr = hDcdMgr;
-	DSP_STATUS status = DSP_EHANDLE;
+	struct dcd_manager *dcd_mgr_obj = hdcd_mgr;
+	dsp_status status = DSP_EHANDLE;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (IsValidHandle(hDcdMgr)) {
+	if (IS_VALID_HANDLE(hdcd_mgr)) {
 		/* Delete the COD manager. */
-		COD_Delete(pDcdMgr->hCodMgr);
+		cod_delete(dcd_mgr_obj->cod_mgr);
 
 		/* Deallocate a DCD manager object. */
-		MEM_FreeObject(pDcdMgr);
+		MEM_FREE_OBJECT(dcd_mgr_obj);
 
 		status = DSP_SOK;
 	}
@@ -195,93 +196,94 @@ DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr)
 }
 
 /*
- *  ======== DCD_EnumerateObject ========
+ *  ======== dcd_enumerate_object ========
  *  Purpose:
  *      Enumerates objects in the DCD.
  */
-DSP_STATUS DCD_EnumerateObject(IN s32 cIndex, IN enum DSP_DCDOBJTYPE objType,
-			       OUT struct DSP_UUID *pUuid)
+dsp_status dcd_enumerate_object(IN s32 cIndex, IN enum dsp_dcdobjtype obj_type,
+				OUT struct dsp_uuid *uuid_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	char szRegKey[REG_MAXREGPATHLENGTH];
-	char szValue[REG_MAXREGPATHLENGTH];
-	char szData[REG_MAXREGPATHLENGTH];
-	u32 dwValueSize;
-	u32 dwDataSize;
-	struct DSP_UUID dspUuid;
-	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
-	u32 dwKeyLen = 0;
-
-	DBC_Require(cRefs >= 0);
-	DBC_Require(cIndex >= 0);
-	DBC_Require(pUuid != NULL);
-
-	if ((cIndex != 0) && (cEnumRefs == 0)) {
+	dsp_status status = DSP_SOK;
+	char sz_reg_key[REG_MAXREGPATHLENGTH];
+	char sz_value[REG_MAXREGPATHLENGTH];
+	char sz_data[REG_MAXREGPATHLENGTH];
+	u32 dw_value_size;
+	u32 dw_data_size;
+	struct dsp_uuid dsp_uuid_obj;
+	char sz_obj_type[MAX_INT2CHAR_LENGTH];	/* str. rep. of obj_type. */
+	u32 dw_key_len = 0;
+
+	DBC_REQUIRE(refs >= 0);
+	DBC_REQUIRE(cIndex >= 0);
+	DBC_REQUIRE(uuid_obj != NULL);
+
+	if ((cIndex != 0) && (enum_refs == 0)) {
 		/*
 		 * If an enumeration is being performed on an index greater
-		 * than zero, then the current cEnumRefs must have been
+		 * than zero, then the current enum_refs must have been
 		 * incremented to greater than zero.
 		 */
 		status = DSP_ECHANGEDURINGENUM;
 	} else {
 		/* Enumerate a specific key in the registry by index. */
-		dwValueSize = REG_MAXREGPATHLENGTH;
-		dwDataSize = REG_MAXREGPATHLENGTH;
+		dw_value_size = REG_MAXREGPATHLENGTH;
+		dw_data_size = REG_MAXREGPATHLENGTH;
 
 		/*
 		 * Pre-determine final key length. It's length of DCD_REGKEY +
-		 *  "_\0" + length of szObjType string + terminating NULL.
+		 *  "_\0" + length of sz_obj_type string + terminating NULL.
 		 */
-		dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
-		DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+		dw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;
+		DBC_ASSERT(dw_key_len < REG_MAXREGPATHLENGTH);
 
 		/* Create proper REG key; concatenate DCD_REGKEY with
-		 * objType. */
-		strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-		if ((strlen(szRegKey) + strlen("_\0")) <
-		   REG_MAXREGPATHLENGTH) {
-			strncat(szRegKey, "_\0", 2);
+		 * obj_type. */
+		strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+		if ((strlen(sz_reg_key) + strlen("_\0")) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, "_\0", 2);
 		} else {
 			status = DSP_EFAIL;
 		}
 
 		/* This snprintf is guaranteed not to exceed max size of an
 		 * integer. */
-		status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d",
-				 objType);
+		status = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d",
+				  obj_type);
 
 		if (status == -1) {
 			status = DSP_EFAIL;
 		} else {
 			status = DSP_SOK;
-			if ((strlen(szRegKey) + strlen(szObjType)) <
-			   REG_MAXREGPATHLENGTH) {
-				strncat(szRegKey, szObjType,
-					strlen(szObjType) + 1);
+			if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
+			    REG_MAXREGPATHLENGTH) {
+				strncat(sz_reg_key, sz_obj_type,
+					strlen(sz_obj_type) + 1);
 			} else {
 				status = DSP_EFAIL;
 			}
 		}
 
 		if (DSP_SUCCEEDED(status)) {
-			status = REG_EnumValue(cIndex, szRegKey, szValue,
-					&dwValueSize, szData, &dwDataSize);
+			status = reg_enum_value(cIndex, sz_reg_key, sz_value,
+						&dw_value_size, sz_data,
+						&dw_data_size);
 		}
 
 		if (DSP_SUCCEEDED(status)) {
 			/* Create UUID value using string retrieved from
 			 * registry. */
-			UUID_UuidFromString(szValue, &dspUuid);
+			uuid_uuid_from_string(sz_value, &dsp_uuid_obj);
 
-			*pUuid = dspUuid;
+			*uuid_obj = dsp_uuid_obj;
 
-			/* Increment cEnumRefs to update reference count. */
-			cEnumRefs++;
+			/* Increment enum_refs to update reference count. */
+			enum_refs++;
 
 			status = DSP_SOK;
 		} else if (status == REG_E_NOMOREITEMS) {
-			/* At the end of enumeration. Reset cEnumRefs. */
-			cEnumRefs = 0;
+			/* At the end of enumeration. Reset enum_refs. */
+			enum_refs = 0;
 
 			status = DSP_SENUMCOMPLETE;
 		} else {
@@ -289,150 +291,155 @@ DSP_STATUS DCD_EnumerateObject(IN s32 cIndex, IN enum DSP_DCDOBJTYPE objType,
 		}
 	}
 
-	DBC_Ensure(pUuid || (status == DSP_EFAIL));
+	DBC_ENSURE(uuid_obj || (status == DSP_EFAIL));
 
 	return status;
 }
 
 /*
- *  ======== DCD_Exit ========
+ *  ======== dcd_exit ========
  *  Purpose:
  *      Discontinue usage of the DCD module.
  */
-void DCD_Exit(void)
+void dcd_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
-	if (cRefs == 0) {
-		COD_Exit();
+	refs--;
+	if (refs == 0) {
+		cod_exit();
 	}
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== DCD_GetDepLibs ========
+ *  ======== dcd_get_dep_libs ========
  */
-DSP_STATUS DCD_GetDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-			 IN struct DSP_UUID *pUuid,
-			 u16 numLibs, OUT struct DSP_UUID *pDepLibUuids,
-			 OUT bool *pPersistentDepLibs, IN enum NLDR_PHASE phase)
+dsp_status dcd_get_dep_libs(IN struct dcd_manager *hdcd_mgr,
+			    IN struct dsp_uuid *uuid_obj,
+			    u16 numLibs, OUT struct dsp_uuid *pDepLibUuids,
+			    OUT bool *pPersistentDepLibs,
+			    IN enum nldr_phase phase)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDcdMgr));
-	DBC_Require(pUuid != NULL);
-	DBC_Require(pDepLibUuids != NULL);
-	DBC_Require(pPersistentDepLibs != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdcd_mgr));
+	DBC_REQUIRE(uuid_obj != NULL);
+	DBC_REQUIRE(pDepLibUuids != NULL);
+	DBC_REQUIRE(pPersistentDepLibs != NULL);
 
-	status = GetDepLibInfo(hDcdMgr, pUuid, &numLibs, NULL, pDepLibUuids,
-			      pPersistentDepLibs, phase);
+	status =
+	    get_dep_lib_info(hdcd_mgr, uuid_obj, &numLibs, NULL, pDepLibUuids,
+			     pPersistentDepLibs, phase);
 
 	return status;
 }
 
 /*
- *  ======== DCD_GetNumDepLibs ========
+ *  ======== dcd_get_num_dep_libs ========
  */
-DSP_STATUS DCD_GetNumDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-			    IN struct DSP_UUID *pUuid, OUT u16 *pNumLibs,
-			    OUT u16 *pNumPersLibs, IN enum NLDR_PHASE phase)
+dsp_status dcd_get_num_dep_libs(IN struct dcd_manager *hdcd_mgr,
+				IN struct dsp_uuid *uuid_obj,
+				OUT u16 *pNumLibs, OUT u16 *pNumPersLibs,
+				IN enum nldr_phase phase)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDcdMgr));
-	DBC_Require(pNumLibs != NULL);
-	DBC_Require(pNumPersLibs != NULL);
-	DBC_Require(pUuid != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdcd_mgr));
+	DBC_REQUIRE(pNumLibs != NULL);
+	DBC_REQUIRE(pNumPersLibs != NULL);
+	DBC_REQUIRE(uuid_obj != NULL);
 
-	status = GetDepLibInfo(hDcdMgr, pUuid, pNumLibs, pNumPersLibs,
-				NULL, NULL, phase);
+	status = get_dep_lib_info(hdcd_mgr, uuid_obj, pNumLibs, pNumPersLibs,
+				  NULL, NULL, phase);
 
 	return status;
 }
 
 /*
- *  ======== DCD_GetObjectDef ========
+ *  ======== dcd_get_object_def ========
  *  Purpose:
  *      Retrieves the properties of a node or processor based on the UUID and
  *      object type.
  */
-DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
-			IN struct DSP_UUID *pObjUuid,
-			IN enum DSP_DCDOBJTYPE objType,
-			OUT struct DCD_GENERICOBJ *pObjDef)
+dsp_status dcd_get_object_def(IN struct dcd_manager *hdcd_mgr,
+			      IN struct dsp_uuid *pObjUuid,
+			      IN enum dsp_dcdobjtype obj_type,
+			      OUT struct dcd_genericobj *pObjDef)
 {
-	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
-	struct COD_LIBRARYOBJ *lib = NULL;
-	DSP_STATUS status = DSP_SOK;
-	u32 ulAddr = 0;	/* Used by COD_GetSection */
-	u32 ulLen = 0;	/* Used by COD_GetSection */
-	u32 dwBufSize;	/* Used by REG functions */
-	char szRegKey[REG_MAXREGPATHLENGTH];
-	char *szUuid;		/*[MAXUUIDLEN];*/
-	char szRegData[REG_MAXREGPATHLENGTH];
-	char szSectName[MAXUUIDLEN + 2];	/* ".[UUID]\0" */
-	char *pszCoffBuf;
-	u32 dwKeyLen;		/* Len of REG key. */
-	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pObjDef != NULL);
-	DBC_Require(pObjUuid != NULL);
-
-	szUuid = (char *)MEM_Calloc(MAXUUIDLEN, MEM_PAGED);
-	if (!szUuid) {
+	struct dcd_manager *dcd_mgr_obj = hdcd_mgr;	/* ptr to DCD mgr */
+	struct cod_libraryobj *lib = NULL;
+	dsp_status status = DSP_SOK;
+	u32 ul_addr = 0;	/* Used by cod_get_section */
+	u32 ul_len = 0;		/* Used by cod_get_section */
+	u32 dw_buf_size;	/* Used by REG functions */
+	char sz_reg_key[REG_MAXREGPATHLENGTH];
+	char *sz_uuid;		/*[MAXUUIDLEN]; */
+	char sz_reg_data[REG_MAXREGPATHLENGTH];
+	char sz_sect_name[MAXUUIDLEN + 2];	/* ".[UUID]\0" */
+	char *psz_coff_buf;
+	u32 dw_key_len;		/* Len of REG key. */
+	char sz_obj_type[MAX_INT2CHAR_LENGTH];	/* str. rep. of obj_type. */
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pObjDef != NULL);
+	DBC_REQUIRE(pObjUuid != NULL);
+
+	sz_uuid = (char *)mem_calloc(MAXUUIDLEN, MEM_PAGED);
+	if (!sz_uuid) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
 
-	if (!IsValidHandle(hDcdMgr)) {
+	if (!IS_VALID_HANDLE(hdcd_mgr)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
 	/* Pre-determine final key length. It's length of DCD_REGKEY +
-	 *  "_\0" + length of szObjType string + terminating NULL */
-	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
-	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+	 *  "_\0" + length of sz_obj_type string + terminating NULL */
+	dw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;
+	DBC_ASSERT(dw_key_len < REG_MAXREGPATHLENGTH);
 
-	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	/* Create proper REG key; concatenate DCD_REGKEY with obj_type. */
+	strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
 
-	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-		strncat(szRegKey, "_\0", 2);
+	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(sz_reg_key, "_\0", 2);
 	else
 		status = DSP_EFAIL;
 
-	status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d", objType);
+	status = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d", obj_type);
 	if (status == -1) {
 		status = DSP_EFAIL;
 	} else {
 		status = DSP_SOK;
 
-		if ((strlen(szRegKey) + strlen(szObjType)) <
-		   REG_MAXREGPATHLENGTH) {
-			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_obj_type,
+				strlen(sz_obj_type) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
 
 		/* Create UUID value to set in registry. */
-		UUID_UuidToString(pObjUuid, szUuid, MAXUUIDLEN);
+		uuid_uuid_to_string(pObjUuid, sz_uuid, MAXUUIDLEN);
 
-		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
 		else
 			status = DSP_EFAIL;
 
-		/* Retrieve paths from the registry based on struct DSP_UUID */
-		dwBufSize = REG_MAXREGPATHLENGTH;
+		/* Retrieve paths from the registry based on struct dsp_uuid */
+		dw_buf_size = REG_MAXREGPATHLENGTH;
 	}
 	if (DSP_SUCCEEDED(status))
-		status = REG_GetValue(szRegKey, (u8 *)szRegData, &dwBufSize);
+		status =
+		    reg_get_value(sz_reg_key, (u8 *) sz_reg_data, &dw_buf_size);
 
 	if (DSP_FAILED(status)) {
 		status = DSP_EUUID;
@@ -440,53 +447,56 @@ DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
 	}
 
 	/* Open COFF file. */
-	status = COD_Open(pDcdMgr->hCodMgr, szRegData, COD_NOLOAD, &lib);
+	status = cod_open(dcd_mgr_obj->cod_mgr, sz_reg_data, COD_NOLOAD, &lib);
 	if (DSP_FAILED(status)) {
 		status = DSP_EDCDLOADBASE;
 		goto func_end;
 	}
 
-	/* Ensure szUuid + 1 is not greater than sizeof szSectName. */
-	DBC_Assert((strlen(szUuid) + 1) < sizeof(szSectName));
+	/* Ensure sz_uuid + 1 is not greater than sizeof sz_sect_name. */
+	DBC_ASSERT((strlen(sz_uuid) + 1) < sizeof(sz_sect_name));
 
 	/* Create section name based on node UUID. A period is
 	 * pre-pended to the UUID string to form the section name.
 	 * I.e. ".24BC8D90_BB45_11d4_B756_006008BDB66F" */
-	strncpy(szSectName, ".", 2);
-	strncat(szSectName, szUuid, strlen(szUuid));
+	strncpy(sz_sect_name, ".", 2);
+	strncat(sz_sect_name, sz_uuid, strlen(sz_uuid));
 
 	/* Get section information. */
-	status = COD_GetSection(lib, szSectName, &ulAddr, &ulLen);
+	status = cod_get_section(lib, sz_sect_name, &ul_addr, &ul_len);
 	if (DSP_FAILED(status)) {
 		status = DSP_EDCDGETSECT;
 		goto func_end;
 	}
 
 	/* Allocate zeroed buffer. */
-	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
+	psz_coff_buf = mem_calloc(ul_len + 4, MEM_PAGED);
 #ifdef _DB_TIOMAP
-	if (strstr(szRegData, "iva") == NULL) {
+	if (strstr(sz_reg_data, "iva") == NULL) {
 		/* Locate section by objectID and read its content. */
-		status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
+		status =
+		    cod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);
 	} else {
-		status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
+		status =
+		    cod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);
 		dev_dbg(bridge, "%s: Skipped Byte swap for IVA!!\n", __func__);
 	}
 #else
-	status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
+	status = cod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);
 #endif
 	if (DSP_SUCCEEDED(status)) {
 		/* Compres DSP buffer to conform to PC format. */
-		if (strstr(szRegData, "iva") == NULL) {
-			CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+		if (strstr(sz_reg_data, "iva") == NULL) {
+			compress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);
 		} else {
-			CompressBuf(pszCoffBuf, ulLen, 1);
+			compress_buf(psz_coff_buf, ul_len, 1);
 			dev_dbg(bridge, "%s: Compressing IVA COFF buffer by 1 "
-						"for IVA!!\n", __func__);
+				"for IVA!!\n", __func__);
 		}
 
 		/* Parse the content of the COFF buffer. */
-		status = GetAttrsFromBuf(pszCoffBuf, ulLen, objType, pObjDef);
+		status =
+		    get_attrs_from_buf(psz_coff_buf, ul_len, obj_type, pObjDef);
 		if (DSP_FAILED(status))
 			status = DSP_EDCDPARSESECT;
 	} else {
@@ -494,90 +504,92 @@ DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
 	}
 
 	/* Free the previously allocated dynamic buffer. */
-	kfree(pszCoffBuf);
+	kfree(psz_coff_buf);
 func_end:
 	if (lib)
-		COD_Close(lib);
+		cod_close(lib);
 
-	kfree(szUuid);
+	kfree(sz_uuid);
 
 	return status;
 }
 
 /*
- *  ======== DCD_GetObjects ========
+ *  ======== dcd_get_objects ========
  */
-DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr, IN char *pszCoffPath,
-			 DCD_REGISTERFXN registerFxn, void *handle)
+dsp_status dcd_get_objects(IN struct dcd_manager *hdcd_mgr,
+			   IN char *pszCoffPath, dcd_registerfxn registerFxn,
+			   void *handle)
 {
-	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
-	DSP_STATUS status = DSP_SOK;
-	char *pszCoffBuf;
-	char *pszCur;
-	struct COD_LIBRARYOBJ *lib = NULL;
-	u32 ulAddr = 0;	/* Used by COD_GetSection */
-	u32 ulLen = 0;	/* Used by COD_GetSection */
+	struct dcd_manager *dcd_mgr_obj = hdcd_mgr;
+	dsp_status status = DSP_SOK;
+	char *psz_coff_buf;
+	char *psz_cur;
+	struct cod_libraryobj *lib = NULL;
+	u32 ul_addr = 0;	/* Used by cod_get_section */
+	u32 ul_len = 0;		/* Used by cod_get_section */
 	char seps[] = ":, ";
-	char *pToken = NULL;
-	struct DSP_UUID dspUuid;
-	s32 cObjectType;
+	char *token = NULL;
+	struct dsp_uuid dsp_uuid_obj;
+	s32 object_type;
 
-	DBC_Require(cRefs > 0);
-	if (!IsValidHandle(hDcdMgr)) {
+	DBC_REQUIRE(refs > 0);
+	if (!IS_VALID_HANDLE(hdcd_mgr)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
 	/* Open DSP coff file, don't load symbols. */
-	status = COD_Open(pDcdMgr->hCodMgr, pszCoffPath, COD_NOLOAD, &lib);
+	status = cod_open(dcd_mgr_obj->cod_mgr, pszCoffPath, COD_NOLOAD, &lib);
 	if (DSP_FAILED(status)) {
 		status = DSP_EDCDLOADBASE;
 		goto func_cont;
 	}
 
 	/* Get DCD_RESIGER_SECTION section information. */
-	status = COD_GetSection(lib, DCD_REGISTER_SECTION, &ulAddr, &ulLen);
-	if (DSP_FAILED(status) ||  !(ulLen > 0)) {
+	status = cod_get_section(lib, DCD_REGISTER_SECTION, &ul_addr, &ul_len);
+	if (DSP_FAILED(status) || !(ul_len > 0)) {
 		status = DSP_EDCDNOAUTOREGISTER;
 		goto func_cont;
 	}
 
 	/* Allocate zeroed buffer. */
-	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
+	psz_coff_buf = mem_calloc(ul_len + 4, MEM_PAGED);
 #ifdef _DB_TIOMAP
 	if (strstr(pszCoffPath, "iva") == NULL) {
 		/* Locate section by objectID and read its content. */
-		status = COD_ReadSection(lib, DCD_REGISTER_SECTION,
-					pszCoffBuf, ulLen);
+		status = cod_read_section(lib, DCD_REGISTER_SECTION,
+					  psz_coff_buf, ul_len);
 	} else {
 		dev_dbg(bridge, "%s: Skipped Byte swap for IVA!!\n", __func__);
-		status = COD_ReadSection(lib, DCD_REGISTER_SECTION,
-					pszCoffBuf, ulLen);
+		status = cod_read_section(lib, DCD_REGISTER_SECTION,
+					  psz_coff_buf, ul_len);
 	}
 #else
-	status = COD_ReadSection(lib, DCD_REGISTER_SECTION, pszCoffBuf, ulLen);
+	status =
+	    cod_read_section(lib, DCD_REGISTER_SECTION, psz_coff_buf, ul_len);
 #endif
 	if (DSP_SUCCEEDED(status)) {
 		/* Compress DSP buffer to conform to PC format. */
 		if (strstr(pszCoffPath, "iva") == NULL) {
-			CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+			compress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);
 		} else {
-			CompressBuf(pszCoffBuf, ulLen, 1);
+			compress_buf(psz_coff_buf, ul_len, 1);
 			dev_dbg(bridge, "%s: Compress COFF buffer with 1 word "
-						"for IVA!!\n", __func__);
+				"for IVA!!\n", __func__);
 		}
 
 		/* Read from buffer and register object in buffer. */
-		pszCur = pszCoffBuf;
-		while ((pToken = strsep(&pszCur, seps)) && *pToken != '\0') {
+		psz_cur = psz_coff_buf;
+		while ((token = strsep(&psz_cur, seps)) && *token != '\0') {
 			/*  Retrieve UUID string. */
-			UUID_UuidFromString(pToken, &dspUuid);
+			uuid_uuid_from_string(token, &dsp_uuid_obj);
 
 			/*  Retrieve object type */
-			pToken = strsep(&pszCur, seps);
+			token = strsep(&psz_cur, seps);
 
 			/*  Retrieve object type */
-			cObjectType = Atoi(pToken);
+			object_type = atoi(token);
 
 			/*
 			 *  Apply registerFxn to the found DCD object.
@@ -587,7 +599,8 @@ DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr, IN char *pszCoffPath,
 			 *  2) Unregister found DCD object (when handle == NULL)
 			 *  3) Add overlay node.
 			 */
-			status = registerFxn(&dspUuid, cObjectType, handle);
+			status =
+			    registerFxn(&dsp_uuid_obj, object_type, handle);
 			if (DSP_FAILED(status)) {
 				/* if error occurs, break from while loop. */
 				break;
@@ -598,220 +611,221 @@ DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr, IN char *pszCoffPath,
 	}
 
 	/* Free the previously allocated dynamic buffer. */
-	kfree(pszCoffBuf);
+	kfree(psz_coff_buf);
 func_cont:
 	if (lib)
-		COD_Close(lib);
+		cod_close(lib);
 
 func_end:
 	return status;
 }
 
 /*
- *  ======== DCD_GetLibraryName ========
+ *  ======== dcd_get_library_name ========
  *  Purpose:
  *      Retrieves the library name for the given UUID.
  *
  */
-DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
-			IN struct DSP_UUID *pUuid,
-			IN OUT char *pstrLibName, IN OUT u32 *pdwSize,
-			enum NLDR_PHASE phase, OUT bool *fPhaseSplit)
+dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
+				IN struct dsp_uuid *uuid_obj,
+				IN OUT char *pstrLibName, IN OUT u32 * pdwSize,
+				enum nldr_phase phase, OUT bool *phase_split)
 {
-	char szRegKey[REG_MAXREGPATHLENGTH];
-	char szUuid[MAXUUIDLEN];
-	u32 dwKeyLen;		/* Len of REG key. */
-	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
-	DSP_STATUS status = DSP_SOK;
+	char sz_reg_key[REG_MAXREGPATHLENGTH];
+	char sz_uuid[MAXUUIDLEN];
+	u32 dw_key_len;		/* Len of REG key. */
+	char sz_obj_type[MAX_INT2CHAR_LENGTH];	/* str. rep. of obj_type. */
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(pUuid != NULL);
-	DBC_Require(pstrLibName != NULL);
-	DBC_Require(pdwSize != NULL);
-	DBC_Require(IsValidHandle(hDcdMgr));
+	DBC_REQUIRE(uuid_obj != NULL);
+	DBC_REQUIRE(pstrLibName != NULL);
+	DBC_REQUIRE(pdwSize != NULL);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdcd_mgr));
 
-	dev_dbg(bridge, "%s: hDcdMgr %p, pUuid %p, pstrLibName %p, pdwSize "
-					"%p\n", __func__, hDcdMgr, pUuid,
-					pstrLibName, pdwSize);
+	dev_dbg(bridge, "%s: hdcd_mgr %p, uuid_obj %p, pstrLibName %p, pdwSize "
+		"%p\n", __func__, hdcd_mgr, uuid_obj, pstrLibName, pdwSize);
 
 	/*
 	 *  Pre-determine final key length. It's length of DCD_REGKEY +
-	 *  "_\0" + length of szObjType string + terminating NULL.
+	 *  "_\0" + length of sz_obj_type string + terminating NULL.
 	 */
-	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
-	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+	dw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;
+	DBC_ASSERT(dw_key_len < REG_MAXREGPATHLENGTH);
 
-	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-		strncat(szRegKey, "_\0", 2);
+	/* Create proper REG key; concatenate DCD_REGKEY with obj_type. */
+	strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(sz_reg_key, "_\0", 2);
 	else
 		status = DSP_EFAIL;
 
 	switch (phase) {
 	case NLDR_CREATE:
 		/* create phase type */
-		sprintf(szObjType, "%d", DSP_DCDCREATELIBTYPE);
+		sprintf(sz_obj_type, "%d", DSP_DCDCREATELIBTYPE);
 		break;
 	case NLDR_EXECUTE:
 		/* execute phase type */
-		sprintf(szObjType, "%d", DSP_DCDEXECUTELIBTYPE);
+		sprintf(sz_obj_type, "%d", DSP_DCDEXECUTELIBTYPE);
 		break;
 	case NLDR_DELETE:
 		/* delete phase type */
-		sprintf(szObjType, "%d", DSP_DCDDELETELIBTYPE);
+		sprintf(sz_obj_type, "%d", DSP_DCDDELETELIBTYPE);
 		break;
 	case NLDR_NOPHASE:
 		/* known to be a dependent library */
-		sprintf(szObjType, "%d", DSP_DCDLIBRARYTYPE);
+		sprintf(sz_obj_type, "%d", DSP_DCDLIBRARYTYPE);
 		break;
 	default:
 		status = DSP_EINVALIDARG;
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		if ((strlen(szRegKey) + strlen(szObjType)) <
-		   REG_MAXREGPATHLENGTH) {
-			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_obj_type,
+				strlen(sz_obj_type) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
 		/* Create UUID value to find match in registry. */
-		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-		if ((strlen(szRegKey) + MAXUUIDLEN) <
-		   REG_MAXREGPATHLENGTH) {
-			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
+		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
 		} else {
 			status = DSP_EFAIL;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		/* Retrieve path from the registry based on DSP_UUID */
-		status = REG_GetValue(szRegKey,	(u8 *)pstrLibName, pdwSize);
+		/* Retrieve path from the registry based on dsp_uuid */
+		status = reg_get_value(sz_reg_key, (u8 *) pstrLibName, pdwSize);
 	}
 
 	/* If can't find, phases might be registered as generic LIBRARYTYPE */
 	if (DSP_FAILED(status) && phase != NLDR_NOPHASE) {
-		if (fPhaseSplit)
-			*fPhaseSplit = false;
+		if (phase_split)
+			*phase_split = false;
 
-		strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-		if ((strlen(szRegKey) + strlen("_\0")) <
-		   REG_MAXREGPATHLENGTH) {
-			strncat(szRegKey, "_\0", 2);
+		strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+		if ((strlen(sz_reg_key) + strlen("_\0")) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, "_\0", 2);
 		} else {
 			status = DSP_EFAIL;
 		}
-		sprintf(szObjType, "%d", DSP_DCDLIBRARYTYPE);
-		if ((strlen(szRegKey) + strlen(szObjType))
-		   < REG_MAXREGPATHLENGTH) {
-			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		sprintf(sz_obj_type, "%d", DSP_DCDLIBRARYTYPE);
+		if ((strlen(sz_reg_key) + strlen(sz_obj_type))
+		    < REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_obj_type,
+				strlen(sz_obj_type) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
-		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
+		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
 		else
 			status = DSP_EFAIL;
 
-		status = REG_GetValue(szRegKey, (u8 *)pstrLibName, pdwSize);
+		status = reg_get_value(sz_reg_key, (u8 *) pstrLibName, pdwSize);
 	}
 
 	return status;
 }
 
 /*
- *  ======== DCD_Init ========
+ *  ======== dcd_init ========
  *  Purpose:
  *      Initialize the DCD module.
  */
-bool DCD_Init(void)
+bool dcd_init(void)
 {
-	bool fInitCOD;
-	bool fInit = true;
+	bool init_cod;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0) {
+	if (refs == 0) {
 		/* Initialize required modules. */
-		fInitCOD = COD_Init();
+		init_cod = cod_init();
 
-		if (!fInitCOD) {
-			fInit = false;
+		if (!init_cod) {
+			ret = false;
 			/* Exit initialized modules. */
-			if (fInitCOD)
-				COD_Exit();
+			if (init_cod)
+				cod_exit();
 		}
 	}
 
-	if (fInit)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fInit && (cRefs > 0)) || (!fInit && (cRefs == 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs == 0)));
 
-	return fInit;
+	return ret;
 }
 
 /*
- *  ======== DCD_RegisterObject ========
+ *  ======== dcd_register_object ========
  *  Purpose:
  *      Registers a node or a processor with the DCD.
- *      If pszPathName == NULL, unregister the specified DCD object.
+ *      If psz_path_name == NULL, unregister the specified DCD object.
  */
-DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
-			IN enum DSP_DCDOBJTYPE objType,
-			IN char *pszPathName)
+dsp_status dcd_register_object(IN struct dsp_uuid *uuid_obj,
+			       IN enum dsp_dcdobjtype obj_type,
+			       IN char *psz_path_name)
 {
-	DSP_STATUS status = DSP_SOK;
-	char szRegKey[REG_MAXREGPATHLENGTH];
-	char szUuid[MAXUUIDLEN + 1];
-	u32 dwPathSize = 0;
-	u32 dwKeyLen;				/* Len of REG key. */
-	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pUuid != NULL);
-	DBC_Require((objType == DSP_DCDNODETYPE) ||
-			(objType == DSP_DCDPROCESSORTYPE) ||
-			(objType == DSP_DCDLIBRARYTYPE) ||
-			(objType == DSP_DCDCREATELIBTYPE) ||
-			(objType == DSP_DCDEXECUTELIBTYPE) ||
-			(objType == DSP_DCDDELETELIBTYPE));
-
-	dev_dbg(bridge, "%s: object UUID %p, objType %d, szPathName %s\n",
-					__func__, pUuid, objType, pszPathName);
+	dsp_status status = DSP_SOK;
+	char sz_reg_key[REG_MAXREGPATHLENGTH];
+	char sz_uuid[MAXUUIDLEN + 1];
+	u32 dw_path_size = 0;
+	u32 dw_key_len;		/* Len of REG key. */
+	char sz_obj_type[MAX_INT2CHAR_LENGTH];	/* str. rep. of obj_type. */
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(uuid_obj != NULL);
+	DBC_REQUIRE((obj_type == DSP_DCDNODETYPE) ||
+		    (obj_type == DSP_DCDPROCESSORTYPE) ||
+		    (obj_type == DSP_DCDLIBRARYTYPE) ||
+		    (obj_type == DSP_DCDCREATELIBTYPE) ||
+		    (obj_type == DSP_DCDEXECUTELIBTYPE) ||
+		    (obj_type == DSP_DCDDELETELIBTYPE));
+
+	dev_dbg(bridge, "%s: object UUID %p, obj_type %d, szPathName %s\n",
+		__func__, uuid_obj, obj_type, psz_path_name);
 
 	/*
 	 * Pre-determine final key length. It's length of DCD_REGKEY +
-	 *  "_\0" + length of szObjType string + terminating NULL.
+	 *  "_\0" + length of sz_obj_type string + terminating NULL.
 	 */
-	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
-	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+	dw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;
+	DBC_ASSERT(dw_key_len < REG_MAXREGPATHLENGTH);
 
-	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-		strncat(szRegKey, "_\0", 2);
+	/* Create proper REG key; concatenate DCD_REGKEY with obj_type. */
+	strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(sz_reg_key, "_\0", 2);
 	else {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
 
-	status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d", objType);
+	status = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d", obj_type);
 	if (status == -1) {
 		status = DSP_EFAIL;
 	} else {
 		status = DSP_SOK;
-		if ((strlen(szRegKey) + strlen(szObjType)) <
-		   REG_MAXREGPATHLENGTH) {
-			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_obj_type,
+				strlen(sz_obj_type) + 1);
 		} else
 			status = DSP_EFAIL;
 
 		/* Create UUID value to set in registry. */
-		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
+		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
 		else
 			status = DSP_EFAIL;
 	}
@@ -820,21 +834,22 @@ DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
 		goto func_end;
 
 	/*
-	 * If pszPathName != NULL, perform registration, otherwise,
+	 * If psz_path_name != NULL, perform registration, otherwise,
 	 * perform unregistration.
 	 */
-	if (pszPathName) {
-		/* Add new reg value (UUID+objType) with COFF path info */
-		dwPathSize = strlen(pszPathName) + 1;
-		status = REG_SetValue(szRegKey, (u8 *)pszPathName, dwPathSize);
-		dev_dbg(bridge, "%s: pszPathName=%s, dwPathSize=%d\n", __func__,
-						pszPathName, dwPathSize);
+	if (psz_path_name) {
+		/* Add new reg value (UUID+obj_type) with COFF path info */
+		dw_path_size = strlen(psz_path_name) + 1;
+		status =
+		    reg_set_value(sz_reg_key, (u8 *) psz_path_name,
+				  dw_path_size);
+		dev_dbg(bridge, "%s: psz_path_name=%s, dw_path_size=%d\n",
+			__func__, psz_path_name, dw_path_size);
 	} else {
 		/* Deregister an existing object */
-		status = REG_DeleteValue(szRegKey);
+		status = reg_delete_value(sz_reg_key);
 	}
 
-
 	if (DSP_SUCCEEDED(status)) {
 		/*
 		 *  Because the node database has been updated through a
@@ -843,36 +858,36 @@ DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
 		 *  current enumerations to reflect this update in the node
 		 *  database.
 		 */
-		cEnumRefs = 0;
+		enum_refs = 0;
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== DCD_UnregisterObject ========
- *  Call DCD_Register object with pszPathName set to NULL to
+ *  ======== dcd_unregister_object ========
+ *  Call DCD_Register object with psz_path_name set to NULL to
  *  perform actual object de-registration.
  */
-DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
-				IN enum DSP_DCDOBJTYPE objType)
+dsp_status dcd_unregister_object(IN struct dsp_uuid *uuid_obj,
+				 IN enum dsp_dcdobjtype obj_type)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pUuid != NULL);
-	DBC_Require((objType == DSP_DCDNODETYPE) ||
-		   (objType == DSP_DCDPROCESSORTYPE) ||
-		   (objType == DSP_DCDLIBRARYTYPE) ||
-		   (objType == DSP_DCDCREATELIBTYPE) ||
-		   (objType == DSP_DCDEXECUTELIBTYPE) ||
-		   (objType == DSP_DCDDELETELIBTYPE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(uuid_obj != NULL);
+	DBC_REQUIRE((obj_type == DSP_DCDNODETYPE) ||
+		    (obj_type == DSP_DCDPROCESSORTYPE) ||
+		    (obj_type == DSP_DCDLIBRARYTYPE) ||
+		    (obj_type == DSP_DCDCREATELIBTYPE) ||
+		    (obj_type == DSP_DCDEXECUTELIBTYPE) ||
+		    (obj_type == DSP_DCDDELETELIBTYPE));
 
 	/*
-	 *  When DCD_RegisterObject is called with NULL as pathname,
+	 *  When dcd_register_object is called with NULL as pathname,
 	 *  it indicates an unregister object operation.
 	 */
-	status = DCD_RegisterObject(pUuid, objType, NULL);
+	status = dcd_register_object(uuid_obj, obj_type, NULL);
 
 	return status;
 }
@@ -884,13 +899,13 @@ DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
  */
 
 /*
- *  ======== Atoi ========
+ *  ======== atoi ========
  *  Purpose:
  *      This function converts strings in decimal or hex format to integers.
  */
-static s32 Atoi(char *pszBuf)
+static s32 atoi(char *psz_buf)
 {
-	char *pch = pszBuf;
+	char *pch = psz_buf;
 	s32 base = 0;
 
 	while (isspace(*pch))
@@ -907,238 +922,248 @@ static s32 Atoi(char *pszBuf)
 }
 
 /*
- *  ======== GetAttrsFromBuf ========
+ *  ======== get_attrs_from_buf ========
  *  Purpose:
  *      Parse the content of a buffer filled with DSP-side data and
  *      retrieve an object's attributes from it. IMPORTANT: Assume the
  *      buffer has been converted from DSP format to GPP format.
  */
-static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
-				 enum DSP_DCDOBJTYPE objType,
-				 struct DCD_GENERICOBJ *pGenObj)
+static dsp_status get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
+				     enum dsp_dcdobjtype obj_type,
+				     struct dcd_genericobj *pGenObj)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	char seps[] = ", ";
-	char *pszCur;
+	char *psz_cur;
 	char *token;
-	s32 cLen = 0;
+	s32 token_len = 0;
 	u32 i = 0;
 #ifdef _DB_TIOMAP
-	s32 iEntry;
+	s32 entry_id;
 #endif
 
-	DBC_Require(pszBuf != NULL);
-	DBC_Require(ulBufSize != 0);
-	DBC_Require((objType == DSP_DCDNODETYPE)
-		    || (objType == DSP_DCDPROCESSORTYPE));
-	DBC_Require(pGenObj != NULL);
+	DBC_REQUIRE(psz_buf != NULL);
+	DBC_REQUIRE(ul_buf_size != 0);
+	DBC_REQUIRE((obj_type == DSP_DCDNODETYPE)
+		    || (obj_type == DSP_DCDPROCESSORTYPE));
+	DBC_REQUIRE(pGenObj != NULL);
 
-	switch (objType) {
+	switch (obj_type) {
 	case DSP_DCDNODETYPE:
 		/*
 		 * Parse COFF sect buffer to retrieve individual tokens used
 		 * to fill in object attrs.
 		 */
-		pszCur = pszBuf;
-		token = strsep(&pszCur, seps);
-
-		/* u32 cbStruct */
-		pGenObj->objData.nodeObj.ndbProps.cbStruct =
-				(u32) Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* DSP_UUID uiNodeID */
-		UUID_UuidFromString(token,
-				  &pGenObj->objData.nodeObj.ndbProps.uiNodeID);
-		token = strsep(&pszCur, seps);
-
-		/* acName */
-		DBC_Require(token);
-		cLen = strlen(token);
-		if (cLen > DSP_MAXNAMELEN - 1)
-			cLen = DSP_MAXNAMELEN - 1;
-
-		strncpy(pGenObj->objData.nodeObj.ndbProps.acName,
-			   token, cLen);
-		pGenObj->objData.nodeObj.ndbProps.acName[cLen] = '\0';
-		token = strsep(&pszCur, seps);
-		/* u32 uNodeType */
-		pGenObj->objData.nodeObj.ndbProps.uNodeType = Atoi(token);
-		token = strsep(&pszCur, seps);
-		/* u32 bCacheOnGPP */
-		pGenObj->objData.nodeObj.ndbProps.bCacheOnGPP = Atoi(token);
-		token = strsep(&pszCur, seps);
-		/* DSP_RESOURCEREQMTS dspResourceReqmts */
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.cbStruct =
-				(u32) Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uStaticDataSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uGlobalDataSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uProgramMemSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uWCExecutionTime = Atoi(token);
-		token = strsep(&pszCur, seps);
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uWCPeriod = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uWCDeadline = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uAvgExectionTime = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uMinimumPeriod = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* s32 iPriority */
-		pGenObj->objData.nodeObj.ndbProps.iPriority = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uStackSize */
-		pGenObj->objData.nodeObj.ndbProps.uStackSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uSysStackSize */
-		pGenObj->objData.nodeObj.ndbProps.uSysStackSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uStackSeg */
-		pGenObj->objData.nodeObj.ndbProps.uStackSeg = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uMessageDepth */
-		pGenObj->objData.nodeObj.ndbProps.uMessageDepth = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uNumInputStreams */
-		pGenObj->objData.nodeObj.ndbProps.uNumInputStreams =
-			Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uNumOutputStreams */
-		pGenObj->objData.nodeObj.ndbProps.uNumOutputStreams =
-			Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uTimeout */
-		pGenObj->objData.nodeObj.ndbProps.uTimeout =
-			Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* char *pstrCreatePhaseFxn */
-		DBC_Require(token);
-		cLen = strlen(token);
-		pGenObj->objData.nodeObj.pstrCreatePhaseFxn =
-			MEM_Calloc(cLen + 1, MEM_PAGED);
-		if (!pGenObj->objData.nodeObj.pstrCreatePhaseFxn) {
+		psz_cur = psz_buf;
+		token = strsep(&psz_cur, seps);
+
+		/* u32 cb_struct */
+		pGenObj->obj_data.node_obj.ndb_props.cb_struct =
+		    (u32) atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* dsp_uuid ui_node_id */
+		uuid_uuid_from_string(token,
+				      &pGenObj->obj_data.node_obj.ndb_props.
+				      ui_node_id);
+		token = strsep(&psz_cur, seps);
+
+		/* ac_name */
+		DBC_REQUIRE(token);
+		token_len = strlen(token);
+		if (token_len > DSP_MAXNAMELEN - 1)
+			token_len = DSP_MAXNAMELEN - 1;
+
+		strncpy(pGenObj->obj_data.node_obj.ndb_props.ac_name,
+			token, token_len);
+		pGenObj->obj_data.node_obj.ndb_props.ac_name[token_len] = '\0';
+		token = strsep(&psz_cur, seps);
+		/* u32 ntype */
+		pGenObj->obj_data.node_obj.ndb_props.ntype = atoi(token);
+		token = strsep(&psz_cur, seps);
+		/* u32 cache_on_gpp */
+		pGenObj->obj_data.node_obj.ndb_props.cache_on_gpp = atoi(token);
+		token = strsep(&psz_cur, seps);
+		/* dsp_resourcereqmts dsp_resource_reqmts */
+		pGenObj->obj_data.node_obj.ndb_props.dsp_resource_reqmts.
+		    cb_struct = (u32) atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.static_data_size = atoi(token);
+		token = strsep(&psz_cur, seps);
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.global_data_size = atoi(token);
+		token = strsep(&psz_cur, seps);
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.program_mem_size = atoi(token);
+		token = strsep(&psz_cur, seps);
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.uwc_execution_time = atoi(token);
+		token = strsep(&psz_cur, seps);
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.uwc_period = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.uwc_deadline = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.avg_exection_time = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.minimum_period = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* s32 prio */
+		pGenObj->obj_data.node_obj.ndb_props.prio = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 stack_size */
+		pGenObj->obj_data.node_obj.ndb_props.stack_size = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 sys_stack_size */
+		pGenObj->obj_data.node_obj.ndb_props.sys_stack_size =
+		    atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 stack_seg */
+		pGenObj->obj_data.node_obj.ndb_props.stack_seg = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 message_depth */
+		pGenObj->obj_data.node_obj.ndb_props.message_depth =
+		    atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 num_input_streams */
+		pGenObj->obj_data.node_obj.ndb_props.num_input_streams =
+		    atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 num_output_streams */
+		pGenObj->obj_data.node_obj.ndb_props.num_output_streams =
+		    atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 utimeout */
+		pGenObj->obj_data.node_obj.ndb_props.utimeout = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* char *pstr_create_phase_fxn */
+		DBC_REQUIRE(token);
+		token_len = strlen(token);
+		pGenObj->obj_data.node_obj.pstr_create_phase_fxn =
+		    mem_calloc(token_len + 1, MEM_PAGED);
+		if (!pGenObj->obj_data.node_obj.pstr_create_phase_fxn) {
 			status = DSP_EMEMORY;
 			break;
 		}
-		strncpy(pGenObj->objData.nodeObj.pstrCreatePhaseFxn,
-			token, cLen);
-		pGenObj->objData.nodeObj.pstrCreatePhaseFxn[cLen] = '\0';
-		token = strsep(&pszCur, seps);
-
-		/* char *pstrExecutePhaseFxn */
-		DBC_Require(token);
-		cLen = strlen(token);
-		pGenObj->objData.nodeObj.pstrExecutePhaseFxn =
-			 MEM_Calloc(cLen + 1, MEM_PAGED);
-		if (!pGenObj->objData.nodeObj.pstrExecutePhaseFxn) {
+		strncpy(pGenObj->obj_data.node_obj.pstr_create_phase_fxn,
+			token, token_len);
+		pGenObj->obj_data.node_obj.pstr_create_phase_fxn[token_len] =
+		    '\0';
+		token = strsep(&psz_cur, seps);
+
+		/* char *pstr_execute_phase_fxn */
+		DBC_REQUIRE(token);
+		token_len = strlen(token);
+		pGenObj->obj_data.node_obj.pstr_execute_phase_fxn =
+		    mem_calloc(token_len + 1, MEM_PAGED);
+		if (!pGenObj->obj_data.node_obj.pstr_execute_phase_fxn) {
 			status = DSP_EMEMORY;
 			break;
 		}
-		strncpy(pGenObj->objData.nodeObj.pstrExecutePhaseFxn,
-			token, cLen);
-		pGenObj->objData.nodeObj.pstrExecutePhaseFxn[cLen] = '\0';
-		token = strsep(&pszCur, seps);
-
-		/* char *pstrDeletePhaseFxn */
-		DBC_Require(token);
-		cLen = strlen(token);
-		pGenObj->objData.nodeObj.pstrDeletePhaseFxn =
-			MEM_Calloc(cLen + 1, MEM_PAGED);
-		if (!pGenObj->objData.nodeObj.pstrDeletePhaseFxn) {
+		strncpy(pGenObj->obj_data.node_obj.pstr_execute_phase_fxn,
+			token, token_len);
+		pGenObj->obj_data.node_obj.pstr_execute_phase_fxn[token_len] =
+		    '\0';
+		token = strsep(&psz_cur, seps);
+
+		/* char *pstr_delete_phase_fxn */
+		DBC_REQUIRE(token);
+		token_len = strlen(token);
+		pGenObj->obj_data.node_obj.pstr_delete_phase_fxn =
+		    mem_calloc(token_len + 1, MEM_PAGED);
+		if (!pGenObj->obj_data.node_obj.pstr_delete_phase_fxn) {
 			status = DSP_EMEMORY;
 			break;
 		}
-		strncpy(pGenObj->objData.nodeObj.pstrDeletePhaseFxn,
-			token, cLen);
-		pGenObj->objData.nodeObj.pstrDeletePhaseFxn[cLen] = '\0';
-		token = strsep(&pszCur, seps);
+		strncpy(pGenObj->obj_data.node_obj.pstr_delete_phase_fxn,
+			token, token_len);
+		pGenObj->obj_data.node_obj.pstr_delete_phase_fxn[token_len] =
+		    '\0';
+		token = strsep(&psz_cur, seps);
 
 		/* Segment id for message buffers */
-		pGenObj->objData.nodeObj.uMsgSegid = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.node_obj.msg_segid = atoi(token);
+		token = strsep(&psz_cur, seps);
 
 		/* Message notification type */
-		pGenObj->objData.nodeObj.uMsgNotifyType = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.node_obj.msg_notify_type = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		/* char *pstrIAlgName */
+		/* char *pstr_i_alg_name */
 		if (token) {
-			cLen = strlen(token);
-			pGenObj->objData.nodeObj.pstrIAlgName =
-				MEM_Calloc(cLen + 1, MEM_PAGED);
-			if (!pGenObj->objData.nodeObj.pstrIAlgName) {
+			token_len = strlen(token);
+			pGenObj->obj_data.node_obj.pstr_i_alg_name =
+			    mem_calloc(token_len + 1, MEM_PAGED);
+			if (!pGenObj->obj_data.node_obj.pstr_i_alg_name) {
 				status = DSP_EMEMORY;
 				break;
 			}
-			strncpy(pGenObj->objData.nodeObj.pstrIAlgName,
-				token, cLen);
-			pGenObj->objData.nodeObj.pstrIAlgName[cLen] = '\0';
-			token = strsep(&pszCur, seps);
+			strncpy(pGenObj->obj_data.node_obj.pstr_i_alg_name,
+				token, token_len);
+			pGenObj->obj_data.node_obj.pstr_i_alg_name[token_len] =
+			    '\0';
+			token = strsep(&psz_cur, seps);
 		}
 
 		/* Load type (static, dynamic, or overlay) */
 		if (token) {
-			pGenObj->objData.nodeObj.usLoadType = Atoi(token);
-			token = strsep(&pszCur, seps);
+			pGenObj->obj_data.node_obj.us_load_type = atoi(token);
+			token = strsep(&psz_cur, seps);
 		}
 
 		/* Dynamic load data requirements */
 		if (token) {
-			pGenObj->objData.nodeObj.ulDataMemSegMask = Atoi(token);
-			token = strsep(&pszCur, seps);
+			pGenObj->obj_data.node_obj.ul_data_mem_seg_mask =
+			    atoi(token);
+			token = strsep(&psz_cur, seps);
 		}
 
 		/* Dynamic load code requirements */
 		if (token) {
-			pGenObj->objData.nodeObj.ulCodeMemSegMask = Atoi(token);
-			token = strsep(&pszCur, seps);
+			pGenObj->obj_data.node_obj.ul_code_mem_seg_mask =
+			    atoi(token);
+			token = strsep(&psz_cur, seps);
 		}
 
 		/* Extract node profiles into node properties */
 		if (token) {
 
-			pGenObj->objData.nodeObj.ndbProps.uCountProfiles =
-				Atoi(token);
-			for (i = 0; i < pGenObj->objData.nodeObj.ndbProps.
-			    uCountProfiles; i++) {
-				token = strsep(&pszCur, seps);
+			pGenObj->obj_data.node_obj.ndb_props.count_profiles =
+			    atoi(token);
+			for (i = 0;
+			     i <
+			     pGenObj->obj_data.node_obj.
+			     ndb_props.count_profiles; i++) {
+				token = strsep(&psz_cur, seps);
 				if (token) {
 					/* Heap Size for the node */
-					pGenObj->objData.nodeObj.ndbProps.
-						aProfiles[i].ulHeapSize =
-						Atoi(token);
+					pGenObj->obj_data.node_obj.
+					    ndb_props.node_profiles[i].
+					    ul_heap_size = atoi(token);
 				}
 			}
 		}
-		token = strsep(&pszCur, seps);
+		token = strsep(&psz_cur, seps);
 		if (token) {
-			pGenObj->objData.nodeObj.ndbProps.uStackSegName =
-				(u32)(token);
+			pGenObj->obj_data.node_obj.ndb_props.stack_seg_name =
+			    (u32) (token);
 		}
 
 		break;
@@ -1148,49 +1173,49 @@ static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
 		 * Parse COFF sect buffer to retrieve individual tokens used
 		 * to fill in object attrs.
 		 */
-		pszCur = pszBuf;
-		token = strsep(&pszCur, seps);
+		psz_cur = psz_buf;
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.cbStruct = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.cb_struct = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.uProcessorFamily = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.processor_family = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.uProcessorType = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.processor_type = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.uClockRate = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.clock_rate = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.ulInternalMemSize = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.ul_internal_mem_size = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.ulExternalMemSize = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.ul_external_mem_size = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.uProcessorID = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.processor_id = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.tyRunningRTOS = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.ty_running_rtos = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.nNodeMinPriority = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.node_min_priority = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.nNodeMaxPriority = Atoi(token);
+		pGenObj->obj_data.proc_info.node_max_priority = atoi(token);
 
 #ifdef _DB_TIOMAP
 		/* Proc object may contain additional(extended) attributes. */
 		/* attr must match proc.hxx */
-		for (iEntry = 0; iEntry < 7; iEntry++) {
-			token = strsep(&pszCur, seps);
-			pGenObj->objData.extProcObj.tyTlb[iEntry].ulGppPhys =
-				Atoi(token);
-
-			token = strsep(&pszCur, seps);
-			pGenObj->objData.extProcObj.tyTlb[iEntry].ulDspVirt =
-				Atoi(token);
+		for (entry_id = 0; entry_id < 7; entry_id++) {
+			token = strsep(&psz_cur, seps);
+			pGenObj->obj_data.ext_proc_obj.ty_tlb[entry_id].
+			    ul_gpp_phys = atoi(token);
+
+			token = strsep(&psz_cur, seps);
+			pGenObj->obj_data.ext_proc_obj.ty_tlb[entry_id].
+			    ul_dsp_virt = atoi(token);
 		}
 #endif
 
@@ -1203,9 +1228,9 @@ static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
 
 	/* Check for Memory leak */
 	if (status == DSP_EMEMORY) {
-		kfree(pGenObj->objData.nodeObj.pstrCreatePhaseFxn);
-		kfree(pGenObj->objData.nodeObj.pstrExecutePhaseFxn);
-		kfree(pGenObj->objData.nodeObj.pstrDeletePhaseFxn);
+		kfree(pGenObj->obj_data.node_obj.pstr_create_phase_fxn);
+		kfree(pGenObj->obj_data.node_obj.pstr_execute_phase_fxn);
+		kfree(pGenObj->obj_data.node_obj.pstr_delete_phase_fxn);
 	}
 
 	return status;
@@ -1216,21 +1241,21 @@ static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
  *  Purpose:
  *      Compress the DSP buffer, if necessary, to conform to PC format.
  */
-static void CompressBuf(char *pszBuf, u32 ulBufSize, s32 cCharSize)
+static void compress_buf(char *psz_buf, u32 ul_buf_size, s32 cCharSize)
 {
 	char *p;
 	char ch;
 	char *q;
 
-	p = pszBuf;
+	p = psz_buf;
 	if (p == NULL)
 		return;
 
-	for (q = pszBuf; q < (pszBuf + ulBufSize);) {
-		ch = DspChar2GppChar(q, cCharSize);
+	for (q = psz_buf; q < (psz_buf + ul_buf_size);) {
+		ch = dsp_char2_gpp_char(q, cCharSize);
 		if (ch == '\\') {
 			q += cCharSize;
-			ch = DspChar2GppChar(q, cCharSize);
+			ch = dsp_char2_gpp_char(q, cCharSize);
 			switch (ch) {
 			case 't':
 				*p = '\t';
@@ -1265,122 +1290,123 @@ static void CompressBuf(char *pszBuf, u32 ulBufSize, s32 cCharSize)
 }
 
 /*
- *  ======== DspChar2GppChar ========
+ *  ======== dsp_char2_gpp_char ========
  *  Purpose:
  *      Convert DSP char to host GPP char in a portable manner
  */
-static char DspChar2GppChar(char *pWord, s32 cDspCharSize)
+static char dsp_char2_gpp_char(char *pWord, s32 cDspCharSize)
 {
 	char ch = '\0';
-	char *chSrc;
+	char *ch_src;
 	s32 i;
 
-	for (chSrc = pWord, i = cDspCharSize; i > 0; i--)
-		ch |= *chSrc++;
+	for (ch_src = pWord, i = cDspCharSize; i > 0; i--)
+		ch |= *ch_src++;
 
 	return ch;
 }
 
 /*
- *  ======== GetDepLibInfo ========
+ *  ======== get_dep_lib_info ========
  */
-static DSP_STATUS GetDepLibInfo(IN struct DCD_MANAGER *hDcdMgr,
-				IN struct DSP_UUID *pUuid,
-				IN OUT u16 *pNumLibs,
-				OPTIONAL OUT u16 *pNumPersLibs,
-				OPTIONAL OUT struct DSP_UUID *pDepLibUuids,
-				OPTIONAL OUT bool *pPersistentDepLibs,
-				enum NLDR_PHASE phase)
+static dsp_status get_dep_lib_info(IN struct dcd_manager *hdcd_mgr,
+				   IN struct dsp_uuid *uuid_obj,
+				   IN OUT u16 *pNumLibs,
+				   OPTIONAL OUT u16 *pNumPersLibs,
+				   OPTIONAL OUT struct dsp_uuid *pDepLibUuids,
+				   OPTIONAL OUT bool *pPersistentDepLibs,
+				   enum nldr_phase phase)
 {
-	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
-	char *pszCoffBuf = NULL;
-	char *pszCur;
-	char *pszFileName = NULL;
-	struct COD_LIBRARYOBJ *lib = NULL;
-	u32 ulAddr = 0;				/* Used by COD_GetSection */
-	u32 ulLen = 0;				/* Used by COD_GetSection */
-	u32 dwDataSize = COD_MAXPATHLENGTH;
+	struct dcd_manager *dcd_mgr_obj = hdcd_mgr;
+	char *psz_coff_buf = NULL;
+	char *psz_cur;
+	char *psz_file_name = NULL;
+	struct cod_libraryobj *lib = NULL;
+	u32 ul_addr = 0;	/* Used by cod_get_section */
+	u32 ul_len = 0;		/* Used by cod_get_section */
+	u32 dw_data_size = COD_MAXPATHLENGTH;
 	char seps[] = ", ";
-	char *pToken = NULL;
-	bool fGetUuids = (pDepLibUuids != NULL);
-	u16 nDepLibs = 0;
-	DSP_STATUS status = DSP_SOK;
+	char *token = NULL;
+	bool get_uuids = (pDepLibUuids != NULL);
+	u16 dep_libs = 0;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	DBC_Require(IsValidHandle(hDcdMgr));
-	DBC_Require(pNumLibs != NULL);
-	DBC_Require(pUuid != NULL);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdcd_mgr));
+	DBC_REQUIRE(pNumLibs != NULL);
+	DBC_REQUIRE(uuid_obj != NULL);
 
 	/*  Initialize to 0 dependent libraries, if only counting number of
 	 *  dependent libraries */
-	if (!fGetUuids) {
+	if (!get_uuids) {
 		*pNumLibs = 0;
 		*pNumPersLibs = 0;
 	}
 
 	/* Allocate a buffer for file name */
-	pszFileName = MEM_Calloc(dwDataSize, MEM_PAGED);
-	if (pszFileName == NULL) {
+	psz_file_name = mem_calloc(dw_data_size, MEM_PAGED);
+	if (psz_file_name == NULL) {
 		status = DSP_EMEMORY;
 	} else {
 		/* Get the name of the library */
-		status = DCD_GetLibraryName(hDcdMgr, pUuid, pszFileName,
-			 &dwDataSize, phase, NULL);
+		status = dcd_get_library_name(hdcd_mgr, uuid_obj, psz_file_name,
+					      &dw_data_size, phase, NULL);
 	}
 
 	/* Open the library */
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_Open(pDcdMgr->hCodMgr, pszFileName,
-				 COD_NOLOAD, &lib);
+		status = cod_open(dcd_mgr_obj->cod_mgr, psz_file_name,
+				  COD_NOLOAD, &lib);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Get dependent library section information. */
-		status = COD_GetSection(lib, DEPLIBSECT, &ulAddr, &ulLen);
+		status = cod_get_section(lib, DEPLIBSECT, &ul_addr, &ul_len);
 
 		if (DSP_FAILED(status)) {
 			/* Ok, no dependent libraries */
-			ulLen = 0;
+			ul_len = 0;
 			status = DSP_SNODEPENDENTLIBS;
 		}
 	}
 
-	if (DSP_FAILED(status) || !(ulLen > 0))
+	if (DSP_FAILED(status) || !(ul_len > 0))
 		goto func_cont;
 
 	/* Allocate zeroed buffer. */
-	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
-	if (pszCoffBuf == NULL)
+	psz_coff_buf = mem_calloc(ul_len + 4, MEM_PAGED);
+	if (psz_coff_buf == NULL)
 		status = DSP_EMEMORY;
 
 	/* Read section contents. */
-	status = COD_ReadSection(lib, DEPLIBSECT, pszCoffBuf, ulLen);
+	status = cod_read_section(lib, DEPLIBSECT, psz_coff_buf, ul_len);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
 	/* Compress and format DSP buffer to conform to PC format. */
-	CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+	compress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);
 
 	/* Read from buffer */
-	pszCur = pszCoffBuf;
-	while ((pToken = strsep(&pszCur, seps)) && *pToken != '\0') {
-		if (fGetUuids) {
-			if (nDepLibs >= *pNumLibs) {
+	psz_cur = psz_coff_buf;
+	while ((token = strsep(&psz_cur, seps)) && *token != '\0') {
+		if (get_uuids) {
+			if (dep_libs >= *pNumLibs) {
 				/* Gone beyond the limit */
 				break;
 			} else {
 				/* Retrieve UUID string. */
-				UUID_UuidFromString(pToken,
-						 &(pDepLibUuids[nDepLibs]));
+				uuid_uuid_from_string(token,
+						      &(pDepLibUuids
+							[dep_libs]));
 				/* Is this library persistent? */
-				pToken = strsep(&pszCur, seps);
-				pPersistentDepLibs[nDepLibs] = Atoi(pToken);
-				nDepLibs++;
+				token = strsep(&psz_cur, seps);
+				pPersistentDepLibs[dep_libs] = atoi(token);
+				dep_libs++;
 			}
 		} else {
 			/* Advanc to next token */
-			pToken = strsep(&pszCur, seps);
-			if (Atoi(pToken))
+			token = strsep(&psz_cur, seps);
+			if (atoi(token))
 				(*pNumPersLibs)++;
 
 			/* Just counting number of dependent libraries */
@@ -1389,12 +1415,12 @@ static DSP_STATUS GetDepLibInfo(IN struct DCD_MANAGER *hDcdMgr,
 	}
 func_cont:
 	if (lib)
-		COD_Close(lib);
+		cod_close(lib);
 
 	/* Free previously allocated dynamic buffers. */
-	kfree(pszFileName);
+	kfree(psz_file_name);
 
-	kfree(pszCoffBuf);
+	kfree(psz_coff_buf);
 
 	return status;
 }
diff --git a/drivers/dsp/bridge/rmgr/disp.c b/drivers/dsp/bridge/rmgr/disp.c
index 7d60b1b..8a3b9d5 100644
--- a/drivers/dsp/bridge/rmgr/disp.c
+++ b/drivers/dsp/bridge/rmgr/disp.c
@@ -50,7 +50,7 @@
 #define DISP_SIGNATURE       0x50534944	/* "PSID" */
 
 /* Size of a reply from RMS */
-#define REPLYSIZE (3 * sizeof(RMS_WORD))
+#define REPLYSIZE (3 * sizeof(rms_word))
 
 /* Reserved channel offsets for communication with RMS */
 #define CHNLTORMSOFFSET       0
@@ -58,70 +58,70 @@
 
 #define CHNLIOREQS      1
 
-#define SwapWord(x)     (((u32)(x) >> 16) | ((u32)(x) << 16))
+#define SWAP_WORD(x)     (((u32)(x) >> 16) | ((u32)(x) << 16))
 
 /*
- *  ======== DISP_OBJECT ========
+ *  ======== disp_object ========
  */
-struct DISP_OBJECT {
-	u32 dwSignature; 	/* Used for object validation */
-	struct DEV_OBJECT *hDevObject; 	/* Device for this processor */
-	struct WMD_DRV_INTERFACE *pIntfFxns; 	/* Function interface to WMD */
-	struct CHNL_MGR *hChnlMgr; 	/* Channel manager */
-	struct CHNL_OBJECT *hChnlToDsp;   /* Channel for commands to RMS */
-	struct CHNL_OBJECT *hChnlFromDsp;   /* Channel for replies from RMS */
-	u8 *pBuf; 		/* Buffer for commands, replies */
-	u32 ulBufsize; 	/* pBuf size in bytes */
-	u32 ulBufsizeRMS; 	/* pBuf size in RMS words */
-	u32 uCharSize; 		/* Size of DSP character */
-	u32 uWordSize; 		/* Size of DSP word */
-	u32 uDataMauSize; 	/* Size of DSP Data MAU */
+struct disp_object {
+	u32 dw_signature;	/* Used for object validation */
+	struct dev_object *hdev_obj;	/* Device for this processor */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	struct chnl_mgr *hchnl_mgr;	/* Channel manager */
+	struct chnl_object *chnl_to_dsp;	/* Chnl for commands to RMS */
+	struct chnl_object *chnl_from_dsp;	/* Chnl for replies from RMS */
+	u8 *pbuf;		/* Buffer for commands, replies */
+	u32 ul_bufsize;		/* pbuf size in bytes */
+	u32 ul_bufsize_rms;	/* pbuf size in RMS words */
+	u32 char_size;		/* Size of DSP character */
+	u32 word_size;		/* Size of DSP word */
+	u32 data_mau_size;	/* Size of DSP Data MAU */
 };
 
-static u32 cRefs;
+static u32 refs;
 
-static void DeleteDisp(struct DISP_OBJECT *hDisp);
-static DSP_STATUS FillStreamDef(RMS_WORD *pdwBuf, u32 *ptotal, u32 offset,
-				struct NODE_STRMDEF strmDef, u32 max,
-				u32 uCharsInRMSWord);
-static DSP_STATUS SendMessage(struct DISP_OBJECT *hDisp, u32 dwTimeout,
-			     u32 ulBytes, OUT u32 *pdwArg);
+static void delete_disp(struct disp_object *disp_obj);
+static dsp_status fill_stream_def(rms_word *pdw_buf, u32 *ptotal, u32 offset,
+				  struct node_strmdef strm_def, u32 max,
+				  u32 chars_in_rms_word);
+static dsp_status send_message(struct disp_object *disp_obj, u32 dwTimeout,
+			       u32 ul_bytes, OUT u32 *pdw_arg);
 
 /*
- *  ======== DISP_Create ========
+ *  ======== disp_create ========
  *  Create a NODE Dispatcher object.
  */
-DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
-		      struct DEV_OBJECT *hDevObject,
-		      IN CONST struct DISP_ATTRS *pDispAttrs)
+dsp_status disp_create(OUT struct disp_object **phDispObject,
+		       struct dev_object *hdev_obj,
+		       IN CONST struct disp_attr *pDispAttrs)
 {
-	struct DISP_OBJECT *pDisp;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	u32 ulChnlId;
-	struct CHNL_ATTRS chnlAttrs;
-	DSP_STATUS status = DSP_SOK;
-	u32 devType;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDispObject != NULL);
-	DBC_Require(pDispAttrs != NULL);
-	DBC_Require(hDevObject != NULL);
+	struct disp_object *disp_obj;
+	struct bridge_drv_interface *intf_fxns;
+	u32 ul_chnl_id;
+	struct chnl_attr chnl_attr_obj;
+	dsp_status status = DSP_SOK;
+	u32 dev_type;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDispObject != NULL);
+	DBC_REQUIRE(pDispAttrs != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
 
 	*phDispObject = NULL;
 
 	/* Allocate Node Dispatcher object */
-	MEM_AllocObject(pDisp, struct DISP_OBJECT, DISP_SIGNATURE);
-	if (pDisp == NULL)
+	MEM_ALLOC_OBJECT(disp_obj, struct disp_object, DISP_SIGNATURE);
+	if (disp_obj == NULL)
 		status = DSP_EMEMORY;
 	else
-		pDisp->hDevObject = hDevObject;
+		disp_obj->hdev_obj = hdev_obj;
 
 	/* Get Channel manager and WMD function interface */
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetChnlMgr(hDevObject, &(pDisp->hChnlMgr));
+		status = dev_get_chnl_mgr(hdev_obj, &(disp_obj->hchnl_mgr));
 		if (DSP_SUCCEEDED(status)) {
-			status = DEV_GetIntfFxns(hDevObject, &pIntfFxns);
-			pDisp->pIntfFxns = pIntfFxns;
+			(void)dev_get_intf_fxns(hdev_obj, &intf_fxns);
+			disp_obj->intf_fxns = intf_fxns;
 		}
 	}
 
@@ -130,189 +130,195 @@ DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	status = DEV_GetDevType(hDevObject, &devType);
+	status = dev_get_dev_type(hdev_obj, &dev_type);
 
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	if (devType != DSP_UNIT) {
+	if (dev_type != DSP_UNIT) {
 		status = DSP_EFAIL;
 		goto func_cont;
 	}
 
-	pDisp->uCharSize = DSPWORDSIZE;
-	pDisp->uWordSize = DSPWORDSIZE;
-	pDisp->uDataMauSize = DSPWORDSIZE;
+	disp_obj->char_size = DSPWORDSIZE;
+	disp_obj->word_size = DSPWORDSIZE;
+	disp_obj->data_mau_size = DSPWORDSIZE;
 	/* Open channels for communicating with the RMS */
-	chnlAttrs.uIOReqs = CHNLIOREQS;
-	chnlAttrs.hEvent = NULL;
-	ulChnlId = pDispAttrs->ulChnlOffset + CHNLTORMSOFFSET;
-	status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlToDsp),
-		 pDisp->hChnlMgr, CHNL_MODETODSP, ulChnlId, &chnlAttrs);
+	chnl_attr_obj.uio_reqs = CHNLIOREQS;
+	chnl_attr_obj.event_obj = NULL;
+	ul_chnl_id = pDispAttrs->ul_chnl_offset + CHNLTORMSOFFSET;
+	status = (*intf_fxns->pfn_chnl_open) (&(disp_obj->chnl_to_dsp),
+					      disp_obj->hchnl_mgr,
+					      CHNL_MODETODSP, ul_chnl_id,
+					      &chnl_attr_obj);
 
 	if (DSP_SUCCEEDED(status)) {
-		ulChnlId = pDispAttrs->ulChnlOffset + CHNLFROMRMSOFFSET;
-		status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlFromDsp),
-			 pDisp->hChnlMgr, CHNL_MODEFROMDSP, ulChnlId,
-			 &chnlAttrs);
+		ul_chnl_id = pDispAttrs->ul_chnl_offset + CHNLFROMRMSOFFSET;
+		status =
+		    (*intf_fxns->pfn_chnl_open) (&(disp_obj->chnl_from_dsp),
+						 disp_obj->hchnl_mgr,
+						 CHNL_MODEFROMDSP, ul_chnl_id,
+						 &chnl_attr_obj);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Allocate buffer for commands, replies */
-		pDisp->ulBufsize = pDispAttrs->ulChnlBufSize;
-		pDisp->ulBufsizeRMS = RMS_COMMANDBUFSIZE;
-		pDisp->pBuf = MEM_Calloc(pDisp->ulBufsize, MEM_PAGED);
-		if (pDisp->pBuf == NULL)
+		disp_obj->ul_bufsize = pDispAttrs->ul_chnl_buf_size;
+		disp_obj->ul_bufsize_rms = RMS_COMMANDBUFSIZE;
+		disp_obj->pbuf = mem_calloc(disp_obj->ul_bufsize, MEM_PAGED);
+		if (disp_obj->pbuf == NULL)
 			status = DSP_EMEMORY;
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status))
-		*phDispObject = pDisp;
+		*phDispObject = disp_obj;
 	else
-		DeleteDisp(pDisp);
+		delete_disp(disp_obj);
 
-	DBC_Ensure(((DSP_FAILED(status)) && ((*phDispObject == NULL))) ||
-		  ((DSP_SUCCEEDED(status)) &&
-		  (MEM_IsValidHandle((*phDispObject), DISP_SIGNATURE))));
+	DBC_ENSURE(((DSP_FAILED(status)) && ((*phDispObject == NULL))) ||
+		   ((DSP_SUCCEEDED(status)) &&
+		    (MEM_IS_VALID_HANDLE((*phDispObject), DISP_SIGNATURE))));
 	return status;
 }
 
 /*
- *  ======== DISP_Delete ========
+ *  ======== disp_delete ========
  *  Delete the NODE Dispatcher.
  */
-void DISP_Delete(struct DISP_OBJECT *hDisp)
+void disp_delete(struct disp_object *disp_obj)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
 
-	DeleteDisp(hDisp);
+	delete_disp(disp_obj);
 
-	DBC_Ensure(!MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+	DBC_ENSURE(!MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
 }
 
 /*
- *  ======== DISP_Exit ========
+ *  ======== disp_exit ========
  *  Discontinue usage of DISP module.
  */
-void DISP_Exit(void)
+void disp_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== DISP_Init ========
+ *  ======== disp_init ========
  *  Initialize the DISP module.
  */
-bool DISP_Init(void)
+bool disp_init(void)
 {
-	bool fRetVal = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (fRetVal)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetVal && (cRefs > 0)) || (!fRetVal && (cRefs >= 0)));
-	return fRetVal;
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
+	return ret;
 }
 
 /*
- *  ======== DISP_NodeChangePriority ========
+ *  ======== disp_node_change_priority ========
  *  Change the priority of a node currently running on the target.
  */
-DSP_STATUS DISP_NodeChangePriority(struct DISP_OBJECT *hDisp,
-				  struct NODE_OBJECT *hNode,
-				  u32 ulRMSFxn, NODE_ENV nodeEnv,
-				  s32 nPriority)
+dsp_status disp_node_change_priority(struct disp_object *disp_obj,
+				     struct node_object *hnode,
+				     u32 ulRMSFxn, nodeenv node_env, s32 prio)
 {
-	u32 dwArg;
-	struct RMS_Command *pCommand;
-	DSP_STATUS status = DSP_SOK;
+	u32 dw_arg;
+	struct rms_command *rms_cmd;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-	DBC_Require(hNode != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
+	DBC_REQUIRE(hnode != NULL);
 
 	/* Send message to RMS to change priority */
-	pCommand = (struct RMS_Command *)(hDisp->pBuf);
-	pCommand->fxn = (RMS_WORD)(ulRMSFxn);
-	pCommand->arg1 = (RMS_WORD)nodeEnv;
-	pCommand->arg2 = nPriority;
-	status = SendMessage(hDisp, NODE_GetTimeout(hNode),
-		 sizeof(struct RMS_Command), &dwArg);
+	rms_cmd = (struct rms_command *)(disp_obj->pbuf);
+	rms_cmd->fxn = (rms_word) (ulRMSFxn);
+	rms_cmd->arg1 = (rms_word) node_env;
+	rms_cmd->arg2 = prio;
+	status = send_message(disp_obj, node_get_timeout(hnode),
+			      sizeof(struct rms_command), &dw_arg);
 
 	return status;
 }
 
 /*
- *  ======== DISP_NodeCreate ========
+ *  ======== disp_node_create ========
  *  Create a node on the DSP by remotely calling the node's create function.
  */
-DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
-			  u32 ulRMSFxn, u32 ulCreateFxn,
-			  IN CONST struct NODE_CREATEARGS *pArgs,
-			  OUT NODE_ENV *pNodeEnv)
+dsp_status disp_node_create(struct disp_object *disp_obj,
+			    struct node_object *hnode, u32 ulRMSFxn,
+			    u32 ul_create_fxn,
+			    IN CONST struct node_createargs *pargs,
+			    OUT nodeenv *pNodeEnv)
 {
-	struct NODE_MSGARGS msgArgs;
-	struct NODE_TASKARGS taskArgs;
-	struct RMS_Command *pCommand;
-	struct RMS_MsgArgs *pMsgArgs;
-	struct RMS_MoreTaskArgs *pMoreTaskArgs;
-	enum NODE_TYPE nodeType;
-	u32 dwLength;
-	RMS_WORD *pdwBuf = NULL;
-	u32 ulBytes;
+	struct node_msgargs node_msg_args;
+	struct node_taskargs task_arg_obj;
+	struct rms_command *rms_cmd;
+	struct rms_msg_args *pmsg_args;
+	struct rms_more_task_args *more_task_args;
+	enum node_type node_type;
+	u32 dw_length;
+	rms_word *pdw_buf = NULL;
+	u32 ul_bytes;
 	u32 i;
 	u32 total;
-	u32 uCharsInRMSWord;
-	s32 taskArgsOffset;
-	s32 sioInDefOffset;
-	s32 sioOutDefOffset;
-	s32 sioDefsOffset;
-	s32 argsOffset = -1;
+	u32 chars_in_rms_word;
+	s32 task_args_offset;
+	s32 sio_in_def_offset;
+	s32 sio_out_def_offset;
+	s32 sio_defs_offset;
+	s32 args_offset = -1;
 	s32 offset;
-	struct NODE_STRMDEF strmDef;
+	struct node_strmdef strm_def;
 	u32 max;
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_NODEINFO nodeInfo;
-	u32 devType;
+	dsp_status status = DSP_SOK;
+	struct dsp_nodeinfo node_info;
+	u32 dev_type;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-	DBC_Require(hNode != NULL);
-	DBC_Require(NODE_GetType(hNode) != NODE_DEVICE);
-	DBC_Require(pNodeEnv != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
+	DBC_REQUIRE(hnode != NULL);
+	DBC_REQUIRE(node_get_type(hnode) != NODE_DEVICE);
+	DBC_REQUIRE(pNodeEnv != NULL);
 
-	status = DEV_GetDevType(hDisp->hDevObject, &devType);
+	status = dev_get_dev_type(disp_obj->hdev_obj, &dev_type);
 
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (devType != DSP_UNIT) {
+	if (dev_type != DSP_UNIT) {
 		dev_dbg(bridge, "%s: unknown device type = 0x%x\n",
-							__func__, devType);
+			__func__, dev_type);
 		goto func_end;
 	}
-	DBC_Require(pArgs != NULL);
-	nodeType = NODE_GetType(hNode);
-	msgArgs = pArgs->asa.msgArgs;
-	max = hDisp->ulBufsizeRMS;    /*Max # of RMS words that can be sent */
-	DBC_Assert(max == RMS_COMMANDBUFSIZE);
-	uCharsInRMSWord = sizeof(RMS_WORD) / hDisp->uCharSize;
+	DBC_REQUIRE(pargs != NULL);
+	node_type = node_get_type(hnode);
+	node_msg_args = pargs->asa.node_msg_args;
+	max = disp_obj->ul_bufsize_rms;	/*Max # of RMS words that can be sent */
+	DBC_ASSERT(max == RMS_COMMANDBUFSIZE);
+	chars_in_rms_word = sizeof(rms_word) / disp_obj->char_size;
 	/* Number of RMS words needed to hold arg data */
-	dwLength = (msgArgs.uArgLength + uCharsInRMSWord - 1) / uCharsInRMSWord;
+	dw_length =
+	    (node_msg_args.arg_length + chars_in_rms_word -
+	     1) / chars_in_rms_word;
 	/* Make sure msg args and command fit in buffer */
-	total = sizeof(struct RMS_Command) / sizeof(RMS_WORD) +
-		sizeof(struct RMS_MsgArgs)
-		/ sizeof(RMS_WORD)  - 1 + dwLength;
+	total = sizeof(struct rms_command) / sizeof(rms_word) +
+	    sizeof(struct rms_msg_args)
+	    / sizeof(rms_word) - 1 + dw_length;
 	if (total >= max) {
 		status = DSP_EFAIL;
 		dev_dbg(bridge, "%s: Message args too large for buffer! size "
-				"= %d, max = %d\n", __func__, total, max);
+			"= %d, max = %d\n", __func__, total, max);
 	}
 	/*
 	 *  Fill in buffer to send to RMS.
@@ -349,100 +355,108 @@ DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
 	 *
 	 */
 	if (DSP_SUCCEEDED(status)) {
-		total = 0; 	/* Total number of words in buffer so far */
-		pdwBuf = (RMS_WORD *)hDisp->pBuf;
-		pCommand = (struct RMS_Command *)pdwBuf;
-		pCommand->fxn = (RMS_WORD)(ulRMSFxn);
-		pCommand->arg1 = (RMS_WORD)(ulCreateFxn);
-		if (NODE_GetLoadType(hNode) == NLDR_DYNAMICLOAD) {
+		total = 0;	/* Total number of words in buffer so far */
+		pdw_buf = (rms_word *) disp_obj->pbuf;
+		rms_cmd = (struct rms_command *)pdw_buf;
+		rms_cmd->fxn = (rms_word) (ulRMSFxn);
+		rms_cmd->arg1 = (rms_word) (ul_create_fxn);
+		if (node_get_load_type(hnode) == NLDR_DYNAMICLOAD) {
 			/* Flush ICACHE on Load */
-			pCommand->arg2 = 1; 	/* dummy argument */
+			rms_cmd->arg2 = 1;	/* dummy argument */
 		} else {
 			/* Do not flush ICACHE */
-			pCommand->arg2 = 0; 	/* dummy argument */
+			rms_cmd->arg2 = 0;	/* dummy argument */
 		}
-		pCommand->data = NODE_GetType(hNode);
+		rms_cmd->data = node_get_type(hnode);
 		/*
-		 *  argsOffset is the offset of the data field in struct
-		 *  RMS_Command structure. We need this to calculate stream
+		 *  args_offset is the offset of the data field in struct
+		 *  rms_command structure. We need this to calculate stream
 		 *  definition offsets.
 		 */
-		argsOffset = 3;
-		total += sizeof(struct RMS_Command) / sizeof(RMS_WORD);
+		args_offset = 3;
+		total += sizeof(struct rms_command) / sizeof(rms_word);
 		/* Message args */
-		pMsgArgs = (struct RMS_MsgArgs *) (pdwBuf + total);
-		pMsgArgs->maxMessages = msgArgs.uMaxMessages;
-		pMsgArgs->segid = msgArgs.uSegid;
-		pMsgArgs->notifyType = msgArgs.uNotifyType;
-		pMsgArgs->argLength = msgArgs.uArgLength;
-		total += sizeof(struct RMS_MsgArgs) / sizeof(RMS_WORD) - 1;
-		memcpy(pdwBuf + total, msgArgs.pData, msgArgs.uArgLength);
-		total += dwLength;
+		pmsg_args = (struct rms_msg_args *)(pdw_buf + total);
+		pmsg_args->max_msgs = node_msg_args.max_msgs;
+		pmsg_args->segid = node_msg_args.seg_id;
+		pmsg_args->notify_type = node_msg_args.notify_type;
+		pmsg_args->arg_length = node_msg_args.arg_length;
+		total += sizeof(struct rms_msg_args) / sizeof(rms_word) - 1;
+		memcpy(pdw_buf + total, node_msg_args.pdata,
+		       node_msg_args.arg_length);
+		total += dw_length;
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* If node is a task node, copy task create arguments into  buffer */
-	if (nodeType == NODE_TASK || nodeType == NODE_DAISSOCKET) {
-		taskArgs = pArgs->asa.taskArgs;
-		taskArgsOffset = total;
-		total += sizeof(struct RMS_MoreTaskArgs) / sizeof(RMS_WORD) +
-			1 + taskArgs.uNumInputs + taskArgs.uNumOutputs;
+	if (node_type == NODE_TASK || node_type == NODE_DAISSOCKET) {
+		task_arg_obj = pargs->asa.task_arg_obj;
+		task_args_offset = total;
+		total += sizeof(struct rms_more_task_args) / sizeof(rms_word) +
+		    1 + task_arg_obj.num_inputs + task_arg_obj.num_outputs;
 		/* Copy task arguments */
 		if (total < max) {
-			total = taskArgsOffset;
-			pMoreTaskArgs = (struct RMS_MoreTaskArgs *)(pdwBuf +
-					total);
+			total = task_args_offset;
+			more_task_args = (struct rms_more_task_args *)(pdw_buf +
+								       total);
 			/*
 			 * Get some important info about the node. Note that we
-			 * don't just reach into the hNode struct because
+			 * don't just reach into the hnode struct because
 			 * that would break the node object's abstraction.
 			 */
-			GetNodeInfo(hNode, &nodeInfo);
-			pMoreTaskArgs->priority = nodeInfo.uExecutionPriority;
-			pMoreTaskArgs->stackSize = taskArgs.uStackSize;
-			pMoreTaskArgs->sysstackSize = taskArgs.uSysStackSize;
-			pMoreTaskArgs->stackSeg = taskArgs.uStackSeg;
-			pMoreTaskArgs->heapAddr = taskArgs.uDSPHeapAddr;
-			pMoreTaskArgs->heapSize = taskArgs.uHeapSize;
-			pMoreTaskArgs->misc = taskArgs.ulDaisArg;
-			pMoreTaskArgs->numInputStreams = taskArgs.uNumInputs;
+			get_node_info(hnode, &node_info);
+			more_task_args->priority = node_info.execution_priority;
+			more_task_args->stack_size = task_arg_obj.stack_size;
+			more_task_args->sysstack_size =
+			    task_arg_obj.sys_stack_size;
+			more_task_args->stack_seg = task_arg_obj.stack_seg;
+			more_task_args->heap_addr = task_arg_obj.udsp_heap_addr;
+			more_task_args->heap_size = task_arg_obj.heap_size;
+			more_task_args->misc = task_arg_obj.ul_dais_arg;
+			more_task_args->num_input_streams =
+			    task_arg_obj.num_inputs;
 			total +=
-			    sizeof(struct RMS_MoreTaskArgs) / sizeof(RMS_WORD);
-			dev_dbg(bridge, "%s: uDSPHeapAddr %x, uHeapSize %x\n",
-					__func__, taskArgs.uDSPHeapAddr,
-					taskArgs.uHeapSize);
+			    sizeof(struct rms_more_task_args) /
+			    sizeof(rms_word);
+			dev_dbg(bridge, "%s: udsp_heap_addr %x, heap_size %x\n",
+				__func__, task_arg_obj.udsp_heap_addr,
+				task_arg_obj.heap_size);
 			/* Keep track of pSIOInDef[] and pSIOOutDef[]
 			 * positions in the buffer, since this needs to be
-			 * filled in later.  */
-			sioInDefOffset = total;
-			total += taskArgs.uNumInputs;
-			pdwBuf[total++] = taskArgs.uNumOutputs;
-			sioOutDefOffset = total;
-			total += taskArgs.uNumOutputs;
-			sioDefsOffset = total;
+			 * filled in later. */
+			sio_in_def_offset = total;
+			total += task_arg_obj.num_inputs;
+			pdw_buf[total++] = task_arg_obj.num_outputs;
+			sio_out_def_offset = total;
+			total += task_arg_obj.num_outputs;
+			sio_defs_offset = total;
 			/* Fill SIO defs and offsets */
-			offset = sioDefsOffset;
-			for (i = 0; i < taskArgs.uNumInputs; i++) {
+			offset = sio_defs_offset;
+			for (i = 0; i < task_arg_obj.num_inputs; i++) {
 				if (DSP_FAILED(status))
 					break;
 
-				pdwBuf[sioInDefOffset + i] =
-					(offset - argsOffset)
-					* (sizeof(RMS_WORD) / DSPWORDSIZE);
-				strmDef = taskArgs.strmInDef[i];
-				status = FillStreamDef(pdwBuf, &total, offset,
-					 strmDef, max, uCharsInRMSWord);
+				pdw_buf[sio_in_def_offset + i] =
+				    (offset - args_offset)
+				    * (sizeof(rms_word) / DSPWORDSIZE);
+				strm_def = task_arg_obj.strm_in_def[i];
+				status =
+				    fill_stream_def(pdw_buf, &total, offset,
+						    strm_def, max,
+						    chars_in_rms_word);
 				offset = total;
 			}
-			for (i = 0;  (i < taskArgs.uNumOutputs) &&
-			    (DSP_SUCCEEDED(status)); i++) {
-				pdwBuf[sioOutDefOffset + i] =
-					(offset - argsOffset)
-					* (sizeof(RMS_WORD) / DSPWORDSIZE);
-				strmDef = taskArgs.strmOutDef[i];
-				status = FillStreamDef(pdwBuf, &total, offset,
-					 strmDef, max, uCharsInRMSWord);
+			for (i = 0; (i < task_arg_obj.num_outputs) &&
+			     (DSP_SUCCEEDED(status)); i++) {
+				pdw_buf[sio_out_def_offset + i] =
+				    (offset - args_offset)
+				    * (sizeof(rms_word) / DSPWORDSIZE);
+				strm_def = task_arg_obj.strm_out_def[i];
+				status =
+				    fill_stream_def(pdw_buf, &total, offset,
+						    strm_def, max,
+						    chars_in_rms_word);
 				offset = total;
 			}
 		} else {
@@ -451,20 +465,20 @@ DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		ulBytes = total * sizeof(RMS_WORD);
-		DBC_Assert(ulBytes < (RMS_COMMANDBUFSIZE * sizeof(RMS_WORD)));
-		status = SendMessage(hDisp, NODE_GetTimeout(hNode),
-			 ulBytes, pNodeEnv);
+		ul_bytes = total * sizeof(rms_word);
+		DBC_ASSERT(ul_bytes < (RMS_COMMANDBUFSIZE * sizeof(rms_word)));
+		status = send_message(disp_obj, node_get_timeout(hnode),
+				      ul_bytes, pNodeEnv);
 		if (DSP_SUCCEEDED(status)) {
 			/*
 			 * Message successfully received from RMS.
 			 * Return the status of the Node's create function
 			 * on the DSP-side
 			 */
-			status = (((RMS_WORD *)(hDisp->pBuf))[0]);
+			status = (((rms_word *) (disp_obj->pbuf))[0]);
 			if (DSP_FAILED(status))
 				dev_dbg(bridge, "%s: DSP-side failed: 0x%x\n",
-							__func__, status);
+					__func__, status);
 		}
 	}
 func_end:
@@ -472,171 +486,176 @@ func_end:
 }
 
 /*
- *  ======== DISP_NodeDelete ========
+ *  ======== disp_node_delete ========
  *  purpose:
  *      Delete a node on the DSP by remotely calling the node's delete function.
  *
  */
-DSP_STATUS DISP_NodeDelete(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
-			  u32 ulRMSFxn, u32 ulDeleteFxn, NODE_ENV nodeEnv)
+dsp_status disp_node_delete(struct disp_object *disp_obj,
+			    struct node_object *hnode, u32 ulRMSFxn,
+			    u32 ul_delete_fxn, nodeenv node_env)
 {
-	u32 dwArg;
-	struct RMS_Command *pCommand;
-	DSP_STATUS status = DSP_SOK;
-	u32 devType;
+	u32 dw_arg;
+	struct rms_command *rms_cmd;
+	dsp_status status = DSP_SOK;
+	u32 dev_type;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-	DBC_Require(hNode != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
+	DBC_REQUIRE(hnode != NULL);
 
-	status = DEV_GetDevType(hDisp->hDevObject, &devType);
+	status = dev_get_dev_type(disp_obj->hdev_obj, &dev_type);
 
 	if (DSP_SUCCEEDED(status)) {
 
-		if (devType == DSP_UNIT) {
+		if (dev_type == DSP_UNIT) {
 
 			/*
 			 *  Fill in buffer to send to RMS
 			 */
-			pCommand = (struct RMS_Command *)hDisp->pBuf;
-			pCommand->fxn = (RMS_WORD)(ulRMSFxn);
-			pCommand->arg1 = (RMS_WORD)nodeEnv;
-			pCommand->arg2 = (RMS_WORD)(ulDeleteFxn);
-			pCommand->data = NODE_GetType(hNode);
-
-			status = SendMessage(hDisp, NODE_GetTimeout(hNode),
-					    sizeof(struct RMS_Command), &dwArg);
+			rms_cmd = (struct rms_command *)disp_obj->pbuf;
+			rms_cmd->fxn = (rms_word) (ulRMSFxn);
+			rms_cmd->arg1 = (rms_word) node_env;
+			rms_cmd->arg2 = (rms_word) (ul_delete_fxn);
+			rms_cmd->data = node_get_type(hnode);
+
+			status = send_message(disp_obj, node_get_timeout(hnode),
+					      sizeof(struct rms_command),
+					      &dw_arg);
 			if (DSP_SUCCEEDED(status)) {
 				/*
 				 * Message successfully received from RMS.
 				 * Return the status of the Node's delete
 				 * function on the DSP-side
 				 */
-				status = (((RMS_WORD *)(hDisp->pBuf))[0]);
+				status = (((rms_word *) (disp_obj->pbuf))[0]);
 				if (DSP_FAILED(status))
 					dev_dbg(bridge, "%s: DSP-side failed: "
 						"0x%x\n", __func__, status);
 			}
 
-
 		}
 	}
 	return status;
 }
 
 /*
- *  ======== DISP_NodeRun ========
+ *  ======== disp_node_run ========
  *  purpose:
  *      Start execution of a node's execute phase, or resume execution of a node
  *      that has been suspended (via DISP_NodePause()) on the DSP.
  */
-DSP_STATUS DISP_NodeRun(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
-			u32 ulRMSFxn, u32 ulExecuteFxn, NODE_ENV nodeEnv)
+dsp_status disp_node_run(struct disp_object *disp_obj,
+			 struct node_object *hnode, u32 ulRMSFxn,
+			 u32 ul_execute_fxn, nodeenv node_env)
 {
-	u32 dwArg;
-	struct RMS_Command *pCommand;
-	DSP_STATUS status = DSP_SOK;
-	u32 devType;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-	DBC_Require(hNode != NULL);
+	u32 dw_arg;
+	struct rms_command *rms_cmd;
+	dsp_status status = DSP_SOK;
+	u32 dev_type;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
+	DBC_REQUIRE(hnode != NULL);
 
-	status = DEV_GetDevType(hDisp->hDevObject, &devType);
+	status = dev_get_dev_type(disp_obj->hdev_obj, &dev_type);
 
 	if (DSP_SUCCEEDED(status)) {
 
-		if (devType == DSP_UNIT) {
+		if (dev_type == DSP_UNIT) {
 
 			/*
 			 *  Fill in buffer to send to RMS.
 			 */
-			pCommand = (struct RMS_Command *) hDisp->pBuf;
-			pCommand->fxn = (RMS_WORD) (ulRMSFxn);
-			pCommand->arg1 = (RMS_WORD) nodeEnv;
-			pCommand->arg2 = (RMS_WORD) (ulExecuteFxn);
-			pCommand->data = NODE_GetType(hNode);
-
-			status = SendMessage(hDisp, NODE_GetTimeout(hNode),
-				 sizeof(struct RMS_Command), &dwArg);
+			rms_cmd = (struct rms_command *)disp_obj->pbuf;
+			rms_cmd->fxn = (rms_word) (ulRMSFxn);
+			rms_cmd->arg1 = (rms_word) node_env;
+			rms_cmd->arg2 = (rms_word) (ul_execute_fxn);
+			rms_cmd->data = node_get_type(hnode);
+
+			status = send_message(disp_obj, node_get_timeout(hnode),
+					      sizeof(struct rms_command),
+					      &dw_arg);
 			if (DSP_SUCCEEDED(status)) {
 				/*
 				 * Message successfully received from RMS.
 				 * Return the status of the Node's execute
 				 * function on the DSP-side
 				 */
-				status = (((RMS_WORD *)(hDisp->pBuf))[0]);
+				status = (((rms_word *) (disp_obj->pbuf))[0]);
 				if (DSP_FAILED(status))
 					dev_dbg(bridge, "%s: DSP-side failed: "
 						"0x%x\n", __func__, status);
-		}
+			}
 
-	}
+		}
 	}
 
 	return status;
 }
 
 /*
- *  ======== DeleteDisp ========
+ *  ======== delete_disp ========
  *  purpose:
  *      Frees the resources allocated for the dispatcher.
  */
-static void DeleteDisp(struct DISP_OBJECT *hDisp)
+static void delete_disp(struct disp_object *disp_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
+	dsp_status status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
 
-	if (MEM_IsValidHandle(hDisp, DISP_SIGNATURE)) {
-		pIntfFxns = hDisp->pIntfFxns;
+	if (MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE)) {
+		intf_fxns = disp_obj->intf_fxns;
 
 		/* Free Node Dispatcher resources */
-		if (hDisp->hChnlFromDsp) {
+		if (disp_obj->chnl_from_dsp) {
 			/* Channel close can fail only if the channel handle
 			 * is invalid. */
-			status = (*pIntfFxns->pfnChnlClose)
-				 (hDisp->hChnlFromDsp);
+			status = (*intf_fxns->pfn_chnl_close)
+			    (disp_obj->chnl_from_dsp);
 			if (DSP_FAILED(status)) {
 				dev_dbg(bridge, "%s: Failed to close channel "
 					"from RMS: 0x%x\n", __func__, status);
 			}
 		}
-		if (hDisp->hChnlToDsp) {
-			status = (*pIntfFxns->pfnChnlClose)(hDisp->hChnlToDsp);
+		if (disp_obj->chnl_to_dsp) {
+			status =
+			    (*intf_fxns->pfn_chnl_close) (disp_obj->
+							  chnl_to_dsp);
 			if (DSP_FAILED(status)) {
 				dev_dbg(bridge, "%s: Failed to close channel to"
 					" RMS: 0x%x\n", __func__, status);
 			}
 		}
-		kfree(hDisp->pBuf);
+		kfree(disp_obj->pbuf);
 
-		MEM_FreeObject(hDisp);
+		MEM_FREE_OBJECT(disp_obj);
 	}
 }
 
 /*
- *  ======== FillStreamDef ========
+ *  ======== fill_stream_def ========
  *  purpose:
  *      Fills stream definitions.
  */
-static DSP_STATUS FillStreamDef(RMS_WORD *pdwBuf, u32 *ptotal, u32 offset,
-				struct NODE_STRMDEF strmDef, u32 max,
-				u32 uCharsInRMSWord)
+static dsp_status fill_stream_def(rms_word *pdw_buf, u32 *ptotal, u32 offset,
+				  struct node_strmdef strm_def, u32 max,
+				  u32 chars_in_rms_word)
 {
-	struct RMS_StrmDef *pStrmDef;
+	struct rms_strm_def *strm_def_obj;
 	u32 total = *ptotal;
-	u32 uNameLen;
-	u32 dwLength;
-	DSP_STATUS status = DSP_SOK;
+	u32 name_len;
+	u32 dw_length;
+	dsp_status status = DSP_SOK;
 
-	if (total + sizeof(struct RMS_StrmDef) / sizeof(RMS_WORD) >= max) {
+	if (total + sizeof(struct rms_strm_def) / sizeof(rms_word) >= max) {
 		status = DSP_EFAIL;
 	} else {
-		pStrmDef = (struct RMS_StrmDef *)(pdwBuf + total);
-		pStrmDef->bufsize = strmDef.uBufsize;
-		pStrmDef->nbufs = strmDef.uNumBufs;
-		pStrmDef->segid = strmDef.uSegid;
-		pStrmDef->align = strmDef.uAlignment;
-		pStrmDef->timeout = strmDef.uTimeout;
+		strm_def_obj = (struct rms_strm_def *)(pdw_buf + total);
+		strm_def_obj->bufsize = strm_def.buf_size;
+		strm_def_obj->nbufs = strm_def.num_bufs;
+		strm_def_obj->segid = strm_def.seg_id;
+		strm_def_obj->align = strm_def.buf_alignment;
+		strm_def_obj->timeout = strm_def.utimeout;
 	}
 
 	if (DSP_SUCCEEDED(status)) {
@@ -644,24 +663,25 @@ static DSP_STATUS FillStreamDef(RMS_WORD *pdwBuf, u32 *ptotal, u32 offset,
 		 *  Since we haven't added the device name yet, subtract
 		 *  1 from total.
 		 */
-		total += sizeof(struct RMS_StrmDef) / sizeof(RMS_WORD) - 1;
-		DBC_Require(strmDef.szDevice);
-		dwLength = strlen(strmDef.szDevice) + 1;
+		total += sizeof(struct rms_strm_def) / sizeof(rms_word) - 1;
+		DBC_REQUIRE(strm_def.sz_device);
+		dw_length = strlen(strm_def.sz_device) + 1;
 
 		/* Number of RMS_WORDS needed to hold device name */
-		uNameLen = (dwLength + uCharsInRMSWord - 1) / uCharsInRMSWord;
+		name_len =
+		    (dw_length + chars_in_rms_word - 1) / chars_in_rms_word;
 
-		if (total + uNameLen >= max) {
+		if (total + name_len >= max) {
 			status = DSP_EFAIL;
 		} else {
 			/*
 			 *  Zero out last word, since the device name may not
 			 *  extend to completely fill this word.
 			 */
-			pdwBuf[total + uNameLen - 1] = 0;
-			/** TODO USE SERVICES **/
-			memcpy(pdwBuf + total, strmDef.szDevice, dwLength);
-			total += uNameLen;
+			pdw_buf[total + name_len - 1] = 0;
+			/** TODO USE SERVICES * */
+			memcpy(pdw_buf + total, strm_def.sz_device, dw_length);
+			total += name_len;
 			*ptotal = total;
 		}
 	}
@@ -670,36 +690,37 @@ static DSP_STATUS FillStreamDef(RMS_WORD *pdwBuf, u32 *ptotal, u32 offset,
 }
 
 /*
- *  ======== SendMessage ======
+ *  ======== send_message ======
  *  Send command message to RMS, get reply from RMS.
  */
-static DSP_STATUS SendMessage(struct DISP_OBJECT *hDisp, u32 dwTimeout,
-			     u32 ulBytes, u32 *pdwArg)
+static dsp_status send_message(struct disp_object *disp_obj, u32 dwTimeout,
+			       u32 ul_bytes, u32 *pdw_arg)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_OBJECT *hChnl;
-	u32 dwArg = 0;
-	u8 *pBuf;
-	struct CHNL_IOC chnlIOC;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	struct chnl_object *chnl_obj;
+	u32 dw_arg = 0;
+	u8 *pbuf;
+	struct chnl_ioc chnl_ioc_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(pdwArg != NULL);
+	DBC_REQUIRE(pdw_arg != NULL);
 
-	*pdwArg = (u32) NULL;
-	pIntfFxns = hDisp->pIntfFxns;
-	hChnl = hDisp->hChnlToDsp;
-	pBuf = hDisp->pBuf;
+	*pdw_arg = (u32) NULL;
+	intf_fxns = disp_obj->intf_fxns;
+	chnl_obj = disp_obj->chnl_to_dsp;
+	pbuf = disp_obj->pbuf;
 
 	/* Send the command */
-	status = (*pIntfFxns->pfnChnlAddIOReq) (hChnl, pBuf, ulBytes, 0,
-		 0L, dwArg);
+	status = (*intf_fxns->pfn_chnl_add_io_req) (chnl_obj, pbuf, ul_bytes, 0,
+						    0L, dw_arg);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	status = (*pIntfFxns->pfnChnlGetIOC) (hChnl, dwTimeout, &chnlIOC);
+	status =
+	    (*intf_fxns->pfn_chnl_get_ioc) (chnl_obj, dwTimeout, &chnl_ioc_obj);
 	if (DSP_SUCCEEDED(status)) {
-		if (!CHNL_IsIOComplete(chnlIOC)) {
-			if (CHNL_IsTimedOut(chnlIOC))
+		if (!CHNL_IS_IO_COMPLETE(chnl_ioc_obj)) {
+			if (CHNL_IS_TIMED_OUT(chnl_ioc_obj))
 				status = DSP_ETIMEOUT;
 			else
 				status = DSP_EFAIL;
@@ -709,25 +730,27 @@ static DSP_STATUS SendMessage(struct DISP_OBJECT *hDisp, u32 dwTimeout,
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	hChnl = hDisp->hChnlFromDsp;
-	ulBytes = REPLYSIZE;
-	status = (*pIntfFxns->pfnChnlAddIOReq)(hChnl, pBuf, ulBytes,
-		 0, 0L, dwArg);
+	chnl_obj = disp_obj->chnl_from_dsp;
+	ul_bytes = REPLYSIZE;
+	status = (*intf_fxns->pfn_chnl_add_io_req) (chnl_obj, pbuf, ul_bytes,
+						    0, 0L, dw_arg);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	status = (*pIntfFxns->pfnChnlGetIOC) (hChnl, dwTimeout, &chnlIOC);
+	status =
+	    (*intf_fxns->pfn_chnl_get_ioc) (chnl_obj, dwTimeout, &chnl_ioc_obj);
 	if (DSP_SUCCEEDED(status)) {
-		if (CHNL_IsTimedOut(chnlIOC)) {
+		if (CHNL_IS_TIMED_OUT(chnl_ioc_obj)) {
 			status = DSP_ETIMEOUT;
-		} else if (chnlIOC.cBytes < ulBytes) {
+		} else if (chnl_ioc_obj.byte_size < ul_bytes) {
 			/* Did not get all of the reply from the RMS */
 			status = DSP_EFAIL;
 		} else {
-			if (CHNL_IsIOComplete(chnlIOC)) {
-				DBC_Assert(chnlIOC.pBuf == pBuf);
-				status = (*((RMS_WORD *)chnlIOC.pBuf));
-				*pdwArg = (((RMS_WORD *)(chnlIOC.pBuf))[1]);
+			if (CHNL_IS_IO_COMPLETE(chnl_ioc_obj)) {
+				DBC_ASSERT(chnl_ioc_obj.pbuf == pbuf);
+				status = (*((rms_word *) chnl_ioc_obj.pbuf));
+				*pdw_arg =
+				    (((rms_word *) (chnl_ioc_obj.pbuf))[1]);
 			} else {
 				status = DSP_EFAIL;
 			}
diff --git a/drivers/dsp/bridge/rmgr/drv.c b/drivers/dsp/bridge/rmgr/drv.c
index 8ac96fd..deefcec 100644
--- a/drivers/dsp/bridge/rmgr/drv.c
+++ b/drivers/dsp/bridge/rmgr/drv.c
@@ -47,123 +47,127 @@
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define SIGNATURE   0x5f52474d	/* "DRV_" (in reverse) */
 
-struct DRV_OBJECT {
-	u32 dwSignature;
-	struct LST_LIST *devList;
-	struct LST_LIST *devNodeString;
+struct drv_object {
+	u32 dw_signature;
+	struct lst_list *dev_list;
+	struct lst_list *dev_node_string;
 };
 
 /*
  *  This is the Device Extension. Named with the Prefix
  *  DRV_ since it is living in this module
  */
-struct DRV_EXT {
+struct drv_ext {
 	struct list_head link;
-	char szString[MAXREGPATHLENGTH];
+	char sz_string[MAXREGPATHLENGTH];
 };
 
 /*  ----------------------------------- Globals */
-static s32 cRefs;
+static s32 refs;
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS RequestBridgeResources(u32 dwContext, s32 fRequest);
-static DSP_STATUS RequestBridgeResourcesDSP(u32 dwContext, s32 fRequest);
+static dsp_status request_bridge_resources(u32 dw_context, s32 fRequest);
+static dsp_status request_bridge_resources_dsp(u32 dw_context, s32 fRequest);
 
 /* GPP PROCESS CLEANUP CODE */
 
-static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt);
-extern enum NODE_STATE NODE_GetState(HANDLE hNode);
+static dsp_status drv_proc_free_node_res(bhandle hPCtxt);
+extern enum node_state node_get_state(bhandle hnode);
 
 /* Allocate and add a node resource element
-* This function is called from .Node_Allocate.  */
-DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE hNodeRes,
-					HANDLE hPCtxt)
+* This function is called from .Node_Allocate. */
+dsp_status drv_insert_node_res_element(bhandle hnode, bhandle hNodeRes,
+				       bhandle hPCtxt)
 {
-	struct NODE_RES_OBJECT **pNodeRes = (struct NODE_RES_OBJECT **)hNodeRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_RES_OBJECT   *pTempNodeRes = NULL;
-
-	*pNodeRes = (struct NODE_RES_OBJECT *)MEM_Calloc
-		    (1 * sizeof(struct NODE_RES_OBJECT), MEM_PAGED);
-	if (*pNodeRes == NULL)
+	struct node_res_object **node_res_obj =
+	    (struct node_res_object **)hNodeRes;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct node_res_object *temp_node_res = NULL;
+
+	*node_res_obj = (struct node_res_object *)mem_calloc
+	    (1 * sizeof(struct node_res_object), MEM_PAGED);
+	if (*node_res_obj == NULL)
 		status = DSP_EHANDLE;
 
 	if (DSP_SUCCEEDED(status)) {
-		if (mutex_lock_interruptible(&pCtxt->node_mutex)) {
-			kfree(*pNodeRes);
+		if (mutex_lock_interruptible(&ctxt->node_mutex)) {
+			kfree(*node_res_obj);
 			return DSP_EFAIL;
 		}
-		(*pNodeRes)->hNode = hNode;
-		if (pCtxt->pNodeList != NULL) {
-			pTempNodeRes = pCtxt->pNodeList;
-			while (pTempNodeRes->next != NULL)
-				pTempNodeRes = pTempNodeRes->next;
+		(*node_res_obj)->hnode = hnode;
+		if (ctxt->node_list != NULL) {
+			temp_node_res = ctxt->node_list;
+			while (temp_node_res->next != NULL)
+				temp_node_res = temp_node_res->next;
 
-			pTempNodeRes->next = *pNodeRes;
+			temp_node_res->next = *node_res_obj;
 		} else {
-			pCtxt->pNodeList = *pNodeRes;
+			ctxt->node_list = *node_res_obj;
 		}
-		mutex_unlock(&pCtxt->node_mutex);
+		mutex_unlock(&ctxt->node_mutex);
 	}
 
 	return status;
 }
 
 /* Release all Node resources and its context
-* This is called from .Node_Delete.  */
-DSP_STATUS DRV_RemoveNodeResElement(HANDLE hNodeRes, HANDLE hPCtxt)
+* This is called from .Node_Delete. */
+dsp_status drv_remove_node_res_element(bhandle hNodeRes, bhandle hPCtxt)
 {
-	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	struct NODE_RES_OBJECT *pTempNode;
-	DSP_STATUS status = DSP_SOK;
+	struct node_res_object *node_res_obj =
+	    (struct node_res_object *)hNodeRes;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct node_res_object *temp_node;
+	dsp_status status = DSP_SOK;
 
-	if (mutex_lock_interruptible(&pCtxt->node_mutex))
+	if (mutex_lock_interruptible(&ctxt->node_mutex))
 		return DSP_EFAIL;
-	pTempNode = pCtxt->pNodeList;
-	if (pTempNode == pNodeRes) {
-		pCtxt->pNodeList = pNodeRes->next;
+	temp_node = ctxt->node_list;
+	if (temp_node == node_res_obj) {
+		ctxt->node_list = node_res_obj->next;
 	} else {
-		while (pTempNode && pTempNode->next != pNodeRes)
-			pTempNode = pTempNode->next;
-		if (!pTempNode)
+		while (temp_node && temp_node->next != node_res_obj)
+			temp_node = temp_node->next;
+		if (!temp_node)
 			status = DSP_ENOTFOUND;
 		else
-			pTempNode->next = pNodeRes->next;
+			temp_node->next = node_res_obj->next;
 	}
-	mutex_unlock(&pCtxt->node_mutex);
-	kfree(pNodeRes);
+	mutex_unlock(&ctxt->node_mutex);
+	kfree(node_res_obj);
 	return status;
 }
 
 /* Actual Node De-Allocation */
-static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt)
+static dsp_status drv_proc_free_node_res(bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_RES_OBJECT *pNodeList = NULL;
-	struct NODE_RES_OBJECT *pNodeRes = NULL;
-	u32  nState;
-
-	pNodeList = pCtxt->pNodeList;
-	while (pNodeList != NULL) {
-		pNodeRes = pNodeList;
-		pNodeList = pNodeList->next;
-		if (pNodeRes->nodeAllocated) {
-			nState = NODE_GetState(pNodeRes->hNode) ;
-			if (nState <= NODE_DELETING) {
-				if ((nState == NODE_RUNNING) ||
-					(nState == NODE_PAUSED) ||
-					(nState == NODE_TERMINATING)) {
-					status = NODE_Terminate
-						(pNodeRes->hNode, &status);
-					status = NODE_Delete(pNodeRes->hNode,
-							pCtxt);
-				} else if ((nState == NODE_ALLOCATED)
-					|| (nState == NODE_CREATED))
-					status = NODE_Delete(pNodeRes->hNode,
-							pCtxt);
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct node_res_object *node_list = NULL;
+	struct node_res_object *node_res_obj = NULL;
+	u32 node_state;
+
+	node_list = ctxt->node_list;
+	while (node_list != NULL) {
+		node_res_obj = node_list;
+		node_list = node_list->next;
+		if (node_res_obj->node_allocated) {
+			node_state = node_get_state(node_res_obj->hnode);
+			if (node_state <= NODE_DELETING) {
+				if ((node_state == NODE_RUNNING) ||
+				    (node_state == NODE_PAUSED) ||
+				    (node_state == NODE_TERMINATING)) {
+					status = node_terminate
+					    (node_res_obj->hnode, &status);
+					status =
+					    node_delete(node_res_obj->hnode,
+							ctxt);
+				} else if ((node_state == NODE_ALLOCATED)
+					   || (node_state == NODE_CREATED))
+					status =
+					    node_delete(node_res_obj->hnode,
+							ctxt);
 			}
 		}
 	}
@@ -171,94 +175,96 @@ static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt)
 }
 
 /* Release all Mapped and Reserved DMM resources */
-DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE hPCtxt)
+dsp_status drv_remove_all_dmm_res_elements(bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct DMM_MAP_OBJECT *temp_map, *map_obj;
-	struct DMM_RSV_OBJECT *temp_rsv, *rsv_obj;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct dmm_map_object *temp_map, *map_obj;
+	struct dmm_rsv_object *temp_rsv, *rsv_obj;
 
 	/* Free DMM mapped memory resources */
-	list_for_each_entry_safe(map_obj, temp_map, &pCtxt->dmm_map_list,
-			link) {
-		status = PROC_UnMap(pCtxt->hProcessor,
-				(void *)map_obj->dsp_addr, pCtxt);
+	list_for_each_entry_safe(map_obj, temp_map, &ctxt->dmm_map_list, link) {
+		status = proc_un_map(ctxt->hprocessor,
+				     (void *)map_obj->dsp_addr, ctxt);
 		if (DSP_FAILED(status))
-			pr_err("%s: PROC_UnMap failed!"
-					" status = 0x%xn", __func__, status);
+			pr_err("%s: proc_un_map failed!"
+			       " status = 0x%xn", __func__, status);
 	}
 
 	/* Free DMM reserved memory resources */
-	list_for_each_entry_safe(rsv_obj, temp_rsv, &pCtxt->dmm_rsv_list,
-			link) {
-		status = PROC_UnReserveMemory(pCtxt->hProcessor,
-				(void *)rsv_obj->dsp_reserved_addr, pCtxt);
+	list_for_each_entry_safe(rsv_obj, temp_rsv, &ctxt->dmm_rsv_list, link) {
+		status = proc_un_reserve_memory(ctxt->hprocessor, (void *)
+						rsv_obj->dsp_reserved_addr,
+						ctxt);
 		if (DSP_FAILED(status))
-			pr_err("%s: PROC_UnReserveMemory failed!"
-					" status = 0x%xn", __func__, status);
+			pr_err("%s: proc_un_reserve_memory failed!"
+			       " status = 0x%xn", __func__, status);
 	}
 	return status;
 }
 
 /* Update Node allocation status */
-void DRV_ProcNodeUpdateStatus(HANDLE hNodeRes, s32 status)
+void drv_proc_node_update_status(bhandle hNodeRes, s32 status)
 {
-	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
-	DBC_Assert(hNodeRes != NULL);
-	pNodeRes->nodeAllocated = status;
+	struct node_res_object *node_res_obj =
+	    (struct node_res_object *)hNodeRes;
+	DBC_ASSERT(hNodeRes != NULL);
+	node_res_obj->node_allocated = status;
 }
 
 /* Update Node Heap status */
-void DRV_ProcNodeUpdateHeapStatus(HANDLE hNodeRes, s32 status)
+void drv_proc_node_update_heap_status(bhandle hNodeRes, s32 status)
 {
-	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
-	DBC_Assert(hNodeRes != NULL);
-	pNodeRes->heapAllocated = status;
+	struct node_res_object *node_res_obj =
+	    (struct node_res_object *)hNodeRes;
+	DBC_ASSERT(hNodeRes != NULL);
+	node_res_obj->heap_allocated = status;
 }
 
 /* Release all Node resources and its context
 * This is called from .bridge_release.
-*/
-DSP_STATUS 	DRV_RemoveAllNodeResElements(HANDLE hPCtxt)
+ */
+dsp_status drv_remove_all_node_res_elements(bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_RES_OBJECT *pTempNode2 = NULL;
-	struct NODE_RES_OBJECT *pTempNode = NULL;
-
-	DRV_ProcFreeNodeRes(pCtxt);
-	pTempNode = pCtxt->pNodeList;
-	while (pTempNode != NULL) {
-		pTempNode2 = pTempNode;
-		pTempNode = pTempNode->next;
-		kfree(pTempNode2);
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct node_res_object *temp_node2 = NULL;
+	struct node_res_object *temp_node = NULL;
+
+	drv_proc_free_node_res(ctxt);
+	temp_node = ctxt->node_list;
+	while (temp_node != NULL) {
+		temp_node2 = temp_node;
+		temp_node = temp_node->next;
+		kfree(temp_node2);
 	}
-	pCtxt->pNodeList = NULL;
+	ctxt->node_list = NULL;
 	return status;
 }
 
 /* Getting the node resource element */
-DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE hNodeRes, HANDLE hPCtxt)
+dsp_status drv_get_node_res_element(bhandle hnode, bhandle hNodeRes,
+				    bhandle hPCtxt)
 {
-	struct NODE_RES_OBJECT **nodeRes = (struct NODE_RES_OBJECT **)hNodeRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_RES_OBJECT *pTempNode2 = NULL;
-	struct NODE_RES_OBJECT *pTempNode = NULL;
+	struct node_res_object **node_res = (struct node_res_object **)hNodeRes;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct node_res_object *temp_node2 = NULL;
+	struct node_res_object *temp_node = NULL;
 
-	if (mutex_lock_interruptible(&pCtxt->node_mutex))
+	if (mutex_lock_interruptible(&ctxt->node_mutex))
 		return DSP_EFAIL;
 
-	pTempNode = pCtxt->pNodeList;
-	while ((pTempNode != NULL) && (pTempNode->hNode != hNode)) {
-		pTempNode2 = pTempNode;
-		pTempNode = pTempNode->next;
+	temp_node = ctxt->node_list;
+	while ((temp_node != NULL) && (temp_node->hnode != hnode)) {
+		temp_node2 = temp_node;
+		temp_node = temp_node->next;
 	}
 
-	mutex_unlock(&pCtxt->node_mutex);
+	mutex_unlock(&ctxt->node_mutex);
 
-	if (pTempNode != NULL)
-		*nodeRes = pTempNode;
+	if (temp_node != NULL)
+		*node_res = temp_node;
 	else
 		status = DSP_ENOTFOUND;
 
@@ -267,132 +273,137 @@ DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE hNodeRes, HANDLE hPCtxt)
 
 /* Allocate the STRM resource element
 * This is called after the actual resource is allocated
-*/
-DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStreamHandle, HANDLE hSTRMRes,
-					HANDLE hPCtxt)
+ */
+dsp_status drv_proc_insert_strm_res_element(bhandle hStreamHandle,
+					    bhandle hstrm_res, bhandle hPCtxt)
 {
-	struct STRM_RES_OBJECT **pSTRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *pTempSTRMRes = NULL;
-
-	*pSTRMRes = (struct STRM_RES_OBJECT *)
-		    MEM_Calloc(1 * sizeof(struct STRM_RES_OBJECT), MEM_PAGED);
-	if (*pSTRMRes == NULL)
+	struct strm_res_object **pstrm_res =
+	    (struct strm_res_object **)hstrm_res;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct strm_res_object *temp_strm_res = NULL;
+
+	*pstrm_res = (struct strm_res_object *)
+	    mem_calloc(1 * sizeof(struct strm_res_object), MEM_PAGED);
+	if (*pstrm_res == NULL)
 		status = DSP_EHANDLE;
 
 	if (DSP_SUCCEEDED(status)) {
-		if (mutex_lock_interruptible(&pCtxt->strm_mutex)) {
-			kfree(*pSTRMRes);
+		if (mutex_lock_interruptible(&ctxt->strm_mutex)) {
+			kfree(*pstrm_res);
 			return DSP_EFAIL;
 		}
-		(*pSTRMRes)->hStream = hStreamHandle;
-		if (pCtxt->pSTRMList != NULL) {
-			pTempSTRMRes = pCtxt->pSTRMList;
-			while (pTempSTRMRes->next != NULL)
-				pTempSTRMRes = pTempSTRMRes->next;
+		(*pstrm_res)->hstream = hStreamHandle;
+		if (ctxt->pstrm_list != NULL) {
+			temp_strm_res = ctxt->pstrm_list;
+			while (temp_strm_res->next != NULL)
+				temp_strm_res = temp_strm_res->next;
 
-			pTempSTRMRes->next = *pSTRMRes;
+			temp_strm_res->next = *pstrm_res;
 		} else {
-			pCtxt->pSTRMList = *pSTRMRes;
+			ctxt->pstrm_list = *pstrm_res;
 		}
-		mutex_unlock(&pCtxt->strm_mutex);
+		mutex_unlock(&ctxt->strm_mutex);
 	}
 	return status;
 }
 
 /* Release Stream resource element context
 * This function called after the actual resource is freed
-*/
-DSP_STATUS 	DRV_ProcRemoveSTRMResElement(HANDLE hSTRMRes, HANDLE hPCtxt)
+ */
+dsp_status drv_proc_remove_strm_res_element(bhandle hstrm_res, bhandle hPCtxt)
 {
-	struct STRM_RES_OBJECT *pSTRMRes = (struct STRM_RES_OBJECT *)hSTRMRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	struct STRM_RES_OBJECT *pTempSTRMRes;
-	DSP_STATUS status = DSP_SOK;
+	struct strm_res_object *pstrm_res = (struct strm_res_object *)hstrm_res;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct strm_res_object *temp_strm_res;
+	dsp_status status = DSP_SOK;
 
-	if (mutex_lock_interruptible(&pCtxt->strm_mutex))
+	if (mutex_lock_interruptible(&ctxt->strm_mutex))
 		return DSP_EFAIL;
-	pTempSTRMRes = pCtxt->pSTRMList;
+	temp_strm_res = ctxt->pstrm_list;
 
-	if (pCtxt->pSTRMList == pSTRMRes) {
-		pCtxt->pSTRMList = pSTRMRes->next;
+	if (ctxt->pstrm_list == pstrm_res) {
+		ctxt->pstrm_list = pstrm_res->next;
 	} else {
-		while (pTempSTRMRes && pTempSTRMRes->next != pSTRMRes)
-			pTempSTRMRes = pTempSTRMRes->next;
-		if (pTempSTRMRes == NULL)
+		while (temp_strm_res && temp_strm_res->next != pstrm_res)
+			temp_strm_res = temp_strm_res->next;
+		if (temp_strm_res == NULL)
 			status = DSP_ENOTFOUND;
 		else
-			pTempSTRMRes->next = pSTRMRes->next;
+			temp_strm_res->next = pstrm_res->next;
 	}
-	mutex_unlock(&pCtxt->strm_mutex);
-	kfree(pSTRMRes);
+	mutex_unlock(&ctxt->strm_mutex);
+	kfree(pstrm_res);
 	return status;
 }
 
 /* Release all Stream resources and its context
 * This is called from .bridge_release.
-*/
-DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE hPCtxt)
+ */
+dsp_status drv_remove_all_strm_res_elements(bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *strm_res = NULL;
-	struct STRM_RES_OBJECT *strm_tmp = NULL;
-	struct STRM_INFO strm_info;
-	struct DSP_STREAMINFO user;
-	u8 **apBuffer = NULL;
-	u8 *pBufPtr;
-	u32 ulBytes;
-	u32 dwArg;
-	s32 ulBufSize;
-
-	strm_tmp = pCtxt->pSTRMList;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct strm_res_object *strm_res = NULL;
+	struct strm_res_object *strm_tmp = NULL;
+	struct stream_info strm_info;
+	struct dsp_streaminfo user;
+	u8 **ap_buffer = NULL;
+	u8 *buf_ptr;
+	u32 ul_bytes;
+	u32 dw_arg;
+	s32 ul_buf_size;
+
+	strm_tmp = ctxt->pstrm_list;
 	while (strm_tmp) {
 		strm_res = strm_tmp;
 		strm_tmp = strm_tmp->next;
-		if (strm_res->uNumBufs) {
-			apBuffer = MEM_Alloc((strm_res->uNumBufs *
-					    sizeof(u8 *)), MEM_NONPAGED);
-			if (apBuffer) {
-				status = STRM_FreeBuffer(strm_res->hStream,
-					apBuffer, strm_res->uNumBufs, pCtxt);
-				kfree(apBuffer);
+		if (strm_res->num_bufs) {
+			ap_buffer = mem_alloc((strm_res->num_bufs *
+					       sizeof(u8 *)), MEM_NONPAGED);
+			if (ap_buffer) {
+				status = strm_free_buffer(strm_res->hstream,
+							  ap_buffer,
+							  strm_res->num_bufs,
+							  ctxt);
+				kfree(ap_buffer);
 			}
 		}
-		strm_info.pUser = &user;
-		user.uNumberBufsInStream = 0;
-		STRM_GetInfo(strm_res->hStream, &strm_info, sizeof(strm_info));
-		while (user.uNumberBufsInStream--)
-			STRM_Reclaim(strm_res->hStream, &pBufPtr, &ulBytes,
-					     (u32 *)&ulBufSize, &dwArg);
-		status = STRM_Close(strm_res->hStream, pCtxt);
+		strm_info.user_strm = &user;
+		user.number_bufs_in_stream = 0;
+		strm_get_info(strm_res->hstream, &strm_info, sizeof(strm_info));
+		while (user.number_bufs_in_stream--)
+			strm_reclaim(strm_res->hstream, &buf_ptr, &ul_bytes,
+				     (u32 *) &ul_buf_size, &dw_arg);
+		status = strm_close(strm_res->hstream, ctxt);
 	}
 	return status;
 }
 
 /* Getting the stream resource element */
-DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE hSTRMRes, HANDLE hPCtxt)
+dsp_status drv_get_strm_res_element(bhandle hStrm, bhandle hstrm_res,
+				    bhandle hPCtxt)
 {
-	struct STRM_RES_OBJECT **STRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *pTempSTRM2 = NULL;
-	struct STRM_RES_OBJECT *pTempSTRM;
-
-	if (mutex_lock_interruptible(&pCtxt->strm_mutex))
+	struct strm_res_object **strm_res =
+	    (struct strm_res_object **)hstrm_res;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct strm_res_object *temp_strm2 = NULL;
+	struct strm_res_object *temp_strm;
+
+	if (mutex_lock_interruptible(&ctxt->strm_mutex))
 		return DSP_EFAIL;
 
-	pTempSTRM = pCtxt->pSTRMList;
-	while ((pTempSTRM != NULL) && (pTempSTRM->hStream != hStrm)) {
-		pTempSTRM2 = pTempSTRM;
-		pTempSTRM = pTempSTRM->next;
+	temp_strm = ctxt->pstrm_list;
+	while ((temp_strm != NULL) && (temp_strm->hstream != hStrm)) {
+		temp_strm2 = temp_strm;
+		temp_strm = temp_strm->next;
 	}
 
-	mutex_unlock(&pCtxt->strm_mutex);
+	mutex_unlock(&ctxt->strm_mutex);
 
-	if (pTempSTRM != NULL)
-		*STRMRes = pTempSTRM;
+	if (temp_strm != NULL)
+		*strm_res = temp_strm;
 	else
 		status = DSP_ENOTFOUND;
 
@@ -400,45 +411,47 @@ DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE hSTRMRes, HANDLE hPCtxt)
 }
 
 /* Updating the stream resource element */
-DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE hSTRMRes)
+dsp_status drv_proc_update_strm_res(u32 num_bufs, bhandle hstrm_res)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT **STRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
+	dsp_status status = DSP_SOK;
+	struct strm_res_object **strm_res =
+	    (struct strm_res_object **)hstrm_res;
 
-	(*STRMRes)->uNumBufs = uNumBufs;
+	(*strm_res)->num_bufs = num_bufs;
 	return status;
 }
 
 /* GPP PROCESS CLEANUP CODE END */
 
 /*
- *  ======== = DRV_Create ======== =
+ *  ======== = drv_create ======== =
  *  Purpose:
  *      DRV Object gets created only once during Driver Loading.
  */
-DSP_STATUS DRV_Create(OUT struct DRV_OBJECT **phDRVObject)
+dsp_status drv_create(OUT struct drv_object **phDRVObject)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject = NULL;
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object = NULL;
 
-	DBC_Require(phDRVObject != NULL);
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(phDRVObject != NULL);
+	DBC_REQUIRE(refs > 0);
 
-	MEM_AllocObject(pDRVObject, struct DRV_OBJECT, SIGNATURE);
-	if (pDRVObject) {
+	MEM_ALLOC_OBJECT(pdrv_object, struct drv_object, SIGNATURE);
+	if (pdrv_object) {
 		/* Create and Initialize List of device objects */
-		pDRVObject->devList = MEM_Calloc(sizeof(struct LST_LIST),
-			MEM_NONPAGED);
-		if (pDRVObject->devList) {
+		pdrv_object->dev_list = mem_calloc(sizeof(struct lst_list),
+						   MEM_NONPAGED);
+		if (pdrv_object->dev_list) {
 			/* Create and Initialize List of device Extension */
-			pDRVObject->devNodeString = MEM_Calloc(sizeof(struct
-				LST_LIST), MEM_NONPAGED);
-			if (!(pDRVObject->devNodeString)) {
+			pdrv_object->dev_node_string =
+					mem_calloc(sizeof(struct lst_list),
+						   MEM_NONPAGED);
+			if (!(pdrv_object->dev_node_string)) {
 				status = DSP_EFAIL;
 			} else {
-				INIT_LIST_HEAD(&pDRVObject->devNodeString->
-					head);
-				INIT_LIST_HEAD(&pDRVObject->devList->head);
+				INIT_LIST_HEAD(&pdrv_object->
+					       dev_node_string->head);
+				INIT_LIST_HEAD(&pdrv_object->dev_list->head);
 			}
 		} else {
 			status = DSP_EMEMORY;
@@ -448,89 +461,90 @@ DSP_STATUS DRV_Create(OUT struct DRV_OBJECT **phDRVObject)
 	}
 	/* Store the DRV Object in the Registry */
 	if (DSP_SUCCEEDED(status))
-		status = CFG_SetObject((u32) pDRVObject, REG_DRV_OBJECT);
+		status = cfg_set_object((u32) pdrv_object, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
-		*phDRVObject = pDRVObject;
+		*phDRVObject = pdrv_object;
 	} else {
-		kfree(pDRVObject->devList);
-		kfree(pDRVObject->devNodeString);
+		kfree(pdrv_object->dev_list);
+		kfree(pdrv_object->dev_node_string);
 		/* Free the DRV Object */
-		kfree(pDRVObject);
+		kfree(pdrv_object);
 	}
 
-	DBC_Ensure(DSP_FAILED(status) ||
-		  MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	DBC_ENSURE(DSP_FAILED(status) ||
+		   MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
 	return status;
 }
 
 /*
- *  ======== DRV_Exit ========
+ *  ======== drv_exit ========
  *  Purpose:
  *      Discontinue usage of the DRV module.
  */
-void DRV_Exit(void)
+void drv_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== = DRV_Destroy ======== =
+ *  ======== = drv_destroy ======== =
  *  purpose:
  *      Invoked during bridge de-initialization
  */
-DSP_STATUS DRV_Destroy(struct DRV_OBJECT *hDRVObject)
+dsp_status drv_destroy(struct drv_object *hDRVObject)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
 
 	/*
 	 *  Delete the List if it exists.Should not come here
-	 *  as the DRV_RemoveDevObject and the Last DRV_RequestResources
+	 *  as the drv_remove_dev_object and the Last drv_request_resources
 	 *  removes the list if the lists are empty.
 	 */
-	kfree(pDRVObject->devList);
-	kfree(pDRVObject->devNodeString);
-	MEM_FreeObject(pDRVObject);
+	kfree(pdrv_object->dev_list);
+	kfree(pdrv_object->dev_node_string);
+	MEM_FREE_OBJECT(pdrv_object);
 	/* Update the DRV Object in Registry to be 0 */
-	(void)CFG_SetObject(0, REG_DRV_OBJECT);
-	DBC_Ensure(!MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	(void)cfg_set_object(0, REG_DRV_OBJECT);
+	DBC_ENSURE(!MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
 	return status;
 }
 
 /*
- *  ======== DRV_GetDevObject ========
+ *  ======== drv_get_dev_object ========
  *  Purpose:
  *      Given a index, returns a handle to DevObject from the list.
  */
-DSP_STATUS DRV_GetDevObject(u32 uIndex, struct DRV_OBJECT *hDrvObject,
-			   struct DEV_OBJECT **phDevObject)
+dsp_status drv_get_dev_object(u32 index, struct drv_object *hdrv_obj,
+			      struct dev_object **phDevObject)
 {
-	DSP_STATUS status = DSP_SOK;
-#ifdef CONFIG_BRIDGE_DEBUG    /* used only for Assertions and debug messages.*/
-	struct DRV_OBJECT *pDrvObject = (struct DRV_OBJECT *)hDrvObject;
+	dsp_status status = DSP_SOK;
+#ifdef CONFIG_BRIDGE_DEBUG
+	/* used only for Assertions and debug messages */
+	struct drv_object *pdrv_obj = (struct drv_object *)hdrv_obj;
 #endif
-	struct DEV_OBJECT *pDevObject;
+	struct dev_object *dev_obj;
 	u32 i;
-	DBC_Require(MEM_IsValidHandle(pDrvObject, SIGNATURE));
-	DBC_Require(phDevObject != NULL);
-	DBC_Require(uIndex >= 0);
-	DBC_Require(cRefs > 0);
-	DBC_Assert(!(LST_IsEmpty(pDrvObject->devList)));
-
-	pDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	for (i = 0; i < uIndex; i++) {
-		pDevObject =
-		   (struct DEV_OBJECT *)DRV_GetNextDevObject((u32)pDevObject);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(pdrv_obj, SIGNATURE));
+	DBC_REQUIRE(phDevObject != NULL);
+	DBC_REQUIRE(index >= 0);
+	DBC_REQUIRE(refs > 0);
+	DBC_ASSERT(!(LST_IS_EMPTY(pdrv_obj->dev_list)));
+
+	dev_obj = (struct dev_object *)drv_get_first_dev_object();
+	for (i = 0; i < index; i++) {
+		dev_obj =
+		    (struct dev_object *)drv_get_next_dev_object((u32) dev_obj);
 	}
-	if (pDevObject) {
-		*phDevObject = (struct DEV_OBJECT *) pDevObject;
+	if (dev_obj) {
+		*phDevObject = (struct dev_object *)dev_obj;
 	} else {
 		*phDevObject = NULL;
 		status = DSP_EFAIL;
@@ -540,200 +554,198 @@ DSP_STATUS DRV_GetDevObject(u32 uIndex, struct DRV_OBJECT *hDrvObject,
 }
 
 /*
- *  ======== DRV_GetFirstDevObject ========
+ *  ======== drv_get_first_dev_object ========
  *  Purpose:
  *      Retrieve the first Device Object handle from an internal linked list of
  *      of DEV_OBJECTs maintained by DRV.
  */
-u32 DRV_GetFirstDevObject(void)
+u32 drv_get_first_dev_object(void)
 {
-	u32 dwDevObject = 0;
-	struct DRV_OBJECT *pDrvObject;
-
-	if (DSP_SUCCEEDED
-	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
-		if ((pDrvObject->devList != NULL) &&
-		   !LST_IsEmpty(pDrvObject->devList))
-			dwDevObject = (u32) LST_First(pDrvObject->devList);
+	u32 dw_dev_object = 0;
+	struct drv_object *pdrv_obj;
+
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
+		if ((pdrv_obj->dev_list != NULL) &&
+		    !LST_IS_EMPTY(pdrv_obj->dev_list))
+			dw_dev_object = (u32) lst_first(pdrv_obj->dev_list);
 	}
 
-	return dwDevObject;
+	return dw_dev_object;
 }
 
 /*
  *  ======== DRV_GetFirstDevNodeString ========
  *  Purpose:
  *      Retrieve the first Device Extension from an internal linked list of
- *      of Pointer to DevNode Strings maintained by DRV.
+ *      of Pointer to dev_node Strings maintained by DRV.
  */
-u32 DRV_GetFirstDevExtension(void)
+u32 drv_get_first_dev_extension(void)
 {
-	u32 dwDevExtension = 0;
-	struct DRV_OBJECT *pDrvObject;
+	u32 dw_dev_extension = 0;
+	struct drv_object *pdrv_obj;
 
-	if (DSP_SUCCEEDED
-	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
 
-		if ((pDrvObject->devNodeString != NULL) &&
-		   !LST_IsEmpty(pDrvObject->devNodeString)) {
-			dwDevExtension = (u32)LST_First(pDrvObject->
-							devNodeString);
+		if ((pdrv_obj->dev_node_string != NULL) &&
+		    !LST_IS_EMPTY(pdrv_obj->dev_node_string)) {
+			dw_dev_extension =
+			    (u32) lst_first(pdrv_obj->dev_node_string);
 		}
 	}
 
-	return dwDevExtension;
+	return dw_dev_extension;
 }
 
 /*
- *  ======== DRV_GetNextDevObject ========
+ *  ======== drv_get_next_dev_object ========
  *  Purpose:
  *      Retrieve the next Device Object handle from an internal linked list of
  *      of DEV_OBJECTs maintained by DRV, after having previously called
- *      DRV_GetFirstDevObject() and zero or more DRV_GetNext.
+ *      drv_get_first_dev_object() and zero or more DRV_GetNext.
  */
-u32 DRV_GetNextDevObject(u32 hDevObject)
+u32 drv_get_next_dev_object(u32 hdev_obj)
 {
-	u32 dwNextDevObject = 0;
-	struct DRV_OBJECT *pDrvObject;
+	u32 dw_next_dev_object = 0;
+	struct drv_object *pdrv_obj;
 
-	DBC_Require(hDevObject != 0);
+	DBC_REQUIRE(hdev_obj != 0);
 
-	if (DSP_SUCCEEDED
-	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
 
-		if ((pDrvObject->devList != NULL) &&
-		   !LST_IsEmpty(pDrvObject->devList)) {
-			dwNextDevObject = (u32)LST_Next(pDrvObject->devList,
-					  (struct list_head *)hDevObject);
+		if ((pdrv_obj->dev_list != NULL) &&
+		    !LST_IS_EMPTY(pdrv_obj->dev_list)) {
+			dw_next_dev_object = (u32) lst_next(pdrv_obj->dev_list,
+							    (struct list_head *)
+							    hdev_obj);
 		}
 	}
-	return dwNextDevObject;
+	return dw_next_dev_object;
 }
 
 /*
- *  ======== DRV_GetNextDevExtension ========
+ *  ======== drv_get_next_dev_extension ========
  *  Purpose:
  *      Retrieve the next Device Extension from an internal linked list of
  *      of pointer to DevNodeString maintained by DRV, after having previously
- *      called DRV_GetFirstDevExtension() and zero or more
- *      DRV_GetNextDevExtension().
+ *      called drv_get_first_dev_extension() and zero or more
+ *      drv_get_next_dev_extension().
  */
-u32 DRV_GetNextDevExtension(u32 hDevExtension)
+u32 drv_get_next_dev_extension(u32 hDevExtension)
 {
-	u32 dwDevExtension = 0;
-	struct DRV_OBJECT *pDrvObject;
-
-	DBC_Require(hDevExtension != 0);
-
-	if (DSP_SUCCEEDED(CFG_GetObject((u32 *)&pDrvObject,
-	   REG_DRV_OBJECT))) {
-		if ((pDrvObject->devNodeString != NULL) &&
-		   !LST_IsEmpty(pDrvObject->devNodeString)) {
-			dwDevExtension = (u32)LST_Next(pDrvObject->
-				devNodeString,
-				(struct list_head *)hDevExtension);
+	u32 dw_dev_extension = 0;
+	struct drv_object *pdrv_obj;
+
+	DBC_REQUIRE(hDevExtension != 0);
+
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
+		if ((pdrv_obj->dev_node_string != NULL) &&
+		    !LST_IS_EMPTY(pdrv_obj->dev_node_string)) {
+			dw_dev_extension =
+			    (u32) lst_next(pdrv_obj->dev_node_string,
+					   (struct list_head *)hDevExtension);
 		}
 	}
 
-	return dwDevExtension;
+	return dw_dev_extension;
 }
 
 /*
- *  ======== DRV_Init ========
+ *  ======== drv_init ========
  *  Purpose:
  *      Initialize DRV module private state.
  */
-DSP_STATUS DRV_Init(void)
+dsp_status drv_init(void)
 {
-	s32 fRetval = 1;	/* function return value */
+	s32 ret = 1;		/* function return value */
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (fRetval)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== DRV_InsertDevObject ========
+ *  ======== drv_insert_dev_object ========
  *  Purpose:
  *      Insert a DevObject into the list of Manager object.
  */
-DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDRVObject,
-				struct DEV_OBJECT *hDevObject)
+dsp_status drv_insert_dev_object(struct drv_object *hDRVObject,
+				 struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hDevObject != NULL);
-	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
-	DBC_Assert(pDRVObject->devList);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hdev_obj != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
+	DBC_ASSERT(pdrv_object->dev_list);
 
-	LST_PutTail(pDRVObject->devList, (struct list_head *)hDevObject);
+	lst_put_tail(pdrv_object->dev_list, (struct list_head *)hdev_obj);
 
-	DBC_Ensure(DSP_SUCCEEDED(status) && !LST_IsEmpty(pDRVObject->devList));
+	DBC_ENSURE(DSP_SUCCEEDED(status)
+		   && !LST_IS_EMPTY(pdrv_object->dev_list));
 
 	return status;
 }
 
 /*
- *  ======== DRV_RemoveDevObject ========
+ *  ======== drv_remove_dev_object ========
  *  Purpose:
  *      Search for and remove a DeviceObject from the given list of DRV
  *      objects.
  */
-DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDRVObject,
-				struct DEV_OBJECT *hDevObject)
+dsp_status drv_remove_dev_object(struct drv_object *hDRVObject,
+				 struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
-	struct list_head *pCurElem;
+	dsp_status status = DSP_EFAIL;
+	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
+	struct list_head *cur_elem;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
-	DBC_Require(hDevObject != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
+	DBC_REQUIRE(hdev_obj != NULL);
 
-	DBC_Require(pDRVObject->devList != NULL);
-	DBC_Require(!LST_IsEmpty(pDRVObject->devList));
+	DBC_REQUIRE(pdrv_object->dev_list != NULL);
+	DBC_REQUIRE(!LST_IS_EMPTY(pdrv_object->dev_list));
 
-	/* Search list for pProcObject: */
-	for (pCurElem = LST_First(pDRVObject->devList); pCurElem != NULL;
-	    pCurElem = LST_Next(pDRVObject->devList, pCurElem)) {
+	/* Search list for p_proc_object: */
+	for (cur_elem = lst_first(pdrv_object->dev_list); cur_elem != NULL;
+	     cur_elem = lst_next(pdrv_object->dev_list, cur_elem)) {
 		/* If found, remove it. */
-		if ((struct DEV_OBJECT *) pCurElem == hDevObject) {
-			LST_RemoveElem(pDRVObject->devList, pCurElem);
+		if ((struct dev_object *)cur_elem == hdev_obj) {
+			lst_remove_elem(pdrv_object->dev_list, cur_elem);
 			status = DSP_SOK;
 			break;
 		}
 	}
 	/* Remove list if empty. */
-	if (LST_IsEmpty(pDRVObject->devList)) {
-		kfree(pDRVObject->devList);
-		pDRVObject->devList = NULL;
+	if (LST_IS_EMPTY(pdrv_object->dev_list)) {
+		kfree(pdrv_object->dev_list);
+		pdrv_object->dev_list = NULL;
 	}
-	DBC_Ensure((pDRVObject->devList == NULL) ||
-		  !LST_IsEmpty(pDRVObject->devList));
+	DBC_ENSURE((pdrv_object->dev_list == NULL) ||
+		   !LST_IS_EMPTY(pdrv_object->dev_list));
 
 	return status;
 }
 
 /*
- *  ======== DRV_RequestResources ========
+ *  ======== drv_request_resources ========
  *  Purpose:
  *      Requests  resources from the OS.
  */
-DSP_STATUS DRV_RequestResources(u32 dwContext, u32 *pDevNodeString)
+dsp_status drv_request_resources(u32 dw_context, u32 *pDevNodeString)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject;
-	struct DRV_EXT *pszdevNode;
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object;
+	struct drv_ext *pszdev_node;
 
-	DBC_Require(dwContext != 0);
-	DBC_Require(pDevNodeString != NULL);
+	DBC_REQUIRE(dw_context != 0);
+	DBC_REQUIRE(pDevNodeString != NULL);
 
 	/*
 	 *  Allocate memory to hold the string. This will live untill
@@ -741,31 +753,31 @@ DSP_STATUS DRV_RequestResources(u32 dwContext, u32 *pDevNodeString)
 	 *  list.
 	 */
 
-	status = CFG_GetObject((u32 *)&pDRVObject, REG_DRV_OBJECT);
+	status = cfg_get_object((u32 *) &pdrv_object, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
-		pszdevNode = MEM_Calloc(sizeof(struct DRV_EXT), MEM_NONPAGED);
-		if (pszdevNode) {
-			LST_InitElem(&pszdevNode->link);
-			strncpy(pszdevNode->szString,
-				 (char *)dwContext, MAXREGPATHLENGTH - 1);
-			pszdevNode->szString[MAXREGPATHLENGTH - 1] = '\0';
+		pszdev_node = mem_calloc(sizeof(struct drv_ext), MEM_NONPAGED);
+		if (pszdev_node) {
+			lst_init_elem(&pszdev_node->link);
+			strncpy(pszdev_node->sz_string,
+				(char *)dw_context, MAXREGPATHLENGTH - 1);
+			pszdev_node->sz_string[MAXREGPATHLENGTH - 1] = '\0';
 			/* Update the Driver Object List */
-			*pDevNodeString = (u32)pszdevNode->szString;
-			LST_PutTail(pDRVObject->devNodeString,
-					(struct list_head *)pszdevNode);
+			*pDevNodeString = (u32) pszdev_node->sz_string;
+			lst_put_tail(pdrv_object->dev_node_string,
+				     (struct list_head *)pszdev_node);
 		} else {
 			status = DSP_EMEMORY;
 			*pDevNodeString = 0;
 		}
 	} else {
 		dev_dbg(bridge, "%s: Failed to get Driver Object from Registry",
-								__func__);
+			__func__);
 		*pDevNodeString = 0;
 	}
 
-	if (!(strcmp((char *) dwContext, "TIOMAP1510"))) {
+	if (!(strcmp((char *)dw_context, "TIOMAP1510"))) {
 		dev_dbg(bridge, "%s: Allocating resources for UMA\n", __func__);
-		status = RequestBridgeResourcesDSP(dwContext, DRV_ASSIGN);
+		status = request_bridge_resources_dsp(dw_context, DRV_ASSIGN);
 	} else {
 		status = DSP_EFAIL;
 		dev_dbg(bridge, "%s: Unknown Device\n", __func__);
@@ -773,307 +785,311 @@ DSP_STATUS DRV_RequestResources(u32 dwContext, u32 *pDevNodeString)
 
 	if (DSP_FAILED(status))
 		dev_dbg(bridge, "%s: Failed to reserve bridge resources\n",
-								__func__);
+			__func__);
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && pDevNodeString != NULL &&
-		  !LST_IsEmpty(pDRVObject->devNodeString)) ||
-		  (DSP_FAILED(status) && *pDevNodeString == 0));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && pDevNodeString != NULL &&
+		    !LST_IS_EMPTY(pdrv_object->dev_node_string)) ||
+		   (DSP_FAILED(status) && *pDevNodeString == 0));
 
 	return status;
 }
 
 /*
- *  ======== DRV_ReleaseResources ========
+ *  ======== drv_release_resources ========
  *  Purpose:
  *      Releases  resources from the OS.
  */
-DSP_STATUS DRV_ReleaseResources(u32 dwContext, struct DRV_OBJECT *hDrvObject)
+dsp_status drv_release_resources(u32 dw_context, struct drv_object *hdrv_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDrvObject;
-	struct DRV_EXT *pszdevNode;
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object = (struct drv_object *)hdrv_obj;
+	struct drv_ext *pszdev_node;
 
-	if (!(strcmp((char *)((struct DRV_EXT *)dwContext)->szString,
-	   "TIOMAP1510")))
-		status = RequestBridgeResources(dwContext, DRV_RELEASE);
+	if (!(strcmp((char *)((struct drv_ext *)dw_context)->sz_string,
+		     "TIOMAP1510")))
+		status = request_bridge_resources(dw_context, DRV_RELEASE);
 	else
 		dev_dbg(bridge, "%s: Unknown device\n", __func__);
 
 	if (DSP_FAILED(status))
 		dev_dbg(bridge, "%s: Failed to relese bridge resources\n",
-								__func__);
+			__func__);
 
 	/*
 	 *  Irrespective of the status go ahead and clean it
 	 *  The following will over write the status.
 	 */
-	for (pszdevNode = (struct DRV_EXT *)DRV_GetFirstDevExtension();
-	    pszdevNode != NULL; pszdevNode = (struct DRV_EXT *)
-	    DRV_GetNextDevExtension((u32)pszdevNode)) {
-		if (!pDRVObject->devNodeString) {
+	for (pszdev_node = (struct drv_ext *)drv_get_first_dev_extension();
+	     pszdev_node != NULL; pszdev_node = (struct drv_ext *)
+	     drv_get_next_dev_extension((u32) pszdev_node)) {
+		if (!pdrv_object->dev_node_string) {
 			/* When this could happen? */
 			continue;
 		}
-		if ((u32)pszdevNode == dwContext) {
+		if ((u32) pszdev_node == dw_context) {
 			/* Found it */
 			/* Delete from the Driver object list */
-			LST_RemoveElem(pDRVObject->devNodeString,
-				      (struct list_head *)pszdevNode);
-			kfree((void *) pszdevNode);
+			lst_remove_elem(pdrv_object->dev_node_string,
+					(struct list_head *)pszdev_node);
+			kfree((void *)pszdev_node);
 			break;
 		}
 		/* Delete the List if it is empty */
-		if (LST_IsEmpty(pDRVObject->devNodeString)) {
-			kfree(pDRVObject->devNodeString);
-			pDRVObject->devNodeString = NULL;
+		if (LST_IS_EMPTY(pdrv_object->dev_node_string)) {
+			kfree(pdrv_object->dev_node_string);
+			pdrv_object->dev_node_string = NULL;
 		}
 	}
 	return status;
 }
 
 /*
- *  ======== RequestBridgeResources ========
+ *  ======== request_bridge_resources ========
  *  Purpose:
  *      Reserves shared memory for bridge.
  */
-static DSP_STATUS RequestBridgeResources(u32 dwContext, s32 bRequest)
+static dsp_status request_bridge_resources(u32 dw_context, s32 bRequest)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_HOSTRES *pResources;
-	u32 dwBuffSize;
+	dsp_status status = DSP_SOK;
+	struct cfg_hostres *host_res;
+	u32 dw_buff_size;
 
-	struct DRV_EXT *driverExt;
+	struct drv_ext *driver_ext;
 	u32 shm_size;
 
-	DBC_Require(dwContext != 0);
+	DBC_REQUIRE(dw_context != 0);
 
 	if (!bRequest) {
-		driverExt = (struct DRV_EXT *)dwContext;
-		/* Releasing resources by deleting the registry key  */
-		dwBuffSize = sizeof(struct CFG_HOSTRES);
-		pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
-		if (pResources != NULL) {
-			if (DSP_FAILED(REG_GetValue(CURRENTCONFIG,
-					(u8 *)pResources, &dwBuffSize))) {
+		driver_ext = (struct drv_ext *)dw_context;
+		/* Releasing resources by deleting the registry key */
+		dw_buff_size = sizeof(struct cfg_hostres);
+		host_res = mem_calloc(dw_buff_size, MEM_NONPAGED);
+		if (host_res != NULL) {
+			if (DSP_FAILED(reg_get_value(CURRENTCONFIG,
+						     (u8 *) host_res,
+						     &dw_buff_size))) {
 				status = CFG_E_RESOURCENOTAVAIL;
 			}
 
-			dwBuffSize = sizeof(shm_size);
-			status = REG_GetValue(SHMSIZE, (u8 *)&shm_size,
-					      &dwBuffSize);
+			dw_buff_size = sizeof(shm_size);
+			status = reg_get_value(SHMSIZE, (u8 *) &shm_size,
+					       &dw_buff_size);
 			if (DSP_SUCCEEDED(status)) {
-				if ((pResources->dwMemBase[1]) &&
-				   (pResources->dwMemPhys[1])) {
-					MEM_FreePhysMem((void *)pResources->
-					dwMemBase[1], pResources->dwMemPhys[1],
-					shm_size);
+				if ((host_res->dw_mem_base[1]) &&
+				    (host_res->dw_mem_phys[1])) {
+					mem_free_phys_mem((void *)
+							  host_res->dw_mem_base
+							  [1],
+							  host_res->dw_mem_phys
+							  [1], shm_size);
 				}
 			} else {
-				dev_dbg(bridge, "%s: Error getting SHM size "
+				dev_dbg(bridge, "%s: Error getting shm size "
 					"from registry: %x. Not calling "
-					"MEM_FreePhysMem\n", __func__, status);
+					"mem_free_phys_mem\n", __func__,
+					status);
 			}
-			pResources->dwMemBase[1] = 0;
-			pResources->dwMemPhys[1] = 0;
-
-			if (pResources->dwPrmBase)
-				iounmap(pResources->dwPrmBase);
-			if (pResources->dwCmBase)
-				iounmap(pResources->dwCmBase);
-			if (pResources->dwMemBase[0])
-				iounmap((void *)pResources->dwMemBase[0]);
-			if (pResources->dwMemBase[2])
-				iounmap((void *)pResources->dwMemBase[2]);
-			if (pResources->dwMemBase[3])
-				iounmap((void *)pResources->dwMemBase[3]);
-			if (pResources->dwMemBase[4])
-				iounmap((void *)pResources->dwMemBase[4]);
-			if (pResources->dwWdTimerDspBase)
-				iounmap(pResources->dwWdTimerDspBase);
-			if (pResources->dwDmmuBase)
-				iounmap(pResources->dwDmmuBase);
-			if (pResources->dwPerBase)
-				iounmap(pResources->dwPerBase);
-			if (pResources->dwPerPmBase)
-				iounmap((void *)pResources->dwPerPmBase);
-			if (pResources->dwCorePmBase)
-				iounmap((void *)pResources->dwCorePmBase);
-			if (pResources->dwSysCtrlBase)
-				iounmap(pResources->dwSysCtrlBase);
-
-			pResources->dwPrmBase = NULL;
-			pResources->dwCmBase = NULL;
-			pResources->dwMemBase[0] = (u32) NULL;
-			pResources->dwMemBase[2] = (u32) NULL;
-			pResources->dwMemBase[3] = (u32) NULL;
-			pResources->dwMemBase[4] = (u32) NULL;
-			pResources->dwWdTimerDspBase = NULL;
-			pResources->dwDmmuBase = NULL;
-			pResources->dwSysCtrlBase = NULL;
-
-			dwBuffSize = sizeof(struct CFG_HOSTRES);
-			status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
-				 (u32)dwBuffSize);
+			host_res->dw_mem_base[1] = 0;
+			host_res->dw_mem_phys[1] = 0;
+
+			if (host_res->dw_prm_base)
+				iounmap(host_res->dw_prm_base);
+			if (host_res->dw_cm_base)
+				iounmap(host_res->dw_cm_base);
+			if (host_res->dw_mem_base[0])
+				iounmap((void *)host_res->dw_mem_base[0]);
+			if (host_res->dw_mem_base[2])
+				iounmap((void *)host_res->dw_mem_base[2]);
+			if (host_res->dw_mem_base[3])
+				iounmap((void *)host_res->dw_mem_base[3]);
+			if (host_res->dw_mem_base[4])
+				iounmap((void *)host_res->dw_mem_base[4]);
+			if (host_res->dw_wd_timer_dsp_base)
+				iounmap(host_res->dw_wd_timer_dsp_base);
+			if (host_res->dw_dmmu_base)
+				iounmap(host_res->dw_dmmu_base);
+			if (host_res->dw_per_base)
+				iounmap(host_res->dw_per_base);
+			if (host_res->dw_per_pm_base)
+				iounmap((void *)host_res->dw_per_pm_base);
+			if (host_res->dw_core_pm_base)
+				iounmap((void *)host_res->dw_core_pm_base);
+			if (host_res->dw_sys_ctrl_base)
+				iounmap(host_res->dw_sys_ctrl_base);
+
+			host_res->dw_prm_base = NULL;
+			host_res->dw_cm_base = NULL;
+			host_res->dw_mem_base[0] = (u32) NULL;
+			host_res->dw_mem_base[2] = (u32) NULL;
+			host_res->dw_mem_base[3] = (u32) NULL;
+			host_res->dw_mem_base[4] = (u32) NULL;
+			host_res->dw_wd_timer_dsp_base = NULL;
+			host_res->dw_dmmu_base = NULL;
+			host_res->dw_sys_ctrl_base = NULL;
+
+			dw_buff_size = sizeof(struct cfg_hostres);
+			status = reg_set_value(CURRENTCONFIG, (u8 *) host_res,
+					       (u32) dw_buff_size);
 			/*  Set all the other entries to NULL */
-			kfree(pResources);
+			kfree(host_res);
 		} else {
 			status = DSP_EMEMORY;
 		}
 		return status;
 	}
-	dwBuffSize = sizeof(struct CFG_HOSTRES);
-	pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
-	if (pResources != NULL) {
-		/* wNumMemWindows must not be more than CFG_MAXMEMREGISTERS */
-		pResources->wNumMemWindows = 2;
+	dw_buff_size = sizeof(struct cfg_hostres);
+	host_res = mem_calloc(dw_buff_size, MEM_NONPAGED);
+	if (host_res != NULL) {
+		/* num_mem_windows must not be more than CFG_MAXMEMREGISTERS */
+		host_res->num_mem_windows = 2;
 		/* First window is for DSP internal memory */
 
-		pResources->dwPrmBase = ioremap(OMAP_IVA2_PRM_BASE,
-							OMAP_IVA2_PRM_SIZE);
-		pResources->dwCmBase = ioremap(OMAP_IVA2_CM_BASE,
-							OMAP_IVA2_CM_SIZE);
-		pResources->dwSysCtrlBase = ioremap(OMAP_SYSC_BASE,
-							OMAP_SYSC_SIZE);
-		dev_dbg(bridge, "dwMemBase[0] 0x%x\n",
-						pResources->dwMemBase[0]);
-		dev_dbg(bridge, "dwMemBase[3] 0x%x\n",
-						pResources->dwMemBase[3]);
-		dev_dbg(bridge, "dwPrmBase %p\n", pResources->dwPrmBase);
-		dev_dbg(bridge, "dwCmBase %p\n", pResources->dwCmBase);
-		dev_dbg(bridge, "dwWdTimerDspBase %p\n",
-						pResources->dwWdTimerDspBase);
-		dev_dbg(bridge, "dwDmmuBase %p\n", pResources->dwDmmuBase);
+		host_res->dw_prm_base = ioremap(OMAP_IVA2_PRM_BASE,
+						OMAP_IVA2_PRM_SIZE);
+		host_res->dw_cm_base = ioremap(OMAP_IVA2_CM_BASE,
+					       OMAP_IVA2_CM_SIZE);
+		host_res->dw_sys_ctrl_base = ioremap(OMAP_SYSC_BASE,
+						     OMAP_SYSC_SIZE);
+		dev_dbg(bridge, "dw_mem_base[0] 0x%x\n",
+			host_res->dw_mem_base[0]);
+		dev_dbg(bridge, "dw_mem_base[3] 0x%x\n",
+			host_res->dw_mem_base[3]);
+		dev_dbg(bridge, "dw_prm_base %p\n", host_res->dw_prm_base);
+		dev_dbg(bridge, "dw_cm_base %p\n", host_res->dw_cm_base);
+		dev_dbg(bridge, "dw_wd_timer_dsp_base %p\n",
+			host_res->dw_wd_timer_dsp_base);
+		dev_dbg(bridge, "dw_dmmu_base %p\n", host_res->dw_dmmu_base);
 
 		/* for 24xx base port is not mapping the mamory for DSP
 		 * internal memory TODO Do a ioremap here */
 		/* Second window is for DSP external memory shared with MPU */
 
 		/* for Linux, these are hard-coded values */
-		pResources->bIRQRegisters = 0;
-		pResources->bIRQAttrib = 0;
-		pResources->dwOffsetForMonitor = 0;
-		pResources->dwChnlOffset = 0;
+		host_res->birq_registers = 0;
+		host_res->birq_attrib = 0;
+		host_res->dw_offset_for_monitor = 0;
+		host_res->dw_chnl_offset = 0;
 		/* CHNL_MAXCHANNELS */
-		pResources->dwNumChnls = CHNL_MAXCHANNELS;
-		pResources->dwChnlBufSize = 0x400;
-		dwBuffSize = sizeof(struct CFG_HOSTRES);
-		status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
-						sizeof(struct CFG_HOSTRES));
+		host_res->dw_num_chnls = CHNL_MAXCHANNELS;
+		host_res->dw_chnl_buf_size = 0x400;
+		dw_buff_size = sizeof(struct cfg_hostres);
+		status = reg_set_value(CURRENTCONFIG, (u8 *) host_res,
+				       sizeof(struct cfg_hostres));
 		if (DSP_FAILED(status)) {
 			dev_dbg(bridge, "%s: Failed to set the registry value "
-					"for CURRENTCONFIG\n", __func__);
+				"for CURRENTCONFIG\n", __func__);
 		}
-		kfree(pResources);
+		kfree(host_res);
 	}
 	/* End Mem alloc */
 	return status;
 }
 
 /*
- *  ======== RequestBridgeResourcesDSP ========
+ *  ======== request_bridge_resources_dsp ========
  *  Purpose:
  *      Reserves shared memory for bridge.
  */
-static DSP_STATUS RequestBridgeResourcesDSP(u32 dwContext, s32 bRequest)
+static dsp_status request_bridge_resources_dsp(u32 dw_context, s32 bRequest)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_HOSTRES *pResources;
-	u32 dwBuffSize;
-	u32 dmaAddr;
+	dsp_status status = DSP_SOK;
+	struct cfg_hostres *host_res;
+	u32 dw_buff_size;
+	u32 dma_addr;
 	u32 shm_size;
 
-	DBC_Require(dwContext != 0);
+	DBC_REQUIRE(dw_context != 0);
 
-	dwBuffSize = sizeof(struct CFG_HOSTRES);
+	dw_buff_size = sizeof(struct cfg_hostres);
 
-	pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
+	host_res = mem_calloc(dw_buff_size, MEM_NONPAGED);
 
-	if (pResources != NULL) {
-		if (DSP_FAILED(CFG_GetHostResources((struct CFG_DEVNODE *)
-		   dwContext, pResources))) {
-			/* Call CFG_GetHostResources to get reserve resouces */
-			status = RequestBridgeResources(dwContext, bRequest);
+	if (host_res != NULL) {
+		if (DSP_FAILED(cfg_get_host_resources((struct cfg_devnode *)
+						      dw_context, host_res))) {
+			status = request_bridge_resources(dw_context, bRequest);
 			if (DSP_SUCCEEDED(status)) {
-				status = CFG_GetHostResources
-					((struct CFG_DEVNODE *) dwContext,
-					pResources);
+				status = cfg_get_host_resources
+				    ((struct cfg_devnode *)dw_context,
+				     host_res);
 			}
 		}
-		/* wNumMemWindows must not be more than CFG_MAXMEMREGISTERS */
-		pResources->wNumMemWindows = 4;
-
-		pResources->dwMemBase[0] = 0;
-		pResources->dwMemBase[2] = (u32)ioremap(OMAP_DSP_MEM1_BASE,
-							OMAP_DSP_MEM1_SIZE);
-		pResources->dwMemBase[3] = (u32)ioremap(OMAP_DSP_MEM2_BASE,
-							OMAP_DSP_MEM2_SIZE);
-		pResources->dwMemBase[4] = (u32)ioremap(OMAP_DSP_MEM3_BASE,
-							OMAP_DSP_MEM3_SIZE);
-		pResources->dwPerBase = ioremap(OMAP_PER_CM_BASE,
-							OMAP_PER_CM_SIZE);
-		pResources->dwPerPmBase = (u32)ioremap(OMAP_PER_PRM_BASE,
-							OMAP_PER_PRM_SIZE);
-		pResources->dwCorePmBase = (u32)ioremap(OMAP_CORE_PRM_BASE,
-							OMAP_CORE_PRM_SIZE);
-		pResources->dwDmmuBase = ioremap(OMAP_DMMU_BASE,
-							OMAP_DMMU_SIZE);
-		pResources->dwWdTimerDspBase = ioremap(OMAP_WDT3_BASE,
-							OMAP_WDT3_BASE);
-
-		dev_dbg(bridge, "dwMemBase[0] 0x%x\n",
-						pResources->dwMemBase[0]);
-		dev_dbg(bridge, "dwMemBase[1] 0x%x\n",
-						pResources->dwMemBase[1]);
-		dev_dbg(bridge, "dwMemBase[2] 0x%x\n",
-						pResources->dwMemBase[2]);
-		dev_dbg(bridge, "dwMemBase[3] 0x%x\n",
-						pResources->dwMemBase[3]);
-		dev_dbg(bridge, "dwMemBase[4] 0x%x\n",
-						pResources->dwMemBase[4]);
-		dev_dbg(bridge, "dwPrmBase %p\n", pResources->dwPrmBase);
-		dev_dbg(bridge, "dwCmBase %p\n", pResources->dwCmBase);
-		dev_dbg(bridge, "dwWdTimerDspBase %p\n",
-						pResources->dwWdTimerDspBase);
-		dev_dbg(bridge, "dwDmmuBase %p\n", pResources->dwDmmuBase);
-		dwBuffSize = sizeof(shm_size);
-		status = REG_GetValue(SHMSIZE, (u8 *)&shm_size, &dwBuffSize);
+		/* num_mem_windows must not be more than CFG_MAXMEMREGISTERS */
+		host_res->num_mem_windows = 4;
+
+		host_res->dw_mem_base[0] = 0;
+		host_res->dw_mem_base[2] = (u32) ioremap(OMAP_DSP_MEM1_BASE,
+							 OMAP_DSP_MEM1_SIZE);
+		host_res->dw_mem_base[3] = (u32) ioremap(OMAP_DSP_MEM2_BASE,
+							 OMAP_DSP_MEM2_SIZE);
+		host_res->dw_mem_base[4] = (u32) ioremap(OMAP_DSP_MEM3_BASE,
+							 OMAP_DSP_MEM3_SIZE);
+		host_res->dw_per_base = ioremap(OMAP_PER_CM_BASE,
+						OMAP_PER_CM_SIZE);
+		host_res->dw_per_pm_base = (u32) ioremap(OMAP_PER_PRM_BASE,
+							 OMAP_PER_PRM_SIZE);
+		host_res->dw_core_pm_base = (u32) ioremap(OMAP_CORE_PRM_BASE,
+							  OMAP_CORE_PRM_SIZE);
+		host_res->dw_dmmu_base = ioremap(OMAP_DMMU_BASE,
+						 OMAP_DMMU_SIZE);
+		host_res->dw_wd_timer_dsp_base = ioremap(OMAP_WDT3_BASE,
+							 OMAP_WDT3_BASE);
+
+		dev_dbg(bridge, "dw_mem_base[0] 0x%x\n",
+			host_res->dw_mem_base[0]);
+		dev_dbg(bridge, "dw_mem_base[1] 0x%x\n",
+			host_res->dw_mem_base[1]);
+		dev_dbg(bridge, "dw_mem_base[2] 0x%x\n",
+			host_res->dw_mem_base[2]);
+		dev_dbg(bridge, "dw_mem_base[3] 0x%x\n",
+			host_res->dw_mem_base[3]);
+		dev_dbg(bridge, "dw_mem_base[4] 0x%x\n",
+			host_res->dw_mem_base[4]);
+		dev_dbg(bridge, "dw_prm_base %p\n", host_res->dw_prm_base);
+		dev_dbg(bridge, "dw_cm_base %p\n", host_res->dw_cm_base);
+		dev_dbg(bridge, "dw_wd_timer_dsp_base %p\n",
+			host_res->dw_wd_timer_dsp_base);
+		dev_dbg(bridge, "dw_dmmu_base %p\n", host_res->dw_dmmu_base);
+		dw_buff_size = sizeof(shm_size);
+		status =
+		    reg_get_value(SHMSIZE, (u8 *) &shm_size, &dw_buff_size);
 		if (DSP_SUCCEEDED(status)) {
 			/* Allocate Physically contiguous,
 			 * non-cacheable  memory */
-			pResources->dwMemBase[1] =
-				(u32)MEM_AllocPhysMem(shm_size, 0x100000,
-							&dmaAddr);
-			if (pResources->dwMemBase[1] == 0) {
+			host_res->dw_mem_base[1] =
+			    (u32) mem_alloc_phys_mem(shm_size, 0x100000,
+						     &dma_addr);
+			if (host_res->dw_mem_base[1] == 0) {
 				status = DSP_EMEMORY;
-				pr_err("SHM reservation Failed\n");
+				pr_err("shm reservation Failed\n");
 			} else {
-				pResources->dwMemLength[1] = shm_size;
-				pResources->dwMemPhys[1] = dmaAddr;
+				host_res->dw_mem_length[1] = shm_size;
+				host_res->dw_mem_phys[1] = dma_addr;
 
-				dev_dbg(bridge, "%s: Bridge SHM address 0x%x "
-					"dmaAddr %x size %x\n", __func__,
-					 pResources->dwMemBase[1],
-					 dmaAddr, shm_size);
+				dev_dbg(bridge, "%s: Bridge shm address 0x%x "
+					"dma_addr %x size %x\n", __func__,
+					host_res->dw_mem_base[1],
+					dma_addr, shm_size);
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* for Linux, these are hard-coded values */
-			pResources->bIRQRegisters = 0;
-			pResources->bIRQAttrib = 0;
-			pResources->dwOffsetForMonitor = 0;
-			pResources->dwChnlOffset = 0;
+			host_res->birq_registers = 0;
+			host_res->birq_attrib = 0;
+			host_res->dw_offset_for_monitor = 0;
+			host_res->dw_chnl_offset = 0;
 			/* CHNL_MAXCHANNELS */
-			pResources->dwNumChnls = CHNL_MAXCHANNELS;
-			pResources->dwChnlBufSize = 0x400;
-			dwBuffSize = sizeof(struct CFG_HOSTRES);
-			status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
-					     sizeof(struct CFG_HOSTRES));
+			host_res->dw_num_chnls = CHNL_MAXCHANNELS;
+			host_res->dw_chnl_buf_size = 0x400;
+			dw_buff_size = sizeof(struct cfg_hostres);
+			status = reg_set_value(CURRENTCONFIG, (u8 *) host_res,
+					       sizeof(struct cfg_hostres));
 			if (DSP_FAILED(status)) {
 				dev_dbg(bridge, "%s: Failed to set the registry"
 					" value for CURRENTCONFIG\n", __func__);
 			}
 		}
-		kfree(pResources);
+		kfree(host_res);
 	}
 	/* End Mem alloc */
 	return status;
diff --git a/drivers/dsp/bridge/rmgr/drv_interface.c b/drivers/dsp/bridge/rmgr/drv_interface.c
index efb7e1e..8e0f238 100644
--- a/drivers/dsp/bridge/rmgr/drv_interface.c
+++ b/drivers/dsp/bridge/rmgr/drv_interface.c
@@ -75,7 +75,7 @@
 #define BRIDGE_NAME "C6410"
 /*  ----------------------------------- Globals */
 #define DRIVER_NAME  "DspBridge"
-#define DSPBRIDGE_VERSION	"0.1"
+#define DSPBRIDGE_VERSION	"0.2"
 s32 dsp_debug;
 
 struct platform_device *omap_dspbridge_dev;
@@ -88,7 +88,7 @@ static struct cdev bridge_cdev;
 
 static struct class *bridge_class;
 
-static u32 driverContext;
+static u32 driver_context;
 static s32 driver_major;
 static char *base_img;
 char *iva_img;
@@ -106,18 +106,18 @@ static bool recover;
 #endif
 
 #ifdef CONFIG_PM
-struct omap34xx_bridge_suspend_data {
+struct omap34_xx_bridge_suspend_data {
 	int suspended;
 	wait_queue_head_t suspend_wq;
 };
 
-static struct omap34xx_bridge_suspend_data bridge_suspend_data;
+static struct omap34_xx_bridge_suspend_data bridge_suspend_data;
 
 static void bridge_create_sysfs(void);
 static void bridge_destroy_sysfs(void);
 
-static int omap34xxbridge_suspend_lockout(
-		struct omap34xx_bridge_suspend_data *s, struct file *f)
+static int omap34_xxbridge_suspend_lockout(struct omap34_xx_bridge_suspend_data
+					   *s, struct file *f)
 {
 	if ((s)->suspended) {
 		if ((f)->f_flags & O_NONBLOCK)
@@ -138,15 +138,15 @@ module_param(base_img, charp, 0);
 MODULE_PARM_DESC(base_img, "DSP base image, default = NULL");
 
 module_param(shm_size, int, 0);
-MODULE_PARM_DESC(shm_size, "SHM size, default = 4 MB, minimum = 64 KB");
+MODULE_PARM_DESC(shm_size, "shm size, default = 4 MB, minimum = 64 KB");
 
 module_param(phys_mempool_base, uint, 0);
 MODULE_PARM_DESC(phys_mempool_base,
-		"Physical memory pool base passed to driver");
+		 "Physical memory pool base passed to driver");
 
 module_param(phys_mempool_size, uint, 0);
 MODULE_PARM_DESC(phys_mempool_size,
-		"Physical memory pool size passed to driver");
+		 "Physical memory pool size passed to driver");
 module_param(tc_wordswapon, int, 0);
 MODULE_PARM_DESC(tc_wordswapon, "TC Word Swap Option. default = 0");
 
@@ -157,18 +157,17 @@ MODULE_VERSION(DSPBRIDGE_VERSION);
 static char *driver_name = DRIVER_NAME;
 
 static const struct file_operations bridge_fops = {
-	.open		= bridge_open,
-	.release	= bridge_release,
-	.unlocked_ioctl	= bridge_ioctl,
-	.mmap		= bridge_mmap,
+	.open = bridge_open,
+	.release = bridge_release,
+	.unlocked_ioctl = bridge_ioctl,
+	.mmap = bridge_mmap,
 };
 
 #ifdef CONFIG_PM
-static u32 timeOut = 1000;
+static u32 time_out = 1000;
 #ifdef CONFIG_BRIDGE_DVFS
 static struct clk *clk_handle;
 #endif
-
 #endif
 
 struct dspbridge_platform_data *omap_dspbridge_pdata;
@@ -176,15 +175,15 @@ struct dspbridge_platform_data *omap_dspbridge_pdata;
 #ifdef CONFIG_BRIDGE_RECOVERY
 static void bridge_recover(struct work_struct *work)
 {
-	struct DEV_OBJECT *dev;
-	struct CFG_DEVNODE *dev_node;
+	struct dev_object *dev;
+	struct cfg_devnode *dev_node;
 	if (atomic_read(&bridge_cref)) {
 		INIT_COMPLETION(bridge_comp);
 		wait_for_completion(&bridge_comp);
 	}
-	dev = DEV_GetFirst();
-	DEV_GetDevNode(dev, &dev_node);
-	if (!dev_node || DSP_FAILED(PROC_AutoStart(dev_node, dev)))
+	dev = dev_get_first();
+	dev_get_dev_node(dev, &dev_node);
+	if (!dev_node || DSP_FAILED(proc_auto_start(dev_node, dev)))
 		pr_err("DSP could not be restarted\n");
 	recover = false;
 	complete_all(&bridge_open_comp);
@@ -200,12 +199,12 @@ void bridge_recover_schedule(void)
 
 #ifdef CONFIG_BRIDGE_DVFS
 static int dspbridge_scale_notification(struct notifier_block *op,
-		unsigned long val, void *ptr)
+					unsigned long val, void *ptr)
 {
 	struct dspbridge_platform_data *pdata =
-					omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 	if (CPUFREQ_POSTCHANGE == val && pdata->dsp_get_opp)
-		PWR_PM_PostScale(PRCM_VDD1, pdata->dsp_get_opp());
+		pwr_pm_post_scale(PRCM_VDD1, pdata->dsp_get_opp());
 	return 0;
 }
 
@@ -215,13 +214,13 @@ static struct notifier_block iva_clk_notifier = {
 };
 #endif
 
-static int __devinit omap34xx_bridge_probe(struct platform_device *pdev)
+static int __devinit omap34_xx_bridge_probe(struct platform_device *pdev)
 {
 	int status;
-	u32 initStatus;
+	u32 init_status;
 	u32 temp;
-	dev_t   dev = 0 ;
-	int     result;
+	dev_t dev = 0;
+	int result;
 	struct dspbridge_platform_data *pdata = pdev->dev.platform_data;
 
 	omap_dspbridge_dev = pdev;
@@ -254,7 +253,7 @@ static int __devinit omap34xx_bridge_probe(struct platform_device *pdev)
 		pr_err("%s: Error creating bridge class\n", __func__);
 
 	device_create(bridge_class, NULL, MKDEV(driver_major, 0),
-			NULL, "DspBridge");
+		      NULL, "DspBridge");
 
 	bridge_create_sysfs();
 #ifdef CONFIG_PM
@@ -265,28 +264,28 @@ static int __devinit omap34xx_bridge_probe(struct platform_device *pdev)
 	}
 #endif
 
-	SERVICES_Init();
+	services_init();
 
 	/*  Autostart flag.  This should be set to true if the DSP image should
-	 *  be loaded and run during bridge module initialization  */
+	 *  be loaded and run during bridge module initialization */
 
 	if (base_img) {
 		temp = true;
-		REG_SetValue(AUTOSTART, (u8 *)&temp, sizeof(temp));
-		REG_SetValue(DEFEXEC, (u8 *)base_img, strlen(base_img) + 1);
+		reg_set_value(AUTOSTART, (u8 *) &temp, sizeof(temp));
+		reg_set_value(DEFEXEC, (u8 *) base_img, strlen(base_img) + 1);
 	} else {
 		temp = false;
-		REG_SetValue(AUTOSTART, (u8 *)&temp, sizeof(temp));
-		REG_SetValue(DEFEXEC, (u8 *) "\0", (u32)2);
+		reg_set_value(AUTOSTART, (u8 *) &temp, sizeof(temp));
+		reg_set_value(DEFEXEC, (u8 *) "\0", (u32) 2);
 	}
 
 	if (shm_size >= 0x10000) {	/* 64 KB */
-		initStatus = REG_SetValue(SHMSIZE, (u8 *)&shm_size,
-					  sizeof(shm_size));
+		init_status = reg_set_value(SHMSIZE, (u8 *) &shm_size,
+					    sizeof(shm_size));
 	} else {
-		initStatus = DSP_EINVALIDARG;
+		init_status = DSP_EINVALIDARG;
 		status = -1;
-		pr_err("%s: SHM size must be at least 64 KB\n", __func__);
+		pr_err("%s: shm size must be at least 64 KB\n", __func__);
 	}
 	dev_dbg(bridge, "%s: requested shm_size = 0x%x\n", __func__, shm_size);
 
@@ -296,49 +295,48 @@ static int __devinit omap34xx_bridge_probe(struct platform_device *pdev)
 	}
 
 	dev_dbg(bridge, "%s: phys_mempool_base = 0x%x \n", __func__,
-							phys_mempool_base);
+		phys_mempool_base);
 
 	dev_dbg(bridge, "%s: phys_mempool_size = 0x%x\n", __func__,
-							phys_mempool_base);
+		phys_mempool_base);
 	if ((phys_mempool_base > 0x0) && (phys_mempool_size > 0x0))
-		MEM_ExtPhysPoolInit(phys_mempool_base, phys_mempool_size);
+		mem_ext_phys_pool_init(phys_mempool_base, phys_mempool_size);
 	if (tc_wordswapon) {
 		dev_dbg(bridge, "%s: TC Word Swap is enabled\n", __func__);
-		REG_SetValue(TCWORDSWAP, (u8 *)&tc_wordswapon,
-			    sizeof(tc_wordswapon));
+		reg_set_value(TCWORDSWAP, (u8 *) &tc_wordswapon,
+			      sizeof(tc_wordswapon));
 	} else {
 		dev_dbg(bridge, "%s: TC Word Swap is disabled\n", __func__);
-		REG_SetValue(TCWORDSWAP, (u8 *)&tc_wordswapon,
-			    sizeof(tc_wordswapon));
+		reg_set_value(TCWORDSWAP, (u8 *) &tc_wordswapon,
+			      sizeof(tc_wordswapon));
 	}
-	if (DSP_SUCCEEDED(initStatus)) {
+	if (DSP_SUCCEEDED(init_status)) {
 #ifdef CONFIG_BRIDGE_DVFS
 		clk_handle = clk_get(NULL, "iva2_ck");
 		if (!clk_handle)
 			pr_err("%s: clk_get failed to get iva2_ck\n", __func__);
 
 		if (cpufreq_register_notifier(&iva_clk_notifier,
-						CPUFREQ_TRANSITION_NOTIFIER))
+					      CPUFREQ_TRANSITION_NOTIFIER))
 			pr_err("%s: cpufreq_register_notifier failed for "
-							"iva2_ck\n", __func__);
+			       "iva2_ck\n", __func__);
 #endif
-		driverContext = DSP_Init(&initStatus);
-		if (DSP_FAILED(initStatus)) {
+		driver_context = dsp_init(&init_status);
+		if (DSP_FAILED(init_status)) {
 			status = -1;
 			pr_err("DSP Bridge driver initialization failed\n");
 		} else {
 			pr_info("DSP Bridge driver loaded\n");
 		}
 	}
-
 #ifdef CONFIG_BRIDGE_RECOVERY
 	bridge_rec_queue = create_workqueue("bridge_rec_queue");
 	INIT_WORK(&bridge_recovery_work, bridge_recover);
 	INIT_COMPLETION(bridge_comp);
 #endif
 
-	DBC_Assert(status == 0);
-	DBC_Assert(DSP_SUCCEEDED(initStatus));
+	DBC_ASSERT(status == 0);
+	DBC_ASSERT(DSP_SUCCEEDED(init_status));
 
 	return 0;
 
@@ -348,40 +346,39 @@ err1:
 	return result;
 }
 
-static int __devexit omap34xx_bridge_remove(struct platform_device *pdev)
+static int __devexit omap34_xx_bridge_remove(struct platform_device *pdev)
 {
 	dev_t devno;
 	bool ret;
-	DSP_STATUS dsp_status = DSP_SOK;
-	HANDLE hDrvObject = NULL;
+	dsp_status status = DSP_SOK;
+	bhandle hdrv_obj = NULL;
 
-	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(dsp_status))
+	status = cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT);
+	if (DSP_FAILED(status))
 		goto func_cont;
 
 #ifdef CONFIG_BRIDGE_DVFS
 	if (cpufreq_unregister_notifier(&iva_clk_notifier,
-						CPUFREQ_TRANSITION_NOTIFIER))
+					CPUFREQ_TRANSITION_NOTIFIER))
 		pr_err("%s: clk_notifier_unregister failed for iva2_ck\n",
-								__func__);
+		       __func__);
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 
-	if (driverContext) {
+	if (driver_context) {
 		/* Put the DSP in reset state */
-		ret = DSP_Deinit(driverContext);
-		driverContext = 0;
-		DBC_Assert(ret == true);
+		ret = dsp_deinit(driver_context);
+		driver_context = 0;
+		DBC_ASSERT(ret == true);
 	}
-
 #ifdef CONFIG_BRIDGE_DVFS
 	clk_put(clk_handle);
 	clk_handle = NULL;
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 
 func_cont:
-	MEM_ExtPhysPoolRelease();
+	mem_ext_phys_pool_release();
 
-	SERVICES_Exit();
+	services_exit();
 
 	bridge_destroy_sysfs();
 
@@ -397,14 +394,13 @@ func_cont:
 	return 0;
 }
 
-
 #ifdef CONFIG_PM
-static int bridge_suspend(struct platform_device *pdev, pm_message_t state)
+static int BRIDGE_SUSPEND(struct platform_device *pdev, pm_message_t state)
 {
 	u32 status;
 	u32 command = PWR_EMERGENCYDEEPSLEEP;
 
-	status = PWR_SleepDSP(command, timeOut);
+	status = pwr_sleep_dsp(command, time_out);
 	if (DSP_FAILED(status))
 		return -1;
 
@@ -412,11 +408,11 @@ static int bridge_suspend(struct platform_device *pdev, pm_message_t state)
 	return 0;
 }
 
-static int bridge_resume(struct platform_device *pdev)
+static int BRIDGE_RESUME(struct platform_device *pdev)
 {
 	u32 status;
 
-	status = PWR_WakeDSP(timeOut);
+	status = pwr_wake_dsp(time_out);
 	if (DSP_FAILED(status))
 		return -1;
 
@@ -425,18 +421,18 @@ static int bridge_resume(struct platform_device *pdev)
 	return 0;
 }
 #else
-#define bridge_suspend NULL
-#define bridge_resume NULL
+#define BRIDGE_SUSPEND NULL
+#define BRIDGE_RESUME NULL
 #endif
 
 static struct platform_driver bridge_driver = {
 	.driver = {
-		.name = BRIDGE_NAME,
-	},
-	.probe	 = omap34xx_bridge_probe,
-	.remove	 = __devexit_p(omap34xx_bridge_remove),
-	.suspend = bridge_suspend,
-	.resume	 = bridge_resume,
+		   .name = BRIDGE_NAME,
+		   },
+	.probe = omap34_xx_bridge_probe,
+	.remove = __devexit_p(omap34_xx_bridge_remove),
+	.suspend = BRIDGE_SUSPEND,
+	.resume = BRIDGE_RESUME,
 };
 
 static int __init bridge_init(void)
@@ -456,7 +452,7 @@ static void __exit bridge_exit(void)
 static int bridge_open(struct inode *ip, struct file *filp)
 {
 	int status = 0;
-	struct PROCESS_CONTEXT *pr_ctxt = NULL;
+	struct process_context *pr_ctxt = NULL;
 
 	/*
 	 * Allocate a new process context and insert it into global
@@ -468,9 +464,9 @@ static int bridge_open(struct inode *ip, struct file *filp)
 		wait_for_completion(&bridge_open_comp);
 #endif
 
-	pr_ctxt = MEM_Calloc(sizeof(struct PROCESS_CONTEXT), MEM_PAGED);
+	pr_ctxt = mem_calloc(sizeof(struct process_context), MEM_PAGED);
 	if (pr_ctxt) {
-		pr_ctxt->resState = PROC_RES_ALLOCATED;
+		pr_ctxt->res_state = PROC_RES_ALLOCATED;
 		spin_lock_init(&pr_ctxt->dmm_map_lock);
 		INIT_LIST_HEAD(&pr_ctxt->dmm_map_list);
 		spin_lock_init(&pr_ctxt->dmm_rsv_lock);
@@ -498,7 +494,7 @@ static int bridge_open(struct inode *ip, struct file *filp)
 static int bridge_release(struct inode *ip, struct file *filp)
 {
 	int status = 0;
-	struct PROCESS_CONTEXT *pr_ctxt;
+	struct process_context *pr_ctxt;
 
 	if (!filp->private_data) {
 		status = -EIO;
@@ -507,8 +503,8 @@ static int bridge_release(struct inode *ip, struct file *filp)
 
 	pr_ctxt = filp->private_data;
 	flush_signals(current);
-	DRV_RemoveAllResources(pr_ctxt);
-	PROC_Detach(pr_ctxt);
+	drv_remove_all_resources(pr_ctxt);
+	proc_detach(pr_ctxt);
 	kfree(pr_ctxt);
 
 	filp->private_data = NULL;
@@ -523,13 +519,13 @@ err:
 
 /* This function provides IO interface to the bridge driver. */
 static long bridge_ioctl(struct file *filp, unsigned int code,
-		unsigned long args)
+			 unsigned long args)
 {
 	int status;
 	u32 retval = DSP_SOK;
-	union Trapped_Args pBufIn;
+	union Trapped_Args buf_in;
 
-	DBC_Require(filp != NULL);
+	DBC_REQUIRE(filp != NULL);
 #ifdef CONFIG_BRIDGE_RECOVERY
 	if (recover) {
 		status = -EIO;
@@ -538,7 +534,7 @@ static long bridge_ioctl(struct file *filp, unsigned int code,
 #endif
 
 #ifdef CONFIG_PM
-	status = omap34xxbridge_suspend_lockout(&bridge_suspend_data, filp);
+	status = omap34_xxbridge_suspend_lockout(&bridge_suspend_data, filp);
 	if (status != 0)
 		return status;
 #endif
@@ -548,12 +544,12 @@ static long bridge_ioctl(struct file *filp, unsigned int code,
 		goto err;
 	}
 
-	status = copy_from_user(&pBufIn, (union Trapped_Args *)args,
+	status = copy_from_user(&buf_in, (union Trapped_Args *)args,
 				sizeof(union Trapped_Args));
 
 	if (!status) {
-		status = WCD_CallDevIOCtl(code, &pBufIn, &retval,
-				filp->private_data);
+		status = wcd_call_dev_io_ctl(code, &buf_in, &retval,
+					     filp->private_data);
 
 		if (DSP_SUCCEEDED(status)) {
 			status = retval;
@@ -575,18 +571,18 @@ static int bridge_mmap(struct file *filp, struct vm_area_struct *vma)
 	u32 offset = vma->vm_pgoff << PAGE_SHIFT;
 	u32 status;
 
-	DBC_Assert(vma->vm_start < vma->vm_end);
+	DBC_ASSERT(vma->vm_start < vma->vm_end);
 
 	vma->vm_flags |= VM_RESERVED | VM_IO;
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
 	dev_dbg(bridge, "%s: vm filp %p offset %x start %lx end %lx page_prot "
-				"%lx flags %lx\n", __func__, filp, offset,
-				vma->vm_start, vma->vm_end, vma->vm_page_prot,
-				vma->vm_flags);
+		"%lx flags %lx\n", __func__, filp, offset,
+		vma->vm_start, vma->vm_end, vma->vm_page_prot, vma->vm_flags);
 
 	status = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
-				vma->vm_end - vma->vm_start, vma->vm_page_prot);
+				 vma->vm_end - vma->vm_start,
+				 vma->vm_page_prot);
 	if (status != 0)
 		status = -EAGAIN;
 
@@ -594,40 +590,39 @@ static int bridge_mmap(struct file *filp, struct vm_area_struct *vma)
 }
 
 /* To remove all process resources before removing the process from the
- * process context list*/
-DSP_STATUS DRV_RemoveAllResources(HANDLE hPCtxt)
+ * process context list */
+dsp_status drv_remove_all_resources(bhandle hPCtxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DRV_RemoveAllSTRMResElements(pCtxt);
-	DRV_RemoveAllNodeResElements(pCtxt);
-	DRV_RemoveAllDMMResElements(pCtxt);
-	pCtxt->resState = PROC_RES_FREED;
+	dsp_status status = DSP_SOK;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	drv_remove_all_strm_res_elements(ctxt);
+	drv_remove_all_node_res_elements(ctxt);
+	drv_remove_all_dmm_res_elements(ctxt);
+	ctxt->res_state = PROC_RES_FREED;
 	return status;
 }
 
-
 #ifdef CONFIG_BRIDGE_WDT3
 static ssize_t wdt3_show(struct device *dev, struct device_attribute *attr,
-							char *buf)
+			 char *buf)
 {
-	return sprintf(buf, "%d\n", (dsp_wdt_get_enable()) ? 1 : 0);
+	return sprintf(buf, "%d\n", (dsp_wdt_get_enable())? 1 : 0);
 }
 
 static ssize_t wdt3_store(struct device *dev, struct device_attribute *attr,
-						const char *buf, size_t n)
+			  const char *buf, size_t n)
 {
 	u32 wdt3;
-	struct DEV_OBJECT *dev_object;
-	struct WMD_DEV_CONTEXT *dev_ctxt;
+	struct dev_object *dev_object;
+	struct wmd_dev_context *dev_ctxt;
 
 	if (sscanf(buf, "%d", &wdt3) != 1)
 		return -EINVAL;
 
-	dev_object = DEV_GetFirst();
+	dev_object = dev_get_first();
 	if (dev_object == NULL)
 		goto func_end;
-	DEV_GetWMDContext(dev_object, &dev_ctxt);
+	dev_get_wmd_context(dev_object, &dev_ctxt);
 	if (dev_ctxt == NULL)
 		goto func_end;
 
@@ -636,13 +631,13 @@ static ssize_t wdt3_store(struct device *dev, struct device_attribute *attr,
 		if (dsp_wdt_get_enable())
 			goto func_end;
 		dsp_wdt_set_enable(true);
-		if (!CLK_Get_UseCnt(SERVICESCLK_wdt3_fck) &&
-				dev_ctxt->dwBrdState != BRD_DSP_HIBERNATION)
+		if (!clk_get_use_cnt(SERVICESCLK_WDT3_FCK) &&
+		    dev_ctxt->dw_brd_state != BRD_DSP_HIBERNATION)
 			dsp_wdt_enable(true);
 	} else if (wdt3 == 0) {
 		if (!dsp_wdt_get_enable())
 			goto func_end;
-		if (CLK_Get_UseCnt(SERVICESCLK_wdt3_fck))
+		if (clk_get_use_cnt(SERVICESCLK_WDT3_FCK))
 			dsp_wdt_enable(false);
 		dsp_wdt_set_enable(false);
 	}
@@ -653,13 +648,14 @@ func_end:
 static DEVICE_ATTR(dsp_wdt, S_IWUSR | S_IRUGO, wdt3_show, wdt3_store);
 
 static ssize_t wdt3_timeout_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+				 struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%d\n", dsp_wdt_get_timeout());
 }
 
 static ssize_t wdt3_timeout_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t n)
+				  struct device_attribute *attr,
+				  const char *buf, size_t n)
 {
 	u32 wdt3_to;
 
@@ -671,7 +667,7 @@ static ssize_t wdt3_timeout_store(struct device *dev,
 }
 
 static DEVICE_ATTR(dsp_wdt_timeout, S_IWUSR | S_IRUGO, wdt3_timeout_show,
-			wdt3_timeout_store);
+		   wdt3_timeout_store);
 
 #endif
 
@@ -683,19 +679,19 @@ static DEVICE_ATTR(dsp_wdt_timeout, S_IWUSR | S_IRUGO, wdt3_timeout_show,
 static ssize_t mpu_address_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-    struct WMD_DEV_CONTEXT *dwContext = NULL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct wmd_dev_context *dw_context = NULL;
+	struct dev_object *hdev_obj = NULL;
 	u32 mem_poolsize = 0;
 	u32 GppPa = 0, DspVa = 0;
 	u32 armPhyMemOffUncached = 0;
-	hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	DEV_GetWMDContext(hDevObject, &dwContext);
-	if (!dwContext) {
+	hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	dev_get_wmd_context(hdev_obj, &dw_context);
+	if (!dw_context) {
 		pr_err("%s: failed to get the dev context handle\n", __func__);
 		return 0;
 	}
-	GppPa = dwContext->aTLBEntry[0].ulGppPa;
-	DspVa = dwContext->aTLBEntry[0].ulDspVa;
+	GppPa = dw_context->atlb_entry[0].ul_gpp_pa;
+	DspVa = dw_context->atlb_entry[0].ul_dsp_va;
 
 	/*
 	 * the physical address offset, this offset is a
@@ -711,19 +707,19 @@ static ssize_t mpu_address_show(struct device *dev,
 
 	/* Retrive the above calculated addresses */
 	return sprintf(buf, "mempoolsizeOffset 0x%x GppPaOffset 0x%x\n",
-					mem_poolsize, armPhyMemOffUncached);
+		       mem_poolsize, armPhyMemOffUncached);
 }
 
 static DEVICE_ATTR(mpu_address, S_IRUGO, mpu_address_show, NULL);
 
- static struct attribute *attrs[] = {
+static struct attribute *attrs[] = {
 #ifdef CONFIG_BRIDGE_WDT3
 	&dev_attr_dsp_wdt.attr,
 	&dev_attr_dsp_wdt_timeout.attr,
 #endif
 	&dev_attr_mpu_address.attr,
 	NULL,
- };
+};
 
 static struct attribute_group attr_group = {
 	.attrs = attrs,
@@ -747,4 +743,3 @@ static void bridge_destroy_sysfs(void)
 /* Bridge driver initialization and de-initialization functions */
 module_init(bridge_init);
 module_exit(bridge_exit);
-
diff --git a/drivers/dsp/bridge/rmgr/drv_interface.h b/drivers/dsp/bridge/rmgr/drv_interface.h
index ca6858a..fd6f489 100644
--- a/drivers/dsp/bridge/rmgr/drv_interface.h
+++ b/drivers/dsp/bridge/rmgr/drv_interface.h
@@ -22,7 +22,6 @@ static int __init bridge_init(void);	/* Initialize bridge */
 static void __exit bridge_exit(void);	/* Opposite of initialize */
 static int bridge_open(struct inode *, struct file *);	/* Open */
 static int bridge_release(struct inode *, struct file *);	/* Release */
-static long bridge_ioctl(struct file *, unsigned int,
-			unsigned long);
+static long bridge_ioctl(struct file *, unsigned int, unsigned long);
 static int bridge_mmap(struct file *filp, struct vm_area_struct *vma);
-#endif				/* ifndef _DRV_INTERFACE_H_ */
+#endif /* ifndef _DRV_INTERFACE_H_ */
diff --git a/drivers/dsp/bridge/rmgr/dspdrv.c b/drivers/dsp/bridge/rmgr/dspdrv.c
index cc965c4..f8ceeba 100644
--- a/drivers/dsp/bridge/rmgr/dspdrv.c
+++ b/drivers/dsp/bridge/rmgr/dspdrv.c
@@ -44,101 +44,102 @@
 #include <dspbridge/dspdrv.h>
 
 /*
- *  ======== DSP_Init ========
+ *  ======== dsp_init ========
  *  	Allocates bridge resources. Loads a base image onto DSP, if specified.
  */
-u32 DSP_Init(OUT u32 *initStatus)
+u32 dsp_init(OUT u32 *init_status)
 {
-	char devNode[MAXREGPATHLENGTH] = "TIOMAP1510";
-	DSP_STATUS status = DSP_EFAIL;
-	struct DRV_OBJECT *drvObject = NULL;
-	u32 deviceNode;
-	u32 deviceNodeString;
+	char dev_node[MAXREGPATHLENGTH] = "TIOMAP1510";
+	dsp_status status = DSP_EFAIL;
+	struct drv_object *drv_obj = NULL;
+	u32 device_node;
+	u32 device_node_string;
 
-	if (!WCD_Init())
+	if (!wcd_init())
 		goto func_cont;
 
-	status = DRV_Create(&drvObject);
+	status = drv_create(&drv_obj);
 	if (DSP_FAILED(status)) {
-		WCD_Exit();
+		wcd_exit();
 		goto func_cont;
-	}		/* End DRV_Create */
+	}
 
+	/* End drv_create */
 	/* Request Resources */
-	status = DRV_RequestResources((u32)&devNode, &deviceNodeString);
+	status = drv_request_resources((u32) &dev_node, &device_node_string);
 	if (DSP_SUCCEEDED(status)) {
 		/* Attempt to Start the Device */
-		status = DEV_StartDevice((struct CFG_DEVNODE *)
-							deviceNodeString);
+		status = dev_start_device((struct cfg_devnode *)
+					  device_node_string);
 		if (DSP_FAILED(status))
-			(void)DRV_ReleaseResources
-				((u32) deviceNodeString, drvObject);
+			(void)drv_release_resources
+			    ((u32) device_node_string, drv_obj);
 	} else {
-		dev_dbg(bridge, "%s: DRV_RequestResources Failed\n", __func__);
+		dev_dbg(bridge, "%s: drv_request_resources Failed\n", __func__);
 		status = DSP_EFAIL;
 	}
 
 	/* Unwind whatever was loaded */
 	if (DSP_FAILED(status)) {
-		/* irrespective of the status of DEV_RemoveDevice we conitinue
+		/* irrespective of the status of dev_remove_device we conitinue
 		 * unloading. Get the Driver Object iterate through and remove.
 		 * Reset the status to E_FAIL to avoid going through
-		 * WCD_InitComplete2. */
-		for (deviceNode = DRV_GetFirstDevExtension(); deviceNode != 0;
-		    deviceNode = DRV_GetNextDevExtension(deviceNode)) {
-			(void)DEV_RemoveDevice
-				((struct CFG_DEVNODE *)deviceNode);
-			(void)DRV_ReleaseResources((u32)deviceNode,
-				drvObject);
+		 * wcd_init_complete2. */
+		for (device_node = drv_get_first_dev_extension();
+		     device_node != 0;
+		     device_node = drv_get_next_dev_extension(device_node)) {
+			(void)dev_remove_device((struct cfg_devnode *)
+						device_node);
+			(void)drv_release_resources((u32) device_node, drv_obj);
 		}
 		/* Remove the Driver Object */
-		(void)DRV_Destroy(drvObject);
-		drvObject = NULL;
-		WCD_Exit();
+		(void)drv_destroy(drv_obj);
+		drv_obj = NULL;
+		wcd_exit();
 		dev_dbg(bridge, "%s: Logical device failed init\n", __func__);
-	}	/* Unwinding the loaded drivers */
+	}			/* Unwinding the loaded drivers */
 func_cont:
 	/* Attempt to Start the Board */
 	if (DSP_SUCCEEDED(status)) {
 		/* BRD_AutoStart could fail if the dsp execuetable is not the
 		 * correct one. We should not propagate that error
 		 * into the device loader. */
-		(void)WCD_InitComplete2();
+		(void)wcd_init_complete2();
 	} else {
 		dev_dbg(bridge, "%s: Failed\n", __func__);
-	}			/* End WCD_InitComplete2 */
-	DBC_Ensure((DSP_SUCCEEDED(status) && drvObject != NULL) ||
-		  (DSP_FAILED(status) && drvObject == NULL));
-	*initStatus = status;
+	}			/* End wcd_init_complete2 */
+	DBC_ENSURE((DSP_SUCCEEDED(status) && drv_obj != NULL) ||
+		   (DSP_FAILED(status) && drv_obj == NULL));
+	*init_status = status;
 	/* Return the Driver Object */
-	return (u32)drvObject;
+	return (u32) drv_obj;
 }
 
 /*
- *  ======== DSP_Deinit ========
+ *  ======== dsp_deinit ========
  *  	Frees the resources allocated for bridge.
  */
-bool DSP_Deinit(u32 deviceContext)
+bool dsp_deinit(u32 deviceContext)
 {
-	bool retVal = true;
-	u32 deviceNode;
-	struct MGR_OBJECT *mgrObject = NULL;
+	bool ret = true;
+	u32 device_node;
+	struct mgr_object *mgr_obj = NULL;
 
-	while ((deviceNode = DRV_GetFirstDevExtension()) != 0) {
-		(void)DEV_RemoveDevice((struct CFG_DEVNODE *)deviceNode);
+	while ((device_node = drv_get_first_dev_extension()) != 0) {
+		(void)dev_remove_device((struct cfg_devnode *)device_node);
 
-		(void)DRV_ReleaseResources((u32)deviceNode,
-			 (struct DRV_OBJECT *)deviceContext);
+		(void)drv_release_resources((u32) device_node,
+					    (struct drv_object *)deviceContext);
 	}
 
-	(void) DRV_Destroy((struct DRV_OBJECT *) deviceContext);
+	(void)drv_destroy((struct drv_object *)deviceContext);
 
 	/* Get the Manager Object from Registry
 	 * MGR Destroy will unload the DCD dll */
-	if (DSP_SUCCEEDED(CFG_GetObject((u32 *)&mgrObject, REG_MGR_OBJECT)))
-		(void)MGR_Destroy(mgrObject);
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &mgr_obj, REG_MGR_OBJECT)))
+		(void)mgr_destroy(mgr_obj);
 
-	WCD_Exit();
+	wcd_exit();
 
-	return retVal;
+	return ret;
 }
diff --git a/drivers/dsp/bridge/rmgr/mgr.c b/drivers/dsp/bridge/rmgr/mgr.c
index d2b80bd..543ba2b 100644
--- a/drivers/dsp/bridge/rmgr/mgr.c
+++ b/drivers/dsp/bridge/rmgr/mgr.c
@@ -43,187 +43,189 @@
 #define ZLDLLNAME               ""
 #define SIGNATURE               0x5f52474d	/* "MGR_" (in reverse) */
 
-struct MGR_OBJECT {
-	u32 dwSignature;
-	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
+struct mgr_object {
+	u32 dw_signature;
+	struct dcd_manager *hdcd_mgr;	/* Proc/Node data manager */
 };
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;
+static u32 refs;
 
 /*
- *  ========= MGR_Create =========
+ *  ========= mgr_create =========
  *  Purpose:
  *      MGR Object gets created only once during driver Loading.
  */
-DSP_STATUS MGR_Create(OUT struct MGR_OBJECT **phMgrObject,
-		     struct CFG_DEVNODE *hDevNode)
+dsp_status mgr_create(OUT struct mgr_object **phMgrObject,
+		      struct cfg_devnode *dev_node_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct MGR_OBJECT *pMgrObject = NULL;
+	dsp_status status = DSP_SOK;
+	struct mgr_object *pmgr_obj = NULL;
 
-	DBC_Require(phMgrObject != NULL);
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(phMgrObject != NULL);
+	DBC_REQUIRE(refs > 0);
 
-	MEM_AllocObject(pMgrObject, struct MGR_OBJECT, SIGNATURE);
-	if (pMgrObject) {
-		status = DCD_CreateManager(ZLDLLNAME, &pMgrObject->hDcdMgr);
+	MEM_ALLOC_OBJECT(pmgr_obj, struct mgr_object, SIGNATURE);
+	if (pmgr_obj) {
+		status = dcd_create_manager(ZLDLLNAME, &pmgr_obj->hdcd_mgr);
 		if (DSP_SUCCEEDED(status)) {
 			/* If succeeded store the handle in the MGR Object */
-			status = CFG_SetObject((u32)pMgrObject,
-							REG_MGR_OBJECT);
+			status = cfg_set_object((u32) pmgr_obj, REG_MGR_OBJECT);
 			if (DSP_SUCCEEDED(status)) {
-				*phMgrObject = pMgrObject;
+				*phMgrObject = pmgr_obj;
 			} else {
-				DCD_DestroyManager(pMgrObject->hDcdMgr);
-				MEM_FreeObject(pMgrObject);
+				dcd_destroy_manager(pmgr_obj->hdcd_mgr);
+				MEM_FREE_OBJECT(pmgr_obj);
 			}
 		} else {
 			/* failed to Create DCD Manager */
-			MEM_FreeObject(pMgrObject);
+			MEM_FREE_OBJECT(pmgr_obj);
 		}
 	} else {
 		status = DSP_EMEMORY;
 	}
 
-	DBC_Ensure(DSP_FAILED(status) ||
-		  MEM_IsValidHandle(pMgrObject, SIGNATURE));
+	DBC_ENSURE(DSP_FAILED(status) ||
+		   MEM_IS_VALID_HANDLE(pmgr_obj, SIGNATURE));
 	return status;
 }
 
 /*
- *  ========= MGR_Destroy =========
+ *  ========= mgr_destroy =========
  *     This function is invoked during bridge driver unloading.Frees MGR object.
  */
-DSP_STATUS MGR_Destroy(struct MGR_OBJECT *hMgrObject)
+dsp_status mgr_destroy(struct mgr_object *hmgr_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct MGR_OBJECT *pMgrObject = (struct MGR_OBJECT *)hMgrObject;
+	dsp_status status = DSP_SOK;
+	struct mgr_object *pmgr_obj = (struct mgr_object *)hmgr_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hMgrObject, SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hmgr_obj, SIGNATURE));
 
 	/* Free resources */
-	if (hMgrObject->hDcdMgr)
-		DCD_DestroyManager(hMgrObject->hDcdMgr);
+	if (hmgr_obj->hdcd_mgr)
+		dcd_destroy_manager(hmgr_obj->hdcd_mgr);
 
-	MEM_FreeObject(pMgrObject);
+	MEM_FREE_OBJECT(pmgr_obj);
 	/* Update the Registry with NULL for MGR Object */
-	(void)CFG_SetObject(0, REG_MGR_OBJECT);
+	(void)cfg_set_object(0, REG_MGR_OBJECT);
 
-	DBC_Ensure(DSP_FAILED(status) ||
-		 !MEM_IsValidHandle(hMgrObject, SIGNATURE));
+	DBC_ENSURE(DSP_FAILED(status) ||
+		   !MEM_IS_VALID_HANDLE(hmgr_obj, SIGNATURE));
 
 	return status;
 }
 
 /*
- *  ======== MGR_EnumNodeInfo ========
+ *  ======== mgr_enum_node_info ========
  *      Enumerate and get configuration information about nodes configured
  *      in the node database.
  */
-DSP_STATUS MGR_EnumNodeInfo(u32 uNode, OUT struct DSP_NDBPROPS *pNDBProps,
-			   u32 uNDBPropsSize, OUT u32 *puNumNodes)
+dsp_status mgr_enum_node_info(u32 node_id, OUT struct dsp_ndbprops *pndb_props,
+			      u32 undb_props_size, OUT u32 *pu_num_nodes)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_UUID Uuid, uTempUuid;
-	u32 uTempIndex = 0;
-	u32 uNodeIndex = 0;
-	struct DCD_GENERICOBJ GenObj;
-	struct MGR_OBJECT *pMgrObject = NULL;
-
-	DBC_Require(pNDBProps != NULL);
-	DBC_Require(puNumNodes != NULL);
-	DBC_Require(uNDBPropsSize >= sizeof(struct DSP_NDBPROPS));
-	DBC_Require(cRefs > 0);
-
-	*puNumNodes = 0;
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid node_uuid, temp_uuid;
+	u32 temp_index = 0;
+	u32 node_index = 0;
+	struct dcd_genericobj gen_obj;
+	struct mgr_object *pmgr_obj = NULL;
+
+	DBC_REQUIRE(pndb_props != NULL);
+	DBC_REQUIRE(pu_num_nodes != NULL);
+	DBC_REQUIRE(undb_props_size >= sizeof(struct dsp_ndbprops));
+	DBC_REQUIRE(refs > 0);
+
+	*pu_num_nodes = 0;
 	/* Get The Manager Object from the Registry */
-	status = CFG_GetObject((u32 *)&pMgrObject, REG_MGR_OBJECT);
+	status = cfg_get_object((u32 *) &pmgr_obj, REG_MGR_OBJECT);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	DBC_Assert(MEM_IsValidHandle(pMgrObject, SIGNATURE));
+	DBC_ASSERT(MEM_IS_VALID_HANDLE(pmgr_obj, SIGNATURE));
 	/* Forever loop till we hit failed or no more items in the
 	 * Enumeration. We will exit the loop other than DSP_SOK; */
 	while (status == DSP_SOK) {
-		status = DCD_EnumerateObject(uTempIndex++, DSP_DCDNODETYPE,
-					    &uTempUuid);
+		status = dcd_enumerate_object(temp_index++, DSP_DCDNODETYPE,
+					      &temp_uuid);
 		if (status == DSP_SOK) {
-			uNodeIndex++;
-			if (uNode == (uNodeIndex - 1))
-				Uuid = uTempUuid;
+			node_index++;
+			if (node_id == (node_index - 1))
+				node_uuid = temp_uuid;
 
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		if (uNode > (uNodeIndex - 1)) {
+		if (node_id > (node_index - 1)) {
 			status = DSP_EINVALIDARG;
 		} else {
-			status = DCD_GetObjectDef(pMgrObject->hDcdMgr,
-						(struct DSP_UUID *)&Uuid,
-						DSP_DCDNODETYPE, &GenObj);
+			status = dcd_get_object_def(pmgr_obj->hdcd_mgr,
+						    (struct dsp_uuid *)
+						    &node_uuid, DSP_DCDNODETYPE,
+						    &gen_obj);
 			if (DSP_SUCCEEDED(status)) {
 				/* Get the Obj def */
-				*pNDBProps = GenObj.objData.nodeObj.ndbProps;
-				*puNumNodes = uNodeIndex;
+				*pndb_props =
+				    gen_obj.obj_data.node_obj.ndb_props;
+				*pu_num_nodes = node_index;
 			}
 		}
 	}
 
 func_cont:
-	DBC_Ensure((DSP_SUCCEEDED(status) && *puNumNodes > 0) ||
-		  (DSP_FAILED(status) && *puNumNodes == 0));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *pu_num_nodes > 0) ||
+		   (DSP_FAILED(status) && *pu_num_nodes == 0));
 
 	return status;
 }
 
 /*
- *  ======== MGR_EnumProcessorInfo ========
+ *  ======== mgr_enum_processor_info ========
  *      Enumerate and get configuration information about available
  *      DSP processors.
  */
-DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
-				OUT struct DSP_PROCESSORINFO *pProcessorInfo,
-				u32 uProcessorInfoSize, OUT u32 *puNumProcs)
+dsp_status mgr_enum_processor_info(u32 processor_id,
+				   OUT struct dsp_processorinfo *
+				   processor_info, u32 processor_info_size,
+				   OUT u32 *pu_num_procs)
 {
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	DSP_STATUS status2 = DSP_SOK;
-	struct DSP_UUID uTempUuid;
-	u32 uTempIndex = 0;
-	u32 uProcIndex = 0;
-	struct DCD_GENERICOBJ GenObj;
-	struct MGR_OBJECT *pMgrObject = NULL;
-	struct MGR_PROCESSOREXTINFO *pExtInfo;
-	struct DEV_OBJECT *hDevObject;
-	struct DRV_OBJECT *hDrvObject;
-	s32 devType;
-	struct CFG_DEVNODE *devNode;
-	struct CFG_DSPRES chipResources;
-	bool procDetect = false;
-
-	DBC_Require(pProcessorInfo != NULL);
-	DBC_Require(puNumProcs != NULL);
-	DBC_Require(uProcessorInfoSize >= sizeof(struct DSP_PROCESSORINFO));
-	DBC_Require(cRefs > 0);
-
-	*puNumProcs = 0;
-	status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	dsp_status status = DSP_SOK;
+	dsp_status status1 = DSP_SOK;
+	dsp_status status2 = DSP_SOK;
+	struct dsp_uuid temp_uuid;
+	u32 temp_index = 0;
+	u32 proc_index = 0;
+	struct dcd_genericobj gen_obj;
+	struct mgr_object *pmgr_obj = NULL;
+	struct mgr_processorextinfo *ext_info;
+	struct dev_object *hdev_obj;
+	struct drv_object *hdrv_obj;
+	s32 dev_type;
+	struct cfg_devnode *dev_node;
+	struct cfg_dspres chip_resources;
+	bool proc_detect = false;
+
+	DBC_REQUIRE(processor_info != NULL);
+	DBC_REQUIRE(pu_num_procs != NULL);
+	DBC_REQUIRE(processor_info_size >= sizeof(struct dsp_processorinfo));
+	DBC_REQUIRE(refs > 0);
+
+	*pu_num_procs = 0;
+	status = cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
-		status = DRV_GetDevObject(uProcessor, hDrvObject, &hDevObject);
+		status = drv_get_dev_object(processor_id, hdrv_obj, &hdev_obj);
 		if (DSP_SUCCEEDED(status)) {
-			status = DEV_GetDevType(hDevObject, (u32 *) &devType);
-			status = DEV_GetDevNode(hDevObject, &devNode);
-			if (devType == DSP_UNIT)
-				status = CFG_GetDSPResources(devNode,
-							 &chipResources);
+			status = dev_get_dev_type(hdev_obj, (u32 *) &dev_type);
+			status = dev_get_dev_node(hdev_obj, &dev_node);
+			if (dev_type == DSP_UNIT)
+				status = cfg_get_dsp_resources(dev_node,
+							       &chip_resources);
 			else
 				status = DSP_EFAIL;
 
 			if (DSP_SUCCEEDED(status)) {
-				pProcessorInfo->uProcessorType =
-						chipResources.uChipType;
+				processor_info->processor_type =
+				    chip_resources.chip_type;
 			}
 		}
 	}
@@ -231,159 +233,157 @@ DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
 		goto func_end;
 
 	/* Get The Manager Object from the Registry */
-	if (DSP_FAILED(CFG_GetObject((u32 *)&pMgrObject,
-	   REG_MGR_OBJECT))) {
+	if (DSP_FAILED(cfg_get_object((u32 *) &pmgr_obj, REG_MGR_OBJECT))) {
 		dev_dbg(bridge, "%s: Failed to get MGR Object\n", __func__);
 		goto func_end;
 	}
-	DBC_Assert(MEM_IsValidHandle(pMgrObject, SIGNATURE));
+	DBC_ASSERT(MEM_IS_VALID_HANDLE(pmgr_obj, SIGNATURE));
 	/* Forever loop till we hit no more items in the
 	 * Enumeration. We will exit the loop other than DSP_SOK; */
 	while (status1 == DSP_SOK) {
-		status1 = DCD_EnumerateObject(uTempIndex++,
-					     DSP_DCDPROCESSORTYPE,
-					     &uTempUuid);
+		status1 = dcd_enumerate_object(temp_index++,
+					       DSP_DCDPROCESSORTYPE,
+					       &temp_uuid);
 		if (status1 != DSP_SOK)
 			break;
 
-		uProcIndex++;
+		proc_index++;
 		/* Get the Object properties to find the Device/Processor
 		 * Type */
-		if (procDetect != false)
+		if (proc_detect != false)
 			continue;
 
-		status2 = DCD_GetObjectDef(pMgrObject->hDcdMgr,
-					(struct DSP_UUID *)&uTempUuid,
-					DSP_DCDPROCESSORTYPE,
-					&GenObj);
+		status2 = dcd_get_object_def(pmgr_obj->hdcd_mgr,
+					     (struct dsp_uuid *)&temp_uuid,
+					     DSP_DCDPROCESSORTYPE, &gen_obj);
 		if (DSP_SUCCEEDED(status2)) {
 			/* Get the Obj def */
-			if (uProcessorInfoSize <
-					sizeof(struct MGR_PROCESSOREXTINFO)) {
-				*pProcessorInfo = GenObj.objData.procObj;
+			if (processor_info_size <
+			    sizeof(struct mgr_processorextinfo)) {
+				*processor_info = gen_obj.obj_data.proc_info;
 			} else {
 				/* extended info */
-				pExtInfo = (struct MGR_PROCESSOREXTINFO *)
-						pProcessorInfo;
-				*pExtInfo = GenObj.objData.extProcObj;
+				ext_info = (struct mgr_processorextinfo *)
+				    processor_info;
+				*ext_info = gen_obj.obj_data.ext_proc_obj;
 			}
 			dev_dbg(bridge, "%s: Got proctype  from DCD %ld\n",
-				__func__, pProcessorInfo->uProcessorType);
+				__func__, processor_info->processor_type);
 			/* See if we got the needed processor */
-			if (devType == DSP_UNIT) {
-				if (pProcessorInfo->uProcessorType ==
-				   DSPPROCTYPE_C64)
-					procDetect = true;
-			} else if (devType == IVA_UNIT) {
-				if (pProcessorInfo->uProcessorType ==
-				   IVAPROCTYPE_ARM7)
-					procDetect = true;
+			if (dev_type == DSP_UNIT) {
+				if (processor_info->processor_type ==
+				    DSPPROCTYPE_C64)
+					proc_detect = true;
+			} else if (dev_type == IVA_UNIT) {
+				if (processor_info->processor_type ==
+				    IVAPROCTYPE_ARM7)
+					proc_detect = true;
 			}
 			/* User applciatiuons aonly check for chip type, so
 			 * this clumsy overwrite */
-			pProcessorInfo->uProcessorType =
-					 chipResources.uChipType;
+			processor_info->processor_type =
+			    chip_resources.chip_type;
 		} else {
 			dev_dbg(bridge, "%s: Failed to get DCD processor info "
-						"%x\n", __func__, status2);
+				"%x\n", __func__, status2);
 			status = DSP_EFAIL;
 		}
 	}
-	*puNumProcs = uProcIndex;
-	if (procDetect == false) {
+	*pu_num_procs = proc_index;
+	if (proc_detect == false) {
 		dev_dbg(bridge, "%s: Failed to get proc info from DCD, so use "
-						"CFG registry\n", __func__);
-		pProcessorInfo->uProcessorType = chipResources.uChipType;
+			"CFG registry\n", __func__);
+		processor_info->processor_type = chip_resources.chip_type;
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== MGR_Exit ========
+ *  ======== mgr_exit ========
  *      Decrement reference count, and free resources when reference count is
  *      0.
  */
-void MGR_Exit(void)
+void mgr_exit(void)
 {
-	DBC_Require(cRefs > 0);
-	cRefs--;
-	if (cRefs == 0)
-		DCD_Exit();
+	DBC_REQUIRE(refs > 0);
+	refs--;
+	if (refs == 0)
+		dcd_exit();
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== MGR_GetDCDHandle ========
+ *  ======== mgr_get_dcd_handle ========
  *      Retrieves the MGR handle. Accessor Function.
  */
-DSP_STATUS MGR_GetDCDHandle(struct MGR_OBJECT *hMGRHandle,
-			   OUT u32 *phDCDHandle)
+dsp_status mgr_get_dcd_handle(struct mgr_object *hMGRHandle,
+			      OUT u32 *phDCDHandle)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct MGR_OBJECT *pMgrObject = (struct MGR_OBJECT *)hMGRHandle;
+	dsp_status status = DSP_EFAIL;
+	struct mgr_object *pmgr_obj = (struct mgr_object *)hMGRHandle;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDCDHandle != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDCDHandle != NULL);
 
-	*phDCDHandle = (u32)NULL;
-	if (MEM_IsValidHandle(pMgrObject, SIGNATURE)) {
-		*phDCDHandle = (u32) pMgrObject->hDcdMgr;
+	*phDCDHandle = (u32) NULL;
+	if (MEM_IS_VALID_HANDLE(pmgr_obj, SIGNATURE)) {
+		*phDCDHandle = (u32) pmgr_obj->hdcd_mgr;
 		status = DSP_SOK;
 	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && *phDCDHandle != (u32)NULL) ||
-		  (DSP_FAILED(status) && *phDCDHandle == (u32)NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *phDCDHandle != (u32) NULL) ||
+		   (DSP_FAILED(status) && *phDCDHandle == (u32) NULL));
 
 	return status;
 }
 
 /*
- *  ======== MGR_Init ========
+ *  ======== mgr_init ========
  *      Initialize MGR's private state, keeping a reference count on each call.
  */
-bool MGR_Init(void)
+bool mgr_init(void)
 {
-	bool fRetval = true;
-	bool fInitDCD = false;
+	bool ret = true;
+	bool init_dcd = false;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0) {
-		fInitDCD = DCD_Init();	/*  DCD Module */
+	if (refs == 0) {
+		init_dcd = dcd_init();	/*  DCD Module */
 
-		if (!fInitDCD)
-			fRetval = false;
+		if (!init_dcd)
+			ret = false;
 	}
 
-	if (fRetval)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== MGR_WaitForBridgeEvents ========
+ *  ======== mgr_wait_for_bridge_events ========
  *      Block on any Bridge event(s)
  */
-DSP_STATUS MGR_WaitForBridgeEvents(struct DSP_NOTIFICATION **aNotifications,
-				  u32 uCount, OUT u32 *puIndex, u32 uTimeout)
+dsp_status mgr_wait_for_bridge_events(struct dsp_notification **anotifications,
+				      u32 count, OUT u32 *pu_index,
+				      u32 utimeout)
 {
-	DSP_STATUS status;
-	struct SYNC_OBJECT *hSyncEvents[MAX_EVENTS];
+	dsp_status status;
+	struct sync_object *sync_events[MAX_EVENTS];
 	u32 i;
 
-	DBC_Require(uCount < MAX_EVENTS);
+	DBC_REQUIRE(count < MAX_EVENTS);
 
-	for (i = 0; i < uCount; i++)
-		hSyncEvents[i] = aNotifications[i]->handle;
+	for (i = 0; i < count; i++)
+		sync_events[i] = anotifications[i]->handle;
 
-	status = SYNC_WaitOnMultipleEvents(hSyncEvents, uCount, uTimeout,
-					 puIndex);
+	status = sync_wait_on_multiple_events(sync_events, count, utimeout,
+					      pu_index);
 
 	return status;
 
 }
-
diff --git a/drivers/dsp/bridge/rmgr/nldr.c b/drivers/dsp/bridge/rmgr/nldr.c
index 3a701c2..58e635f 100644
--- a/drivers/dsp/bridge/rmgr/nldr.c
+++ b/drivers/dsp/bridge/rmgr/nldr.c
@@ -85,9 +85,9 @@
 #define MAXSEGID	3	/* Largest possible (real) segid */
 #define MEMINTERNALID   32	/* Segid meaning use internal mem */
 #define MEMEXTERNALID   33	/* Segid meaning use external mem */
-#define NULLID	  63	/* Segid meaning no memory req/pref */
-#define FLAGBIT	 7	/* 7th bit is pref./req. flag */
-#define SEGMASK	 0x3f	/* Bits 0 - 5 */
+#define NULLID	  63		/* Segid meaning no memory req/pref */
+#define FLAGBIT	 7		/* 7th bit is pref./req. flag */
+#define SEGMASK	 0x3f		/* Bits 0 - 5 */
 
 #define CREATEBIT	0	/* Create segid starts at bit 0 */
 #define DELETEBIT	8	/* Delete segid starts at bit 8 */
@@ -120,12 +120,12 @@
 #define DELETECODEFLAGBIT   5
 #define MAXFLAGS	    6
 
-#define IsInternal(hNldr, segid) (((segid) <= MAXSEGID && \
-	    hNldr->segTable[(segid)] & DYNM_INTERNAL) || \
+#define IS_INTERNAL(nldr_obj, segid) (((segid) <= MAXSEGID && \
+	    nldr_obj->seg_table[(segid)] & DYNM_INTERNAL) || \
 	    (segid) == MEMINTERNALID)
 
-#define IsExternal(hNldr, segid) (((segid) <= MAXSEGID && \
-	    hNldr->segTable[(segid)] & DYNM_EXTERNAL) || \
+#define IS_EXTERNAL(nldr_obj, segid) (((segid) <= MAXSEGID && \
+	    nldr_obj->seg_table[(segid)] & DYNM_EXTERNAL) || \
 	    (segid) == MEMEXTERNALID)
 
 #define SWAPLONG(x) ((((x) << 24) & 0xFF000000) | (((x) << 8) & 0xFF0000L) | \
@@ -136,25 +136,25 @@
     /*
      *  These names may be embedded in overlay sections to identify which
      *  node phase the section should be overlayed.
-     */
+ */
 #define PCREATE	 "create"
 #define PDELETE	 "delete"
 #define PEXECUTE	"execute"
 
-#define IsEqualUUID(uuid1, uuid2) (\
-	((uuid1).ulData1 == (uuid2).ulData1) && \
-	((uuid1).usData2 == (uuid2).usData2) && \
-	((uuid1).usData3 == (uuid2).usData3) && \
-	((uuid1).ucData4 == (uuid2).ucData4) && \
-	((uuid1).ucData5 == (uuid2).ucData5) && \
-	(strncmp((void *)(uuid1).ucData6, (void *)(uuid2).ucData6, 6)) == 0)
+#define IS_EQUAL_UUID(uuid1, uuid2) (\
+	((uuid1).ul_data1 == (uuid2).ul_data1) && \
+	((uuid1).us_data2 == (uuid2).us_data2) && \
+	((uuid1).us_data3 == (uuid2).us_data3) && \
+	((uuid1).uc_data4 == (uuid2).uc_data4) && \
+	((uuid1).uc_data5 == (uuid2).uc_data5) && \
+	(strncmp((void *)(uuid1).uc_data6, (void *)(uuid2).uc_data6, 6)) == 0)
 
     /*
-     *  ======== MemInfo ========
+     *  ======== mem_seg_info ========
      *  Format of dynamic loading memory segment info in coff file.
      *  Must match dynm.h55.
-     */
-struct MemInfo {
+ */
+struct mem_seg_info {
 	u32 segid;		/* Dynamic loading memory segment number */
 	u32 base;
 	u32 len;
@@ -162,320 +162,320 @@ struct MemInfo {
 };
 
 /*
- *  ======== LibNode ========
+ *  ======== lib_node ========
  *  For maintaining a tree of library dependencies.
  */
-struct LibNode {
-	struct DBLL_LibraryObj *lib;	/* The library */
-	u16 nDepLibs;	/* Number of dependent libraries */
-	struct LibNode *pDepLibs;	/* Dependent libraries of lib */
+struct lib_node {
+	struct dbll_library_obj *lib;	/* The library */
+	u16 dep_libs;		/* Number of dependent libraries */
+	struct lib_node *dep_libs_tree;	/* Dependent libraries of lib */
 };
 
 /*
- *  ======== OvlySect ========
+ *  ======== ovly_sect ========
  *  Information needed to overlay a section.
  */
-struct OvlySect {
-	struct OvlySect *pNextSect;
-	u32 loadAddr;		/* Load address of section */
-	u32 runAddr;		/* Run address of section */
+struct ovly_sect {
+	struct ovly_sect *next_sect;
+	u32 sect_load_addr;	/* Load address of section */
+	u32 sect_run_addr;	/* Run address of section */
 	u32 size;		/* Size of section */
 	u16 page;		/* DBL_CODE, DBL_DATA */
 };
 
 /*
- *  ======== OvlyNode ========
+ *  ======== ovly_node ========
  *  For maintaining a list of overlay nodes, with sections that need to be
  *  overlayed for each of the nodes phases.
  */
-struct OvlyNode {
-	struct DSP_UUID uuid;
-	char *pNodeName;
-	struct OvlySect *pCreateSects;
-	struct OvlySect *pDeleteSects;
-	struct OvlySect *pExecuteSects;
-	struct OvlySect *pOtherSects;
-	u16 nCreateSects;
-	u16 nDeleteSects;
-	u16 nExecuteSects;
-	u16 nOtherSects;
-	u16 createRef;
-	u16 deleteRef;
-	u16 executeRef;
-	u16 otherRef;
+struct ovly_node {
+	struct dsp_uuid uuid;
+	char *node_name;
+	struct ovly_sect *create_sects_list;
+	struct ovly_sect *delete_sects_list;
+	struct ovly_sect *execute_sects_list;
+	struct ovly_sect *other_sects_list;
+	u16 create_sects;
+	u16 delete_sects;
+	u16 execute_sects;
+	u16 other_sects;
+	u16 create_ref;
+	u16 delete_ref;
+	u16 execute_ref;
+	u16 other_ref;
 };
 
 /*
- *  ======== NLDR_OBJECT ========
+ *  ======== nldr_object ========
  *  Overlay loader object.
  */
-struct NLDR_OBJECT {
-	u32 dwSignature;	/* For object validation */
-	struct DEV_OBJECT *hDevObject;	/* Device object */
-	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
-	struct DBLL_TarObj *dbll;	/* The DBL loader */
-	struct DBLL_LibraryObj *baseLib;	/* Base image library */
-	struct RMM_TargetObj *rmm;	/* Remote memory manager for DSP */
-	struct DBLL_Fxns dbllFxns;	/* Loader function table */
-	struct DBLL_Attrs dbllAttrs;	/* attrs to pass to loader functions */
-	NLDR_OVLYFXN ovlyFxn;	/* "write" for overlay nodes */
-	NLDR_WRITEFXN writeFxn;	/* "write" for dynamic nodes */
-	struct OvlyNode *ovlyTable;	/* Table of overlay nodes */
-	u16 nOvlyNodes;	/* Number of overlay nodes in base */
-	u16 nNode;		/* Index for tracking overlay nodes */
-	u16 nSegs;		/* Number of dynamic load mem segs */
-	u32 *segTable;	/* memtypes of dynamic memory segs
+struct nldr_object {
+	u32 dw_signature;	/* For object validation */
+	struct dev_object *hdev_obj;	/* Device object */
+	struct dcd_manager *hdcd_mgr;	/* Proc/Node data manager */
+	struct dbll_tar_obj *dbll;	/* The DBL loader */
+	struct dbll_library_obj *base_lib;	/* Base image library */
+	struct rmm_target_obj *rmm;	/* Remote memory manager for DSP */
+	struct dbll_fxns ldr_fxns;	/* Loader function table */
+	struct dbll_attrs ldr_attrs;	/* attrs to pass to loader functions */
+	nldr_ovlyfxn ovly_fxn;	/* "write" for overlay nodes */
+	nldr_writefxn write_fxn;	/* "write" for dynamic nodes */
+	struct ovly_node *ovly_table;	/* Table of overlay nodes */
+	u16 ovly_nodes;		/* Number of overlay nodes in base */
+	u16 ovly_nid;		/* Index for tracking overlay nodes */
+	u16 dload_segs;		/* Number of dynamic load mem segs */
+	u32 *seg_table;		/* memtypes of dynamic memory segs
 				 * indexed by segid
 				 */
-	u16 usDSPMauSize;	/* Size of DSP MAU */
-	u16 usDSPWordSize;	/* Size of DSP word */
+	u16 us_dsp_mau_size;	/* Size of DSP MAU */
+	u16 us_dsp_word_size;	/* Size of DSP word */
 };
 
 /*
- *  ======== NLDR_NODEOBJECT ========
+ *  ======== nldr_nodeobject ========
  *  Dynamic node object. This object is created when a node is allocated.
  */
-struct NLDR_NODEOBJECT {
-	u32 dwSignature;	/* For object validation */
-	struct NLDR_OBJECT *pNldr;	/* Dynamic loader handle */
-	void *pPrivRef;		/* Handle to pass to DBL_WriteFxn */
-	struct DSP_UUID uuid;		/* Node's UUID */
-	bool fDynamic;		/* Dynamically loaded node? */
-	bool fOverlay;		/* Overlay node? */
-	bool *pfPhaseSplit;	/* Multiple phase libraries? */
-	struct LibNode root;		/* Library containing node phase */
-	struct LibNode createLib;    /* Library containing create phase lib */
-	struct LibNode executeLib;   /* Library containing execute phase lib */
-	struct LibNode deleteLib;    /* Library containing delete phase lib */
-	struct LibNode persLib[MAXLIBS];  /* libs remain loaded until Delete */
-	s32 nPersLib;		/* Number of persistent libraries */
+struct nldr_nodeobject {
+	u32 dw_signature;	/* For object validation */
+	struct nldr_object *nldr_obj;	/* Dynamic loader handle */
+	void *priv_ref;		/* Handle to pass to dbl_write_fxn */
+	struct dsp_uuid uuid;	/* Node's UUID */
+	bool dynamic;		/* Dynamically loaded node? */
+	bool overlay;		/* Overlay node? */
+	bool *pf_phase_split;	/* Multiple phase libraries? */
+	struct lib_node root;	/* Library containing node phase */
+	struct lib_node create_lib;	/* Library with create phase lib */
+	struct lib_node execute_lib;	/* Library with execute phase lib */
+	struct lib_node delete_lib;	/* Library with delete phase lib */
+	/* libs remain loaded until Delete */
+	struct lib_node pers_lib_table[MAXLIBS];
+	s32 pers_libs;		/* Number of persistent libraries */
 	/* Path in lib dependency tree */
-	struct DBLL_LibraryObj *libPath[MAXDEPTH + 1];
-	enum NLDR_PHASE phase;	/* Node phase currently being loaded */
+	struct dbll_library_obj *lib_path[MAXDEPTH + 1];
+	enum nldr_phase phase;	/* Node phase currently being loaded */
 
 	/*
 	 *  Dynamic loading memory segments for data and code of each phase.
 	 */
-	u16 segId[MAXFLAGS];
+	u16 seg_id[MAXFLAGS];
 
 	/*
-	 *  Mask indicating whether each mem segment specified in segId[]
+	 *  Mask indicating whether each mem segment specified in seg_id[]
 	 *  is preferred or required.
-	 *  For example if (codeDataFlagMask & (1 << EXECUTEDATAFLAGBIT)) != 0,
+	 *  For example
+	 *  	if (code_data_flag_mask & (1 << EXECUTEDATAFLAGBIT)) != 0,
 	 *  then it is required to load execute phase data into the memory
-	 *  specified by segId[EXECUTEDATAFLAGBIT].
+	 *  specified by seg_id[EXECUTEDATAFLAGBIT].
 	 */
-	u32 codeDataFlagMask;
+	u32 code_data_flag_mask;
 };
 
 /* Dynamic loader function table */
-static struct DBLL_Fxns dbllFxns = {
-	(DBLL_CloseFxn) DBLL_close,
-	(DBLL_CreateFxn) DBLL_create,
-	(DBLL_DeleteFxn) DBLL_delete,
-	(DBLL_ExitFxn) DBLL_exit,
-	(DBLL_GetAttrsFxn) DBLL_getAttrs,
-	(DBLL_GetAddrFxn) DBLL_getAddr,
-	(DBLL_GetCAddrFxn) DBLL_getCAddr,
-	(DBLL_GetSectFxn) DBLL_getSect,
-	(DBLL_InitFxn) DBLL_init,
-	(DBLL_LoadFxn) DBLL_load,
-	(DBLL_LoadSectFxn) DBLL_loadSect,
-	(DBLL_OpenFxn) DBLL_open,
-	(DBLL_ReadSectFxn) DBLL_readSect,
-	(DBLL_SetAttrsFxn) DBLL_setAttrs,
-	(DBLL_UnloadFxn) DBLL_unload,
-	(DBLL_UnloadSectFxn) DBLL_unloadSect,
+static struct dbll_fxns ldr_fxns = {
+	(dbll_close_fxn) dbll_close,
+	(dbll_create_fxn) dbll_create,
+	(dbll_delete_fxn) dbll_delete,
+	(dbll_exit_fxn) dbll_exit,
+	(dbll_get_attrs_fxn) dbll_get_attrs,
+	(dbll_get_addr_fxn) dbll_get_addr,
+	(dbll_get_c_addr_fxn) dbll_get_c_addr,
+	(dbll_get_sect_fxn) dbll_get_sect,
+	(dbll_init_fxn) dbll_init,
+	(dbll_load_fxn) dbll_load,
+	(dbll_load_sect_fxn) dbll_load_sect,
+	(dbll_open_fxn) dbll_open,
+	(dbll_read_sect_fxn) dbll_read_sect,
+	(dbll_set_attrs_fxn) dbll_set_attrs,
+	(dbll_unload_fxn) dbll_unload,
+	(dbll_unload_sect_fxn) dbll_unload_sect,
 };
 
-static u32 cRefs;		/* module reference count */
-
-static DSP_STATUS AddOvlyInfo(void *handle, struct DBLL_SectInfo *sectInfo,
-			     u32 addr, u32 nBytes);
-static DSP_STATUS AddOvlyNode(struct DSP_UUID *pUuid,
-			     enum DSP_DCDOBJTYPE objType,
-			     IN void *handle);
-static DSP_STATUS AddOvlySect(struct NLDR_OBJECT *hNldr,
-			      struct OvlySect **pList,
-			      struct DBLL_SectInfo *pSectInfo, bool *pExists,
-			      u32 addr, u32 nBytes);
-static s32 fakeOvlyWrite(void *handle, u32 dspAddr, void *buf, u32 nBytes,
-			s32 mtype);
-static void FreeSects(struct NLDR_OBJECT *hNldr, struct OvlySect *pPhaseSects,
-		     u16 nAlloc);
-static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
-			  char *symName, struct DBLL_Symbol **sym);
-static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
-			 struct LibNode *root, struct DSP_UUID uuid,
-			 bool rootPersistent, struct DBLL_LibraryObj **libPath,
-			 enum NLDR_PHASE phase, u16 depth);
-static DSP_STATUS LoadOvly(struct NLDR_NODEOBJECT *hNldrNode,
-			  enum NLDR_PHASE phase);
-static DSP_STATUS RemoteAlloc(void **pRef, u16 memType, u32 size,
-			     u32 align, u32 *dspAddr,
-			     OPTIONAL s32 segmentId, OPTIONAL s32 req,
-			     bool reserve);
-static DSP_STATUS RemoteFree(void **pRef, u16 space, u32 dspAddr,
-			    u32 size, bool reserve);
-
-static void UnloadLib(struct NLDR_NODEOBJECT *hNldrNode, struct LibNode *root);
-static void UnloadOvly(struct NLDR_NODEOBJECT *hNldrNode,
-		      enum NLDR_PHASE phase);
-static bool findInPersistentLibArray(struct NLDR_NODEOBJECT *hNldrNode,
-				    struct DBLL_LibraryObj *lib);
-static u32 findLcm(u32 a, u32 b);
-static u32 findGcf(u32 a, u32 b);
+static u32 refs;		/* module reference count */
+
+static dsp_status add_ovly_info(void *handle, struct dbll_sect_info *sect_info,
+				u32 addr, u32 bytes);
+static dsp_status add_ovly_node(struct dsp_uuid *uuid_obj,
+				enum dsp_dcdobjtype obj_type, IN void *handle);
+static dsp_status add_ovly_sect(struct nldr_object *nldr_obj,
+				struct ovly_sect **pList,
+				struct dbll_sect_info *pSectInfo,
+				bool *pExists, u32 addr, u32 bytes);
+static s32 fake_ovly_write(void *handle, u32 dspAddr, void *buf, u32 bytes,
+			   s32 mtype);
+static void free_sects(struct nldr_object *nldr_obj,
+		       struct ovly_sect *phase_sects, u16 alloc_num);
+static bool get_symbol_value(void *handle, void *parg, void *rmm_handle,
+			     char *symName, struct dbll_sym_val **sym);
+static dsp_status load_lib(struct nldr_nodeobject *nldr_node_obj,
+			   struct lib_node *root, struct dsp_uuid uuid,
+			   bool rootPersistent,
+			   struct dbll_library_obj **lib_path,
+			   enum nldr_phase phase, u16 depth);
+static dsp_status load_ovly(struct nldr_nodeobject *nldr_node_obj,
+			    enum nldr_phase phase);
+static dsp_status remote_alloc(void **pRef, u16 mem_sect_type, u32 size,
+			       u32 align, u32 *dspAddr, OPTIONAL s32 segmentId,
+			       OPTIONAL s32 req, bool reserve);
+static dsp_status remote_free(void **pRef, u16 space, u32 dspAddr, u32 size,
+			      bool reserve);
+
+static void unload_lib(struct nldr_nodeobject *nldr_node_obj,
+		       struct lib_node *root);
+static void unload_ovly(struct nldr_nodeobject *nldr_node_obj,
+			enum nldr_phase phase);
+static bool find_in_persistent_lib_array(struct nldr_nodeobject *nldr_node_obj,
+					 struct dbll_library_obj *lib);
+static u32 find_lcm(u32 a, u32 b);
+static u32 find_gcf(u32 a, u32 b);
 
 /*
- *  ======== NLDR_Allocate ========
+ *  ======== nldr_allocate ========
  */
-DSP_STATUS NLDR_Allocate(struct NLDR_OBJECT *hNldr, void *pPrivRef,
-			 IN CONST struct DCD_NODEPROPS *pNodeProps,
-			 OUT struct NLDR_NODEOBJECT **phNldrNode,
-			 IN bool *pfPhaseSplit)
+dsp_status nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,
+			 IN CONST struct dcd_nodeprops *node_props,
+			 OUT struct nldr_nodeobject **phNldrNode,
+			 IN bool *pf_phase_split)
 {
-	struct NLDR_NODEOBJECT *pNldrNode = NULL;
-	DSP_STATUS status = DSP_SOK;
+	struct nldr_nodeobject *nldr_node_obj = NULL;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pNodeProps != NULL);
-	DBC_Require(phNldrNode != NULL);
-	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(node_props != NULL);
+	DBC_REQUIRE(phNldrNode != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
 
 	/* Initialize handle in case of failure */
 	*phNldrNode = NULL;
 	/* Allocate node object */
-	MEM_AllocObject(pNldrNode, struct NLDR_NODEOBJECT, NLDR_NODESIGNATURE);
+	MEM_ALLOC_OBJECT(nldr_node_obj, struct nldr_nodeobject,
+			 NLDR_NODESIGNATURE);
 
-	if (pNldrNode == NULL) {
+	if (nldr_node_obj == NULL) {
 		status = DSP_EMEMORY;
 	} else {
-		pNldrNode->pfPhaseSplit = pfPhaseSplit;
-		pNldrNode->nPersLib = 0;
-		pNldrNode->pNldr = hNldr;
-		pNldrNode->pPrivRef = pPrivRef;
+		nldr_node_obj->pf_phase_split = pf_phase_split;
+		nldr_node_obj->pers_libs = 0;
+		nldr_node_obj->nldr_obj = nldr_obj;
+		nldr_node_obj->priv_ref = priv_ref;
 		/* Save node's UUID. */
-		pNldrNode->uuid = pNodeProps->ndbProps.uiNodeID;
+		nldr_node_obj->uuid = node_props->ndb_props.ui_node_id;
 		/*
 		 *  Determine if node is a dynamically loaded node from
-		 *  ndbProps.
+		 *  ndb_props.
 		 */
-		if (pNodeProps->usLoadType == NLDR_DYNAMICLOAD) {
+		if (node_props->us_load_type == NLDR_DYNAMICLOAD) {
 			/* Dynamic node */
-			pNldrNode->fDynamic = true;
+			nldr_node_obj->dynamic = true;
 			/*
-			 *  Extract memory requirements from ndbProps masks
+			 *  Extract memory requirements from ndb_props masks
 			 */
 			/* Create phase */
-			pNldrNode->segId[CREATEDATAFLAGBIT] = (u16)
-				(pNodeProps->ulDataMemSegMask >> CREATEBIT) &
-				SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulDataMemSegMask >>
-				(CREATEBIT + FLAGBIT)) & 1) <<
-				CREATEDATAFLAGBIT;
-			pNldrNode->segId[CREATECODEFLAGBIT] = (u16)
-				(pNodeProps->ulCodeMemSegMask >>
-				CREATEBIT) & SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulCodeMemSegMask >>
-				(CREATEBIT + FLAGBIT)) & 1) <<
-				CREATECODEFLAGBIT;
+			nldr_node_obj->seg_id[CREATEDATAFLAGBIT] = (u16)
+			    (node_props->ul_data_mem_seg_mask >> CREATEBIT) &
+			    SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_data_mem_seg_mask >>
+			      (CREATEBIT + FLAGBIT)) & 1) << CREATEDATAFLAGBIT;
+			nldr_node_obj->seg_id[CREATECODEFLAGBIT] = (u16)
+			    (node_props->ul_code_mem_seg_mask >>
+			     CREATEBIT) & SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_code_mem_seg_mask >>
+			      (CREATEBIT + FLAGBIT)) & 1) << CREATECODEFLAGBIT;
 			/* Execute phase */
-			pNldrNode->segId[EXECUTEDATAFLAGBIT] = (u16)
-				(pNodeProps->ulDataMemSegMask >>
-				EXECUTEBIT) & SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulDataMemSegMask >>
-				(EXECUTEBIT + FLAGBIT)) & 1) <<
-				EXECUTEDATAFLAGBIT;
-			pNldrNode->segId[EXECUTECODEFLAGBIT] = (u16)
-				(pNodeProps->ulCodeMemSegMask >>
-				EXECUTEBIT) & SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulCodeMemSegMask >>
-				(EXECUTEBIT + FLAGBIT)) & 1) <<
-				EXECUTECODEFLAGBIT;
+			nldr_node_obj->seg_id[EXECUTEDATAFLAGBIT] = (u16)
+			    (node_props->ul_data_mem_seg_mask >>
+			     EXECUTEBIT) & SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_data_mem_seg_mask >>
+			      (EXECUTEBIT + FLAGBIT)) & 1) <<
+			    EXECUTEDATAFLAGBIT;
+			nldr_node_obj->seg_id[EXECUTECODEFLAGBIT] = (u16)
+			    (node_props->ul_code_mem_seg_mask >>
+			     EXECUTEBIT) & SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_code_mem_seg_mask >>
+			      (EXECUTEBIT + FLAGBIT)) & 1) <<
+			    EXECUTECODEFLAGBIT;
 			/* Delete phase */
-			pNldrNode->segId[DELETEDATAFLAGBIT] = (u16)
-			    (pNodeProps->ulDataMemSegMask >> DELETEBIT) &
+			nldr_node_obj->seg_id[DELETEDATAFLAGBIT] = (u16)
+			    (node_props->ul_data_mem_seg_mask >> DELETEBIT) &
 			    SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulDataMemSegMask >>
-				(DELETEBIT + FLAGBIT)) & 1) <<
-				DELETEDATAFLAGBIT;
-			pNldrNode->segId[DELETECODEFLAGBIT] = (u16)
-				(pNodeProps->ulCodeMemSegMask >>
-				DELETEBIT) & SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulCodeMemSegMask >>
-				(DELETEBIT + FLAGBIT)) & 1) <<
-				DELETECODEFLAGBIT;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_data_mem_seg_mask >>
+			      (DELETEBIT + FLAGBIT)) & 1) << DELETEDATAFLAGBIT;
+			nldr_node_obj->seg_id[DELETECODEFLAGBIT] = (u16)
+			    (node_props->ul_code_mem_seg_mask >>
+			     DELETEBIT) & SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_code_mem_seg_mask >>
+			      (DELETEBIT + FLAGBIT)) & 1) << DELETECODEFLAGBIT;
 		} else {
 			/* Non-dynamically loaded nodes are part of the
 			 * base image */
-			pNldrNode->root.lib = hNldr->baseLib;
+			nldr_node_obj->root.lib = nldr_obj->base_lib;
 			/* Check for overlay node */
-			if (pNodeProps->usLoadType == NLDR_OVLYLOAD)
-				pNldrNode->fOverlay = true;
+			if (node_props->us_load_type == NLDR_OVLYLOAD)
+				nldr_node_obj->overlay = true;
 
 		}
-		*phNldrNode = (struct NLDR_NODEOBJECT *) pNldrNode;
+		*phNldrNode = (struct nldr_nodeobject *)nldr_node_obj;
 	}
 	/* Cleanup on failure */
-	if (DSP_FAILED(status) && pNldrNode)
-		MEM_FreeObject(pNldrNode);
+	if (DSP_FAILED(status) && nldr_node_obj)
+		MEM_FREE_OBJECT(nldr_node_obj);
 
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle(((struct NLDR_NODEOBJECT *)(*phNldrNode)),
-		  NLDR_NODESIGNATURE)) || (DSP_FAILED(status) &&
-		  *phNldrNode == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE(((struct nldr_nodeobject
+					  *)(*phNldrNode)), NLDR_NODESIGNATURE))
+		   || (DSP_FAILED(status) && *phNldrNode == NULL));
 	return status;
 }
 
 /*
- *  ======== NLDR_Create ========
+ *  ======== nldr_create ========
  */
-DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
-		      struct DEV_OBJECT *hDevObject,
-		      IN CONST struct NLDR_ATTRS *pAttrs)
+dsp_status nldr_create(OUT struct nldr_object **phNldr,
+		       struct dev_object *hdev_obj,
+		       IN CONST struct nldr_attrs *pattrs)
 {
-	struct COD_MANAGER *hCodMgr;	/* COD manager */
-	char *pszCoffBuf = NULL;
-	char szZLFile[COD_MAXPATHLENGTH];
-	struct NLDR_OBJECT *pNldr = NULL;
-	struct DBLL_Attrs saveAttrs;
-	struct DBLL_Attrs newAttrs;
-	DBLL_Flags flags;
-	u32 ulEntry;
-	u16 nSegs = 0;
-	struct MemInfo *pMemInfo;
-	u32 ulLen = 0;
-	u32 ulAddr;
-	struct RMM_Segment *rmmSegs = NULL;
+	struct cod_manager *cod_mgr;	/* COD manager */
+	char *psz_coff_buf = NULL;
+	char sz_zl_file[COD_MAXPATHLENGTH];
+	struct nldr_object *nldr_obj = NULL;
+	struct dbll_attrs save_attrs;
+	struct dbll_attrs new_attrs;
+	dbll_flags flags;
+	u32 ul_entry;
+	u16 dload_segs = 0;
+	struct mem_seg_info *mem_info_obj;
+	u32 ul_len = 0;
+	u32 ul_addr;
+	struct rmm_segment *rmm_segs = NULL;
 	u16 i;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(phNldr != NULL);
-	DBC_Require(hDevObject != NULL);
-	DBC_Require(pAttrs != NULL);
-	DBC_Require(pAttrs->pfnOvly != NULL);
-	DBC_Require(pAttrs->pfnWrite != NULL);
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phNldr != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
+	DBC_REQUIRE(pattrs != NULL);
+	DBC_REQUIRE(pattrs->pfn_ovly != NULL);
+	DBC_REQUIRE(pattrs->pfn_write != NULL);
 
 	/* Allocate dynamic loader object */
-	MEM_AllocObject(pNldr, struct NLDR_OBJECT, NLDR_SIGNATURE);
-	if (pNldr) {
-		pNldr->hDevObject = hDevObject;
-		status = DEV_GetCodMgr(hDevObject, &hCodMgr);
-		if (hCodMgr) {
-			COD_GetLoader(hCodMgr, &pNldr->dbll);
-			COD_GetBaseLib(hCodMgr, &pNldr->baseLib);
-			COD_GetBaseName(hCodMgr, szZLFile, COD_MAXPATHLENGTH);
+	MEM_ALLOC_OBJECT(nldr_obj, struct nldr_object, NLDR_SIGNATURE);
+	if (nldr_obj) {
+		nldr_obj->hdev_obj = hdev_obj;
+		status = dev_get_cod_mgr(hdev_obj, &cod_mgr);
+		if (cod_mgr) {
+			cod_get_loader(cod_mgr, &nldr_obj->dbll);
+			cod_get_base_lib(cod_mgr, &nldr_obj->base_lib);
+			cod_get_base_name(cod_mgr, sz_zl_file,
+					  COD_MAXPATHLENGTH);
 		}
-		pNldr->usDSPMauSize = pAttrs->usDSPMauSize;
-		pNldr->usDSPWordSize = pAttrs->usDSPWordSize;
-		pNldr->dbllFxns = dbllFxns;
-		if (!(pNldr->dbllFxns.initFxn()))
+		nldr_obj->us_dsp_mau_size = pattrs->us_dsp_mau_size;
+		nldr_obj->us_dsp_word_size = pattrs->us_dsp_word_size;
+		nldr_obj->ldr_fxns = ldr_fxns;
+		if (!(nldr_obj->ldr_fxns.init_fxn()))
 			status = DSP_EMEMORY;
 
 	} else {
@@ -483,246 +483,266 @@ DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
 	}
 	/* Create the DCD Manager */
 	if (DSP_SUCCEEDED(status))
-		status = DCD_CreateManager(NULL, &pNldr->hDcdMgr);
+		status = dcd_create_manager(NULL, &nldr_obj->hdcd_mgr);
 
 	/* Get dynamic loading memory sections from base lib */
 	if (DSP_SUCCEEDED(status)) {
-		status = pNldr->dbllFxns.getSectFxn(pNldr->baseLib, DYNMEMSECT,
-			 &ulAddr, &ulLen);
+		status =
+		    nldr_obj->ldr_fxns.get_sect_fxn(nldr_obj->base_lib,
+						    DYNMEMSECT, &ul_addr,
+						    &ul_len);
 		if (DSP_SUCCEEDED(status)) {
-			pszCoffBuf = MEM_Calloc(ulLen * pNldr->usDSPMauSize,
-						MEM_PAGED);
-			if (!pszCoffBuf) {
+			psz_coff_buf =
+			    mem_calloc(ul_len * nldr_obj->us_dsp_mau_size,
+				       MEM_PAGED);
+			if (!psz_coff_buf) {
 				status = DSP_EMEMORY;
 			}
 		} else {
 			/* Ok to not have dynamic loading memory */
 			status = DSP_SOK;
-			ulLen = 0;
+			ul_len = 0;
 			dev_dbg(bridge, "%s: failed - no dynamic loading mem "
-					"segments: 0x%x\n", __func__, status);
+				"segments: 0x%x\n", __func__, status);
 		}
 	}
-	if (DSP_SUCCEEDED(status) && ulLen > 0) {
+	if (DSP_SUCCEEDED(status) && ul_len > 0) {
 		/* Read section containing dynamic load mem segments */
-		status = pNldr->dbllFxns.readSectFxn(pNldr->baseLib, DYNMEMSECT,
-						    pszCoffBuf, ulLen);
+		status =
+		    nldr_obj->ldr_fxns.read_sect_fxn(nldr_obj->base_lib,
+						     DYNMEMSECT, psz_coff_buf,
+						     ul_len);
 	}
-	if (DSP_SUCCEEDED(status) && ulLen > 0) {
+	if (DSP_SUCCEEDED(status) && ul_len > 0) {
 		/* Parse memory segment data */
-		nSegs = (u16)(*((u32 *)pszCoffBuf));
-		if (nSegs > MAXMEMSEGS)
+		dload_segs = (u16) (*((u32 *) psz_coff_buf));
+		if (dload_segs > MAXMEMSEGS)
 			status = DSP_ECORRUPTFILE;
 	}
 	/* Parse dynamic load memory segments */
-	if (DSP_SUCCEEDED(status) && nSegs > 0) {
-		rmmSegs = MEM_Calloc(sizeof(struct RMM_Segment) * nSegs,
-				    MEM_PAGED);
-		pNldr->segTable = MEM_Calloc(sizeof(u32) * nSegs, MEM_PAGED);
-		if (rmmSegs == NULL || pNldr->segTable == NULL) {
+	if (DSP_SUCCEEDED(status) && dload_segs > 0) {
+		rmm_segs = mem_calloc(sizeof(struct rmm_segment) * dload_segs,
+				      MEM_PAGED);
+		nldr_obj->seg_table =
+		    mem_calloc(sizeof(u32) * dload_segs, MEM_PAGED);
+		if (rmm_segs == NULL || nldr_obj->seg_table == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			pNldr->nSegs = nSegs;
-			pMemInfo = (struct MemInfo *)(pszCoffBuf +
-				   sizeof(u32));
-			for (i = 0; i < nSegs; i++) {
-				rmmSegs[i].base = (pMemInfo + i)->base;
-				rmmSegs[i].length = (pMemInfo + i)->len;
-				rmmSegs[i].space = 0;
-				pNldr->segTable[i] = (pMemInfo + i)->type;
-				dev_dbg(bridge, "(proc) DLL MEMSEGMENT: %d, "
+			nldr_obj->dload_segs = dload_segs;
+			mem_info_obj = (struct mem_seg_info *)(psz_coff_buf +
+							       sizeof(u32));
+			for (i = 0; i < dload_segs; i++) {
+				rmm_segs[i].base = (mem_info_obj + i)->base;
+				rmm_segs[i].length = (mem_info_obj + i)->len;
+				rmm_segs[i].space = 0;
+				nldr_obj->seg_table[i] =
+				    (mem_info_obj + i)->type;
+				dev_dbg(bridge,
+					"(proc) DLL MEMSEGMENT: %d, "
 					"Base: 0x%x, Length: 0x%x\n", i,
-					rmmSegs[i].base, rmmSegs[i].length);
+					rmm_segs[i].base, rmm_segs[i].length);
 			}
 		}
 	}
 	/* Create Remote memory manager */
 	if (DSP_SUCCEEDED(status))
-		status = RMM_create(&pNldr->rmm, rmmSegs, nSegs);
+		status = rmm_create(&nldr_obj->rmm, rmm_segs, dload_segs);
 
 	if (DSP_SUCCEEDED(status)) {
 		/* set the alloc, free, write functions for loader */
-		pNldr->dbllFxns.getAttrsFxn(pNldr->dbll, &saveAttrs);
-		newAttrs = saveAttrs;
-		newAttrs.alloc = (DBLL_AllocFxn) RemoteAlloc;
-		newAttrs.free = (DBLL_FreeFxn) RemoteFree;
-		newAttrs.symLookup = (DBLL_SymLookup) GetSymbolValue;
-		newAttrs.symHandle = pNldr;
-		newAttrs.write = (DBLL_WriteFxn) pAttrs->pfnWrite;
-		pNldr->ovlyFxn = pAttrs->pfnOvly;
-		pNldr->writeFxn = pAttrs->pfnWrite;
-		pNldr->dbllAttrs = newAttrs;
+		nldr_obj->ldr_fxns.get_attrs_fxn(nldr_obj->dbll, &save_attrs);
+		new_attrs = save_attrs;
+		new_attrs.alloc = (dbll_alloc_fxn) remote_alloc;
+		new_attrs.free = (dbll_free_fxn) remote_free;
+		new_attrs.sym_lookup = (dbll_sym_lookup) get_symbol_value;
+		new_attrs.sym_handle = nldr_obj;
+		new_attrs.write = (dbll_write_fxn) pattrs->pfn_write;
+		nldr_obj->ovly_fxn = pattrs->pfn_ovly;
+		nldr_obj->write_fxn = pattrs->pfn_write;
+		nldr_obj->ldr_attrs = new_attrs;
 	}
-	kfree(rmmSegs);
+	kfree(rmm_segs);
 
-	kfree(pszCoffBuf);
+	kfree(psz_coff_buf);
 
 	/* Get overlay nodes */
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_GetBaseName(hCodMgr, szZLFile, COD_MAXPATHLENGTH);
+		status =
+		    cod_get_base_name(cod_mgr, sz_zl_file, COD_MAXPATHLENGTH);
 		/* lazy check */
-		DBC_Assert(DSP_SUCCEEDED(status));
+		DBC_ASSERT(DSP_SUCCEEDED(status));
 		/* First count number of overlay nodes */
-		status = DCD_GetObjects(pNldr->hDcdMgr, szZLFile, AddOvlyNode,
-					(void *) pNldr);
+		status =
+		    dcd_get_objects(nldr_obj->hdcd_mgr, sz_zl_file,
+				    add_ovly_node, (void *)nldr_obj);
 		/* Now build table of overlay nodes */
-		if (DSP_SUCCEEDED(status) && pNldr->nOvlyNodes > 0) {
+		if (DSP_SUCCEEDED(status) && nldr_obj->ovly_nodes > 0) {
 			/* Allocate table for overlay nodes */
-			pNldr->ovlyTable =
-			MEM_Calloc(sizeof(struct OvlyNode) * pNldr->nOvlyNodes,
-				  MEM_PAGED);
+			nldr_obj->ovly_table =
+			    mem_calloc(sizeof(struct ovly_node) *
+				       nldr_obj->ovly_nodes, MEM_PAGED);
 			/* Put overlay nodes in the table */
-			pNldr->nNode = 0;
-			status = DCD_GetObjects(pNldr->hDcdMgr, szZLFile,
-						AddOvlyNode,
-						(void *) pNldr);
+			nldr_obj->ovly_nid = 0;
+			status = dcd_get_objects(nldr_obj->hdcd_mgr, sz_zl_file,
+						 add_ovly_node,
+						 (void *)nldr_obj);
 		}
 	}
 	/* Do a fake reload of the base image to get overlay section info */
-	if (DSP_SUCCEEDED(status) && pNldr->nOvlyNodes > 0) {
-		saveAttrs.write = fakeOvlyWrite;
-		saveAttrs.logWrite = AddOvlyInfo;
-		saveAttrs.logWriteHandle = pNldr;
+	if (DSP_SUCCEEDED(status) && nldr_obj->ovly_nodes > 0) {
+		save_attrs.write = fake_ovly_write;
+		save_attrs.log_write = add_ovly_info;
+		save_attrs.log_write_handle = nldr_obj;
 		flags = DBLL_CODE | DBLL_DATA | DBLL_SYMB;
-		status = pNldr->dbllFxns.loadFxn(pNldr->baseLib, flags,
-						&saveAttrs, &ulEntry);
+		status = nldr_obj->ldr_fxns.load_fxn(nldr_obj->base_lib, flags,
+						     &save_attrs, &ul_entry);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		*phNldr = (struct NLDR_OBJECT *) pNldr;
+		*phNldr = (struct nldr_object *)nldr_obj;
 	} else {
-		if (pNldr)
-			NLDR_Delete((struct NLDR_OBJECT *) pNldr);
+		if (nldr_obj)
+			nldr_delete((struct nldr_object *)nldr_obj);
 
 		*phNldr = NULL;
 	}
 	/* FIXME:Temp. Fix. Must be removed */
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-			 MEM_IsValidHandle(((struct NLDR_OBJECT *)*phNldr),
-					  NLDR_SIGNATURE))
-			|| (DSP_FAILED(status) && (*phNldr == NULL)));
+	DBC_ENSURE((DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE(((struct nldr_object *)*phNldr),
+					NLDR_SIGNATURE))
+		   || (DSP_FAILED(status) && (*phNldr == NULL)));
 	return status;
 }
 
 /*
- *  ======== NLDR_Delete ========
+ *  ======== nldr_delete ========
  */
-void NLDR_Delete(struct NLDR_OBJECT *hNldr)
+void nldr_delete(struct nldr_object *nldr_obj)
 {
-	struct OvlySect *pSect;
-	struct OvlySect *pNext;
+	struct ovly_sect *ovly_section;
+	struct ovly_sect *next;
 	u16 i;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
 
-	hNldr->dbllFxns.exitFxn();
-	if (hNldr->rmm)
-		RMM_delete(hNldr->rmm);
+	nldr_obj->ldr_fxns.exit_fxn();
+	if (nldr_obj->rmm)
+		rmm_delete(nldr_obj->rmm);
 
-	kfree(hNldr->segTable);
+	kfree(nldr_obj->seg_table);
 
-	if (hNldr->hDcdMgr)
-		DCD_DestroyManager(hNldr->hDcdMgr);
+	if (nldr_obj->hdcd_mgr)
+		dcd_destroy_manager(nldr_obj->hdcd_mgr);
 
 	/* Free overlay node information */
-	if (hNldr->ovlyTable) {
-		for (i = 0; i < hNldr->nOvlyNodes; i++) {
-			pSect = hNldr->ovlyTable[i].pCreateSects;
-			while (pSect) {
-				pNext = pSect->pNextSect;
-				kfree(pSect);
-				pSect = pNext;
+	if (nldr_obj->ovly_table) {
+		for (i = 0; i < nldr_obj->ovly_nodes; i++) {
+			ovly_section =
+			    nldr_obj->ovly_table[i].create_sects_list;
+			while (ovly_section) {
+				next = ovly_section->next_sect;
+				kfree(ovly_section);
+				ovly_section = next;
 			}
-			pSect = hNldr->ovlyTable[i].pDeleteSects;
-			while (pSect) {
-				pNext = pSect->pNextSect;
-				kfree(pSect);
-				pSect = pNext;
+			ovly_section =
+			    nldr_obj->ovly_table[i].delete_sects_list;
+			while (ovly_section) {
+				next = ovly_section->next_sect;
+				kfree(ovly_section);
+				ovly_section = next;
 			}
-			pSect = hNldr->ovlyTable[i].pExecuteSects;
-			while (pSect) {
-				pNext = pSect->pNextSect;
-				kfree(pSect);
-				pSect = pNext;
+			ovly_section =
+			    nldr_obj->ovly_table[i].execute_sects_list;
+			while (ovly_section) {
+				next = ovly_section->next_sect;
+				kfree(ovly_section);
+				ovly_section = next;
 			}
-			pSect = hNldr->ovlyTable[i].pOtherSects;
-			while (pSect) {
-				pNext = pSect->pNextSect;
-				kfree(pSect);
-				pSect = pNext;
+			ovly_section = nldr_obj->ovly_table[i].other_sects_list;
+			while (ovly_section) {
+				next = ovly_section->next_sect;
+				kfree(ovly_section);
+				ovly_section = next;
 			}
 		}
-		kfree(hNldr->ovlyTable);
+		kfree(nldr_obj->ovly_table);
 	}
-	MEM_FreeObject(hNldr);
-	DBC_Ensure(!MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+	MEM_FREE_OBJECT(nldr_obj);
+	DBC_ENSURE(!MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
 }
 
 /*
- *  ======== NLDR_Exit ========
+ *  ======== nldr_exit ========
  *  Discontinue usage of NLDR module.
  */
-void NLDR_Exit(void)
+void nldr_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	if (cRefs == 0)
-		RMM_exit();
+	if (refs == 0)
+		rmm_exit();
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== NLDR_GetFxnAddr ========
+ *  ======== nldr_get_fxn_addr ========
  */
-DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode, char *pstrFxn,
-			  u32 *pulAddr)
+dsp_status nldr_get_fxn_addr(struct nldr_nodeobject *nldr_node_obj,
+			     char *pstrFxn, u32 * pulAddr)
 {
-	struct DBLL_Symbol *pSym;
-	struct NLDR_OBJECT *hNldr;
-	DSP_STATUS status = DSP_SOK;
+	struct dbll_sym_val *dbll_sym;
+	struct nldr_object *nldr_obj;
+	dsp_status status = DSP_SOK;
 	bool status1 = false;
 	s32 i = 0;
-	struct LibNode root = { NULL, 0, NULL };
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
-	DBC_Require(pulAddr != NULL);
-	DBC_Require(pstrFxn != NULL);
-
-	hNldr = hNldrNode->pNldr;
-	/* Called from NODE_Create(), NODE_Delete(), or NODE_Run(). */
-	if (hNldrNode->fDynamic && *hNldrNode->pfPhaseSplit) {
-		switch (hNldrNode->phase) {
+	struct lib_node root = { NULL, 0, NULL };
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_node_obj, NLDR_NODESIGNATURE));
+	DBC_REQUIRE(pulAddr != NULL);
+	DBC_REQUIRE(pstrFxn != NULL);
+
+	nldr_obj = nldr_node_obj->nldr_obj;
+	/* Called from node_create(), node_delete(), or node_run(). */
+	if (nldr_node_obj->dynamic && *nldr_node_obj->pf_phase_split) {
+		switch (nldr_node_obj->phase) {
 		case NLDR_CREATE:
-			root = hNldrNode->createLib;
+			root = nldr_node_obj->create_lib;
 			break;
 		case NLDR_EXECUTE:
-			root = hNldrNode->executeLib;
+			root = nldr_node_obj->execute_lib;
 			break;
 		case NLDR_DELETE:
-			root = hNldrNode->deleteLib;
+			root = nldr_node_obj->delete_lib;
 			break;
 		default:
-			DBC_Assert(false);
+			DBC_ASSERT(false);
 			break;
 		}
 	} else {
 		/* for Overlay nodes or non-split Dynamic nodes */
-		root = hNldrNode->root;
+		root = nldr_node_obj->root;
 	}
-	status1 = hNldr->dbllFxns.getCAddrFxn(root.lib, pstrFxn, &pSym);
+	status1 =
+	    nldr_obj->ldr_fxns.get_c_addr_fxn(root.lib, pstrFxn, &dbll_sym);
 	if (!status1)
-		status1 = hNldr->dbllFxns.getAddrFxn(root.lib, pstrFxn, &pSym);
+		status1 =
+		    nldr_obj->ldr_fxns.get_addr_fxn(root.lib, pstrFxn,
+						    &dbll_sym);
 
 	/* If symbol not found, check dependent libraries */
 	if (!status1) {
-		for (i = 0; i < root.nDepLibs; i++) {
-			status1 = hNldr->dbllFxns.getAddrFxn(root.pDepLibs[i].
-					lib, pstrFxn, &pSym);
+		for (i = 0; i < root.dep_libs; i++) {
+			status1 =
+			    nldr_obj->ldr_fxns.get_addr_fxn(root.dep_libs_tree
+							    [i].lib, pstrFxn,
+							    &dbll_sym);
 			if (!status1) {
-				status1 = hNldr->dbllFxns.getCAddrFxn(root.
-					pDepLibs[i].lib, pstrFxn, &pSym);
+				status1 =
+				    nldr_obj->ldr_fxns.
+				    get_c_addr_fxn(root.dep_libs_tree[i].lib,
+						   pstrFxn, &dbll_sym);
 			}
 			if (status1) {
 				/* Symbol found */
@@ -732,13 +752,16 @@ DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode, char *pstrFxn,
 	}
 	/* Check persistent libraries */
 	if (!status1) {
-		for (i = 0; i < hNldrNode->nPersLib; i++) {
-			status1 = hNldr->dbllFxns.getAddrFxn(hNldrNode->
-					persLib[i].lib,	pstrFxn, &pSym);
+		for (i = 0; i < nldr_node_obj->pers_libs; i++) {
+			status1 =
+			    nldr_obj->ldr_fxns.
+			    get_addr_fxn(nldr_node_obj->pers_lib_table[i].lib,
+					 pstrFxn, &dbll_sym);
 			if (!status1) {
 				status1 =
-				    hNldr->dbllFxns.getCAddrFxn(hNldrNode->
-					persLib[i].lib,	pstrFxn, &pSym);
+				    nldr_obj->ldr_fxns.
+				    get_c_addr_fxn(nldr_node_obj->pers_lib_table
+						   [i].lib, pstrFxn, &dbll_sym);
 			}
 			if (status1) {
 				/* Symbol found */
@@ -748,7 +771,7 @@ DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode, char *pstrFxn,
 	}
 
 	if (status1)
-		*pulAddr = pSym->value;
+		*pulAddr = dbll_sym->value;
 	else
 		status = DSP_ESYMBOL;
 
@@ -756,97 +779,102 @@ DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode, char *pstrFxn,
 }
 
 /*
- *  ======== NLDR_GetRmmManager ========
+ *  ======== nldr_get_rmm_manager ========
  *  Given a NLDR object, retrieve RMM Manager Handle
  */
-DSP_STATUS NLDR_GetRmmManager(struct NLDR_OBJECT *hNldrObject,
-			     OUT struct RMM_TargetObj **phRmmMgr)
+dsp_status nldr_get_rmm_manager(struct nldr_object *hNldrObject,
+				OUT struct rmm_target_obj **phRmmMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct NLDR_OBJECT *pNldrObject = hNldrObject;
-	DBC_Require(phRmmMgr != NULL);
+	dsp_status status = DSP_SOK;
+	struct nldr_object *nldr_obj = hNldrObject;
+	DBC_REQUIRE(phRmmMgr != NULL);
 
-	if (MEM_IsValidHandle(hNldrObject, NLDR_SIGNATURE)) {
-		*phRmmMgr = pNldrObject->rmm;
+	if (MEM_IS_VALID_HANDLE(hNldrObject, NLDR_SIGNATURE)) {
+		*phRmmMgr = nldr_obj->rmm;
 	} else {
 		*phRmmMgr = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phRmmMgr != NULL) &&
-		  (*phRmmMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phRmmMgr != NULL) &&
+					     (*phRmmMgr == NULL)));
 
 	return status;
 }
 
 /*
- *  ======== NLDR_Init ========
+ *  ======== nldr_init ========
  *  Initialize the NLDR module.
  */
-bool NLDR_Init(void)
+bool nldr_init(void)
 {
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0)
-		RMM_init();
+	if (refs == 0)
+		rmm_init();
 
-	cRefs++;
+	refs++;
 
-	DBC_Ensure(cRefs > 0);
+	DBC_ENSURE(refs > 0);
 	return true;
 }
 
 /*
- *  ======== NLDR_Load ========
+ *  ======== nldr_load ========
  */
-DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+dsp_status nldr_load(struct nldr_nodeobject *nldr_node_obj,
+		     enum nldr_phase phase)
 {
-	struct NLDR_OBJECT *hNldr;
-	struct DSP_UUID libUUID;
-	DSP_STATUS status = DSP_SOK;
+	struct nldr_object *nldr_obj;
+	struct dsp_uuid lib_uuid;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_node_obj, NLDR_NODESIGNATURE));
 
-	hNldr = hNldrNode->pNldr;
+	nldr_obj = nldr_node_obj->nldr_obj;
 
-	if (hNldrNode->fDynamic) {
-		hNldrNode->phase = phase;
+	if (nldr_node_obj->dynamic) {
+		nldr_node_obj->phase = phase;
 
-		libUUID = hNldrNode->uuid;
+		lib_uuid = nldr_node_obj->uuid;
 
 		/* At this point, we may not know if node is split into
 		 * different libraries. So we'll go ahead and load the
 		 * library, and then save the pointer to the appropriate
 		 * location after we know. */
 
-		status = LoadLib(hNldrNode, &hNldrNode->root, libUUID, false,
-				hNldrNode->libPath, phase, 0);
+		status =
+		    load_lib(nldr_node_obj, &nldr_node_obj->root, lib_uuid,
+			     false, nldr_node_obj->lib_path, phase, 0);
 
 		if (DSP_SUCCEEDED(status)) {
-			if (*hNldrNode->pfPhaseSplit) {
+			if (*nldr_node_obj->pf_phase_split) {
 				switch (phase) {
 				case NLDR_CREATE:
-					hNldrNode->createLib = hNldrNode->root;
+					nldr_node_obj->create_lib =
+					    nldr_node_obj->root;
 					break;
 
 				case NLDR_EXECUTE:
-					hNldrNode->executeLib = hNldrNode->root;
+					nldr_node_obj->execute_lib =
+					    nldr_node_obj->root;
 					break;
 
 				case NLDR_DELETE:
-					hNldrNode->deleteLib = hNldrNode->root;
+					nldr_node_obj->delete_lib =
+					    nldr_node_obj->root;
 					break;
 
 				default:
-					DBC_Assert(false);
+					DBC_ASSERT(false);
 					break;
 				}
 			}
 		}
 	} else {
-		if (hNldrNode->fOverlay)
-			status = LoadOvly(hNldrNode, phase);
+		if (nldr_node_obj->overlay)
+			status = load_ovly(nldr_node_obj, phase);
 
 	}
 
@@ -854,50 +882,53 @@ DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
 }
 
 /*
- *  ======== NLDR_Unload ========
+ *  ======== nldr_unload ========
  */
-DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+dsp_status nldr_unload(struct nldr_nodeobject *nldr_node_obj,
+		       enum nldr_phase phase)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct LibNode *pRootLib = NULL;
+	dsp_status status = DSP_SOK;
+	struct lib_node *root_lib = NULL;
 	s32 i = 0;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_node_obj, NLDR_NODESIGNATURE));
 
-	if (hNldrNode != NULL) {
-		if (hNldrNode->fDynamic) {
-			if (*hNldrNode->pfPhaseSplit) {
+	if (nldr_node_obj != NULL) {
+		if (nldr_node_obj->dynamic) {
+			if (*nldr_node_obj->pf_phase_split) {
 				switch (phase) {
 				case NLDR_CREATE:
-					pRootLib = &hNldrNode->createLib;
+					root_lib = &nldr_node_obj->create_lib;
 					break;
 				case NLDR_EXECUTE:
-					pRootLib = &hNldrNode->executeLib;
+					root_lib = &nldr_node_obj->execute_lib;
 					break;
 				case NLDR_DELETE:
-					pRootLib = &hNldrNode->deleteLib;
+					root_lib = &nldr_node_obj->delete_lib;
 					/* Unload persistent libraries */
-					for (i = 0; i < hNldrNode->nPersLib;
-					    i++) {
-						UnloadLib(hNldrNode,
-							&hNldrNode->persLib[i]);
+					for (i = 0;
+					     i < nldr_node_obj->pers_libs;
+					     i++) {
+						unload_lib(nldr_node_obj,
+							   &nldr_node_obj->
+							   pers_lib_table[i]);
 					}
-					hNldrNode->nPersLib = 0;
+					nldr_node_obj->pers_libs = 0;
 					break;
 				default:
-					DBC_Assert(false);
+					DBC_ASSERT(false);
 					break;
 				}
 			} else {
 				/* Unload main library */
-				pRootLib = &hNldrNode->root;
+				root_lib = &nldr_node_obj->root;
 			}
-			if (pRootLib)
-				UnloadLib(hNldrNode, pRootLib);
+			if (root_lib)
+				unload_lib(nldr_node_obj, root_lib);
 		} else {
-			if (hNldrNode->fOverlay)
-				UnloadOvly(hNldrNode, phase);
+			if (nldr_node_obj->overlay)
+				unload_ovly(nldr_node_obj, phase);
 
 		}
 	}
@@ -905,72 +936,77 @@ DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
 }
 
 /*
- *  ======== AddOvlyInfo ========
+ *  ======== add_ovly_info ========
  */
-static DSP_STATUS AddOvlyInfo(void *handle, struct DBLL_SectInfo *sectInfo,
-			     u32 addr, u32 nBytes)
+static dsp_status add_ovly_info(void *handle, struct dbll_sect_info *sect_info,
+				u32 addr, u32 bytes)
 {
-	char *pNodeName;
-	char *pSectName = (char *)sectInfo->name;
-	bool fExists = false;
+	char *node_name;
+	char *sect_name = (char *)sect_info->name;
+	bool sect_exists = false;
 	char seps = ':';
 	char *pch;
 	u16 i;
-	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
-	DSP_STATUS status = DSP_SOK;
+	struct nldr_object *nldr_obj = (struct nldr_object *)handle;
+	dsp_status status = DSP_SOK;
 
 	/* Is this an overlay section (load address != run address)? */
-	if (sectInfo->loadAddr == sectInfo->runAddr)
+	if (sect_info->sect_load_addr == sect_info->sect_run_addr)
 		goto func_end;
 
 	/* Find the node it belongs to */
-	for (i = 0; i < hNldr->nOvlyNodes; i++) {
-		pNodeName = hNldr->ovlyTable[i].pNodeName;
-		DBC_Require(pNodeName);
-		if (strncmp(pNodeName, pSectName + 1,
-				strlen(pNodeName)) == 0) {
-				/* Found the node */
-				break;
+	for (i = 0; i < nldr_obj->ovly_nodes; i++) {
+		node_name = nldr_obj->ovly_table[i].node_name;
+		DBC_REQUIRE(node_name);
+		if (strncmp(node_name, sect_name + 1, strlen(node_name)) == 0) {
+			/* Found the node */
+			break;
 		}
 	}
-	if (!(i < hNldr->nOvlyNodes))
+	if (!(i < nldr_obj->ovly_nodes))
 		goto func_end;
 
 	/* Determine which phase this section belongs to */
-	for (pch = pSectName + 1; *pch && *pch != seps; pch++)
-		;
+	for (pch = sect_name + 1; *pch && *pch != seps; pch++) ;
 
 	if (*pch) {
-		pch++;	/* Skip over the ':' */
+		pch++;		/* Skip over the ':' */
 		if (strncmp(pch, PCREATE, strlen(PCREATE)) == 0) {
-			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
-				pCreateSects, sectInfo, &fExists, addr, nBytes);
-			if (DSP_SUCCEEDED(status) && !fExists)
-				hNldr->ovlyTable[i].nCreateSects++;
-
-		} else
-		if (strncmp(pch, PDELETE, strlen(PDELETE)) == 0) {
-			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
-					    pDeleteSects, sectInfo, &fExists,
-					    addr, nBytes);
-			if (DSP_SUCCEEDED(status) && !fExists)
-				hNldr->ovlyTable[i].nDeleteSects++;
-
-		} else
-		if (strncmp(pch, PEXECUTE, strlen(PEXECUTE)) == 0) {
-			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
-					    pExecuteSects, sectInfo, &fExists,
-					    addr, nBytes);
-			if (DSP_SUCCEEDED(status) && !fExists)
-				hNldr->ovlyTable[i].nExecuteSects++;
+			status =
+			    add_ovly_sect(nldr_obj,
+					  &nldr_obj->
+					  ovly_table[i].create_sects_list,
+					  sect_info, &sect_exists, addr, bytes);
+			if (DSP_SUCCEEDED(status) && !sect_exists)
+				nldr_obj->ovly_table[i].create_sects++;
+
+		} else if (strncmp(pch, PDELETE, strlen(PDELETE)) == 0) {
+			status =
+			    add_ovly_sect(nldr_obj,
+					  &nldr_obj->
+					  ovly_table[i].delete_sects_list,
+					  sect_info, &sect_exists, addr, bytes);
+			if (DSP_SUCCEEDED(status) && !sect_exists)
+				nldr_obj->ovly_table[i].delete_sects++;
+
+		} else if (strncmp(pch, PEXECUTE, strlen(PEXECUTE)) == 0) {
+			status =
+			    add_ovly_sect(nldr_obj,
+					  &nldr_obj->
+					  ovly_table[i].execute_sects_list,
+					  sect_info, &sect_exists, addr, bytes);
+			if (DSP_SUCCEEDED(status) && !sect_exists)
+				nldr_obj->ovly_table[i].execute_sects++;
 
 		} else {
 			/* Put in "other" sectins */
-			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
-					    pOtherSects, sectInfo, &fExists,
-					    addr, nBytes);
-			if (DSP_SUCCEEDED(status) && !fExists)
-				hNldr->ovlyTable[i].nOtherSects++;
+			status =
+			    add_ovly_sect(nldr_obj,
+					  &nldr_obj->
+					  ovly_table[i].other_sects_list,
+					  sect_info, &sect_exists, addr, bytes);
+			if (DSP_SUCCEEDED(status) && !sect_exists)
+				nldr_obj->ovly_table[i].other_sects++;
 
 		}
 	}
@@ -979,109 +1015,114 @@ func_end:
 }
 
 /*
- *  ======== AddOvlyNode =========
- *  Callback function passed to DCD_GetObjects.
+ *  ======== add_ovly_node =========
+ *  Callback function passed to dcd_get_objects.
  */
-static DSP_STATUS AddOvlyNode(struct DSP_UUID *pUuid,
-			     enum DSP_DCDOBJTYPE objType,
-			     IN void *handle)
+static dsp_status add_ovly_node(struct dsp_uuid *uuid_obj,
+				enum dsp_dcdobjtype obj_type, IN void *handle)
 {
-	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
-	char *pNodeName = NULL;
-	char *pBuf = NULL;
-	u32 uLen;
-	struct DCD_GENERICOBJ objDef;
-	DSP_STATUS status = DSP_SOK;
-
-	if (objType != DSP_DCDNODETYPE)
+	struct nldr_object *nldr_obj = (struct nldr_object *)handle;
+	char *node_name = NULL;
+	char *pbuf = NULL;
+	u32 len;
+	struct dcd_genericobj obj_def;
+	dsp_status status = DSP_SOK;
+
+	if (obj_type != DSP_DCDNODETYPE)
 		goto func_end;
 
-	status = DCD_GetObjectDef(hNldr->hDcdMgr, pUuid, objType, &objDef);
+	status =
+	    dcd_get_object_def(nldr_obj->hdcd_mgr, uuid_obj, obj_type,
+			       &obj_def);
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* If overlay node, add to the list */
-	if (objDef.objData.nodeObj.usLoadType == NLDR_OVLYLOAD) {
-		if (hNldr->ovlyTable == NULL) {
-			hNldr->nOvlyNodes++;
+	if (obj_def.obj_data.node_obj.us_load_type == NLDR_OVLYLOAD) {
+		if (nldr_obj->ovly_table == NULL) {
+			nldr_obj->ovly_nodes++;
 		} else {
 			/* Add node to table */
-			hNldr->ovlyTable[hNldr->nNode].uuid = *pUuid;
-			DBC_Require(objDef.objData.nodeObj.ndbProps.acName);
-			uLen = strlen(objDef.objData.nodeObj.ndbProps.acName);
-			pNodeName = objDef.objData.nodeObj.ndbProps.acName;
-			pBuf = MEM_Calloc(uLen + 1, MEM_PAGED);
-			if (pBuf == NULL) {
+			nldr_obj->ovly_table[nldr_obj->ovly_nid].uuid =
+			    *uuid_obj;
+			DBC_REQUIRE(obj_def.obj_data.node_obj.ndb_props.
+				    ac_name);
+			len =
+			    strlen(obj_def.obj_data.node_obj.ndb_props.ac_name);
+			node_name = obj_def.obj_data.node_obj.ndb_props.ac_name;
+			pbuf = mem_calloc(len + 1, MEM_PAGED);
+			if (pbuf == NULL) {
 				status = DSP_EMEMORY;
 			} else {
-				strncpy(pBuf, pNodeName, uLen);
-				hNldr->ovlyTable[hNldr->nNode].pNodeName = pBuf;
-				hNldr->nNode++;
+				strncpy(pbuf, node_name, len);
+				nldr_obj->ovly_table[nldr_obj->ovly_nid].
+				    node_name = pbuf;
+				nldr_obj->ovly_nid++;
 			}
 		}
 	}
-	/* These were allocated in DCD_GetObjectDef */
-	kfree(objDef.objData.nodeObj.pstrCreatePhaseFxn);
+	/* These were allocated in dcd_get_object_def */
+	kfree(obj_def.obj_data.node_obj.pstr_create_phase_fxn);
 
-	kfree(objDef.objData.nodeObj.pstrExecutePhaseFxn);
+	kfree(obj_def.obj_data.node_obj.pstr_execute_phase_fxn);
 
-	kfree(objDef.objData.nodeObj.pstrDeletePhaseFxn);
+	kfree(obj_def.obj_data.node_obj.pstr_delete_phase_fxn);
 
-	kfree(objDef.objData.nodeObj.pstrIAlgName);
+	kfree(obj_def.obj_data.node_obj.pstr_i_alg_name);
 
 func_end:
 	return status;
 }
 
 /*
- *  ======== AddOvlySect ========
+ *  ======== add_ovly_sect ========
  */
-static DSP_STATUS AddOvlySect(struct NLDR_OBJECT *hNldr,
-			      struct OvlySect **pList,
-			      struct DBLL_SectInfo *pSectInfo, bool *pExists,
-			      u32 addr, u32 nBytes)
+static dsp_status add_ovly_sect(struct nldr_object *nldr_obj,
+				struct ovly_sect **pList,
+				struct dbll_sect_info *pSectInfo,
+				bool *pExists, u32 addr, u32 bytes)
 {
-	struct OvlySect *pNewSect = NULL;
-	struct OvlySect *pLastSect;
-	struct OvlySect *pSect;
-	DSP_STATUS status = DSP_SOK;
+	struct ovly_sect *new_sect = NULL;
+	struct ovly_sect *last_sect;
+	struct ovly_sect *ovly_section;
+	dsp_status status = DSP_SOK;
 
-	pSect = pLastSect = *pList;
+	ovly_section = last_sect = *pList;
 	*pExists = false;
-	while (pSect) {
+	while (ovly_section) {
 		/*
 		 *  Make sure section has not already been added. Multiple
 		 *  'write' calls may be made to load the section.
 		 */
-		if (pSect->loadAddr == addr) {
+		if (ovly_section->sect_load_addr == addr) {
 			/* Already added */
 			*pExists = true;
 			break;
 		}
-		pLastSect = pSect;
-		pSect = pSect->pNextSect;
+		last_sect = ovly_section;
+		ovly_section = ovly_section->next_sect;
 	}
 
-	if (!pSect) {
+	if (!ovly_section) {
 		/* New section */
-		pNewSect = MEM_Calloc(sizeof(struct OvlySect), MEM_PAGED);
-		if (pNewSect == NULL) {
+		new_sect = mem_calloc(sizeof(struct ovly_sect), MEM_PAGED);
+		if (new_sect == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			pNewSect->loadAddr = addr;
-			pNewSect->runAddr = pSectInfo->runAddr +
-					    (addr - pSectInfo->loadAddr);
-			pNewSect->size = nBytes;
-			pNewSect->page = pSectInfo->type;
+			new_sect->sect_load_addr = addr;
+			new_sect->sect_run_addr = pSectInfo->sect_run_addr +
+			    (addr - pSectInfo->sect_load_addr);
+			new_sect->size = bytes;
+			new_sect->page = pSectInfo->type;
 		}
 
 		/* Add to the list */
 		if (DSP_SUCCEEDED(status)) {
 			if (*pList == NULL) {
 				/* First in the list */
-				*pList = pNewSect;
+				*pList = new_sect;
 			} else {
-				pLastSect->pNextSect = pNewSect;
+				last_sect->next_sect = new_sect;
 			}
 		}
 	}
@@ -1090,54 +1131,58 @@ static DSP_STATUS AddOvlySect(struct NLDR_OBJECT *hNldr,
 }
 
 /*
- *  ======== fakeOvlyWrite ========
+ *  ======== fake_ovly_write ========
  */
-static s32 fakeOvlyWrite(void *handle, u32 dspAddr, void *buf, u32 nBytes,
-			s32 mtype)
+static s32 fake_ovly_write(void *handle, u32 dspAddr, void *buf, u32 bytes,
+			   s32 mtype)
 {
-	return (s32)nBytes;
+	return (s32) bytes;
 }
 
 /*
- *  ======== FreeSects ========
+ *  ======== free_sects ========
  */
-static void FreeSects(struct NLDR_OBJECT *hNldr, struct OvlySect *pPhaseSects,
-		     u16 nAlloc)
+static void free_sects(struct nldr_object *nldr_obj,
+		       struct ovly_sect *phase_sects, u16 alloc_num)
 {
-	struct OvlySect *pSect = pPhaseSects;
+	struct ovly_sect *ovly_section = phase_sects;
 	u16 i = 0;
-	bool fRet;
+	bool ret;
 
-	while (pSect && i < nAlloc) {
+	while (ovly_section && i < alloc_num) {
 		/* 'Deallocate' */
 		/* segid - page not supported yet */
 		/* Reserved memory */
-		fRet = RMM_free(hNldr->rmm, 0, pSect->runAddr, pSect->size,
-				true);
-		DBC_Assert(fRet);
-		pSect = pSect->pNextSect;
+		ret =
+		    rmm_free(nldr_obj->rmm, 0, ovly_section->sect_run_addr,
+			     ovly_section->size, true);
+		DBC_ASSERT(ret);
+		ovly_section = ovly_section->next_sect;
 		i++;
 	}
 }
 
 /*
- *  ======== GetSymbolValue ========
+ *  ======== get_symbol_value ========
  *  Find symbol in library's base image.  If not there, check dependent
  *  libraries.
  */
-static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
-			  char *name, struct DBLL_Symbol **sym)
+static bool get_symbol_value(void *handle, void *parg, void *rmm_handle,
+			     char *name, struct dbll_sym_val **sym)
 {
-	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
-	struct NLDR_NODEOBJECT *hNldrNode = (struct NLDR_NODEOBJECT *)rmmHandle;
-	struct LibNode *root = (struct LibNode *)pArg;
+	struct nldr_object *nldr_obj = (struct nldr_object *)handle;
+	struct nldr_nodeobject *nldr_node_obj =
+	    (struct nldr_nodeobject *)rmm_handle;
+	struct lib_node *root = (struct lib_node *)parg;
 	u16 i;
 	bool status = false;
 
 	/* check the base image */
-	status = hNldr->dbllFxns.getAddrFxn(hNldr->baseLib, name, sym);
+	status = nldr_obj->ldr_fxns.get_addr_fxn(nldr_obj->base_lib, name, sym);
 	if (!status)
-		status = hNldr->dbllFxns.getCAddrFxn(hNldr->baseLib, name, sym);
+		status =
+		    nldr_obj->ldr_fxns.get_c_addr_fxn(nldr_obj->base_lib, name,
+						      sym);
 
 	/*
 	 *  Check in root lib itself. If the library consists of
@@ -1145,10 +1190,11 @@ static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
 	 *  library may need to be resolved.
 	 */
 	if (!status) {
-		status = hNldr->dbllFxns.getAddrFxn(root->lib, name, sym);
+		status = nldr_obj->ldr_fxns.get_addr_fxn(root->lib, name, sym);
 		if (!status) {
 			status =
-			    hNldr->dbllFxns.getCAddrFxn(root->lib, name, sym);
+			    nldr_obj->ldr_fxns.get_c_addr_fxn(root->lib, name,
+							      sym);
 		}
 	}
 
@@ -1157,12 +1203,15 @@ static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
 	 *  libraries' dependents.
 	 */
 	if (!status) {
-		for (i = 0; i < root->nDepLibs; i++) {
-			status = hNldr->dbllFxns.getAddrFxn(root->pDepLibs[i].
-							   lib, name, sym);
+		for (i = 0; i < root->dep_libs; i++) {
+			status =
+			    nldr_obj->ldr_fxns.get_addr_fxn(root->dep_libs_tree
+							    [i].lib, name, sym);
 			if (!status) {
-				status = hNldr->dbllFxns.getCAddrFxn(root->
-					 pDepLibs[i].lib, name, sym);
+				status =
+				    nldr_obj->ldr_fxns.
+				    get_c_addr_fxn(root->dep_libs_tree[i].lib,
+						   name, sym);
 			}
 			if (status) {
 				/* Symbol found */
@@ -1174,12 +1223,15 @@ static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
 	 * Check in persistent libraries
 	 */
 	if (!status) {
-		for (i = 0; i < hNldrNode->nPersLib; i++) {
-			status = hNldr->dbllFxns.getAddrFxn(hNldrNode->
-				 persLib[i].lib, name, sym);
+		for (i = 0; i < nldr_node_obj->pers_libs; i++) {
+			status =
+			    nldr_obj->ldr_fxns.
+			    get_addr_fxn(nldr_node_obj->pers_lib_table[i].lib,
+					 name, sym);
 			if (!status) {
-				status = hNldr->dbllFxns.getCAddrFxn
-					(hNldrNode->persLib[i].lib, name, sym);
+				status = nldr_obj->ldr_fxns.get_c_addr_fxn
+				    (nldr_node_obj->pers_lib_table[i].lib, name,
+				     sym);
 			}
 			if (status) {
 				/* Symbol found */
@@ -1192,75 +1244,82 @@ static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
 }
 
 /*
- *  ======== LoadLib ========
+ *  ======== load_lib ========
  *  Recursively load library and all its dependent libraries. The library
  *  we're loading is specified by a uuid.
  */
-static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
-			 struct LibNode *root, struct DSP_UUID uuid,
-			 bool rootPersistent, struct DBLL_LibraryObj **libPath,
-			 enum NLDR_PHASE phase, u16 depth)
+static dsp_status load_lib(struct nldr_nodeobject *nldr_node_obj,
+			   struct lib_node *root, struct dsp_uuid uuid,
+			   bool rootPersistent,
+			   struct dbll_library_obj **lib_path,
+			   enum nldr_phase phase, u16 depth)
 {
-	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
-	u16 nLibs = 0;	/* Number of dependent libraries */
-	u16 nPLibs = 0;	/* Number of persistent libraries */
-	u16 nLoaded = 0;	/* Number of dep. libraries loaded */
+	struct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;
+	u16 nd_libs = 0;	/* Number of dependent libraries */
+	u16 np_libs = 0;	/* Number of persistent libraries */
+	u16 nd_libs_loaded = 0;	/* Number of dep. libraries loaded */
 	u16 i;
 	u32 entry;
-	u32 dwBufSize = NLDR_MAXPATHLENGTH;
-	DBLL_Flags flags = DBLL_SYMB | DBLL_CODE | DBLL_DATA | DBLL_DYNAMIC;
-	struct DBLL_Attrs newAttrs;
-	char *pszFileName = NULL;
-	struct DSP_UUID *depLibUUIDs = NULL;
-	bool *persistentDepLibs = NULL;
-	DSP_STATUS status = DSP_SOK;
-	bool fStatus = false;
-	struct LibNode *pDepLib;
+	u32 dw_buf_size = NLDR_MAXPATHLENGTH;
+	dbll_flags flags = DBLL_SYMB | DBLL_CODE | DBLL_DATA | DBLL_DYNAMIC;
+	struct dbll_attrs new_attrs;
+	char *psz_file_name = NULL;
+	struct dsp_uuid *dep_lib_uui_ds = NULL;
+	bool *persistent_dep_libs = NULL;
+	dsp_status status = DSP_SOK;
+	bool lib_status = false;
+	struct lib_node *dep_lib;
 
 	if (depth > MAXDEPTH) {
 		/* Error */
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 	}
 	root->lib = NULL;
 	/* Allocate a buffer for library file name of size DBL_MAXPATHLENGTH */
-	pszFileName = MEM_Calloc(DBLL_MAXPATHLENGTH, MEM_PAGED);
-	if (pszFileName == NULL)
+	psz_file_name = mem_calloc(DBLL_MAXPATHLENGTH, MEM_PAGED);
+	if (psz_file_name == NULL)
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Get the name of the library */
 		if (depth == 0) {
-			status = DCD_GetLibraryName(hNldrNode->pNldr->hDcdMgr,
-				&uuid, pszFileName, &dwBufSize, phase,
-				hNldrNode->pfPhaseSplit);
+			status =
+			    dcd_get_library_name(nldr_node_obj->nldr_obj->
+						 hdcd_mgr, &uuid, psz_file_name,
+						 &dw_buf_size, phase,
+						 nldr_node_obj->pf_phase_split);
 		} else {
 			/* Dependent libraries are registered with a phase */
-			status = DCD_GetLibraryName(hNldrNode->pNldr->hDcdMgr,
-				&uuid, pszFileName, &dwBufSize, NLDR_NOPHASE,
-				NULL);
+			status =
+			    dcd_get_library_name(nldr_node_obj->nldr_obj->
+						 hdcd_mgr, &uuid, psz_file_name,
+						 &dw_buf_size, NLDR_NOPHASE,
+						 NULL);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Open the library, don't load symbols */
-		status = hNldr->dbllFxns.openFxn(hNldr->dbll, pszFileName,
-			 DBLL_NOLOAD, &root->lib);
+		status =
+		    nldr_obj->ldr_fxns.open_fxn(nldr_obj->dbll, psz_file_name,
+						DBLL_NOLOAD, &root->lib);
 	}
 	/* Done with file name */
-	kfree(pszFileName);
+	kfree(psz_file_name);
 
 	/* Check to see if library not already loaded */
 	if (DSP_SUCCEEDED(status) && rootPersistent) {
-		fStatus = findInPersistentLibArray(hNldrNode, root->lib);
+		lib_status =
+		    find_in_persistent_lib_array(nldr_node_obj, root->lib);
 		/* Close library */
-		if (fStatus) {
-			hNldr->dbllFxns.closeFxn(root->lib);
+		if (lib_status) {
+			nldr_obj->ldr_fxns.close_fxn(root->lib);
 			return DSP_SALREADYLOADED;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Check for circular dependencies. */
 		for (i = 0; i < depth; i++) {
-			if (root->lib == libPath[i]) {
+			if (root->lib == lib_path[i]) {
 				/* This condition could be checked by a
 				 * tool at build time. */
 				status = DSP_EDYNLOAD;
@@ -1269,43 +1328,47 @@ static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Add library to current path in dependency tree */
-		libPath[depth] = root->lib;
+		lib_path[depth] = root->lib;
 		depth++;
 		/* Get number of dependent libraries */
-		status = DCD_GetNumDepLibs(hNldrNode->pNldr->hDcdMgr, &uuid,
-					  &nLibs, &nPLibs, phase);
+		status =
+		    dcd_get_num_dep_libs(nldr_node_obj->nldr_obj->hdcd_mgr,
+					 &uuid, &nd_libs, &np_libs, phase);
 	}
-	DBC_Assert(nLibs >= nPLibs);
+	DBC_ASSERT(nd_libs >= np_libs);
 	if (DSP_SUCCEEDED(status)) {
-		if (!(*hNldrNode->pfPhaseSplit))
-			nPLibs = 0;
-
-		/* nLibs = #of dependent libraries */
-		root->nDepLibs = nLibs - nPLibs;
-		if (nLibs > 0) {
-			depLibUUIDs = MEM_Calloc(sizeof(struct DSP_UUID) *
-				      nLibs, MEM_PAGED);
-			persistentDepLibs =
-				MEM_Calloc(sizeof(bool) * nLibs, MEM_PAGED);
-			if (!depLibUUIDs || !persistentDepLibs)
+		if (!(*nldr_node_obj->pf_phase_split))
+			np_libs = 0;
+
+		/* nd_libs = #of dependent libraries */
+		root->dep_libs = nd_libs - np_libs;
+		if (nd_libs > 0) {
+			dep_lib_uui_ds = mem_calloc(sizeof(struct dsp_uuid) *
+						    nd_libs, MEM_PAGED);
+			persistent_dep_libs =
+			    mem_calloc(sizeof(bool) * nd_libs, MEM_PAGED);
+			if (!dep_lib_uui_ds || !persistent_dep_libs)
 				status = DSP_EMEMORY;
 
-			if (root->nDepLibs > 0) {
+			if (root->dep_libs > 0) {
 				/* Allocate arrays for dependent lib UUIDs,
 				 * lib nodes */
-				root->pDepLibs = MEM_Calloc
-					(sizeof(struct LibNode) *
-					(root->nDepLibs), MEM_PAGED);
-				if (!(root->pDepLibs))
+				root->dep_libs_tree = mem_calloc
+				    (sizeof(struct lib_node) *
+				     (root->dep_libs), MEM_PAGED);
+				if (!(root->dep_libs_tree))
 					status = DSP_EMEMORY;
 
 			}
 
 			if (DSP_SUCCEEDED(status)) {
 				/* Get the dependent library UUIDs */
-				status = DCD_GetDepLibs(hNldrNode->pNldr->
-					hDcdMgr, &uuid, nLibs, depLibUUIDs,
-					persistentDepLibs, phase);
+				status =
+				    dcd_get_dep_libs(nldr_node_obj->
+						     nldr_obj->hdcd_mgr, &uuid,
+						     nd_libs, dep_lib_uui_ds,
+						     persistent_dep_libs,
+						     phase);
 			}
 		}
 	}
@@ -1314,44 +1377,43 @@ static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
 	 *  Recursively load dependent libraries.
 	 */
 	if (DSP_SUCCEEDED(status)) {
-		for (i = 0; i < nLibs; i++) {
+		for (i = 0; i < nd_libs; i++) {
 			/* If root library is NOT persistent, and dep library
 			 * is, then record it.  If root library IS persistent,
 			 * the deplib is already included */
-			if (!rootPersistent && persistentDepLibs[i] &&
-			   *hNldrNode->pfPhaseSplit) {
-				if ((hNldrNode->nPersLib) > MAXLIBS) {
+			if (!rootPersistent && persistent_dep_libs[i] &&
+			    *nldr_node_obj->pf_phase_split) {
+				if ((nldr_node_obj->pers_libs) > MAXLIBS) {
 					status = DSP_EDYNLOAD;
 					break;
 				}
 
 				/* Allocate library outside of phase */
-				pDepLib = &hNldrNode->persLib[hNldrNode->
-					  nPersLib];
+				dep_lib =
+				    &nldr_node_obj->pers_lib_table
+				    [nldr_node_obj->pers_libs];
 			} else {
 				if (rootPersistent)
-					persistentDepLibs[i] = true;
-
+					persistent_dep_libs[i] = true;
 
 				/* Allocate library within phase */
-				pDepLib = &root->pDepLibs[nLoaded];
+				dep_lib = &root->dep_libs_tree[nd_libs_loaded];
 			}
 
-			status = LoadLib(hNldrNode, pDepLib,
-						depLibUUIDs[i],
-						persistentDepLibs[i], libPath,
-						phase,
-						depth);
+			status = load_lib(nldr_node_obj, dep_lib,
+					  dep_lib_uui_ds[i],
+					  persistent_dep_libs[i], lib_path,
+					  phase, depth);
 
 			if (DSP_SUCCEEDED(status)) {
 				if ((status != DSP_SALREADYLOADED) &&
-				   !rootPersistent && persistentDepLibs[i] &&
-				   *hNldrNode->pfPhaseSplit) {
-					(hNldrNode->nPersLib)++;
+				    !rootPersistent && persistent_dep_libs[i] &&
+				    *nldr_node_obj->pf_phase_split) {
+					(nldr_node_obj->pers_libs)++;
 				} else {
-					if (!persistentDepLibs[i] ||
-					   !(*hNldrNode->pfPhaseSplit)) {
-						nLoaded++;
+					if (!persistent_dep_libs[i] ||
+					    !(*nldr_node_obj->pf_phase_split)) {
+						nd_libs_loaded++;
 					}
 				}
 			} else {
@@ -1362,14 +1424,15 @@ static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
 
 	/* Now we can load the root library */
 	if (DSP_SUCCEEDED(status)) {
-		newAttrs = hNldr->dbllAttrs;
-		newAttrs.symArg = root;
-		newAttrs.rmmHandle = hNldrNode;
-		newAttrs.wHandle = hNldrNode->pPrivRef;
-		newAttrs.baseImage = false;
-
-		status = hNldr->dbllFxns.loadFxn(root->lib, flags, &newAttrs,
-			 &entry);
+		new_attrs = nldr_obj->ldr_attrs;
+		new_attrs.sym_arg = root;
+		new_attrs.rmm_handle = nldr_node_obj;
+		new_attrs.input_params = nldr_node_obj->priv_ref;
+		new_attrs.base_image = false;
+
+		status =
+		    nldr_obj->ldr_fxns.load_fxn(root->lib, flags, &new_attrs,
+						&entry);
 	}
 
 	/*
@@ -1379,168 +1442,185 @@ static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
 	 */
 	if (DSP_FAILED(status)) {
 		if (phase != NLDR_EXECUTE) {
-			for (i = 0; i < hNldrNode->nPersLib; i++)
-				UnloadLib(hNldrNode, &hNldrNode->persLib[i]);
+			for (i = 0; i < nldr_node_obj->pers_libs; i++)
+				unload_lib(nldr_node_obj,
+					   &nldr_node_obj->pers_lib_table[i]);
 
-			hNldrNode->nPersLib = 0;
+			nldr_node_obj->pers_libs = 0;
 		}
-		for (i = 0; i < nLoaded; i++)
-			UnloadLib(hNldrNode, &root->pDepLibs[i]);
+		for (i = 0; i < nd_libs_loaded; i++)
+			unload_lib(nldr_node_obj, &root->dep_libs_tree[i]);
 
 		if (root->lib)
-			hNldr->dbllFxns.closeFxn(root->lib);
+			nldr_obj->ldr_fxns.close_fxn(root->lib);
 
 	}
 
 	/* Going up one node in the dependency tree */
 	depth--;
 
-	kfree(depLibUUIDs);
-	depLibUUIDs = NULL;
+	kfree(dep_lib_uui_ds);
+	dep_lib_uui_ds = NULL;
 
-	kfree(persistentDepLibs);
-	persistentDepLibs = NULL;
+	kfree(persistent_dep_libs);
+	persistent_dep_libs = NULL;
 
 	return status;
 }
 
 /*
- *  ======== LoadOvly ========
+ *  ======== load_ovly ========
  */
-static DSP_STATUS LoadOvly(struct NLDR_NODEOBJECT *hNldrNode,
-			  enum NLDR_PHASE phase)
+static dsp_status load_ovly(struct nldr_nodeobject *nldr_node_obj,
+			    enum nldr_phase phase)
 {
-	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
-	struct OvlyNode *pONode = NULL;
-	struct OvlySect *pPhaseSects = NULL;
-	struct OvlySect *pOtherSects = NULL;
+	struct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;
+	struct ovly_node *po_node = NULL;
+	struct ovly_sect *phase_sects = NULL;
+	struct ovly_sect *other_sects_list = NULL;
 	u16 i;
-	u16 nAlloc = 0;
-	u16 nOtherAlloc = 0;
-	u16 *pRefCount = NULL;
-	u16 *pOtherRef = NULL;
-	u32 nBytes;
-	struct OvlySect *pSect;
-	DSP_STATUS status = DSP_SOK;
+	u16 alloc_num = 0;
+	u16 other_alloc = 0;
+	u16 *ref_count = NULL;
+	u16 *other_ref = NULL;
+	u32 bytes;
+	struct ovly_sect *ovly_section;
+	dsp_status status = DSP_SOK;
 
 	/* Find the node in the table */
-	for (i = 0; i < hNldr->nOvlyNodes; i++) {
-		if (IsEqualUUID(hNldrNode->uuid, hNldr->ovlyTable[i].uuid)) {
+	for (i = 0; i < nldr_obj->ovly_nodes; i++) {
+		if (IS_EQUAL_UUID
+		    (nldr_node_obj->uuid, nldr_obj->ovly_table[i].uuid)) {
 			/* Found it */
-			pONode = &(hNldr->ovlyTable[i]);
+			po_node = &(nldr_obj->ovly_table[i]);
 			break;
 		}
 	}
 
-	DBC_Assert(i < hNldr->nOvlyNodes);
+	DBC_ASSERT(i < nldr_obj->ovly_nodes);
 
-	if (!pONode) {
+	if (!po_node) {
 		status = DSP_ENOTFOUND;
 		goto func_end;
 	}
 
 	switch (phase) {
 	case NLDR_CREATE:
-		pRefCount = &(pONode->createRef);
-		pOtherRef = &(pONode->otherRef);
-		pPhaseSects = pONode->pCreateSects;
-		pOtherSects = pONode->pOtherSects;
+		ref_count = &(po_node->create_ref);
+		other_ref = &(po_node->other_ref);
+		phase_sects = po_node->create_sects_list;
+		other_sects_list = po_node->other_sects_list;
 		break;
 
 	case NLDR_EXECUTE:
-		pRefCount = &(pONode->executeRef);
-		pPhaseSects = pONode->pExecuteSects;
+		ref_count = &(po_node->execute_ref);
+		phase_sects = po_node->execute_sects_list;
 		break;
 
 	case NLDR_DELETE:
-		pRefCount = &(pONode->deleteRef);
-		pPhaseSects = pONode->pDeleteSects;
+		ref_count = &(po_node->delete_ref);
+		phase_sects = po_node->delete_sects_list;
 		break;
 
 	default:
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 		break;
 	}
 
-	if (pRefCount == NULL)
+	if (ref_count == NULL)
 		goto func_end;
 
-	if (*pRefCount != 0)
+	if (*ref_count != 0)
 		goto func_end;
 
 	/* 'Allocate' memory for overlay sections of this phase */
-	pSect = pPhaseSects;
-	while (pSect) {
-		/* allocate */ /* page not supported yet */
-		  /* reserve */ /* align */
-		status = RMM_alloc(hNldr->rmm, 0, pSect->size, 0,
-			 &(pSect->runAddr), true);
+	ovly_section = phase_sects;
+	while (ovly_section) {
+		/* allocate *//* page not supported yet */
+		/* reserve *//* align */
+		status = rmm_alloc(nldr_obj->rmm, 0, ovly_section->size, 0,
+				   &(ovly_section->sect_run_addr), true);
 		if (DSP_SUCCEEDED(status)) {
-			pSect = pSect->pNextSect;
-			nAlloc++;
+			ovly_section = ovly_section->next_sect;
+			alloc_num++;
 		} else {
 			break;
 		}
 	}
-	if (pOtherRef && *pOtherRef == 0) {
+	if (other_ref && *other_ref == 0) {
 		/* 'Allocate' memory for other overlay sections
 		 * (create phase) */
 		if (DSP_SUCCEEDED(status)) {
-			pSect = pOtherSects;
-			while (pSect) {
-				/* page not supported */ /* align */
+			ovly_section = other_sects_list;
+			while (ovly_section) {
+				/* page not supported *//* align */
 				/* reserve */
-				status = RMM_alloc(hNldr->rmm, 0, pSect->size,
-					 0, &(pSect->runAddr), true);
+				status =
+				    rmm_alloc(nldr_obj->rmm, 0,
+					      ovly_section->size, 0,
+					      &(ovly_section->sect_run_addr),
+					      true);
 				if (DSP_SUCCEEDED(status)) {
-					pSect = pSect->pNextSect;
-					nOtherAlloc++;
+					ovly_section = ovly_section->next_sect;
+					other_alloc++;
 				} else {
 					break;
 				}
 			}
 		}
 	}
-	if (*pRefCount == 0) {
+	if (*ref_count == 0) {
 		if (DSP_SUCCEEDED(status)) {
 			/* Load sections for this phase */
-			pSect = pPhaseSects;
-			while (pSect && DSP_SUCCEEDED(status)) {
-				nBytes = (*hNldr->ovlyFxn)(hNldrNode->pPrivRef,
-					 pSect->runAddr, pSect->loadAddr,
-					 pSect->size, pSect->page);
-				if (nBytes != pSect->size)
+			ovly_section = phase_sects;
+			while (ovly_section && DSP_SUCCEEDED(status)) {
+				bytes =
+				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
+							   priv_ref,
+							   ovly_section->
+							   sect_run_addr,
+							   ovly_section->
+							   sect_load_addr,
+							   ovly_section->size,
+							   ovly_section->page);
+				if (bytes != ovly_section->size)
 					status = DSP_EFAIL;
 
-				pSect = pSect->pNextSect;
+				ovly_section = ovly_section->next_sect;
 			}
 		}
 	}
-	if (pOtherRef && *pOtherRef == 0) {
+	if (other_ref && *other_ref == 0) {
 		if (DSP_SUCCEEDED(status)) {
 			/* Load other sections (create phase) */
-			pSect = pOtherSects;
-			while (pSect && DSP_SUCCEEDED(status)) {
-				nBytes = (*hNldr->ovlyFxn)(hNldrNode->pPrivRef,
-					 pSect->runAddr, pSect->loadAddr,
-					 pSect->size, pSect->page);
-				if (nBytes != pSect->size)
+			ovly_section = other_sects_list;
+			while (ovly_section && DSP_SUCCEEDED(status)) {
+				bytes =
+				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
+							   priv_ref,
+							   ovly_section->
+							   sect_run_addr,
+							   ovly_section->
+							   sect_load_addr,
+							   ovly_section->size,
+							   ovly_section->page);
+				if (bytes != ovly_section->size)
 					status = DSP_EFAIL;
 
-				pSect = pSect->pNextSect;
+				ovly_section = ovly_section->next_sect;
 			}
 		}
 	}
 	if (DSP_FAILED(status)) {
 		/* 'Deallocate' memory */
-		FreeSects(hNldr, pPhaseSects, nAlloc);
-		FreeSects(hNldr, pOtherSects, nOtherAlloc);
+		free_sects(nldr_obj, phase_sects, alloc_num);
+		free_sects(nldr_obj, other_sects_list, other_alloc);
 	}
 func_end:
-	if (DSP_SUCCEEDED(status) && (pRefCount != NULL)) {
-		*pRefCount += 1;
-		if (pOtherRef)
-			*pOtherRef += 1;
+	if (DSP_SUCCEEDED(status) && (ref_count != NULL)) {
+		*ref_count += 1;
+		if (other_ref)
+			*other_ref += 1;
 
 	}
 
@@ -1548,116 +1628,121 @@ func_end:
 }
 
 /*
- *  ======== RemoteAlloc ========
+ *  ======== remote_alloc ========
  */
-static DSP_STATUS RemoteAlloc(void **pRef, u16 space, u32 size,
-			     u32 align, u32 *dspAddr,
-			     OPTIONAL s32 segmentId, OPTIONAL s32 req,
-			     bool reserve)
+static dsp_status remote_alloc(void **pRef, u16 space, u32 size,
+			       u32 align, u32 *dspAddr,
+			       OPTIONAL s32 segmentId, OPTIONAL s32 req,
+			       bool reserve)
 {
-	struct NLDR_NODEOBJECT *hNode = (struct NLDR_NODEOBJECT *)pRef;
-	struct NLDR_OBJECT *hNldr;
-	struct RMM_TargetObj *rmm;
-	u16 memPhaseBit = MAXFLAGS;
+	struct nldr_nodeobject *hnode = (struct nldr_nodeobject *)pRef;
+	struct nldr_object *nldr_obj;
+	struct rmm_target_obj *rmm;
+	u16 mem_phase_bit = MAXFLAGS;
 	u16 segid = 0;
 	u16 i;
-	u16 memType;
-	u32 nWords;
-	struct RMM_Addr *pRmmAddr = (struct RMM_Addr *)dspAddr;
-	bool fReq = false;
-	DSP_STATUS status = DSP_EMEMORY;	/* Set to fail */
-	DBC_Require(MEM_IsValidHandle(hNode, NLDR_NODESIGNATURE));
-	DBC_Require(space == DBLL_CODE || space == DBLL_DATA ||
-		   space == DBLL_BSS);
-	hNldr = hNode->pNldr;
-	rmm = hNldr->rmm;
+	u16 mem_sect_type;
+	u32 word_size;
+	struct rmm_addr *rmm_addr_obj = (struct rmm_addr *)dspAddr;
+	bool mem_load_req = false;
+	dsp_status status = DSP_EMEMORY;	/* Set to fail */
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NLDR_NODESIGNATURE));
+	DBC_REQUIRE(space == DBLL_CODE || space == DBLL_DATA ||
+		    space == DBLL_BSS);
+	nldr_obj = hnode->nldr_obj;
+	rmm = nldr_obj->rmm;
 	/* Convert size to DSP words */
-	nWords = (size + hNldr->usDSPWordSize - 1) / hNldr->usDSPWordSize;
+	word_size =
+	    (size + nldr_obj->us_dsp_word_size -
+	     1) / nldr_obj->us_dsp_word_size;
 	/* Modify memory 'align' to account for DSP cache line size */
-	align = findLcm(GEM_CACHE_LINE_SIZE, align);
+	align = find_lcm(GEM_CACHE_LINE_SIZE, align);
 	dev_dbg(bridge, "%s: memory align to 0x%x\n", __func__, align);
 	if (segmentId != -1) {
-		pRmmAddr->segid = segmentId;
+		rmm_addr_obj->segid = segmentId;
 		segid = segmentId;
-		fReq = req;
+		mem_load_req = req;
 	} else {
-		switch (hNode->phase) {
+		switch (hnode->phase) {
 		case NLDR_CREATE:
-			memPhaseBit = CREATEDATAFLAGBIT;
+			mem_phase_bit = CREATEDATAFLAGBIT;
 			break;
 		case NLDR_DELETE:
-			memPhaseBit = DELETEDATAFLAGBIT;
+			mem_phase_bit = DELETEDATAFLAGBIT;
 			break;
 		case NLDR_EXECUTE:
-			memPhaseBit = EXECUTEDATAFLAGBIT;
+			mem_phase_bit = EXECUTEDATAFLAGBIT;
 			break;
 		default:
-			DBC_Assert(false);
+			DBC_ASSERT(false);
 			break;
 		}
 		if (space == DBLL_CODE)
-			memPhaseBit++;
+			mem_phase_bit++;
 
-		if (memPhaseBit < MAXFLAGS)
-			segid = hNode->segId[memPhaseBit];
+		if (mem_phase_bit < MAXFLAGS)
+			segid = hnode->seg_id[mem_phase_bit];
 
 		/* Determine if there is a memory loading requirement */
-		if ((hNode->codeDataFlagMask >> memPhaseBit) & 0x1)
-			fReq = true;
+		if ((hnode->code_data_flag_mask >> mem_phase_bit) & 0x1)
+			mem_load_req = true;
 
 	}
-	memType = (space == DBLL_CODE) ? DYNM_CODE : DYNM_DATA;
+	mem_sect_type = (space == DBLL_CODE) ? DYNM_CODE : DYNM_DATA;
 
 	/* Find an appropriate segment based on space */
 	if (segid == NULLID) {
 		/* No memory requirements of preferences */
-		DBC_Assert(!fReq);
+		DBC_ASSERT(!mem_load_req);
 		goto func_cont;
 	}
 	if (segid <= MAXSEGID) {
-		DBC_Assert(segid < hNldr->nSegs);
+		DBC_ASSERT(segid < nldr_obj->dload_segs);
 		/* Attempt to allocate from segid first. */
-		pRmmAddr->segid = segid;
-		status = RMM_alloc(rmm, segid, nWords, align, dspAddr, false);
+		rmm_addr_obj->segid = segid;
+		status =
+		    rmm_alloc(rmm, segid, word_size, align, dspAddr, false);
 		if (DSP_FAILED(status)) {
 			dev_dbg(bridge, "%s: Unable allocate from segment %d\n",
-							__func__, segid);
+				__func__, segid);
 		}
 	} else {
 		/* segid > MAXSEGID ==> Internal or external memory */
-		DBC_Assert(segid == MEMINTERNALID || segid == MEMEXTERNALID);
-		 /*  Check for any internal or external memory segment,
-		  *  depending on segid.*/
-		memType |= segid == MEMINTERNALID ?
-				 DYNM_INTERNAL : DYNM_EXTERNAL;
-		for (i = 0; i < hNldr->nSegs; i++) {
-			if ((hNldr->segTable[i] & memType) != memType)
+		DBC_ASSERT(segid == MEMINTERNALID || segid == MEMEXTERNALID);
+		/*  Check for any internal or external memory segment,
+		 *  depending on segid. */
+		mem_sect_type |= segid == MEMINTERNALID ?
+		    DYNM_INTERNAL : DYNM_EXTERNAL;
+		for (i = 0; i < nldr_obj->dload_segs; i++) {
+			if ((nldr_obj->seg_table[i] & mem_sect_type) !=
+			    mem_sect_type)
 				continue;
 
-			status = RMM_alloc(rmm, i, nWords, align, dspAddr,
+			status = rmm_alloc(rmm, i, word_size, align, dspAddr,
 					   false);
 			if (DSP_SUCCEEDED(status)) {
 				/* Save segid for freeing later */
-				pRmmAddr->segid = i;
+				rmm_addr_obj->segid = i;
 				break;
 			}
 		}
 	}
 func_cont:
 	/* Haven't found memory yet, attempt to find any segment that works */
-	if (status == DSP_EMEMORY && !fReq) {
+	if (status == DSP_EMEMORY && !mem_load_req) {
 		dev_dbg(bridge, "%s: Preferred segment unavailable, trying "
-							"another\n", __func__);
-		for (i = 0; i < hNldr->nSegs; i++) {
-			/* All bits of memType must be set */
-			if ((hNldr->segTable[i] & memType) != memType)
+			"another\n", __func__);
+		for (i = 0; i < nldr_obj->dload_segs; i++) {
+			/* All bits of mem_sect_type must be set */
+			if ((nldr_obj->seg_table[i] & mem_sect_type) !=
+			    mem_sect_type)
 				continue;
 
-			status = RMM_alloc(rmm, i, nWords, align, dspAddr,
-					  false);
+			status = rmm_alloc(rmm, i, word_size, align, dspAddr,
+					   false);
 			if (DSP_SUCCEEDED(status)) {
 				/* Save segid */
-				pRmmAddr->segid = i;
+				rmm_addr_obj->segid = i;
 				break;
 			}
 		}
@@ -1666,142 +1751,147 @@ func_cont:
 	return status;
 }
 
-static DSP_STATUS RemoteFree(void **pRef, u16 space, u32 dspAddr,
-				u32 size, bool reserve)
+static dsp_status remote_free(void **pRef, u16 space, u32 dspAddr,
+			      u32 size, bool reserve)
 {
-	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)pRef;
-	struct RMM_TargetObj *rmm;
-	u32 nWords;
-	DSP_STATUS status = DSP_EMEMORY;	/* Set to fail */
+	struct nldr_object *nldr_obj = (struct nldr_object *)pRef;
+	struct rmm_target_obj *rmm;
+	u32 word_size;
+	dsp_status status = DSP_EMEMORY;	/* Set to fail */
 
-	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
 
-	rmm = hNldr->rmm;
+	rmm = nldr_obj->rmm;
 
 	/* Convert size to DSP words */
-	nWords = (size + hNldr->usDSPWordSize - 1) / hNldr->usDSPWordSize;
+	word_size =
+	    (size + nldr_obj->us_dsp_word_size -
+	     1) / nldr_obj->us_dsp_word_size;
 
-	if (RMM_free(rmm, space, dspAddr, nWords, reserve))
+	if (rmm_free(rmm, space, dspAddr, word_size, reserve))
 		status = DSP_SOK;
 
 	return status;
 }
 
 /*
- *  ======== UnloadLib ========
+ *  ======== unload_lib ========
  */
-static void UnloadLib(struct NLDR_NODEOBJECT *hNldrNode, struct LibNode *root)
+static void unload_lib(struct nldr_nodeobject *nldr_node_obj,
+		       struct lib_node *root)
 {
-	struct DBLL_Attrs newAttrs;
-	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
+	struct dbll_attrs new_attrs;
+	struct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;
 	u16 i;
 
-	DBC_Assert(root != NULL);
+	DBC_ASSERT(root != NULL);
 
 	/* Unload dependent libraries */
-	for (i = 0; i < root->nDepLibs; i++)
-		UnloadLib(hNldrNode, &root->pDepLibs[i]);
+	for (i = 0; i < root->dep_libs; i++)
+		unload_lib(nldr_node_obj, &root->dep_libs_tree[i]);
 
-	root->nDepLibs = 0;
+	root->dep_libs = 0;
 
-	newAttrs = hNldr->dbllAttrs;
-	newAttrs.rmmHandle = hNldr->rmm;
-	newAttrs.wHandle = hNldrNode->pPrivRef;
-	newAttrs.baseImage = false;
-	newAttrs.symArg = root;
+	new_attrs = nldr_obj->ldr_attrs;
+	new_attrs.rmm_handle = nldr_obj->rmm;
+	new_attrs.input_params = nldr_node_obj->priv_ref;
+	new_attrs.base_image = false;
+	new_attrs.sym_arg = root;
 
 	if (root->lib) {
 		/* Unload the root library */
-		hNldr->dbllFxns.unloadFxn(root->lib, &newAttrs);
-		hNldr->dbllFxns.closeFxn(root->lib);
+		nldr_obj->ldr_fxns.unload_fxn(root->lib, &new_attrs);
+		nldr_obj->ldr_fxns.close_fxn(root->lib);
 	}
 
 	/* Free dependent library list */
-	kfree(root->pDepLibs);
-	root->pDepLibs = NULL;
+	kfree(root->dep_libs_tree);
+	root->dep_libs_tree = NULL;
 }
 
 /*
- *  ======== UnloadOvly ========
+ *  ======== unload_ovly ========
  */
-static void UnloadOvly(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+static void unload_ovly(struct nldr_nodeobject *nldr_node_obj,
+			enum nldr_phase phase)
 {
-	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
-	struct OvlyNode *pONode = NULL;
-	struct OvlySect *pPhaseSects = NULL;
-	struct OvlySect *pOtherSects = NULL;
+	struct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;
+	struct ovly_node *po_node = NULL;
+	struct ovly_sect *phase_sects = NULL;
+	struct ovly_sect *other_sects_list = NULL;
 	u16 i;
-	u16 nAlloc = 0;
-	u16 nOtherAlloc = 0;
-	u16 *pRefCount = NULL;
-	u16 *pOtherRef = NULL;
+	u16 alloc_num = 0;
+	u16 other_alloc = 0;
+	u16 *ref_count = NULL;
+	u16 *other_ref = NULL;
 
 	/* Find the node in the table */
-	for (i = 0; i < hNldr->nOvlyNodes; i++) {
-		if (IsEqualUUID(hNldrNode->uuid, hNldr->ovlyTable[i].uuid)) {
+	for (i = 0; i < nldr_obj->ovly_nodes; i++) {
+		if (IS_EQUAL_UUID
+		    (nldr_node_obj->uuid, nldr_obj->ovly_table[i].uuid)) {
 			/* Found it */
-			pONode = &(hNldr->ovlyTable[i]);
+			po_node = &(nldr_obj->ovly_table[i]);
 			break;
 		}
 	}
 
-	DBC_Assert(i < hNldr->nOvlyNodes);
+	DBC_ASSERT(i < nldr_obj->ovly_nodes);
 
-	if (!pONode)
+	if (!po_node)
 		/* TODO: Should we print warning here? */
 		return;
 
 	switch (phase) {
 	case NLDR_CREATE:
-		pRefCount = &(pONode->createRef);
-		pPhaseSects = pONode->pCreateSects;
-		nAlloc = pONode->nCreateSects;
+		ref_count = &(po_node->create_ref);
+		phase_sects = po_node->create_sects_list;
+		alloc_num = po_node->create_sects;
 		break;
 	case NLDR_EXECUTE:
-		pRefCount = &(pONode->executeRef);
-		pPhaseSects = pONode->pExecuteSects;
-		nAlloc = pONode->nExecuteSects;
+		ref_count = &(po_node->execute_ref);
+		phase_sects = po_node->execute_sects_list;
+		alloc_num = po_node->execute_sects;
 		break;
 	case NLDR_DELETE:
-		pRefCount = &(pONode->deleteRef);
-		pOtherRef = &(pONode->otherRef);
-		pPhaseSects = pONode->pDeleteSects;
+		ref_count = &(po_node->delete_ref);
+		other_ref = &(po_node->other_ref);
+		phase_sects = po_node->delete_sects_list;
 		/* 'Other' overlay sections are unloaded in the delete phase */
-		pOtherSects = pONode->pOtherSects;
-		nAlloc = pONode->nDeleteSects;
-		nOtherAlloc = pONode->nOtherSects;
+		other_sects_list = po_node->other_sects_list;
+		alloc_num = po_node->delete_sects;
+		other_alloc = po_node->other_sects;
 		break;
 	default:
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 		break;
 	}
-	DBC_Assert(pRefCount && (*pRefCount > 0));
-	 if (pRefCount && (*pRefCount > 0)) {
-		*pRefCount -= 1;
-		if (pOtherRef) {
-			DBC_Assert(*pOtherRef > 0);
-			*pOtherRef -= 1;
+	DBC_ASSERT(ref_count && (*ref_count > 0));
+	if (ref_count && (*ref_count > 0)) {
+		*ref_count -= 1;
+		if (other_ref) {
+			DBC_ASSERT(*other_ref > 0);
+			*other_ref -= 1;
 		}
 	}
 
-	if (pRefCount && *pRefCount == 0) {
+	if (ref_count && *ref_count == 0) {
 		/* 'Deallocate' memory */
-		FreeSects(hNldr, pPhaseSects, nAlloc);
+		free_sects(nldr_obj, phase_sects, alloc_num);
 	}
-	if (pOtherRef && *pOtherRef == 0)
-		FreeSects(hNldr, pOtherSects, nOtherAlloc);
+	if (other_ref && *other_ref == 0)
+		free_sects(nldr_obj, other_sects_list, other_alloc);
 }
 
 /*
- *  ======== findInPersistentLibArray ========
+ *  ======== find_in_persistent_lib_array ========
  */
-static bool findInPersistentLibArray(struct NLDR_NODEOBJECT *hNldrNode,
-				    struct DBLL_LibraryObj *lib)
+static bool find_in_persistent_lib_array(struct nldr_nodeobject *nldr_node_obj,
+					 struct dbll_library_obj *lib)
 {
 	s32 i = 0;
 
-	for (i = 0; i < hNldrNode->nPersLib; i++) {
-		if (lib == hNldrNode->persLib[i].lib)
+	for (i = 0; i < nldr_node_obj->pers_libs; i++) {
+		if (lib == nldr_node_obj->pers_lib_table[i].lib)
 			return true;
 
 	}
@@ -1812,19 +1902,19 @@ static bool findInPersistentLibArray(struct NLDR_NODEOBJECT *hNldrNode,
 /*
  * ================ Find LCM (Least Common Multiplier ===
  */
-static u32 findLcm(u32 a, u32 b)
+static u32 find_lcm(u32 a, u32 b)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = a * b / findGcf(a, b);
+	ret = a * b / find_gcf(a, b);
 
-	return retVal;
+	return ret;
 }
 
 /*
  * ================ Find GCF (Greatest Common Factor ) ===
  */
-static u32 findGcf(u32 a, u32 b)
+static u32 find_gcf(u32 a, u32 b)
 {
 	u32 c;
 
@@ -1836,4 +1926,3 @@ static u32 findGcf(u32 a, u32 b)
 	}
 	return b;
 }
-
diff --git a/drivers/dsp/bridge/rmgr/node.c b/drivers/dsp/bridge/rmgr/node.c
index ff1ee0e..b1bff58 100644
--- a/drivers/dsp/bridge/rmgr/node.c
+++ b/drivers/dsp/bridge/rmgr/node.c
@@ -67,19 +67,20 @@
 #include <dspbridge/drvdefs.h>
 #include <dspbridge/resourcecleanup.h>
 
-
 #define NODE_SIGNATURE      0x45444f4e	/* "EDON" */
 #define NODEMGR_SIGNATURE   0x52474d4e	/* "RGMN" */
 
 #define HOSTPREFIX	  "/host"
 #define PIPEPREFIX	  "/dbpipe"
 
-#define MaxInputs(h)  ((h)->dcdProps.objData.nodeObj.ndbProps.uNumInputStreams)
-#define MaxOutputs(h) ((h)->dcdProps.objData.nodeObj.ndbProps.uNumOutputStreams)
+#define MAX_INPUTS(h)  \
+		((h)->dcd_props.obj_data.node_obj.ndb_props.num_input_streams)
+#define MAX_OUTPUTS(h) \
+		((h)->dcd_props.obj_data.node_obj.ndb_props.num_output_streams)
 
-#define NODE_GetPriority(h) ((h)->nPriority)
-#define NODE_SetPriority(hNode, nPriority) ((hNode)->nPriority = nPriority)
-#define NODE_SetState(hNode, state) ((hNode)->nState = state)
+#define NODE_GET_PRIORITY(h) ((h)->prio)
+#define NODE_SET_PRIORITY(hnode, prio) ((hnode)->prio = prio)
+#define NODE_SET_STATE(hnode, state) ((hnode)->node_state = state)
 
 #define MAXPIPES	100	/* Max # of /pipe connections (CSL limit) */
 #define MAXDEVSUFFIXLEN 2	/* Max(Log base 10 of MAXPIPES, MAXSTREAMS) */
@@ -87,7 +88,7 @@
 #define PIPENAMELEN     (sizeof(PIPEPREFIX) + MAXDEVSUFFIXLEN)
 #define HOSTNAMELEN     (sizeof(HOSTPREFIX) + MAXDEVSUFFIXLEN)
 
-#define MAXDEVNAMELEN	32	/* DSP_NDBPROPS.acName size */
+#define MAXDEVNAMELEN	32	/* dsp_ndbprops.ac_name size */
 #define CREATEPHASE	1
 #define EXECUTEPHASE	2
 #define DELETEPHASE	3
@@ -118,232 +119,232 @@
 
 #define PWR_TIMEOUT		500	/* default PWR timeout in msec */
 
-#define STACKSEGLABEL "L1DSRAM_HEAP"  /* Label for DSP Stack Segment Address */
+#define STACKSEGLABEL "L1DSRAM_HEAP"	/* Label for DSP Stack Segment Addr */
 
 /*
- *  ======== NODE_MGR ========
+ *  ======== node_mgr ========
  */
-struct NODE_MGR {
-	u32 dwSignature;	/* For object validation */
-	struct DEV_OBJECT *hDevObject;	/* Device object */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
-	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
-	struct DISP_OBJECT *hDisp;	/* Node dispatcher */
-	struct LST_LIST *nodeList;	/* List of all allocated nodes */
-	u32 uNumNodes;		/* Number of nodes in nodeList */
-	u32 uNumCreated;	/* Number of nodes *created* on DSP */
-	struct GB_TMap *pipeMap;		/* Pipe connection bit map */
-	struct GB_TMap *pipeDoneMap;	/* Pipes that are half free */
-	struct GB_TMap *chnlMap;		/* Channel allocation bit map */
-	struct GB_TMap *dmaChnlMap;	/* DMA Channel allocation bit map */
-	struct GB_TMap *zChnlMap;	/* Zero-Copy Channel alloc bit map */
-	struct NTFY_OBJECT *hNtfy;	/* Manages registered notifications */
-	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
-	u32 ulFxnAddrs[NUMRMSFXNS];	/* RMS function addresses */
-	struct MSG_MGR *hMsg;
+struct node_mgr {
+	u32 dw_signature;	/* For object validation */
+	struct dev_object *hdev_obj;	/* Device object */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	struct dcd_manager *hdcd_mgr;	/* Proc/Node data manager */
+	struct disp_object *disp_obj;	/* Node dispatcher */
+	struct lst_list *node_list;	/* List of all allocated nodes */
+	u32 num_nodes;		/* Number of nodes in node_list */
+	u32 num_created;	/* Number of nodes *created* on DSP */
+	struct gb_t_map *pipe_map;	/* Pipe connection bit map */
+	struct gb_t_map *pipe_done_map;	/* Pipes that are half free */
+	struct gb_t_map *chnl_map;	/* Channel allocation bit map */
+	struct gb_t_map *dma_chnl_map;	/* DMA Channel allocation bit map */
+	struct gb_t_map *zc_chnl_map;	/* Zero-Copy Channel alloc bit map */
+	struct ntfy_object *ntfy_obj;	/* Manages registered notifications */
+	struct mutex node_mgr_lock;	/* For critical sections */
+	u32 ul_fxn_addrs[NUMRMSFXNS];	/* RMS function addresses */
+	struct msg_mgr *msg_mgr_obj;
 
 	/* Processor properties needed by Node Dispatcher */
-	u32 ulNumChnls;	/* Total number of channels */
-	u32 ulChnlOffset;	/* Offset of chnl ids rsvd for RMS */
-	u32 ulChnlBufSize;	/* Buffer size for data to RMS */
-	long procFamily;	/* eg, 5000 */
-	long procType;	/* eg, 5510 */
-	u32 uDSPWordSize;	/* Size of DSP word on host bytes */
-	u32 uDSPDataMauSize;	/* Size of DSP data MAU */
-	u32 uDSPMauSize;	/* Size of MAU */
-	s32 nMinPri;		/* Minimum runtime priority for node */
-	s32 nMaxPri;		/* Maximum runtime priority for node */
-
-	struct STRM_MGR *hStrmMgr;	/* STRM manager */
+	u32 ul_num_chnls;	/* Total number of channels */
+	u32 ul_chnl_offset;	/* Offset of chnl ids rsvd for RMS */
+	u32 ul_chnl_buf_size;	/* Buffer size for data to RMS */
+	int proc_family;	/* eg, 5000 */
+	int proc_type;		/* eg, 5510 */
+	u32 udsp_word_size;	/* Size of DSP word on host bytes */
+	u32 udsp_data_mau_size;	/* Size of DSP data MAU */
+	u32 udsp_mau_size;	/* Size of MAU */
+	s32 min_pri;		/* Minimum runtime priority for node */
+	s32 max_pri;		/* Maximum runtime priority for node */
+
+	struct strm_mgr *strm_mgr_obj;	/* STRM manager */
 
 	/* Loader properties */
-	struct NLDR_OBJECT *hNldr;	/* Handle to loader */
-	struct NLDR_FXNS nldrFxns;	/* Handle to loader functions */
-	bool fLoaderInit;	/* Loader Init function succeeded? */
+	struct nldr_object *nldr_obj;	/* Handle to loader */
+	struct node_ldr_fxns nldr_fxns;	/* Handle to loader functions */
+	bool loader_init;	/* Loader Init function succeeded? */
 };
 
 /*
- *  ======== CONNECTTYPE ========
+ *  ======== connecttype ========
  */
-enum CONNECTTYPE {
+enum connecttype {
 	NOTCONNECTED = 0,
 	NODECONNECT,
 	HOSTCONNECT,
 	DEVICECONNECT,
-} ;
+};
 
 /*
- *  ======== STREAM ========
+ *  ======== stream_chnl ========
  */
-struct STREAM {
-	enum CONNECTTYPE type;	/* Type of stream connection */
-	u32 devId;		/* pipe or channel id */
+struct stream_chnl {
+	enum connecttype type;	/* Type of stream connection */
+	u32 dev_id;		/* pipe or channel id */
 };
 
 /*
- *  ======== NODE_OBJECT ========
+ *  ======== node_object ========
  */
-struct NODE_OBJECT {
-	struct list_head listElem;
-	u32 dwSignature;	/* For object validation */
-	struct NODE_MGR *hNodeMgr;	/* The manager of this node */
-	struct PROC_OBJECT *hProcessor;	/* Back pointer to processor */
-	struct DSP_UUID nodeId;	/* Node's ID */
-	s32 nPriority;		/* Node's current priority */
-	u32 uTimeout;		/* Timeout for blocking NODE calls */
-	u32 uHeapSize;		/* Heap Size */
-	u32 uDSPHeapVirtAddr;	/* Heap Size */
-	u32 uGPPHeapVirtAddr;	/* Heap Size */
-	enum NODE_TYPE nType;	/* Type of node: message, task, etc */
-	enum NODE_STATE nState;	/* NODE_ALLOCATED, NODE_CREATED, ... */
-	u32 uNumInputs;	/* Current number of inputs */
-	u32 uNumOutputs;	/* Current number of outputs */
-	u32 uMaxInputIndex;	/* Current max input stream index */
-	u32 uMaxOutputIndex;	/* Current max output stream index */
-	struct STREAM *inputs;		/* Node's input streams */
-	struct STREAM *outputs;	/* Node's output streams */
-	struct NODE_CREATEARGS createArgs;  /* Args for node create function */
-	NODE_ENV nodeEnv;	/* Environment returned by RMS */
-	struct DCD_GENERICOBJ dcdProps;	/* Node properties from DCD */
-	struct DSP_CBDATA *pArgs;	/* Optional args to pass to node */
-	struct NTFY_OBJECT *hNtfy;	/* Manages registered notifications */
-	char *pstrDevName;	/* device name, if device node */
-	struct SYNC_OBJECT *hSyncDone;	/* Synchronize NODE_Terminate */
-	s32 nExitStatus;	/* execute function return status */
-
-	/* Information needed for NODE_GetAttr() */
-	void *hDeviceOwner;	/* If dev node, task that owns it */
-	u32 uNumGPPInputs;	/* Current # of from GPP streams */
-	u32 uNumGPPOutputs;	/* Current # of to GPP streams */
+struct node_object {
+	struct list_head list_elem;
+	u32 dw_signature;	/* For object validation */
+	struct node_mgr *hnode_mgr;	/* The manager of this node */
+	struct proc_object *hprocessor;	/* Back pointer to processor */
+	struct dsp_uuid node_uuid;	/* Node's ID */
+	s32 prio;		/* Node's current priority */
+	u32 utimeout;		/* Timeout for blocking NODE calls */
+	u32 heap_size;		/* Heap Size */
+	u32 udsp_heap_virt_addr;	/* Heap Size */
+	u32 ugpp_heap_virt_addr;	/* Heap Size */
+	enum node_type ntype;	/* Type of node: message, task, etc */
+	enum node_state node_state;	/* NODE_ALLOCATED, NODE_CREATED, ... */
+	u32 num_inputs;		/* Current number of inputs */
+	u32 num_outputs;	/* Current number of outputs */
+	u32 max_input_index;	/* Current max input stream index */
+	u32 max_output_index;	/* Current max output stream index */
+	struct stream_chnl *inputs;	/* Node's input streams */
+	struct stream_chnl *outputs;	/* Node's output streams */
+	struct node_createargs create_args;	/* Args for node create func */
+	nodeenv node_env;	/* Environment returned by RMS */
+	struct dcd_genericobj dcd_props;	/* Node properties from DCD */
+	struct dsp_cbdata *pargs;	/* Optional args to pass to node */
+	struct ntfy_object *ntfy_obj;	/* Manages registered notifications */
+	char *pstr_dev_name;	/* device name, if device node */
+	struct sync_object *sync_done;	/* Synchronize node_terminate */
+	s32 exit_status;	/* execute function return status */
+
+	/* Information needed for node_get_attr() */
+	void *device_owner;	/* If dev node, task that owns it */
+	u32 num_gpp_inputs;	/* Current # of from GPP streams */
+	u32 num_gpp_outputs;	/* Current # of to GPP streams */
 	/* Current stream connections */
-	struct DSP_STREAMCONNECT *streamConnect;
+	struct dsp_streamconnect *stream_connect;
 
 	/* Message queue */
-	struct MSG_QUEUE *hMsgQueue;
+	struct msg_queue *msg_queue_obj;
 
 	/* These fields used for SM messaging */
-	struct CMM_XLATOROBJECT *hXlator;   /* Node's SM address translator */
+	struct cmm_xlatorobject *xlator;	/* Node's SM addr translator */
 
 	/* Handle to pass to dynamic loader */
-	struct NLDR_NODEOBJECT *hNldrNode;
-	bool fLoaded;		/* Code is (dynamically) loaded */
-	bool fPhaseSplit;	/* Phases split in many libs or ovly */
+	struct nldr_nodeobject *nldr_node_obj;
+	bool loaded;		/* Code is (dynamically) loaded */
+	bool phase_split;	/* Phases split in many libs or ovly */
 
-} ;
+};
 
 /* Default buffer attributes */
-static struct DSP_BUFFERATTR NODE_DFLTBUFATTRS = {
-	0, 			/* cbStruct */
-	1, 			/* uSegment */
-	0, 			/* uAlignment */
+static struct dsp_bufferattr node_dfltbufattrs = {
+	0,			/* cb_struct */
+	1,			/* segment_id */
+	0,			/* buf_alignment */
 };
 
-static void DeleteNode(struct NODE_OBJECT *hNode,
-		struct PROCESS_CONTEXT *pr_ctxt);
-static void DeleteNodeMgr(struct NODE_MGR *hNodeMgr);
-static void FillStreamConnect(struct NODE_OBJECT *hNode1,
-			     struct NODE_OBJECT *hNode2, u32 uStream1,
-			     u32 uStream2);
-static void FillStreamDef(struct NODE_OBJECT *hNode,
-			struct NODE_STRMDEF *pstrmDef,
-			struct DSP_STRMATTR *pAttrs);
-static void FreeStream(struct NODE_MGR *hNodeMgr, struct STREAM stream);
-static DSP_STATUS GetFxnAddress(struct NODE_OBJECT *hNode, u32 *pulFxnAddr,
-				u32 uPhase);
-static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
-				struct NODE_OBJECT *hNode,
-				CONST struct DSP_UUID *pNodeId,
-				struct DCD_GENERICOBJ *pdcdProps);
-static DSP_STATUS GetProcProps(struct NODE_MGR *hNodeMgr,
-			      struct DEV_OBJECT *hDevObject);
-static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr);
-static u32 Ovly(void *pPrivRef, u32 ulDspRunAddr, u32 ulDspLoadAddr,
-			u32 ulNumBytes, u32 nMemSpace);
-static u32 Write(void *pPrivRef, u32 ulDspAddr, void *pBuf,
-			u32 ulNumBytes, u32 nMemSpace);
+static void delete_node(struct node_object *hnode,
+			struct process_context *pr_ctxt);
+static void delete_node_mgr(struct node_mgr *hnode_mgr);
+static void fill_stream_connect(struct node_object *hNode1,
+				struct node_object *hNode2, u32 uStream1,
+				u32 uStream2);
+static void fill_stream_def(struct node_object *hnode,
+			    struct node_strmdef *pstrm_def,
+			    struct dsp_strmattr *pattrs);
+static void free_stream(struct node_mgr *hnode_mgr, struct stream_chnl stream);
+static dsp_status get_fxn_address(struct node_object *hnode, u32 * pulFxnAddr,
+				  u32 uPhase);
+static dsp_status get_node_props(struct dcd_manager *hdcd_mgr,
+				 struct node_object *hnode,
+				 CONST struct dsp_uuid *pNodeId,
+				 struct dcd_genericobj *pdcdProps);
+static dsp_status get_proc_props(struct node_mgr *hnode_mgr,
+				 struct dev_object *hdev_obj);
+static dsp_status get_rms_fxns(struct node_mgr *hnode_mgr);
+static u32 ovly(void *priv_ref, u32 ulDspRunAddr, u32 ulDspLoadAddr,
+		u32 ul_num_bytes, u32 nMemSpace);
+static u32 mem_write(void *priv_ref, u32 ulDspAddr, void *pbuf,
+		     u32 ul_num_bytes, u32 nMemSpace);
 
 #ifdef DSP_DMM_DEBUG
-extern u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr);
+extern u32 dmm_mem_map_dump(struct dmm_object *dmm_mgr);
 #endif
 
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /* Dynamic loader functions. */
-static struct NLDR_FXNS nldrFxns = {
-	NLDR_Allocate,
-	NLDR_Create,
-	NLDR_Delete,
-	NLDR_Exit,
-	NLDR_GetFxnAddr,
-	NLDR_Init,
-	NLDR_Load,
-	NLDR_Unload,
+static struct node_ldr_fxns nldr_fxns = {
+	nldr_allocate,
+	nldr_create,
+	nldr_delete,
+	nldr_exit,
+	nldr_get_fxn_addr,
+	nldr_init,
+	nldr_load,
+	nldr_unload,
 };
 
-enum NODE_STATE NODE_GetState(HANDLE hNode)
+enum node_state node_get_state(bhandle hnode)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE))
-		return  -1;
+	struct node_object *pnode = (struct node_object *)hnode;
+	if (!MEM_IS_VALID_HANDLE(pnode, NODE_SIGNATURE))
+		return -1;
 	else
-		return pNode->nState;
+		return pnode->node_state;
 }
 
 /*
- *  ======== NODE_Allocate ========
+ *  ======== node_allocate ========
  *  Purpose:
  *      Allocate GPP resources to manage a node on the DSP.
  */
-DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
-			IN CONST struct DSP_UUID *pNodeId,
-			OPTIONAL IN CONST struct DSP_CBDATA *pArgs,
-			OPTIONAL IN CONST struct DSP_NODEATTRIN *pAttrIn,
-			OUT struct NODE_OBJECT **phNode,
-			struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status node_allocate(struct proc_object *hprocessor,
+			 IN CONST struct dsp_uuid *pNodeId,
+			 OPTIONAL IN CONST struct dsp_cbdata *pargs,
+			 OPTIONAL IN CONST struct dsp_nodeattrin *attr_in,
+			 OUT struct node_object **ph_node,
+			 struct process_context *pr_ctxt)
 {
-	struct NODE_MGR *hNodeMgr;
-	struct DEV_OBJECT *hDevObject;
-	struct NODE_OBJECT *pNode = NULL;
-	enum NODE_TYPE nodeType = NODE_TASK;
-	struct NODE_MSGARGS *pmsgArgs;
-	struct NODE_TASKARGS *ptaskArgs;
-	u32 uNumStreams;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_OBJECT *hCmmMgr = NULL; /* Shared memory manager hndl */
-	u32 procId;
-	u32 pulValue;
-	u32 dynextBase;
-	u32 offSet = 0;
-	u32 ulStackSegAddr, ulStackSegVal;
-	u32 ulGppMemBase;
-	struct CFG_HOSTRES hostRes;
-	u32 pMappedAddr = 0;
-	u32 mapAttrs = 0x0;
-	struct DSP_PROCESSORSTATE procStatus;
+	struct node_mgr *hnode_mgr;
+	struct dev_object *hdev_obj;
+	struct node_object *pnode = NULL;
+	enum node_type node_type = NODE_TASK;
+	struct node_msgargs *pmsg_args;
+	struct node_taskargs *ptask_args;
+	u32 num_streams;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
+	struct cmm_object *hcmm_mgr = NULL;	/* Shared memory manager hndl */
+	u32 proc_id;
+	u32 pul_value;
+	u32 dynext_base;
+	u32 off_set = 0;
+	u32 ul_stack_seg_addr, ul_stack_seg_val;
+	u32 ul_gpp_mem_base;
+	struct cfg_hostres host_res;
+	u32 mapped_addr = 0;
+	u32 map_attrs = 0x0;
+	struct dsp_processorstate proc_state;
 #ifdef DSP_DMM_DEBUG
-	struct DMM_OBJECT *hDmmMgr;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct dmm_object *dmm_mgr;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 #endif
 
-	HANDLE nodeRes;
+	bhandle node_res;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hProcessor != NULL);
-	DBC_Require(phNode != NULL);
-	DBC_Require(pNodeId != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hprocessor != NULL);
+	DBC_REQUIRE(ph_node != NULL);
+	DBC_REQUIRE(pNodeId != NULL);
 
-	*phNode = NULL;
+	*ph_node = NULL;
 
-	status = PROC_GetProcessorId(hProcessor, &procId);
+	status = proc_get_processor_id(hprocessor, &proc_id);
 
-	if (procId != DSP_UNIT)
+	if (proc_id != DSP_UNIT)
 		goto func_end;
 
-	status = PROC_GetDevObject(hProcessor, &hDevObject);
+	status = proc_get_dev_object(hprocessor, &hdev_obj);
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
-		if (hNodeMgr == NULL)
+		status = dev_get_node_manager(hdev_obj, &hnode_mgr);
+		if (hnode_mgr == NULL)
 			status = DSP_EFAIL;
 
 	}
@@ -351,28 +352,28 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	status = PROC_GetState(hProcessor, &procStatus,
-			sizeof(struct DSP_PROCESSORSTATE));
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt
-	    to send the message */
-	if (procStatus.iState == PROC_ERROR) {
+	   to send the message */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
 
 	/* Assuming that 0 is not a valid function address */
-	if (hNodeMgr->ulFxnAddrs[0] == 0) {
+	if (hnode_mgr->ul_fxn_addrs[0] == 0) {
 		/* No RMS on target - we currently can't handle this */
 		pr_err("%s: Failed, no RMS in base image\n", __func__);
 		status = DSP_EFAIL;
 	} else {
-		/* Validate pAttrIn fields, if non-NULL */
-		if (pAttrIn) {
-			/* Check if pAttrIn->iPriority is within range */
-			if (pAttrIn->iPriority < hNodeMgr->nMinPri ||
-			   pAttrIn->iPriority > hNodeMgr->nMaxPri)
+		/* Validate attr_in fields, if non-NULL */
+		if (attr_in) {
+			/* Check if attr_in->prio is within range */
+			if (attr_in->prio < hnode_mgr->min_pri ||
+			    attr_in->prio > hnode_mgr->max_pri)
 				status = DSP_ERANGE;
 		}
 	}
@@ -380,342 +381,365 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	MEM_AllocObject(pNode, struct NODE_OBJECT, NODE_SIGNATURE);
-	if (pNode == NULL) {
+	MEM_ALLOC_OBJECT(pnode, struct node_object, NODE_SIGNATURE);
+	if (pnode == NULL) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	pNode->hNodeMgr = hNodeMgr;
-	/* This critical section protects GetNodeProps */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	pnode->hnode_mgr = hnode_mgr;
+	/* This critical section protects get_node_props */
+	mutex_lock(&hnode_mgr->node_mgr_lock);
 
-	if (DSP_FAILED(status))
-		goto func_end;
-
-	/* Get DSP_NDBPROPS from node database */
-	status = GetNodeProps(hNodeMgr->hDcdMgr, pNode, pNodeId,
-			     &(pNode->dcdProps));
+	/* Get dsp_ndbprops from node database */
+	status = get_node_props(hnode_mgr->hdcd_mgr, pnode, pNodeId,
+				&(pnode->dcd_props));
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	pNode->nodeId = *pNodeId;
-	pNode->hProcessor = hProcessor;
-	pNode->nType = pNode->dcdProps.objData.nodeObj.ndbProps.uNodeType;
-	pNode->uTimeout = pNode->dcdProps.objData.nodeObj.ndbProps.uTimeout;
-	pNode->nPriority = pNode->dcdProps.objData.nodeObj.ndbProps.iPriority;
+	pnode->node_uuid = *pNodeId;
+	pnode->hprocessor = hprocessor;
+	pnode->ntype = pnode->dcd_props.obj_data.node_obj.ndb_props.ntype;
+	pnode->utimeout = pnode->dcd_props.obj_data.node_obj.ndb_props.utimeout;
+	pnode->prio = pnode->dcd_props.obj_data.node_obj.ndb_props.prio;
 
 	/* Currently only C64 DSP builds support Node Dynamic * heaps */
 	/* Allocate memory for node heap */
-	pNode->createArgs.asa.taskArgs.uHeapSize = 0;
-	pNode->createArgs.asa.taskArgs.uDSPHeapAddr = 0;
-	pNode->createArgs.asa.taskArgs.uDSPHeapResAddr = 0;
-	pNode->createArgs.asa.taskArgs.uGPPHeapAddr = 0;
-	if (!pAttrIn)
+	pnode->create_args.asa.task_arg_obj.heap_size = 0;
+	pnode->create_args.asa.task_arg_obj.udsp_heap_addr = 0;
+	pnode->create_args.asa.task_arg_obj.udsp_heap_res_addr = 0;
+	pnode->create_args.asa.task_arg_obj.ugpp_heap_addr = 0;
+	if (!attr_in)
 		goto func_cont;
 
 	/* Check if we have a user allocated node heap */
-	if (!(pAttrIn->pGPPVirtAddr))
+	if (!(attr_in->pgpp_virt_addr))
 		goto func_cont;
 
 	/* check for page aligned Heap size */
-	if (((pAttrIn->uHeapSize) & (PG_SIZE_4K - 1))) {
+	if (((attr_in->heap_size) & (PG_SIZE4K - 1))) {
 		pr_err("%s: node heap size not aligned to 4K, size = 0x%x \n",
-						__func__, pAttrIn->uHeapSize);
+		       __func__, attr_in->heap_size);
 		status = DSP_EINVALIDARG;
 	} else {
-		pNode->createArgs.asa.taskArgs.uHeapSize = pAttrIn->uHeapSize;
-		pNode->createArgs.asa.taskArgs.uGPPHeapAddr =
-						 (u32)pAttrIn->pGPPVirtAddr;
+		pnode->create_args.asa.task_arg_obj.heap_size =
+		    attr_in->heap_size;
+		pnode->create_args.asa.task_arg_obj.ugpp_heap_addr =
+		    (u32) attr_in->pgpp_virt_addr;
 	}
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	status = PROC_ReserveMemory(hProcessor,
-			pNode->createArgs.asa.taskArgs.uHeapSize + PAGE_SIZE,
-			(void **)&(pNode->createArgs.asa.taskArgs.
-				uDSPHeapResAddr), pr_ctxt);
+	status = proc_reserve_memory(hprocessor,
+				     pnode->create_args.asa.task_arg_obj.
+				     heap_size + PAGE_SIZE,
+				     (void **)&(pnode->create_args.asa.
+					task_arg_obj.udsp_heap_res_addr),
+				     pr_ctxt);
 	if (DSP_FAILED(status)) {
 		pr_err("%s: Failed to reserve memory for heap: 0x%x\n",
-							__func__, status);
+		       __func__, status);
 		goto func_cont;
 	}
 #ifdef DSP_DMM_DEBUG
-	status = DMM_GetHandle(pProcObject, &hDmmMgr);
+	status = dmm_get_handle(p_proc_object, &dmm_mgr);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	DMM_MemMapDump(hDmmMgr);
+	dmm_mem_map_dump(dmm_mgr);
 #endif
 
-	mapAttrs |= DSP_MAPLITTLEENDIAN;
-	mapAttrs |= DSP_MAPELEMSIZE32;
-	mapAttrs |= DSP_MAPVIRTUALADDR;
-	status = PROC_Map(hProcessor, (void *)pAttrIn->pGPPVirtAddr,
-			pNode->createArgs.asa.taskArgs.uHeapSize,
-			(void *)pNode->createArgs.asa.taskArgs.uDSPHeapResAddr,
-			(void **)&pMappedAddr, mapAttrs, pr_ctxt);
+	map_attrs |= DSP_MAPLITTLEENDIAN;
+	map_attrs |= DSP_MAPELEMSIZE32;
+	map_attrs |= DSP_MAPVIRTUALADDR;
+	status = proc_map(hprocessor, (void *)attr_in->pgpp_virt_addr,
+			  pnode->create_args.asa.task_arg_obj.heap_size,
+			  (void *)pnode->create_args.asa.task_arg_obj.
+			  udsp_heap_res_addr, (void **)&mapped_addr, map_attrs,
+			  pr_ctxt);
 	if (DSP_FAILED(status))
 		pr_err("%s: Failed to map memory for Heap: 0x%x\n",
-							__func__, status);
+		       __func__, status);
 	else
-		pNode->createArgs.asa.taskArgs.uDSPHeapAddr = (u32)pMappedAddr;
+		pnode->create_args.asa.task_arg_obj.udsp_heap_addr =
+		    (u32) mapped_addr;
 
 func_cont:
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
-	if (pAttrIn != NULL) {
+	mutex_unlock(&hnode_mgr->node_mgr_lock);
+	if (attr_in != NULL) {
 		/* Overrides of NBD properties */
-		pNode->uTimeout = pAttrIn->uTimeout;
-		pNode->nPriority = pAttrIn->iPriority;
+		pnode->utimeout = attr_in->utimeout;
+		pnode->prio = attr_in->prio;
 	}
 	/* Create object to manage notifications */
-	if (DSP_SUCCEEDED(status))
-		status = NTFY_Create(&pNode->hNtfy);
+	if (DSP_SUCCEEDED(status)) {
+		pnode->ntfy_obj = kmalloc(sizeof(struct ntfy_object),
+							GFP_KERNEL);
+		if (pnode->ntfy_obj)
+			ntfy_init(pnode->ntfy_obj);
+		else
+			status = DSP_EMEMORY;
+	}
 
 	if (DSP_SUCCEEDED(status)) {
-		nodeType = NODE_GetType(pNode);
-		 /*  Allocate DSP_STREAMCONNECT array for device, task, and
-		 *  dais socket nodes.  */
-		if (nodeType != NODE_MESSAGE) {
-			uNumStreams = MaxInputs(pNode) + MaxOutputs(pNode);
-			pNode->streamConnect = MEM_Calloc(uNumStreams *
-					sizeof(struct DSP_STREAMCONNECT),
+		node_type = node_get_type(pnode);
+		/*  Allocate dsp_streamconnect array for device, task, and
+		 *  dais socket nodes. */
+		if (node_type != NODE_MESSAGE) {
+			num_streams = MAX_INPUTS(pnode) + MAX_OUTPUTS(pnode);
+			pnode->stream_connect = mem_calloc(num_streams *
+					sizeof(struct dsp_streamconnect),
 					MEM_PAGED);
-			if (uNumStreams > 0 && pNode->streamConnect == NULL)
+			if (num_streams > 0 && pnode->stream_connect == NULL)
 				status = DSP_EMEMORY;
 
 		}
-		if (DSP_SUCCEEDED(status) && (nodeType == NODE_TASK ||
-		   nodeType == NODE_DAISSOCKET)) {
+		if (DSP_SUCCEEDED(status) && (node_type == NODE_TASK ||
+					      node_type == NODE_DAISSOCKET)) {
 			/* Allocate arrays for maintainig stream connections */
-			pNode->inputs =
-				MEM_Calloc(MaxInputs(pNode) *
-					sizeof(struct STREAM), MEM_PAGED);
-			pNode->outputs =
-				MEM_Calloc(MaxOutputs(pNode) *
-					sizeof(struct STREAM), MEM_PAGED);
-			ptaskArgs = &(pNode->createArgs.asa.taskArgs);
-			ptaskArgs->strmInDef =
-				MEM_Calloc(MaxInputs(pNode) *
-					sizeof(struct NODE_STRMDEF),
-					MEM_PAGED);
-			ptaskArgs->strmOutDef =
-					MEM_Calloc(MaxOutputs(pNode) *
-						sizeof(struct NODE_STRMDEF),
-						MEM_PAGED);
-			if ((MaxInputs(pNode) > 0 && (pNode->inputs == NULL ||
-			   ptaskArgs->strmInDef == NULL)) ||
-			   (MaxOutputs(pNode) > 0 && (pNode->outputs == NULL ||
-			   ptaskArgs->strmOutDef == NULL)))
+			pnode->inputs =
+			    mem_calloc(MAX_INPUTS(pnode) *
+				       sizeof(struct stream_chnl), MEM_PAGED);
+			pnode->outputs =
+			    mem_calloc(MAX_OUTPUTS(pnode) *
+				       sizeof(struct stream_chnl), MEM_PAGED);
+			ptask_args = &(pnode->create_args.asa.task_arg_obj);
+			ptask_args->strm_in_def =
+			    mem_calloc(MAX_INPUTS(pnode) *
+				       sizeof(struct node_strmdef), MEM_PAGED);
+			ptask_args->strm_out_def =
+			    mem_calloc(MAX_OUTPUTS(pnode) *
+				       sizeof(struct node_strmdef), MEM_PAGED);
+			if ((MAX_INPUTS(pnode) > 0 && (pnode->inputs == NULL ||
+						       ptask_args->strm_in_def
+						       == NULL))
+			    || (MAX_OUTPUTS(pnode) > 0
+				&& (pnode->outputs == NULL
+				    || ptask_args->strm_out_def == NULL)))
 				status = DSP_EMEMORY;
 		}
 	}
-	if (DSP_SUCCEEDED(status) && (nodeType != NODE_DEVICE)) {
+	if (DSP_SUCCEEDED(status) && (node_type != NODE_DEVICE)) {
 		/* Create an event that will be posted when RMS_EXIT is
 		 * received. */
-		status = SYNC_OpenEvent(&pNode->hSyncDone, NULL);
+		pnode->sync_done = kzalloc(sizeof(struct sync_object),
+								GFP_KERNEL);
+		if (pnode->sync_done)
+			sync_init_event(pnode->sync_done);
+		else
+			status = DSP_EMEMORY;
+
 		if (DSP_SUCCEEDED(status)) {
 			/*Get the shared mem mgr for this nodes dev object */
-			status = CMM_GetHandle(hProcessor, &hCmmMgr);
+			status = cmm_get_handle(hprocessor, &hcmm_mgr);
 			if (DSP_SUCCEEDED(status)) {
 				/* Allocate a SM addr translator for this node
 				 * w/ deflt attr */
-				status = CMM_XlatorCreate(&pNode->hXlator,
-					 hCmmMgr, NULL);
+				status = cmm_xlator_create(&pnode->xlator,
+							   hcmm_mgr, NULL);
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Fill in message args */
-			if ((pArgs != NULL) && (pArgs->cbData > 0)) {
-				pmsgArgs = &(pNode->createArgs.asa.msgArgs);
-				pmsgArgs->pData = MEM_Calloc(pArgs->cbData,
-							    MEM_PAGED);
-				if (pmsgArgs->pData == NULL) {
+			if ((pargs != NULL) && (pargs->cb_data > 0)) {
+				pmsg_args =
+				    &(pnode->create_args.asa.node_msg_args);
+				pmsg_args->pdata =
+				    mem_calloc(pargs->cb_data, MEM_PAGED);
+				if (pmsg_args->pdata == NULL) {
 					status = DSP_EMEMORY;
 				} else {
-					pmsgArgs->uArgLength = pArgs->cbData;
-					memcpy(pmsgArgs->pData, pArgs->cData,
-						pArgs->cbData);
+					pmsg_args->arg_length = pargs->cb_data;
+					memcpy(pmsg_args->pdata,
+					       pargs->node_data,
+					       pargs->cb_data);
 				}
 			}
 		}
 	}
 
-	if (DSP_SUCCEEDED(status) && nodeType != NODE_DEVICE) {
+	if (DSP_SUCCEEDED(status) && node_type != NODE_DEVICE) {
 		/* Create a message queue for this node */
-		pIntfFxns = hNodeMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnMsgCreateQueue)(hNodeMgr->hMsg,
-				&pNode->hMsgQueue, 0,
-				    pNode->createArgs.asa.msgArgs.uMaxMessages,
-				    pNode);
+		intf_fxns = hnode_mgr->intf_fxns;
+		status =
+		    (*intf_fxns->pfn_msg_create_queue) (hnode_mgr->msg_mgr_obj,
+							&pnode->msg_queue_obj,
+							0,
+							pnode->create_args.asa.
+							node_msg_args.max_msgs,
+							pnode);
 	}
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Create object for dynamic loading */
 
-		status = hNodeMgr->nldrFxns.pfnAllocate(hNodeMgr->hNldr,
-					     (void *) pNode,
-					     &pNode->dcdProps.objData.nodeObj,
-					     &pNode->hNldrNode,
-					     &pNode->fPhaseSplit);
+		status = hnode_mgr->nldr_fxns.pfn_allocate(hnode_mgr->nldr_obj,
+							   (void *)pnode,
+							   &pnode->dcd_props.
+							   obj_data.node_obj,
+							   &pnode->
+							   nldr_node_obj,
+							   &pnode->phase_split);
 	}
 
 	/* Compare value read from Node Properties and check if it is same as
 	 * STACKSEGLABEL, if yes read the Address of STACKSEGLABEL, calculate
 	 * GPP Address, Read the value in that address and override the
-	 * uStackSeg value in task args */
+	 * stack_seg value in task args */
 	if (DSP_SUCCEEDED(status) &&
-	   (char *)pNode->dcdProps.objData.nodeObj.ndbProps.uStackSegName !=
-	   NULL) {
+	    (char *)pnode->dcd_props.obj_data.node_obj.ndb_props.
+	    stack_seg_name != NULL) {
 		if (strcmp((char *)
-		    pNode->dcdProps.objData.nodeObj.ndbProps.uStackSegName,
-		    STACKSEGLABEL) == 0) {
-			status = hNodeMgr->nldrFxns.pfnGetFxnAddr(pNode->
-				 hNldrNode, "DYNEXT_BEG", &dynextBase);
+			   pnode->dcd_props.obj_data.node_obj.ndb_props.
+			   stack_seg_name, STACKSEGLABEL) == 0) {
+			status =
+			    hnode_mgr->nldr_fxns.
+			    pfn_get_fxn_addr(pnode->nldr_node_obj, "DYNEXT_BEG",
+					     &dynext_base);
 			if (DSP_FAILED(status))
 				pr_err("%s: Failed to get addr for DYNEXT_BEG"
-					" status = 0x%x\n", __func__, status);
+				       " status = 0x%x\n", __func__, status);
 
-			status = hNodeMgr->nldrFxns.pfnGetFxnAddr(pNode->
-				 hNldrNode, "L1DSRAM_HEAP", &pulValue);
+			status =
+			    hnode_mgr->nldr_fxns.
+			    pfn_get_fxn_addr(pnode->nldr_node_obj,
+					     "L1DSRAM_HEAP", &pul_value);
 
 			if (DSP_FAILED(status))
 				pr_err("%s: Failed to get addr for L1DSRAM_HEAP"
-					" status = 0x%x\n", __func__, status);
+				       " status = 0x%x\n", __func__, status);
 
-			status = CFG_GetHostResources((struct CFG_DEVNODE *)
-				 DRV_GetFirstDevExtension(), &hostRes);
+			status = cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&host_res);
 
 			if (DSP_FAILED(status)) {
 				pr_err("%s: Failed to get host resource, status"
-						" = 0x%x\n", __func__, status);
+				       " = 0x%x\n", __func__, status);
 				goto func_end;
 			}
 
-			ulGppMemBase = (u32)hostRes.dwMemBase[1];
-			offSet = pulValue - dynextBase;
-			ulStackSegAddr = ulGppMemBase + offSet;
-			ulStackSegVal = (u32)*((REG_UWORD32 *)
-					((u32)(ulStackSegAddr)));
+			ul_gpp_mem_base = (u32) host_res.dw_mem_base[1];
+			off_set = pul_value - dynext_base;
+			ul_stack_seg_addr = ul_gpp_mem_base + off_set;
+			ul_stack_seg_val = (u32) *((reg_uword32 *)
+						    ((u32)
+						     (ul_stack_seg_addr)));
 
 			dev_dbg(bridge, "%s: StackSegVal = 0x%x, StackSegAddr ="
-					" 0x%x\n", __func__, ulStackSegVal,
-					ulStackSegAddr);
+				" 0x%x\n", __func__, ul_stack_seg_val,
+				ul_stack_seg_addr);
 
-			pNode->createArgs.asa.taskArgs.uStackSeg =
-				ulStackSegVal;
+			pnode->create_args.asa.task_arg_obj.stack_seg =
+			    ul_stack_seg_val;
 
 		}
 	}
 
-
 	if (DSP_SUCCEEDED(status)) {
 		/* Add the node to the node manager's list of allocated
 		 * nodes. */
-		LST_InitElem((struct list_head *)pNode);
-		NODE_SetState(pNode, NODE_ALLOCATED);
+		lst_init_elem((struct list_head *)pnode);
+		NODE_SET_STATE(pnode, NODE_ALLOCATED);
 
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		mutex_lock(&hnode_mgr->node_mgr_lock);
 
-		if (DSP_SUCCEEDED(status)) {
-			LST_PutTail(hNodeMgr->nodeList,
-					(struct list_head *) pNode);
-			++(hNodeMgr->uNumNodes);
-		}
+		lst_put_tail(hnode_mgr->node_list, (struct list_head *) pnode);
+			++(hnode_mgr->num_nodes);
 
 		/* Exit critical section */
-		(void) SYNC_LeaveCS(hNodeMgr->hSync);
+		mutex_unlock(&hnode_mgr->node_mgr_lock);
 
 		/* Preset this to assume phases are split
 		 * (for overlay and dll) */
-		pNode->fPhaseSplit = true;
+		pnode->phase_split = true;
 
 		if (DSP_SUCCEEDED(status))
-			*phNode = pNode;
-
+			*ph_node = pnode;
 
 		/* Notify all clients registered for DSP_NODESTATECHANGE. */
-		PROC_NotifyAllClients(hProcessor, DSP_NODESTATECHANGE);
+		proc_notify_all_clients(hprocessor, DSP_NODESTATECHANGE);
 	} else {
 		/* Cleanup */
-		if (pNode)
-			DeleteNode(pNode, pr_ctxt);
+		if (pnode)
+			delete_node(pnode, pr_ctxt);
 
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		DRV_InsertNodeResElement(*phNode, &nodeRes, pr_ctxt);
-		DRV_ProcNodeUpdateHeapStatus(nodeRes, true);
-		DRV_ProcNodeUpdateStatus(nodeRes, true);
+		drv_insert_node_res_element(*ph_node, &node_res, pr_ctxt);
+		drv_proc_node_update_heap_status(node_res, true);
+		drv_proc_node_update_status(node_res, true);
 	}
-	DBC_Ensure((DSP_FAILED(status) && (*phNode == NULL)) ||
-		  (DSP_SUCCEEDED(status)
-		    && MEM_IsValidHandle((*phNode), NODE_SIGNATURE)));
+	DBC_ENSURE((DSP_FAILED(status) && (*ph_node == NULL)) ||
+		   (DSP_SUCCEEDED(status)
+		    && MEM_IS_VALID_HANDLE((*ph_node), NODE_SIGNATURE)));
 func_end:
-	dev_dbg(bridge, "%s: hProcessor: %p pNodeId: %p pArgs: %p pAttrIn: %p "
-			"phNode: %p status: 0x%x\n", __func__, hProcessor,
-			pNodeId, pArgs, pAttrIn, phNode, status);
+	dev_dbg(bridge, "%s: hprocessor: %p pNodeId: %p pargs: %p attr_in: %p "
+		"ph_node: %p status: 0x%x\n", __func__, hprocessor,
+		pNodeId, pargs, attr_in, ph_node, status);
 	return status;
 }
 
 /*
- *  ======== NODE_AllocMsgBuf ========
+ *  ======== node_alloc_msg_buf ========
  *  Purpose:
  *      Allocates buffer for zero copy messaging.
  */
-DBAPI NODE_AllocMsgBuf(struct NODE_OBJECT *hNode, u32 uSize,
-			OPTIONAL IN OUT struct DSP_BUFFERATTR *pAttr,
-			OUT u8 **pBuffer)
+DBAPI node_alloc_msg_buf(struct node_object *hnode, u32 usize,
+			 OPTIONAL IN OUT struct dsp_bufferattr *pattr,
+			 OUT u8 **pbuffer)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	DSP_STATUS status = DSP_SOK;
-	bool bVirtAddr = false;
-	bool bSetInfo;
-	u32 procId;
+	struct node_object *pnode = (struct node_object *)hnode;
+	dsp_status status = DSP_SOK;
+	bool va_flag = false;
+	bool set_info;
+	u32 proc_id;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBuffer != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pbuffer != NULL);
 
-	DBC_Require(uSize > 0);
+	DBC_REQUIRE(usize > 0);
 
-	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(pnode, NODE_SIGNATURE))
 		status = DSP_EHANDLE;
-	else if (NODE_GetType(pNode) == NODE_DEVICE)
+	else if (node_get_type(pnode) == NODE_DEVICE)
 		status = DSP_ENODETYPE;
 
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (pAttr == NULL)
-		pAttr = &NODE_DFLTBUFATTRS;	/* set defaults */
+	if (pattr == NULL)
+		pattr = &node_dfltbufattrs;	/* set defaults */
 
-	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
-	if (procId != DSP_UNIT) {
-		DBC_Assert(NULL);
+	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+	if (proc_id != DSP_UNIT) {
+		DBC_ASSERT(NULL);
 		goto func_end;
 	}
-	 /*  If segment ID includes MEM_SETVIRTUALSEGID then pBuffer is a
+	/*  If segment ID includes MEM_SETVIRTUALSEGID then pbuffer is a
 	 *  virt  address, so set this info in this node's translator
 	 *  object for  future ref. If MEM_GETVIRTUALSEGID then retrieve
-	 *  virtual address  from node's translator.  */
-	if ((pAttr->uSegment & MEM_SETVIRTUALSEGID) ||
-			    (pAttr->uSegment & MEM_GETVIRTUALSEGID)) {
-		bVirtAddr = true;
-		bSetInfo = (pAttr->uSegment & MEM_SETVIRTUALSEGID) ?
-			   true : false;
-		pAttr->uSegment &= ~MEM_MASKVIRTUALSEGID; /* clear mask bits */
+	 *  virtual address  from node's translator. */
+	if ((pattr->segment_id & MEM_SETVIRTUALSEGID) ||
+	    (pattr->segment_id & MEM_GETVIRTUALSEGID)) {
+		va_flag = true;
+		set_info = (pattr->segment_id & MEM_SETVIRTUALSEGID) ?
+		    true : false;
+		/* Clear mask bits */
+		pattr->segment_id &= ~MEM_MASKVIRTUALSEGID;
 		/* Set/get this node's translators virtual address base/size */
-		status = CMM_XlatorInfo(pNode->hXlator, pBuffer, uSize,
-					pAttr->uSegment, bSetInfo);
+		status = cmm_xlator_info(pnode->xlator, pbuffer, usize,
+					 pattr->segment_id, set_info);
 	}
-	if (DSP_SUCCEEDED(status) && (!bVirtAddr)) {
-		if (pAttr->uSegment != 1) {
+	if (DSP_SUCCEEDED(status) && (!va_flag)) {
+		if (pattr->segment_id != 1) {
 			/* Node supports single SM segment only. */
 			status = DSP_EBADSEGID;
 		}
-		 /*  Arbitrary SM buffer alignment not supported for host side
-		  *  allocs, but guaranteed for the following alignment
-		  *  values.  */
-		switch (pAttr->uAlignment) {
+		/*  Arbitrary SM buffer alignment not supported for host side
+		 *  allocs, but guaranteed for the following alignment
+		 *  values. */
+		switch (pattr->buf_alignment) {
 		case 0:
 		case 1:
 		case 2:
@@ -727,13 +751,13 @@ DBAPI NODE_AllocMsgBuf(struct NODE_OBJECT *hNode, u32 uSize,
 			break;
 		}
 		if (DSP_SUCCEEDED(status)) {
-			/* allocate physical buffer from segId in node's
+			/* allocate physical buffer from seg_id in node's
 			 * translator */
-			(void)CMM_XlatorAllocBuf(pNode->hXlator, pBuffer,
-						 uSize);
-			if (*pBuffer == NULL) {
+			(void)cmm_xlator_alloc_buf(pnode->xlator, pbuffer,
+						   usize);
+			if (*pbuffer == NULL) {
 				pr_err("%s: error - Out of shared memory\n",
-								__func__);
+				       __func__);
 				status = DSP_EMEMORY;
 			}
 		}
@@ -743,105 +767,104 @@ func_end:
 }
 
 /*
- *  ======== NODE_ChangePriority ========
+ *  ======== node_change_priority ========
  *  Purpose:
  *      Change the priority of a node in the allocated state, or that is
  *      currently running or paused on the target.
  */
-DSP_STATUS NODE_ChangePriority(struct NODE_OBJECT *hNode, s32 nPriority)
+dsp_status node_change_priority(struct node_object *hnode, s32 prio)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr = NULL;
-	enum NODE_TYPE nodeType;
-	enum NODE_STATE state;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId;
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr = NULL;
+	enum node_type node_type;
+	enum node_state state;
+	dsp_status status = DSP_SOK;
+	u32 proc_id;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE) || !hNode->hNodeMgr) {
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE) || !hnode->hnode_mgr) {
 		status = DSP_EHANDLE;
 	} else {
-		hNodeMgr = hNode->hNodeMgr;
-		nodeType = NODE_GetType(hNode);
-		if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
+		hnode_mgr = hnode->hnode_mgr;
+		node_type = node_get_type(hnode);
+		if (node_type != NODE_TASK && node_type != NODE_DAISSOCKET)
 			status = DSP_ENODETYPE;
-		else if (nPriority < hNodeMgr->nMinPri ||
-				nPriority > hNodeMgr->nMaxPri)
-				status = DSP_ERANGE;
+		else if (prio < hnode_mgr->min_pri || prio > hnode_mgr->max_pri)
+			status = DSP_ERANGE;
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
-	if (DSP_FAILED(status))
-		goto func_end;
+	mutex_lock(&hnode_mgr->node_mgr_lock);
 
-	state = NODE_GetState(hNode);
+	state = node_get_state(hnode);
 	if (state == NODE_ALLOCATED || state == NODE_PAUSED) {
-		NODE_SetPriority(hNode, nPriority);
+		NODE_SET_PRIORITY(hnode, prio);
 	} else {
 		if (state != NODE_RUNNING) {
 			status = DSP_EWRONGSTATE;
 			goto func_cont;
 		}
-		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
-		if (procId == DSP_UNIT) {
-			status = DISP_NodeChangePriority(hNodeMgr->
-			    hDisp, hNode,
-			    hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY],
-			    hNode->nodeEnv, nPriority);
+		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+		if (proc_id == DSP_UNIT) {
+			status =
+			    disp_node_change_priority(hnode_mgr->disp_obj,
+						      hnode,
+						      hnode_mgr->ul_fxn_addrs
+						      [RMSCHANGENODEPRIORITY],
+						      hnode->node_env, prio);
 		}
 		if (DSP_SUCCEEDED(status))
-			NODE_SetPriority(hNode, nPriority);
+			NODE_SET_PRIORITY(hnode, prio);
 
 	}
 func_cont:
-		/* Leave critical section */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	/* Leave critical section */
+	mutex_unlock(&hnode_mgr->node_mgr_lock);
 func_end:
 	return status;
 }
 
 /*
- *  ======== NODE_Connect ========
+ *  ======== node_connect ========
  *  Purpose:
  *      Connect two nodes on the DSP, or a node on the DSP to the GPP.
  */
-DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1, u32 uStream1,
-			struct NODE_OBJECT *hNode2,
-			u32 uStream2, OPTIONAL IN struct DSP_STRMATTR *pAttrs,
-			OPTIONAL IN struct DSP_CBDATA *pConnParam)
+dsp_status node_connect(struct node_object *hNode1, u32 uStream1,
+			struct node_object *hNode2,
+			u32 uStream2, OPTIONAL IN struct dsp_strmattr *pattrs,
+			OPTIONAL IN struct dsp_cbdata *conn_param)
 {
-	struct NODE_MGR *hNodeMgr;
-	char *pstrDevName = NULL;
-	enum NODE_TYPE node1Type = NODE_TASK;
-	enum NODE_TYPE node2Type = NODE_TASK;
-	struct NODE_STRMDEF *pstrmDef;
-	struct NODE_STRMDEF *pInput = NULL;
-	struct NODE_STRMDEF *pOutput = NULL;
-	struct NODE_OBJECT *hDevNode;
-	struct NODE_OBJECT *hNode;
-	struct STREAM *pStream;
-	GB_BitNum pipeId = GB_NOBITS;
-	GB_BitNum chnlId = GB_NOBITS;
-	short int uMode;
-	u32 dwLength;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-
-	if ((hNode1 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
-			!MEM_IsValidHandle(hNode1, NODE_SIGNATURE)) ||
-			(hNode2 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
-			!MEM_IsValidHandle(hNode2, NODE_SIGNATURE)))
+	struct node_mgr *hnode_mgr;
+	char *pstr_dev_name = NULL;
+	enum node_type node1_type = NODE_TASK;
+	enum node_type node2_type = NODE_TASK;
+	struct node_strmdef *pstrm_def;
+	struct node_strmdef *input = NULL;
+	struct node_strmdef *output = NULL;
+	struct node_object *dev_node_obj;
+	struct node_object *hnode;
+	struct stream_chnl *pstream;
+	gb_bit_num pipe_id = GB_NOBITS;
+	gb_bit_num chnl_id = GB_NOBITS;
+	short int chnl_mode;
+	u32 dw_length;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+
+	if ((hNode1 != (struct node_object *)DSP_HGPPNODE &&
+	     !MEM_IS_VALID_HANDLE(hNode1, NODE_SIGNATURE)) ||
+	    (hNode2 != (struct node_object *)DSP_HGPPNODE &&
+	     !MEM_IS_VALID_HANDLE(hNode2, NODE_SIGNATURE)))
 		status = DSP_EHANDLE;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* The two nodes must be on the same processor */
-		if (hNode1 != (struct NODE_OBJECT *)DSP_HGPPNODE &&
-		   hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE &&
-		   hNode1->hNodeMgr != hNode2->hNodeMgr)
+		if (hNode1 != (struct node_object *)DSP_HGPPNODE &&
+		    hNode2 != (struct node_object *)DSP_HGPPNODE &&
+		    hNode1->hnode_mgr != hNode2->hnode_mgr)
 			status = DSP_EFAIL;
 		/* Cannot connect a node to itself */
 		if (hNode1 == hNode2)
@@ -849,14 +872,17 @@ DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1, u32 uStream1,
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		/* NODE_GetType() will return NODE_GPP if hNode =
+		/* node_get_type() will return NODE_GPP if hnode =
 		 * DSP_HGPPNODE. */
-		node1Type = NODE_GetType(hNode1);
-		node2Type = NODE_GetType(hNode2);
-	/* Check stream indices ranges */
-		if ((node1Type != NODE_GPP && node1Type != NODE_DEVICE &&
-		   uStream1 >= MaxOutputs(hNode1)) || (node2Type != NODE_GPP &&
-		   node2Type != NODE_DEVICE && uStream2 >= MaxInputs(hNode2)))
+		node1_type = node_get_type(hNode1);
+		node2_type = node_get_type(hNode2);
+		/* Check stream indices ranges */
+		if ((node1_type != NODE_GPP && node1_type != NODE_DEVICE &&
+		     uStream1 >= MAX_OUTPUTS(hNode1)) || (node2_type != NODE_GPP
+							  && node2_type !=
+							  NODE_DEVICE
+							  && uStream2 >=
+							  MAX_INPUTS(hNode2)))
 			status = DSP_EVALUE;
 	}
 	if (DSP_SUCCEEDED(status)) {
@@ -869,311 +895,316 @@ DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1, u32 uStream1,
 		 *  ie, no message nodes, and at least one task or dais
 		 *  socket node.
 		 */
-		if (node1Type == NODE_MESSAGE || node2Type == NODE_MESSAGE ||
-		    (node1Type != NODE_TASK && node1Type != NODE_DAISSOCKET &&
-		     node2Type != NODE_TASK && node2Type != NODE_DAISSOCKET))
+		if (node1_type == NODE_MESSAGE || node2_type == NODE_MESSAGE ||
+		    (node1_type != NODE_TASK && node1_type != NODE_DAISSOCKET &&
+		     node2_type != NODE_TASK && node2_type != NODE_DAISSOCKET))
 			status = DSP_EFAIL;
 	}
 	/*
 	 * Check stream mode. Default is STRMMODE_PROCCOPY.
 	 */
-	if (DSP_SUCCEEDED(status) && pAttrs) {
-		if (pAttrs->lMode != STRMMODE_PROCCOPY)
+	if (DSP_SUCCEEDED(status) && pattrs) {
+		if (pattrs->strm_mode != STRMMODE_PROCCOPY)
 			status = DSP_ESTRMMODE;	/* illegal stream mode */
 
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (node1Type != NODE_GPP) {
-		hNodeMgr = hNode1->hNodeMgr;
+	if (node1_type != NODE_GPP) {
+		hnode_mgr = hNode1->hnode_mgr;
 	} else {
-		DBC_Assert(hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE);
-		hNodeMgr = hNode2->hNodeMgr;
+		DBC_ASSERT(hNode2 != (struct node_object *)DSP_HGPPNODE);
+		hnode_mgr = hNode2->hnode_mgr;
 	}
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
-	if (DSP_FAILED(status))
-		goto func_cont;
+	mutex_lock(&hnode_mgr->node_mgr_lock);
 
 	/* Nodes must be in the allocated state */
-	if (node1Type != NODE_GPP && NODE_GetState(hNode1) != NODE_ALLOCATED)
+	if (node1_type != NODE_GPP && node_get_state(hNode1) != NODE_ALLOCATED)
 		status = DSP_EWRONGSTATE;
 
-	if (node2Type != NODE_GPP && NODE_GetState(hNode2) != NODE_ALLOCATED)
+	if (node2_type != NODE_GPP && node_get_state(hNode2) != NODE_ALLOCATED)
 		status = DSP_EWRONGSTATE;
 
 	if (DSP_SUCCEEDED(status)) {
 		/*  Check that stream indices for task and dais socket nodes
 		 *  are not already be used. (Device nodes checked later) */
-		if (node1Type == NODE_TASK || node1Type == NODE_DAISSOCKET) {
-			pOutput = &(hNode1->createArgs.asa.taskArgs.
-				  strmOutDef[uStream1]);
-			if (pOutput->szDevice != NULL)
+		if (node1_type == NODE_TASK || node1_type == NODE_DAISSOCKET) {
+			output =
+			    &(hNode1->create_args.asa.
+			      task_arg_obj.strm_out_def[uStream1]);
+			if (output->sz_device != NULL)
 				status = DSP_EALREADYCONNECTED;
 
 		}
-		if (node2Type == NODE_TASK || node2Type == NODE_DAISSOCKET) {
-			pInput = &(hNode2->createArgs.asa.taskArgs.
-				 strmInDef[uStream2]);
-			if (pInput->szDevice != NULL)
+		if (node2_type == NODE_TASK || node2_type == NODE_DAISSOCKET) {
+			input =
+			    &(hNode2->create_args.asa.
+			      task_arg_obj.strm_in_def[uStream2]);
+			if (input->sz_device != NULL)
 				status = DSP_EALREADYCONNECTED;
 
 		}
 	}
 	/* Connecting two task nodes? */
-	if (DSP_SUCCEEDED(status) && ((node1Type == NODE_TASK ||
-	   node1Type == NODE_DAISSOCKET) && (node2Type == NODE_TASK ||
-	   node2Type == NODE_DAISSOCKET))) {
+	if (DSP_SUCCEEDED(status) && ((node1_type == NODE_TASK ||
+				       node1_type == NODE_DAISSOCKET)
+				      && (node2_type == NODE_TASK
+					  || node2_type == NODE_DAISSOCKET))) {
 		/* Find available pipe */
-		pipeId = GB_findandset(hNodeMgr->pipeMap);
-		if (pipeId == GB_NOBITS) {
+		pipe_id = gb_findandset(hnode_mgr->pipe_map);
+		if (pipe_id == GB_NOBITS) {
 			status = DSP_ENOMORECONNECTIONS;
 		} else {
 			hNode1->outputs[uStream1].type = NODECONNECT;
 			hNode2->inputs[uStream2].type = NODECONNECT;
-			hNode1->outputs[uStream1].devId = pipeId;
-			hNode2->inputs[uStream2].devId = pipeId;
-			pOutput->szDevice = MEM_Calloc(PIPENAMELEN + 1,
+			hNode1->outputs[uStream1].dev_id = pipe_id;
+			hNode2->inputs[uStream2].dev_id = pipe_id;
+			output->sz_device = mem_calloc(PIPENAMELEN + 1,
+						       MEM_PAGED);
+			input->sz_device = mem_calloc(PIPENAMELEN + 1,
 						      MEM_PAGED);
-			pInput->szDevice = MEM_Calloc(PIPENAMELEN + 1,
-						     MEM_PAGED);
-			if (pOutput->szDevice == NULL ||
-			   pInput->szDevice == NULL) {
+			if (output->sz_device == NULL ||
+			    input->sz_device == NULL) {
 				/* Undo the connection */
-				kfree(pOutput->szDevice);
+				kfree(output->sz_device);
 
-				kfree(pInput->szDevice);
+				kfree(input->sz_device);
 
-				pOutput->szDevice = NULL;
-				pInput->szDevice = NULL;
-				GB_clear(hNodeMgr->pipeMap, pipeId);
+				output->sz_device = NULL;
+				input->sz_device = NULL;
+				gb_clear(hnode_mgr->pipe_map, pipe_id);
 				status = DSP_EMEMORY;
 			} else {
 				/* Copy "/dbpipe<pipId>" name to device names */
-				sprintf(pOutput->szDevice, "%s%d",
-						PIPEPREFIX, pipeId);
-				strcpy(pInput->szDevice, pOutput->szDevice);
+				sprintf(output->sz_device, "%s%d",
+					PIPEPREFIX, pipe_id);
+				strcpy(input->sz_device, output->sz_device);
 			}
 		}
 	}
 	/* Connecting task node to host? */
-	if (DSP_SUCCEEDED(status) && (node1Type == NODE_GPP ||
-	   node2Type == NODE_GPP)) {
-		if (node1Type == NODE_GPP) {
-			uMode = CHNL_MODETODSP;
+	if (DSP_SUCCEEDED(status) && (node1_type == NODE_GPP ||
+				      node2_type == NODE_GPP)) {
+		if (node1_type == NODE_GPP) {
+			chnl_mode = CHNL_MODETODSP;
 		} else {
-			DBC_Assert(node2Type == NODE_GPP);
-			uMode = CHNL_MODEFROMDSP;
+			DBC_ASSERT(node2_type == NODE_GPP);
+			chnl_mode = CHNL_MODEFROMDSP;
 		}
-		 /*  Reserve a channel id. We need to put the name "/host<id>"
-		 *  in the node's createArgs, but the host
+		/*  Reserve a channel id. We need to put the name "/host<id>"
+		 *  in the node's create_args, but the host
 		 *  side channel will not be opened until DSPStream_Open is
-		 *  called for this node.  */
-		if (pAttrs) {
-			if (pAttrs->lMode == STRMMODE_RDMA) {
-				chnlId = GB_findandset(hNodeMgr->dmaChnlMap);
+		 *  called for this node. */
+		if (pattrs) {
+			if (pattrs->strm_mode == STRMMODE_RDMA) {
+				chnl_id =
+				    gb_findandset(hnode_mgr->dma_chnl_map);
 				/* dma chans are 2nd transport chnl set
-				 * ids(e.g. 16-31)*/
-				(chnlId != GB_NOBITS) ?
-				   (chnlId = chnlId + hNodeMgr->ulNumChnls) :
-				   chnlId;
-			} else if (pAttrs->lMode == STRMMODE_ZEROCOPY) {
-				chnlId = GB_findandset(hNodeMgr->zChnlMap);
+				 * ids(e.g. 16-31) */
+				(chnl_id != GB_NOBITS) ?
+				    (chnl_id =
+				     chnl_id +
+				     hnode_mgr->ul_num_chnls) : chnl_id;
+			} else if (pattrs->strm_mode == STRMMODE_ZEROCOPY) {
+				chnl_id = gb_findandset(hnode_mgr->zc_chnl_map);
 				/* zero-copy chans are 3nd transport set
 				 * (e.g. 32-47) */
-				(chnlId != GB_NOBITS) ?  (chnlId = chnlId +
-					(2 * hNodeMgr->ulNumChnls)) : chnlId;
+				(chnl_id != GB_NOBITS) ? (chnl_id = chnl_id +
+							  (2 *
+							   hnode_mgr->
+							   ul_num_chnls))
+				    : chnl_id;
 			} else {	/* must be PROCCOPY */
-				DBC_Assert(pAttrs->lMode == STRMMODE_PROCCOPY);
-				chnlId = GB_findandset(hNodeMgr->chnlMap);
+				DBC_ASSERT(pattrs->strm_mode ==
+					   STRMMODE_PROCCOPY);
+				chnl_id = gb_findandset(hnode_mgr->chnl_map);
 				/* e.g. 0-15 */
 			}
 		} else {
 			/* default to PROCCOPY */
-			chnlId = GB_findandset(hNodeMgr->chnlMap);
+			chnl_id = gb_findandset(hnode_mgr->chnl_map);
 		}
-		if (chnlId == GB_NOBITS) {
+		if (chnl_id == GB_NOBITS) {
 			status = DSP_ENOMORECONNECTIONS;
 			goto func_cont2;
 		}
-		pstrDevName = MEM_Calloc(HOSTNAMELEN + 1, MEM_PAGED);
-		if (pstrDevName != NULL)
+		pstr_dev_name = mem_calloc(HOSTNAMELEN + 1, MEM_PAGED);
+		if (pstr_dev_name != NULL)
 			goto func_cont2;
 
-		if (pAttrs) {
-			if (pAttrs->lMode == STRMMODE_RDMA) {
-				GB_clear(hNodeMgr->dmaChnlMap, chnlId -
-					 hNodeMgr->ulNumChnls);
-			} else if (pAttrs->lMode == STRMMODE_ZEROCOPY) {
-				GB_clear(hNodeMgr->zChnlMap, chnlId -
-					(2*hNodeMgr->ulNumChnls));
+		if (pattrs) {
+			if (pattrs->strm_mode == STRMMODE_RDMA) {
+				gb_clear(hnode_mgr->dma_chnl_map, chnl_id -
+					 hnode_mgr->ul_num_chnls);
+			} else if (pattrs->strm_mode == STRMMODE_ZEROCOPY) {
+				gb_clear(hnode_mgr->zc_chnl_map, chnl_id -
+					 (2 * hnode_mgr->ul_num_chnls));
 			} else {
-				DBC_Assert(pAttrs->lMode == STRMMODE_PROCCOPY);
-				GB_clear(hNodeMgr->chnlMap, chnlId);
+				DBC_ASSERT(pattrs->strm_mode ==
+					   STRMMODE_PROCCOPY);
+				gb_clear(hnode_mgr->chnl_map, chnl_id);
 			}
 		} else {
-			GB_clear(hNodeMgr->chnlMap, chnlId);
+			gb_clear(hnode_mgr->chnl_map, chnl_id);
 		}
 		status = DSP_EMEMORY;
 func_cont2:
 		if (DSP_SUCCEEDED(status)) {
-			if (hNode1 == (struct NODE_OBJECT *) DSP_HGPPNODE) {
+			if (hNode1 == (struct node_object *)DSP_HGPPNODE) {
 				hNode2->inputs[uStream2].type = HOSTCONNECT;
-				hNode2->inputs[uStream2].devId = chnlId;
-				pInput->szDevice = pstrDevName;
+				hNode2->inputs[uStream2].dev_id = chnl_id;
+				input->sz_device = pstr_dev_name;
 			} else {
 				hNode1->outputs[uStream1].type = HOSTCONNECT;
-				hNode1->outputs[uStream1].devId = chnlId;
-				pOutput->szDevice = pstrDevName;
+				hNode1->outputs[uStream1].dev_id = chnl_id;
+				output->sz_device = pstr_dev_name;
 			}
-			sprintf(pstrDevName, "%s%d", HOSTPREFIX, chnlId);
+			sprintf(pstr_dev_name, "%s%d", HOSTPREFIX, chnl_id);
 		}
 	}
 	/* Connecting task node to device node? */
-	if (DSP_SUCCEEDED(status) && ((node1Type == NODE_DEVICE) ||
-	   (node2Type == NODE_DEVICE))) {
-		if (node2Type == NODE_DEVICE) {
+	if (DSP_SUCCEEDED(status) && ((node1_type == NODE_DEVICE) ||
+				      (node2_type == NODE_DEVICE))) {
+		if (node2_type == NODE_DEVICE) {
 			/* node1 == > device */
-			hDevNode = hNode2;
-			hNode = hNode1;
-			pStream = &(hNode1->outputs[uStream1]);
-			pstrmDef = pOutput;
+			dev_node_obj = hNode2;
+			hnode = hNode1;
+			pstream = &(hNode1->outputs[uStream1]);
+			pstrm_def = output;
 		} else {
 			/* device == > node2 */
-			hDevNode = hNode1;
-			hNode = hNode2;
-			pStream = &(hNode2->inputs[uStream2]);
-			pstrmDef = pInput;
+			dev_node_obj = hNode1;
+			hnode = hNode2;
+			pstream = &(hNode2->inputs[uStream2]);
+			pstrm_def = input;
 		}
 		/* Set up create args */
-		pStream->type = DEVICECONNECT;
-		dwLength = strlen(hDevNode->pstrDevName);
-		if (pConnParam != NULL) {
-			pstrmDef->szDevice = MEM_Calloc(dwLength + 1 +
-						(u32) pConnParam->cbData,
-						MEM_PAGED);
+		pstream->type = DEVICECONNECT;
+		dw_length = strlen(dev_node_obj->pstr_dev_name);
+		if (conn_param != NULL) {
+			pstrm_def->sz_device = mem_calloc(dw_length + 1 + (u32)
+							  conn_param->cb_data,
+							  MEM_PAGED);
 		} else {
-			pstrmDef->szDevice = MEM_Calloc(dwLength + 1,
-							MEM_PAGED);
+			pstrm_def->sz_device = mem_calloc(dw_length + 1,
+							  MEM_PAGED);
 		}
-		if (pstrmDef->szDevice == NULL) {
+		if (pstrm_def->sz_device == NULL) {
 			status = DSP_EMEMORY;
 		} else {
 			/* Copy device name */
-			strncpy(pstrmDef->szDevice, hDevNode->pstrDevName,
-				dwLength);
-			if (pConnParam != NULL) {
-				strncat(pstrmDef->szDevice,
-					(char *)pConnParam->cData,
-					(u32)pConnParam->cbData);
+			strncpy(pstrm_def->sz_device,
+				dev_node_obj->pstr_dev_name, dw_length);
+			if (conn_param != NULL) {
+				strncat(pstrm_def->sz_device,
+					(char *)conn_param->node_data,
+					(u32) conn_param->cb_data);
 			}
-			hDevNode->hDeviceOwner = hNode;
+			dev_node_obj->device_owner = hnode;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Fill in create args */
-		if (node1Type == NODE_TASK || node1Type == NODE_DAISSOCKET) {
-			hNode1->createArgs.asa.taskArgs.uNumOutputs++;
-			FillStreamDef(hNode1, pOutput, pAttrs);
+		if (node1_type == NODE_TASK || node1_type == NODE_DAISSOCKET) {
+			hNode1->create_args.asa.task_arg_obj.num_outputs++;
+			fill_stream_def(hNode1, output, pattrs);
 		}
-		if (node2Type == NODE_TASK || node2Type == NODE_DAISSOCKET) {
-			hNode2->createArgs.asa.taskArgs.uNumInputs++;
-			FillStreamDef(hNode2, pInput, pAttrs);
+		if (node2_type == NODE_TASK || node2_type == NODE_DAISSOCKET) {
+			hNode2->create_args.asa.task_arg_obj.num_inputs++;
+			fill_stream_def(hNode2, input, pattrs);
 		}
-		/* Update hNode1 and hNode2 streamConnect */
-		if (node1Type != NODE_GPP && node1Type != NODE_DEVICE) {
-			hNode1->uNumOutputs++;
-			if (uStream1 > hNode1->uMaxOutputIndex)
-				hNode1->uMaxOutputIndex = uStream1;
+		/* Update hNode1 and hNode2 stream_connect */
+		if (node1_type != NODE_GPP && node1_type != NODE_DEVICE) {
+			hNode1->num_outputs++;
+			if (uStream1 > hNode1->max_output_index)
+				hNode1->max_output_index = uStream1;
 
 		}
-		if (node2Type != NODE_GPP && node2Type != NODE_DEVICE) {
-			hNode2->uNumInputs++;
-			if (uStream2 > hNode2->uMaxInputIndex)
-				hNode2->uMaxInputIndex = uStream2;
+		if (node2_type != NODE_GPP && node2_type != NODE_DEVICE) {
+			hNode2->num_inputs++;
+			if (uStream2 > hNode2->max_input_index)
+				hNode2->max_input_index = uStream2;
 
 		}
-		FillStreamConnect(hNode1, hNode2, uStream1, uStream2);
+		fill_stream_connect(hNode1, hNode2, uStream1, uStream2);
 	}
-func_cont:
-	/* end of SYNC_EnterCS */
+	/* end of sync_enter_cs */
 	/* Exit critical section */
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	mutex_unlock(&hnode_mgr->node_mgr_lock);
 func_end:
 	dev_dbg(bridge, "%s: hNode1: %p uStream1: %d hNode2: %p uStream2: %d"
-				"pAttrs: %p status: 0x%x\n", __func__, hNode1,
-				uStream1, hNode2, uStream2, pAttrs, status);
+		"pattrs: %p status: 0x%x\n", __func__, hNode1,
+		uStream1, hNode2, uStream2, pattrs, status);
 	return status;
 }
 
 /*
- *  ======== NODE_Create ========
+ *  ======== node_create ========
  *  Purpose:
  *      Create a node on the DSP by remotely calling the node's create function.
  */
-DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode)
+dsp_status node_create(struct node_object *hnode)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	u32 ulCreateFxn;
-	enum NODE_TYPE nodeType;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	struct DSP_CBDATA cbData;
-	u32 procId = 255;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr;
+	struct bridge_drv_interface *intf_fxns;
+	u32 ul_create_fxn;
+	enum node_type node_type;
+	dsp_status status = DSP_SOK;
+	dsp_status status1 = DSP_SOK;
+	struct dsp_cbdata cb_data;
+	u32 proc_id = 255;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
 	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 #endif
 
-	DBC_Require(cRefs > 0);
-	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE)) {
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(pnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hProcessor = hNode->hProcessor;
-	status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+	hprocessor = hnode->hprocessor;
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt to create
-	    new node */
-	if (procStatus.iState == PROC_ERROR) {
+	   new node */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	/* create struct DSP_CBDATA struct for PWR calls */
-	cbData.cbData = PWR_TIMEOUT;
-	nodeType = NODE_GetType(hNode);
-	hNodeMgr = hNode->hNodeMgr;
-	pIntfFxns = hNodeMgr->pIntfFxns;
+	/* create struct dsp_cbdata struct for PWR calls */
+	cb_data.cb_data = PWR_TIMEOUT;
+	node_type = node_get_type(hnode);
+	hnode_mgr = hnode->hnode_mgr;
+	intf_fxns = hnode_mgr->intf_fxns;
 	/* Get access to node dispatcher */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
-	if (DSP_FAILED(status))
-		goto func_end;
+	mutex_lock(&hnode_mgr->node_mgr_lock);
 
 	/* Check node state */
-	if (NODE_GetState(hNode) != NODE_ALLOCATED)
+	if (node_get_state(hnode) != NODE_ALLOCATED)
 		status = DSP_EWRONGSTATE;
 
 	if (DSP_SUCCEEDED(status))
-		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 
 	if (DSP_FAILED(status))
 		goto func_cont2;
 
-	if (procId != DSP_UNIT)
+	if (proc_id != DSP_UNIT)
 		goto func_cont2;
 
 	/* Make sure streams are properly connected */
-	if ((hNode->uNumInputs && hNode->uMaxInputIndex >
-	   hNode->uNumInputs - 1) ||
-	   (hNode->uNumOutputs && hNode->uMaxOutputIndex >
-	   hNode->uNumOutputs - 1))
+	if ((hnode->num_inputs && hnode->max_input_index >
+	     hnode->num_inputs - 1) ||
+	    (hnode->num_outputs && hnode->max_output_index >
+	     hnode->num_outputs - 1))
 		status = DSP_ENOTCONNECTED;
 
 	if (DSP_SUCCEEDED(status)) {
@@ -1181,371 +1212,400 @@ DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode)
 		/* Boost the OPP level to max level that DSP can be requested */
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
 		if (pdata->cpu_set_freq)
-			(*pdata->cpu_set_freq)(pdata->mpu_max_speed);
+			(*pdata->cpu_set_freq) (pdata->mpu_max_speed);
 #endif
-		status = hNodeMgr->nldrFxns.pfnLoad(hNode->hNldrNode,
-						   NLDR_CREATE);
+		status = hnode_mgr->nldr_fxns.pfn_load(hnode->nldr_node_obj,
+						       NLDR_CREATE);
 		/* Get address of node's create function */
 		if (DSP_SUCCEEDED(status)) {
-			hNode->fLoaded = true;
-			if (nodeType != NODE_DEVICE) {
-				status = GetFxnAddress(hNode, &ulCreateFxn,
-							CREATEPHASE);
+			hnode->loaded = true;
+			if (node_type != NODE_DEVICE) {
+				status = get_fxn_address(hnode, &ul_create_fxn,
+							 CREATEPHASE);
 			}
 		} else {
 			pr_err("%s: failed to load create code: 0x%x\n",
-							__func__, status);
+			       __func__, status);
 		}
-		/* Request the lowest OPP level*/
+		/* Request the lowest OPP level */
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
 		if (pdata->cpu_set_freq)
-			(*pdata->cpu_set_freq)(pdata->mpu_min_speed);
+			(*pdata->cpu_set_freq) (pdata->mpu_min_speed);
 #endif
 		/* Get address of iAlg functions, if socket node */
 		if (DSP_SUCCEEDED(status)) {
-			if (nodeType == NODE_DAISSOCKET) {
-				status = hNodeMgr->nldrFxns.pfnGetFxnAddr
-					(hNode->hNldrNode, hNode->dcdProps.
-					objData.nodeObj.pstrIAlgName,
-					&hNode->createArgs.asa.taskArgs.
-					ulDaisArg);
+			if (node_type == NODE_DAISSOCKET) {
+				status = hnode_mgr->nldr_fxns.pfn_get_fxn_addr
+				    (hnode->nldr_node_obj,
+				     hnode->dcd_props.obj_data.node_obj.
+				     pstr_i_alg_name,
+				     &hnode->create_args.asa.
+				     task_arg_obj.ul_dais_arg);
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		if (nodeType != NODE_DEVICE) {
-			status = DISP_NodeCreate(hNodeMgr->hDisp, hNode,
-				 hNodeMgr->ulFxnAddrs[RMSCREATENODE],
-				 ulCreateFxn, &(hNode->createArgs),
-				 &(hNode->nodeEnv));
+		if (node_type != NODE_DEVICE) {
+			status = disp_node_create(hnode_mgr->disp_obj, hnode,
+						  hnode_mgr->ul_fxn_addrs
+						  [RMSCREATENODE],
+						  ul_create_fxn,
+						  &(hnode->create_args),
+						  &(hnode->node_env));
 			if (DSP_SUCCEEDED(status)) {
 				/* Set the message queue id to the node env
 				 * pointer */
-				pIntfFxns = hNodeMgr->pIntfFxns;
-				(*pIntfFxns->pfnMsgSetQueueId)(hNode->hMsgQueue,
-				hNode->nodeEnv);
+				intf_fxns = hnode_mgr->intf_fxns;
+				(*intf_fxns->pfn_msg_set_queue_id) (hnode->
+							msg_queue_obj,
+							hnode->node_env);
 			}
 		}
 	}
 	/*  Phase II/Overlays: Create, execute, delete phases  possibly in
 	 *  different files/sections. */
-	if (hNode->fLoaded && hNode->fPhaseSplit) {
+	if (hnode->loaded && hnode->phase_split) {
 		/* If create code was dynamically loaded, we can now unload
 		 * it. */
-		status1 = hNodeMgr->nldrFxns.pfnUnload(hNode->hNldrNode,
-						      NLDR_CREATE);
-		hNode->fLoaded = false;
+		status1 = hnode_mgr->nldr_fxns.pfn_unload(hnode->nldr_node_obj,
+							  NLDR_CREATE);
+		hnode->loaded = false;
 	}
 	if (DSP_FAILED(status1))
 		pr_err("%s: Failed to unload create code: 0x%x\n",
-							__func__, status1);
+		       __func__, status1);
 func_cont2:
 	/* Update node state and node manager state */
 	if (DSP_SUCCEEDED(status)) {
-		NODE_SetState(hNode, NODE_CREATED);
-		hNodeMgr->uNumCreated++;
+		NODE_SET_STATE(hnode, NODE_CREATED);
+		hnode_mgr->num_created++;
 		goto func_cont;
 	}
 	if (status != DSP_EWRONGSTATE) {
 		/* Put back in NODE_ALLOCATED state if error occurred */
-		NODE_SetState(hNode, NODE_ALLOCATED);
+		NODE_SET_STATE(hnode, NODE_ALLOCATED);
 	}
 func_cont:
-		/* Free access to node dispatcher */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	/* Free access to node dispatcher */
+	mutex_unlock(&hnode_mgr->node_mgr_lock);
 func_end:
 	if (DSP_SUCCEEDED(status)) {
-		PROC_NotifyClients(hNode->hProcessor, DSP_NODESTATECHANGE);
-		NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+		proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+		ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 	}
 
-	dev_dbg(bridge, "%s: hNode: %p status: 0x%x\n", __func__,
-							hNode, status);
+	dev_dbg(bridge, "%s: hnode: %p status: 0x%x\n", __func__,
+		hnode, status);
 	return status;
 }
 
 /*
- *  ======== NODE_CreateMgr ========
+ *  ======== node_create_mgr ========
  *  Purpose:
  *      Create a NODE Manager object.
  */
-DSP_STATUS NODE_CreateMgr(OUT struct NODE_MGR **phNodeMgr,
-			 struct DEV_OBJECT *hDevObject)
+dsp_status node_create_mgr(OUT struct node_mgr **phNodeMgr,
+			   struct dev_object *hdev_obj)
 {
 	u32 i;
-	struct NODE_MGR *pNodeMgr = NULL;
-	struct DISP_ATTRS dispAttrs;
-	char *szZLFile = "";
-	struct NLDR_ATTRS nldrAttrs;
-	DSP_STATUS status = DSP_SOK;
-	u32 devType;
-	DBC_Require(cRefs > 0);
-	DBC_Require(phNodeMgr != NULL);
-	DBC_Require(hDevObject != NULL);
+	struct node_mgr *node_mgr_obj = NULL;
+	struct disp_attr disp_attr_obj;
+	char *sz_zl_file = "";
+	struct nldr_attrs nldr_attrs_obj;
+	dsp_status status = DSP_SOK;
+	u32 dev_type;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phNodeMgr != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
 
 	*phNodeMgr = NULL;
 	/* Allocate Node manager object */
-	MEM_AllocObject(pNodeMgr, struct NODE_MGR, NODEMGR_SIGNATURE);
-	if (pNodeMgr) {
-		pNodeMgr->hDevObject = hDevObject;
-		pNodeMgr->nodeList = MEM_Calloc(sizeof(struct LST_LIST),
-						MEM_NONPAGED);
-		pNodeMgr->pipeMap = GB_create(MAXPIPES);
-		pNodeMgr->pipeDoneMap = GB_create(MAXPIPES);
-		if (pNodeMgr->nodeList == NULL || pNodeMgr->pipeMap == NULL ||
-		   pNodeMgr->pipeDoneMap == NULL) {
+	MEM_ALLOC_OBJECT(node_mgr_obj, struct node_mgr, NODEMGR_SIGNATURE);
+	if (node_mgr_obj) {
+		node_mgr_obj->hdev_obj = hdev_obj;
+		node_mgr_obj->node_list = mem_calloc(sizeof(struct lst_list),
+						     MEM_NONPAGED);
+		node_mgr_obj->pipe_map = gb_create(MAXPIPES);
+		node_mgr_obj->pipe_done_map = gb_create(MAXPIPES);
+		if (node_mgr_obj->node_list == NULL
+		    || node_mgr_obj->pipe_map == NULL
+		    || node_mgr_obj->pipe_done_map == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			INIT_LIST_HEAD(&pNodeMgr->nodeList->head);
-			status = NTFY_Create(&pNodeMgr->hNtfy);
+			INIT_LIST_HEAD(&node_mgr_obj->node_list->head);
+			node_mgr_obj->ntfy_obj = kmalloc(
+				sizeof(struct ntfy_object), GFP_KERNEL);
+			if (node_mgr_obj->ntfy_obj)
+				ntfy_init(node_mgr_obj->ntfy_obj);
+			else
+				status = DSP_EMEMORY;
 		}
-		pNodeMgr->uNumCreated = 0;
+		node_mgr_obj->num_created = 0;
 	} else {
 		status = DSP_EMEMORY;
 	}
 	/* get devNodeType */
 	if (DSP_SUCCEEDED(status))
-		status = DEV_GetDevType(hDevObject, &devType);
+		status = dev_get_dev_type(hdev_obj, &dev_type);
 
 	/* Create the DCD Manager */
 	if (DSP_SUCCEEDED(status)) {
-		status = DCD_CreateManager(szZLFile, &pNodeMgr->hDcdMgr);
+		status =
+		    dcd_create_manager(sz_zl_file, &node_mgr_obj->hdcd_mgr);
 		if (DSP_SUCCEEDED(status))
-			status = GetProcProps(pNodeMgr, hDevObject);
+			status = get_proc_props(node_mgr_obj, hdev_obj);
 
 	}
 	/* Create NODE Dispatcher */
 	if (DSP_SUCCEEDED(status)) {
-		dispAttrs.ulChnlOffset = pNodeMgr->ulChnlOffset;
-		dispAttrs.ulChnlBufSize = pNodeMgr->ulChnlBufSize;
-		dispAttrs.procFamily = pNodeMgr->procFamily;
-		dispAttrs.procType = pNodeMgr->procType;
-		status = DISP_Create(&pNodeMgr->hDisp, hDevObject, &dispAttrs);
+		disp_attr_obj.ul_chnl_offset = node_mgr_obj->ul_chnl_offset;
+		disp_attr_obj.ul_chnl_buf_size = node_mgr_obj->ul_chnl_buf_size;
+		disp_attr_obj.proc_family = node_mgr_obj->proc_family;
+		disp_attr_obj.proc_type = node_mgr_obj->proc_type;
+		status =
+		    disp_create(&node_mgr_obj->disp_obj, hdev_obj,
+				&disp_attr_obj);
 	}
 	/* Create a STRM Manager */
 	if (DSP_SUCCEEDED(status))
-		status = STRM_Create(&pNodeMgr->hStrmMgr, hDevObject);
+		status = strm_create(&node_mgr_obj->strm_mgr_obj, hdev_obj);
 
 	if (DSP_SUCCEEDED(status)) {
-		DEV_GetIntfFxns(hDevObject, &pNodeMgr->pIntfFxns);
-		/* Get MSG queue manager */
-		DEV_GetMsgMgr(hDevObject, &pNodeMgr->hMsg);
-		status = SYNC_InitializeCS(&pNodeMgr->hSync);
-	}
-	if (DSP_SUCCEEDED(status)) {
-		pNodeMgr->chnlMap = GB_create(pNodeMgr->ulNumChnls);
-		/* dma chnl map. ulNumChnls is # per transport */
-		pNodeMgr->dmaChnlMap = GB_create(pNodeMgr->ulNumChnls);
-		pNodeMgr->zChnlMap = GB_create(pNodeMgr->ulNumChnls);
-		if ((pNodeMgr->chnlMap == NULL) ||
-		   (pNodeMgr->dmaChnlMap == NULL) ||
-		   (pNodeMgr->zChnlMap == NULL)) {
+		dev_get_intf_fxns(hdev_obj, &node_mgr_obj->intf_fxns);
+		/* Get msg_ctrl queue manager */
+		dev_get_msg_mgr(hdev_obj, &node_mgr_obj->msg_mgr_obj);
+		mutex_init(&node_mgr_obj->node_mgr_lock);
+		node_mgr_obj->chnl_map = gb_create(node_mgr_obj->ul_num_chnls);
+		/* dma chnl map. ul_num_chnls is # per transport */
+		node_mgr_obj->dma_chnl_map =
+		    gb_create(node_mgr_obj->ul_num_chnls);
+		node_mgr_obj->zc_chnl_map =
+		    gb_create(node_mgr_obj->ul_num_chnls);
+		if ((node_mgr_obj->chnl_map == NULL)
+		    || (node_mgr_obj->dma_chnl_map == NULL)
+		    || (node_mgr_obj->zc_chnl_map == NULL)) {
 			status = DSP_EMEMORY;
 		} else {
 			/* Block out reserved channels */
-			for (i = 0; i < pNodeMgr->ulChnlOffset; i++)
-				GB_set(pNodeMgr->chnlMap, i);
+			for (i = 0; i < node_mgr_obj->ul_chnl_offset; i++)
+				gb_set(node_mgr_obj->chnl_map, i);
 
 			/* Block out channels reserved for RMS */
-			GB_set(pNodeMgr->chnlMap, pNodeMgr->ulChnlOffset);
-			GB_set(pNodeMgr->chnlMap, pNodeMgr->ulChnlOffset + 1);
+			gb_set(node_mgr_obj->chnl_map,
+			       node_mgr_obj->ul_chnl_offset);
+			gb_set(node_mgr_obj->chnl_map,
+			       node_mgr_obj->ul_chnl_offset + 1);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* NO RM Server on the IVA */
-		if (devType != IVA_UNIT) {
+		if (dev_type != IVA_UNIT) {
 			/* Get addresses of any RMS functions loaded */
-			status = GetRMSFxns(pNodeMgr);
+			status = get_rms_fxns(node_mgr_obj);
 		}
 	}
 
 	/* Get loader functions and create loader */
 	if (DSP_SUCCEEDED(status))
-		pNodeMgr->nldrFxns = nldrFxns;	/* Dynamic loader functions */
+		node_mgr_obj->nldr_fxns = nldr_fxns;	/* Dyn loader funcs */
 
 	if (DSP_SUCCEEDED(status)) {
-		nldrAttrs.pfnOvly = Ovly;
-		nldrAttrs.pfnWrite = Write;
-		nldrAttrs.usDSPWordSize = pNodeMgr->uDSPWordSize;
-		nldrAttrs.usDSPMauSize = pNodeMgr->uDSPMauSize;
-		pNodeMgr->fLoaderInit = pNodeMgr->nldrFxns.pfnInit();
-		status = pNodeMgr->nldrFxns.pfnCreate(&pNodeMgr->hNldr,
-						     hDevObject, &nldrAttrs);
+		nldr_attrs_obj.pfn_ovly = ovly;
+		nldr_attrs_obj.pfn_write = mem_write;
+		nldr_attrs_obj.us_dsp_word_size = node_mgr_obj->udsp_word_size;
+		nldr_attrs_obj.us_dsp_mau_size = node_mgr_obj->udsp_mau_size;
+		node_mgr_obj->loader_init = node_mgr_obj->nldr_fxns.pfn_init();
+		status =
+		    node_mgr_obj->nldr_fxns.pfn_create(&node_mgr_obj->nldr_obj,
+						       hdev_obj,
+						       &nldr_attrs_obj);
 	}
 	if (DSP_SUCCEEDED(status))
-		*phNodeMgr = pNodeMgr;
+		*phNodeMgr = node_mgr_obj;
 	else
-		DeleteNodeMgr(pNodeMgr);
+		delete_node_mgr(node_mgr_obj);
 
-	DBC_Ensure((DSP_FAILED(status) && (*phNodeMgr == NULL)) ||
-		  (DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle((*phNodeMgr), NODEMGR_SIGNATURE)));
+	DBC_ENSURE((DSP_FAILED(status) && (*phNodeMgr == NULL)) ||
+		   (DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE((*phNodeMgr), NODEMGR_SIGNATURE)));
 
 	return status;
 }
 
 /*
- *  ======== NODE_Delete ========
+ *  ======== node_delete ========
  *  Purpose:
  *      Delete a node on the DSP by remotely calling the node's delete function.
  *      Loads the node's delete function if necessary. Free GPP side resources
  *      after node's delete function returns.
  */
-DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status node_delete(struct node_object *hnode,
+		       struct process_context *pr_ctxt)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr;
-	struct PROC_OBJECT *hProcessor;
-	struct DISP_OBJECT *hDisp;
-	u32 ulDeleteFxn;
-	enum NODE_TYPE nodeType;
-	enum NODE_STATE state;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	struct DSP_CBDATA cbData;
-	u32 procId;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-
-	HANDLE		nodeRes;
-
-	struct DSP_PROCESSORSTATE procStatus;
-	DBC_Require(cRefs > 0);
-
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr;
+	struct proc_object *hprocessor;
+	struct disp_object *disp_obj;
+	u32 ul_delete_fxn;
+	enum node_type node_type;
+	enum node_state state;
+	dsp_status status = DSP_SOK;
+	dsp_status status1 = DSP_SOK;
+	struct dsp_cbdata cb_data;
+	u32 proc_id;
+	struct bridge_drv_interface *intf_fxns;
+
+	bhandle node_res;
+
+	struct dsp_processorstate proc_state;
+	DBC_REQUIRE(refs > 0);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	/* create struct DSP_CBDATA struct for PWR call */
-	cbData.cbData = PWR_TIMEOUT;
-	hNodeMgr = hNode->hNodeMgr;
-	hProcessor = hNode->hProcessor;
-	hDisp = hNodeMgr->hDisp;
-	nodeType = NODE_GetType(hNode);
-	pIntfFxns = hNodeMgr->pIntfFxns;
+	/* create struct dsp_cbdata struct for PWR call */
+	cb_data.cb_data = PWR_TIMEOUT;
+	hnode_mgr = hnode->hnode_mgr;
+	hprocessor = hnode->hprocessor;
+	disp_obj = hnode_mgr->disp_obj;
+	node_type = node_get_type(hnode);
+	intf_fxns = hnode_mgr->intf_fxns;
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
-	if (DSP_FAILED(status))
-		goto func_end;
-
-	state = NODE_GetState(hNode);
-	 /*  Execute delete phase code for non-device node in all cases
-	  *  except when the node was only allocated. Delete phase must be
-	  *  executed even if create phase was executed, but failed.
-	  *  If the node environment pointer is non-NULL, the delete phase
-	  *  code must be  executed.  */
-	if (!(state == NODE_ALLOCATED && hNode->nodeEnv == (u32)NULL) &&
-	   nodeType != NODE_DEVICE) {
-		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+	mutex_lock(&hnode_mgr->node_mgr_lock);
+
+	state = node_get_state(hnode);
+	/*  Execute delete phase code for non-device node in all cases
+	 *  except when the node was only allocated. Delete phase must be
+	 *  executed even if create phase was executed, but failed.
+	 *  If the node environment pointer is non-NULL, the delete phase
+	 *  code must be  executed. */
+	if (!(state == NODE_ALLOCATED && hnode->node_env == (u32) NULL) &&
+	    node_type != NODE_DEVICE) {
+		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 		if (DSP_FAILED(status))
 			goto func_cont1;
 
-		if (procId == DSP_UNIT || procId == IVA_UNIT) {
+		if (proc_id == DSP_UNIT || proc_id == IVA_UNIT) {
 			/*  If node has terminated, execute phase code will
-			 *  have already been unloaded in NODE_OnExit(). If the
+			 *  have already been unloaded in node_on_exit(). If the
 			 *  node is PAUSED, the execute phase is loaded, and it
 			 *  is now ok to unload it. If the node is running, we
 			 *  will unload the execute phase only after deleting
-			 *  the node.  */
-			if (state == NODE_PAUSED && hNode->fLoaded &&
-			   hNode->fPhaseSplit) {
+			 *  the node. */
+			if (state == NODE_PAUSED && hnode->loaded &&
+			    hnode->phase_split) {
 				/* Ok to unload execute code as long as node
 				 * is not * running */
-				status1 = hNodeMgr->nldrFxns.pfnUnload(hNode->
-					  hNldrNode, NLDR_EXECUTE);
-				hNode->fLoaded = false;
-				NODE_SetState(hNode, NODE_DONE);
+				status1 =
+				    hnode_mgr->nldr_fxns.
+				    pfn_unload(hnode->nldr_node_obj,
+					       NLDR_EXECUTE);
+				hnode->loaded = false;
+				NODE_SET_STATE(hnode, NODE_DONE);
 			}
 			/* Load delete phase code if not loaded or if haven't
 			 * * unloaded EXECUTE phase */
-			if ((!(hNode->fLoaded) || (state == NODE_RUNNING)) &&
-			   hNode->fPhaseSplit) {
-				status = hNodeMgr->nldrFxns.pfnLoad(hNode->
-					 hNldrNode, NLDR_DELETE);
+			if ((!(hnode->loaded) || (state == NODE_RUNNING)) &&
+			    hnode->phase_split) {
+				status =
+				    hnode_mgr->nldr_fxns.
+				    pfn_load(hnode->nldr_node_obj, NLDR_DELETE);
 				if (DSP_SUCCEEDED(status))
-					hNode->fLoaded = true;
+					hnode->loaded = true;
 				else
 					pr_err("%s: fail - load delete code:"
-						" 0x%x\n", __func__, status);
+					       " 0x%x\n", __func__, status);
 			}
 		}
 func_cont1:
 		if (DSP_SUCCEEDED(status)) {
 			/* Unblock a thread trying to terminate the node */
-			(void)SYNC_SetEvent(hNode->hSyncDone);
-			if (procId == DSP_UNIT) {
-				/* ulDeleteFxn = address of node's delete
+			(void)sync_set_event(hnode->sync_done);
+			if (proc_id == DSP_UNIT) {
+				/* ul_delete_fxn = address of node's delete
 				 * function */
-				status = GetFxnAddress(hNode, &ulDeleteFxn,
-						      DELETEPHASE);
-			} else if (procId == IVA_UNIT)
-				ulDeleteFxn = (u32)hNode->nodeEnv;
+				status = get_fxn_address(hnode, &ul_delete_fxn,
+							 DELETEPHASE);
+			} else if (proc_id == IVA_UNIT)
+				ul_delete_fxn = (u32) hnode->node_env;
 			if (DSP_SUCCEEDED(status)) {
-				status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
-				if (procStatus.iState != PROC_ERROR) {
-					status = DISP_NodeDelete(hDisp, hNode,
-					hNodeMgr->ulFxnAddrs[RMSDELETENODE],
-					ulDeleteFxn, hNode->nodeEnv);
+				status = proc_get_state(hprocessor,
+						&proc_state,
+						sizeof(struct
+						       dsp_processorstate));
+				if (proc_state.proc_state != PROC_ERROR) {
+					status =
+					    disp_node_delete(disp_obj, hnode,
+							     hnode_mgr->
+							     ul_fxn_addrs
+							     [RMSDELETENODE],
+							     ul_delete_fxn,
+							     hnode->node_env);
 				} else
-					NODE_SetState(hNode, NODE_DONE);
+					NODE_SET_STATE(hnode, NODE_DONE);
 
 				/* Unload execute, if not unloaded, and delete
 				 * function */
 				if (state == NODE_RUNNING &&
-				   hNode->fPhaseSplit) {
-					status1 = hNodeMgr->nldrFxns.pfnUnload(
-						hNode->hNldrNode, NLDR_EXECUTE);
+				    hnode->phase_split) {
+					status1 =
+					    hnode_mgr->nldr_fxns.
+					    pfn_unload(hnode->nldr_node_obj,
+						       NLDR_EXECUTE);
 				}
 				if (DSP_FAILED(status1))
 					pr_err("%s: fail - unload execute code:"
-						" 0x%x\n", __func__, status1);
+					       " 0x%x\n", __func__, status1);
 
-				status1 = hNodeMgr->nldrFxns.pfnUnload(
-					  hNode->hNldrNode, NLDR_DELETE);
-				hNode->fLoaded = false;
+				status1 =
+				    hnode_mgr->nldr_fxns.pfn_unload(hnode->
+							    nldr_node_obj,
+							    NLDR_DELETE);
+				hnode->loaded = false;
 				if (DSP_FAILED(status1))
 					pr_err("%s: fail - unload delete code: "
-						"0x%x\n", __func__, status1);
+					       "0x%x\n", __func__, status1);
 			}
 		}
 	}
 	/* Free host side resources even if a failure occurred */
-	/* Remove node from hNodeMgr->nodeList */
-	LST_RemoveElem(hNodeMgr->nodeList, (struct list_head *) hNode);
-	hNodeMgr->uNumNodes--;
+	/* Remove node from hnode_mgr->node_list */
+	lst_remove_elem(hnode_mgr->node_list, (struct list_head *)hnode);
+	hnode_mgr->num_nodes--;
 	/* Decrement count of nodes created on DSP */
 	if ((state != NODE_ALLOCATED) || ((state == NODE_ALLOCATED) &&
-	(hNode->nodeEnv != (u32) NULL)))
-		hNodeMgr->uNumCreated--;
-	 /*  Free host-side resources allocated by NODE_Create()
-	 *  DeleteNode() fails if SM buffers not freed by client!  */
-	if (DRV_GetNodeResElement(hNode, &nodeRes, pr_ctxt) != DSP_ENOTFOUND)
-		DRV_ProcNodeUpdateStatus(nodeRes, false);
-	DeleteNode(hNode, pr_ctxt);
-
-	DRV_RemoveNodeResElement(nodeRes, pr_ctxt);
+					  (hnode->node_env != (u32) NULL)))
+		hnode_mgr->num_created--;
+	/*  Free host-side resources allocated by node_create()
+	 *  delete_node() fails if SM buffers not freed by client! */
+	if (drv_get_node_res_element(hnode, &node_res, pr_ctxt) !=
+	    DSP_ENOTFOUND)
+		drv_proc_node_update_status(node_res, false);
+	delete_node(hnode, pr_ctxt);
+
+	drv_remove_node_res_element(node_res, pr_ctxt);
 	/* Exit critical section */
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
-	PROC_NotifyClients(hProcessor, DSP_NODESTATECHANGE);
+	mutex_unlock(&hnode_mgr->node_mgr_lock);
+	proc_notify_clients(hprocessor, DSP_NODESTATECHANGE);
 func_end:
-	dev_dbg(bridge, "%s: hNode: %p status 0x%x\n", __func__, hNode, status);
+	dev_dbg(bridge, "%s: hnode: %p status 0x%x\n", __func__, hnode, status);
 	return status;
 }
 
 /*
- *  ======== NODE_DeleteMgr ========
+ *  ======== node_delete_mgr ========
  *  Purpose:
  *      Delete the NODE Manager.
  */
-DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr)
+dsp_status node_delete_mgr(struct node_mgr *hnode_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
-		DeleteNodeMgr(hNodeMgr);
+	if (MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE))
+		delete_node_mgr(hnode_mgr);
 	else
 		status = DSP_EHANDLE;
 
@@ -1553,191 +1613,188 @@ DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr)
 }
 
 /*
- *  ======== NODE_EnumNodes ========
+ *  ======== node_enum_nodes ========
  *  Purpose:
  *      Enumerate currently allocated nodes.
  */
-DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr, void **aNodeTab,
-			 u32 uNodeTabSize, OUT u32 *puNumNodes,
-			 OUT u32 *puAllocated)
+dsp_status node_enum_nodes(struct node_mgr *hnode_mgr, void **node_tab,
+			   u32 node_tab_size, OUT u32 *pu_num_nodes,
+			   OUT u32 *pu_allocated)
 {
-	struct NODE_OBJECT *hNode;
+	struct node_object *hnode;
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(aNodeTab != NULL || uNodeTabSize == 0);
-	DBC_Require(puNumNodes != NULL);
-	DBC_Require(puAllocated != NULL);
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(node_tab != NULL || node_tab_size == 0);
+	DBC_REQUIRE(pu_num_nodes != NULL);
+	DBC_REQUIRE(pu_allocated != NULL);
 
-	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
-	if (DSP_SUCCEEDED(status)) {
-		if (hNodeMgr->uNumNodes > uNodeTabSize) {
-			*puAllocated = hNodeMgr->uNumNodes;
-			*puNumNodes = 0;
-			status = DSP_ESIZE;
-		} else {
-			hNode = (struct NODE_OBJECT *)LST_First(hNodeMgr->
-				nodeList);
-			for (i = 0; i < hNodeMgr->uNumNodes; i++) {
-				DBC_Assert(MEM_IsValidHandle(hNode,
-					  NODE_SIGNATURE));
-				aNodeTab[i] = hNode;
-				hNode = (struct NODE_OBJECT *)LST_Next
-					(hNodeMgr->nodeList,
-					(struct list_head *)hNode);
-			}
-			*puAllocated = *puNumNodes = hNodeMgr->uNumNodes;
-		}
-	}
-	/* end of SYNC_EnterCS */
+	mutex_lock(&hnode_mgr->node_mgr_lock);
+
+	if (hnode_mgr->num_nodes > node_tab_size) {
+		*pu_allocated = hnode_mgr->num_nodes;
+		*pu_num_nodes = 0;
+		status = DSP_ESIZE;
+	} else {
+		hnode = (struct node_object *)lst_first(hnode_mgr->
+			node_list);
+		for (i = 0; i < hnode_mgr->num_nodes; i++) {
+			DBC_ASSERT(MEM_IS_VALID_HANDLE(hnode,
+				  NODE_SIGNATURE));
+			node_tab[i] = hnode;
+			hnode = (struct node_object *)lst_next
+				(hnode_mgr->node_list,
+				(struct list_head *)hnode);
+		}
+		*pu_allocated = *pu_num_nodes = hnode_mgr->num_nodes;
+	}
+	/* end of sync_enter_cs */
 	/* Exit critical section */
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	mutex_unlock(&hnode_mgr->node_mgr_lock);
 func_end:
 	return status;
 }
 
 /*
- *  ======== NODE_Exit ========
+ *  ======== node_exit ========
  *  Purpose:
  *      Discontinue usage of NODE module.
  */
-void NODE_Exit(void)
+void node_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== NODE_FreeMsgBuf ========
+ *  ======== node_free_msg_buf ========
  *  Purpose:
  *      Frees the message buffer.
  */
-DSP_STATUS NODE_FreeMsgBuf(struct NODE_OBJECT *hNode, IN u8 *pBuffer,
-				 OPTIONAL struct DSP_BUFFERATTR *pAttr)
+dsp_status node_free_msg_buf(struct node_object *hnode, IN u8 * pbuffer,
+			     OPTIONAL struct dsp_bufferattr *pattr)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId;
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBuffer != NULL);
-	DBC_Require(pNode != NULL);
-	DBC_Require(pNode->hXlator != NULL);
-
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_object *pnode = (struct node_object *)hnode;
+	dsp_status status = DSP_SOK;
+	u32 proc_id;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pbuffer != NULL);
+	DBC_REQUIRE(pnode != NULL);
+	DBC_REQUIRE(pnode->xlator != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
-	if (procId == DSP_UNIT) {
+	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+	if (proc_id == DSP_UNIT) {
 		if (DSP_SUCCEEDED(status)) {
-			if (pAttr == NULL) {
+			if (pattr == NULL) {
 				/* set defaults */
-				pAttr = &NODE_DFLTBUFATTRS;
+				pattr = &node_dfltbufattrs;
 			}
-			 /* Node supports single SM segment only */
-			if (pAttr->uSegment != 1)
+			/* Node supports single SM segment only */
+			if (pattr->segment_id != 1)
 				status = DSP_EBADSEGID;
 
-			/* pBuffer is clients Va. */
-			status = CMM_XlatorFreeBuf(pNode->hXlator, pBuffer);
+			/* pbuffer is clients Va. */
+			status = cmm_xlator_free_buf(pnode->xlator, pbuffer);
 		}
 	} else {
-		DBC_Assert(NULL);	/* BUG */
+		DBC_ASSERT(NULL);	/* BUG */
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== NODE_GetAttr ========
+ *  ======== node_get_attr ========
  *  Purpose:
- *      Copy the current attributes of the specified node into a DSP_NODEATTR
+ *      Copy the current attributes of the specified node into a dsp_nodeattr
  *      structure.
  */
-DSP_STATUS NODE_GetAttr(struct NODE_OBJECT *hNode,
-			OUT struct DSP_NODEATTR *pAttr, u32 uAttrSize)
+dsp_status node_get_attr(struct node_object *hnode,
+			 OUT struct dsp_nodeattr *pattr, u32 attr_size)
 {
-	struct NODE_MGR *hNodeMgr;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAttr != NULL);
-	DBC_Require(uAttrSize >= sizeof(struct DSP_NODEATTR));
+	struct node_mgr *hnode_mgr;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pattr != NULL);
+	DBC_REQUIRE(attr_size >= sizeof(struct dsp_nodeattr));
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		hNodeMgr = hNode->hNodeMgr;
-		 /* Enter hNodeMgr critical section (since we're accessing
-		  * data that could be changed by NODE_ChangePriority() and
-		  * NODE_Connect().  */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
-		if (DSP_SUCCEEDED(status)) {
-			pAttr->cbStruct = sizeof(struct DSP_NODEATTR);
-			/* DSP_NODEATTRIN */
-			pAttr->inNodeAttrIn.cbStruct =
-					 sizeof(struct DSP_NODEATTRIN);
-			pAttr->inNodeAttrIn.iPriority = hNode->nPriority;
-			pAttr->inNodeAttrIn.uTimeout = hNode->uTimeout;
-			pAttr->inNodeAttrIn.uHeapSize =
-				hNode->createArgs.asa.taskArgs.uHeapSize;
-			pAttr->inNodeAttrIn.pGPPVirtAddr = (void *)
-				hNode->createArgs.asa.taskArgs.uGPPHeapAddr;
-			pAttr->uInputs = hNode->uNumGPPInputs;
-			pAttr->uOutputs = hNode->uNumGPPOutputs;
-			/* DSP_NODEINFO */
-			GetNodeInfo(hNode, &(pAttr->iNodeInfo));
-		}
-		/* end of SYNC_EnterCS */
+		hnode_mgr = hnode->hnode_mgr;
+		/* Enter hnode_mgr critical section (since we're accessing
+		 * data that could be changed by node_change_priority() and
+		 * node_connect(). */
+		mutex_lock(&hnode_mgr->node_mgr_lock);
+		pattr->cb_struct = sizeof(struct dsp_nodeattr);
+		/* dsp_nodeattrin */
+		pattr->in_node_attr_in.cb_struct =
+				 sizeof(struct dsp_nodeattrin);
+		pattr->in_node_attr_in.prio = hnode->prio;
+		pattr->in_node_attr_in.utimeout = hnode->utimeout;
+		pattr->in_node_attr_in.heap_size =
+			hnode->create_args.asa.task_arg_obj.heap_size;
+		pattr->in_node_attr_in.pgpp_virt_addr = (void *)
+			hnode->create_args.asa.task_arg_obj.ugpp_heap_addr;
+		pattr->node_attr_inputs = hnode->num_gpp_inputs;
+		pattr->node_attr_outputs = hnode->num_gpp_outputs;
+		/* dsp_nodeinfo */
+		get_node_info(hnode, &(pattr->node_info));
+		/* end of sync_enter_cs */
 		/* Exit critical section */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		mutex_unlock(&hnode_mgr->node_mgr_lock);
 	}
 	return status;
 }
 
 /*
- *  ======== NODE_GetChannelId ========
+ *  ======== node_get_channel_id ========
  *  Purpose:
  *      Get the channel index reserved for a stream connection between the
  *      host and a node.
  */
-DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
-			    OUT u32 *pulId)
+dsp_status node_get_channel_id(struct node_object *hnode, u32 dir, u32 index,
+			       OUT u32 *pulId)
 {
-	enum NODE_TYPE nodeType;
-	DSP_STATUS status = DSP_EVALUE;
-	DBC_Require(cRefs > 0);
-	DBC_Require(uDir == DSP_TONODE || uDir == DSP_FROMNODE);
-	DBC_Require(pulId != NULL);
+	enum node_type node_type;
+	dsp_status status = DSP_EVALUE;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(dir == DSP_TONODE || dir == DSP_FROMNODE);
+	DBC_REQUIRE(pulId != NULL);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
-	nodeType = NODE_GetType(hNode);
-	if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET) {
+	node_type = node_get_type(hnode);
+	if (node_type != NODE_TASK && node_type != NODE_DAISSOCKET) {
 		status = DSP_ENODETYPE;
 		return status;
 	}
-	if (uDir == DSP_TONODE) {
-		if (uIndex < MaxInputs(hNode)) {
-			if (hNode->inputs[uIndex].type == HOSTCONNECT) {
-				*pulId = hNode->inputs[uIndex].devId;
+	if (dir == DSP_TONODE) {
+		if (index < MAX_INPUTS(hnode)) {
+			if (hnode->inputs[index].type == HOSTCONNECT) {
+				*pulId = hnode->inputs[index].dev_id;
 				status = DSP_SOK;
 			}
 		}
 	} else {
-		DBC_Assert(uDir == DSP_FROMNODE);
-		if (uIndex < MaxOutputs(hNode)) {
-			if (hNode->outputs[uIndex].type == HOSTCONNECT) {
-				*pulId = hNode->outputs[uIndex].devId;
+		DBC_ASSERT(dir == DSP_FROMNODE);
+		if (index < MAX_OUTPUTS(hnode)) {
+			if (hnode->outputs[index].type == HOSTCONNECT) {
+				*pulId = hnode->outputs[index].dev_id;
 				status = DSP_SOK;
 			}
 		}
@@ -1746,69 +1803,71 @@ DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
 }
 
 /*
- *  ======== NODE_GetMessage ========
+ *  ======== node_get_message ========
  *  Purpose:
  *      Retrieve a message from a node on the DSP.
  */
-DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode, OUT struct DSP_MSG *pMsg,
-			  u32 uTimeout)
+dsp_status node_get_message(struct node_object *hnode,
+			    OUT struct dsp_msg *pmsg, u32 utimeout)
 {
-	struct NODE_MGR *hNodeMgr;
-	enum NODE_TYPE nodeType;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-	void *pTmpBuf;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pMsg != NULL);
-
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_mgr *hnode_mgr;
+	enum node_type node_type;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
+	void *tmp_buf;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pmsg != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hProcessor = hNode->hProcessor;
-	status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+	hprocessor = hnode->hprocessor;
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt to get the
-	    message */
-	if (procStatus.iState == PROC_ERROR) {
+	   message */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	hNodeMgr = hNode->hNodeMgr;
-	nodeType = NODE_GetType(hNode);
-	if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
-	   nodeType != NODE_DAISSOCKET) {
+	hnode_mgr = hnode->hnode_mgr;
+	node_type = node_get_type(hnode);
+	if (node_type != NODE_MESSAGE && node_type != NODE_TASK &&
+	    node_type != NODE_DAISSOCKET) {
 		status = DSP_ENODETYPE;
 		goto func_end;
 	}
-	 /*  This function will block unless a message is available. Since
+	/*  This function will block unless a message is available. Since
 	 *  DSPNode_RegisterNotify() allows notification when a message
 	 *  is available, the system can be designed so that
 	 *  DSPNode_GetMessage() is only called when a message is
-	 *  available.  */
-	pIntfFxns = hNodeMgr->pIntfFxns;
-	status = (*pIntfFxns->pfnMsgGet)(hNode->hMsgQueue, pMsg, uTimeout);
+	 *  available. */
+	intf_fxns = hnode_mgr->intf_fxns;
+	status =
+	    (*intf_fxns->pfn_msg_get) (hnode->msg_queue_obj, pmsg, utimeout);
 	/* Check if message contains SM descriptor */
-	if (DSP_FAILED(status) ||  !(pMsg->dwCmd & DSP_RMSBUFDESC))
+	if (DSP_FAILED(status) || !(pmsg->dw_cmd & DSP_RMSBUFDESC))
 		goto func_end;
 
-	 /* Translate DSP byte addr to GPP Va.  */
-	pTmpBuf = CMM_XlatorTranslate(hNode->hXlator,
-		(void *)(pMsg->dwArg1 * hNode->hNodeMgr->uDSPWordSize),
-		CMM_DSPPA2PA);
-	if (pTmpBuf  != NULL) {
+	/* Translate DSP byte addr to GPP Va. */
+	tmp_buf = cmm_xlator_translate(hnode->xlator,
+				       (void *)(pmsg->dw_arg1 *
+						hnode->hnode_mgr->
+						udsp_word_size), CMM_DSPPA2PA);
+	if (tmp_buf != NULL) {
 		/* now convert this GPP Pa to Va */
-		pTmpBuf = CMM_XlatorTranslate(hNode->hXlator, pTmpBuf,
-							CMM_PA2VA);
-		if (pTmpBuf != NULL) {
+		tmp_buf = cmm_xlator_translate(hnode->xlator, tmp_buf,
+					       CMM_PA2VA);
+		if (tmp_buf != NULL) {
 			/* Adjust SM size in msg */
-			pMsg->dwArg1 = (u32) pTmpBuf;
-			pMsg->dwArg2 *= hNode->hNodeMgr->uDSPWordSize;
+			pmsg->dw_arg1 = (u32) tmp_buf;
+			pmsg->dw_arg2 *= hnode->hnode_mgr->udsp_word_size;
 		} else {
 			status = DSP_ETRANSLATE;
 		}
@@ -1816,308 +1875,306 @@ DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode, OUT struct DSP_MSG *pMsg,
 		status = DSP_ETRANSLATE;
 	}
 func_end:
-	dev_dbg(bridge, "%s: hNode: %p pMsg: %p uTimeout: 0x%x\n", __func__,
-							hNode, pMsg, uTimeout);
+	dev_dbg(bridge, "%s: hnode: %p pmsg: %p utimeout: 0x%x\n", __func__,
+		hnode, pmsg, utimeout);
 	return status;
 }
 
 /*
- *   ======== NODE_GetNldrObj ========
+ *   ======== node_get_nldr_obj ========
  */
-DSP_STATUS NODE_GetNldrObj(struct NODE_MGR *hNodeMgr,
-			  struct NLDR_OBJECT **phNldrObj)
+dsp_status node_get_nldr_obj(struct node_mgr *hnode_mgr,
+			     struct nldr_object **phNldrObj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_MGR *pNodeMgr = hNodeMgr;
-	DBC_Require(phNldrObj != NULL);
+	dsp_status status = DSP_SOK;
+	struct node_mgr *node_mgr_obj = hnode_mgr;
+	DBC_REQUIRE(phNldrObj != NULL);
 
-	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE))
 		status = DSP_EHANDLE;
 	else
-		*phNldrObj = pNodeMgr->hNldr;
+		*phNldrObj = node_mgr_obj->nldr_obj;
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phNldrObj != NULL) &&
-		  (*phNldrObj == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phNldrObj != NULL) &&
+					     (*phNldrObj == NULL)));
 	return status;
 }
 
 /*
- *  ======== NODE_GetStrmMgr ========
+ *  ======== node_get_strm_mgr ========
  *  Purpose:
  *      Returns the Stream manager.
  */
-DSP_STATUS NODE_GetStrmMgr(struct NODE_OBJECT *hNode,
-			  struct STRM_MGR **phStrmMgr)
+dsp_status node_get_strm_mgr(struct node_object *hnode,
+			     struct strm_mgr **phStrmMgr)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE))
 		status = DSP_EHANDLE;
 	else
-		*phStrmMgr = hNode->hNodeMgr->hStrmMgr;
+		*phStrmMgr = hnode->hnode_mgr->strm_mgr_obj;
 
 	return status;
 }
 
 /*
- *  ======== NODE_GetLoadType ========
+ *  ======== node_get_load_type ========
  */
-enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode)
+enum nldr_loadtype node_get_load_type(struct node_object *hnode)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		dev_dbg(bridge, "%s: Failed. hNode: %p\n", __func__, hNode);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
+		dev_dbg(bridge, "%s: Failed. hnode: %p\n", __func__, hnode);
 		return -1;
 	} else {
-		return hNode->dcdProps.objData.nodeObj.usLoadType;
+		return hnode->dcd_props.obj_data.node_obj.us_load_type;
 	}
 }
 
 /*
- *  ======== NODE_GetTimeout ========
+ *  ======== node_get_timeout ========
  *  Purpose:
  *      Returns the timeout value for this node.
  */
-u32 NODE_GetTimeout(struct NODE_OBJECT *hNode)
+u32 node_get_timeout(struct node_object *hnode)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		dev_dbg(bridge, "%s: failed. hNode: %p\n", __func__, hNode);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
+		dev_dbg(bridge, "%s: failed. hnode: %p\n", __func__, hnode);
 		return 0;
 	} else {
-		return hNode->uTimeout;
+		return hnode->utimeout;
 	}
 }
 
 /*
- *  ======== NODE_GetType ========
+ *  ======== node_get_type ========
  *  Purpose:
  *      Returns the node type.
  */
-enum NODE_TYPE NODE_GetType(struct NODE_OBJECT *hNode)
+enum node_type node_get_type(struct node_object *hnode)
 {
-	enum NODE_TYPE nodeType;
+	enum node_type node_type;
 
-	if (hNode == (struct NODE_OBJECT *) DSP_HGPPNODE)
-		nodeType = NODE_GPP;
+	if (hnode == (struct node_object *)DSP_HGPPNODE)
+		node_type = NODE_GPP;
 	else {
-		if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
-			nodeType = -1;
+		if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE))
+			node_type = -1;
 		else
-			nodeType = hNode->nType;
+			node_type = hnode->ntype;
 	}
-	return nodeType;
+	return node_type;
 }
 
 /*
- *  ======== NODE_Init ========
+ *  ======== node_init ========
  *  Purpose:
  *      Initialize the NODE module.
  */
-bool NODE_Init(void)
+bool node_init(void)
 {
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	cRefs++;
+	refs++;
 
 	return true;
 }
 
 /*
- *  ======== NODE_OnExit ========
+ *  ======== node_on_exit ========
  *  Purpose:
  *      Gets called when RMS_EXIT is received for a node.
  */
-void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus)
+void node_on_exit(struct node_object *hnode, s32 nStatus)
 {
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE))
 		return;
 
 	/* Set node state to done */
-	NODE_SetState(hNode, NODE_DONE);
-	hNode->nExitStatus = nStatus;
-	if (hNode->fLoaded && hNode->fPhaseSplit) {
-		(void)hNode->hNodeMgr->nldrFxns.pfnUnload(hNode->hNldrNode,
-							 NLDR_EXECUTE);
-		hNode->fLoaded = false;
-	}
-	/* Unblock call to NODE_Terminate */
-	(void) SYNC_SetEvent(hNode->hSyncDone);
+	NODE_SET_STATE(hnode, NODE_DONE);
+	hnode->exit_status = nStatus;
+	if (hnode->loaded && hnode->phase_split) {
+		(void)hnode->hnode_mgr->nldr_fxns.pfn_unload(hnode->
+							     nldr_node_obj,
+							     NLDR_EXECUTE);
+		hnode->loaded = false;
+	}
+	/* Unblock call to node_terminate */
+	(void)sync_set_event(hnode->sync_done);
 	/* Notify clients */
-	PROC_NotifyClients(hNode->hProcessor, DSP_NODESTATECHANGE);
-	NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+	proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+	ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 }
 
 /*
- *  ======== NODE_Pause ========
+ *  ======== node_pause ========
  *  Purpose:
  *      Suspend execution of a node currently running on the DSP.
  */
-DSP_STATUS NODE_Pause(struct NODE_OBJECT *hNode)
+dsp_status node_pause(struct node_object *hnode)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	enum NODE_TYPE nodeType;
-	enum NODE_STATE state;
-	struct NODE_MGR *hNodeMgr;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
-
-	DBC_Require(cRefs > 0);
-
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_object *pnode = (struct node_object *)hnode;
+	enum node_type node_type;
+	enum node_state state;
+	struct node_mgr *hnode_mgr;
+	dsp_status status = DSP_SOK;
+	u32 proc_id;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
+
+	DBC_REQUIRE(refs > 0);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		nodeType = NODE_GetType(hNode);
-		if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
+		node_type = node_get_type(hnode);
+		if (node_type != NODE_TASK && node_type != NODE_DAISSOCKET)
 			status = DSP_ENODETYPE;
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 
-	if (procId == IVA_UNIT)
+	if (proc_id == IVA_UNIT)
 		status = DSP_ENOTIMPL;
 
 	if (DSP_SUCCEEDED(status)) {
-		hNodeMgr = hNode->hNodeMgr;
+		hnode_mgr = hnode->hnode_mgr;
 
 		/* Enter critical section */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		mutex_lock(&hnode_mgr->node_mgr_lock);
+		state = node_get_state(hnode);
+		/* Check node state */
+		if (state != NODE_RUNNING)
+			status = DSP_EWRONGSTATE;
 
-		if (DSP_SUCCEEDED(status)) {
-			state = NODE_GetState(hNode);
-			/* Check node state */
-			if (state != NODE_RUNNING)
-				status = DSP_EWRONGSTATE;
+		if (DSP_FAILED(status))
+			goto func_cont;
+		hprocessor = hnode->hprocessor;
+		status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
+		if (DSP_FAILED(status))
+			goto func_cont;
+		/* If processor is in error state then don't attempt
+		   to send the message */
+		if (proc_state.proc_state == PROC_ERROR) {
+			status = DSP_EFAIL;
+			goto func_cont;
+		}
 
-			if (DSP_FAILED(status))
-				goto func_cont;
-			hProcessor = hNode->hProcessor;
-			status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
-			if (DSP_FAILED(status))
-				goto func_cont;
-			/* If processor is in error state then don't attempt
-			    to send the message */
-			if (procStatus.iState == PROC_ERROR) {
-				status = DSP_EFAIL;
-				goto func_cont;
-			}
-			if (DSP_SUCCEEDED(status)) {
-				status = DISP_NodeChangePriority(hNodeMgr->
-				   hDisp, hNode,
-				   hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY],
-				   hNode->nodeEnv, NODE_SUSPENDEDPRI);
-			}
+		status = disp_node_change_priority(hnode_mgr->disp_obj, hnode,
+			hnode_mgr->ul_fxn_addrs[RMSCHANGENODEPRIORITY],
+			hnode->node_env, NODE_SUSPENDEDPRI);
+
+		/* Update state */
+		if (DSP_SUCCEEDED(status))
+			NODE_SET_STATE(hnode, NODE_PAUSED);
 
-			/* Update state */
-			if (DSP_SUCCEEDED(status))
-				NODE_SetState(hNode, NODE_PAUSED);
-		}
 func_cont:
-		/* End of SYNC_EnterCS */
+		/* End of sync_enter_cs */
 		/* Leave critical section */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		mutex_unlock(&hnode_mgr->node_mgr_lock);
 		if (DSP_SUCCEEDED(status)) {
-			PROC_NotifyClients(hNode->hProcessor,
-					  DSP_NODESTATECHANGE);
-			NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+			proc_notify_clients(hnode->hprocessor,
+					    DSP_NODESTATECHANGE);
+			ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 		}
 	}
 func_end:
-	dev_dbg(bridge, "%s: hNode: %p status 0x%x\n", __func__, hNode, status);
+	dev_dbg(bridge, "%s: hnode: %p status 0x%x\n", __func__, hnode, status);
 	return status;
 }
 
 /*
- *  ======== NODE_PutMessage ========
+ *  ======== node_put_message ========
  *  Purpose:
  *      Send a message to a message node, task node, or XDAIS socket node. This
  *      function will block until the message stream can accommodate the
  *      message, or a timeout occurs.
  */
-DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
-			  IN CONST struct DSP_MSG *pMsg, u32 uTimeout)
+dsp_status node_put_message(struct node_object *hnode,
+			    IN CONST struct dsp_msg *pmsg, u32 utimeout)
 {
-	struct NODE_MGR *hNodeMgr = NULL;
-	enum NODE_TYPE nodeType;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	enum NODE_STATE state;
-	DSP_STATUS status = DSP_SOK;
-	void *pTmpBuf;
-	struct DSP_MSG newMsg;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pMsg != NULL);
-
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_mgr *hnode_mgr = NULL;
+	enum node_type node_type;
+	struct bridge_drv_interface *intf_fxns;
+	enum node_state state;
+	dsp_status status = DSP_SOK;
+	void *tmp_buf;
+	struct dsp_msg new_msg;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pmsg != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hProcessor = hNode->hProcessor;
-	status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+	hprocessor = hnode->hprocessor;
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in bad state then don't attempt sending the
-	    message */
-	if (procStatus.iState == PROC_ERROR) {
+	   message */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	hNodeMgr = hNode->hNodeMgr;
-	nodeType = NODE_GetType(hNode);
-	if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
-	    nodeType != NODE_DAISSOCKET)
+	hnode_mgr = hnode->hnode_mgr;
+	node_type = node_get_type(hnode);
+	if (node_type != NODE_MESSAGE && node_type != NODE_TASK &&
+	    node_type != NODE_DAISSOCKET)
 		status = DSP_ENODETYPE;
 
 	if (DSP_SUCCEEDED(status)) {
 		/*  Check node state. Can't send messages to a node after
 		 *  we've sent the RMS_EXIT command. There is still the
-		 *  possibility that NODE_Terminate can be called after we've
+		 *  possibility that node_terminate can be called after we've
 		 *  checked the state. Could add another SYNC object to
-		 *  prevent this (can't use hNodeMgr->hSync, since we don't
+		 *  prevent this (can't use node_mgr_lock, since we don't
 		 *  want to block other NODE functions). However, the node may
-		 *  still exit on its own, before this message is sent.  */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
-		if (DSP_SUCCEEDED(status)) {
-			state = NODE_GetState(hNode);
-			if (state == NODE_TERMINATING || state == NODE_DONE)
-				status = DSP_EWRONGSTATE;
+		 *  still exit on its own, before this message is sent. */
+		mutex_lock(&hnode_mgr->node_mgr_lock);
+		state = node_get_state(hnode);
+		if (state == NODE_TERMINATING || state == NODE_DONE)
+			status = DSP_EWRONGSTATE;
 
-		}
-		/* end of SYNC_EnterCS */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		/* end of sync_enter_cs */
+		mutex_unlock(&hnode_mgr->node_mgr_lock);
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	/* assign pMsg values to new msg  */
-	newMsg = *pMsg;
+	/* assign pmsg values to new msg */
+	new_msg = *pmsg;
 	/* Now, check if message contains a SM buffer descriptor */
-	if (pMsg->dwCmd & DSP_RMSBUFDESC) {
+	if (pmsg->dw_cmd & DSP_RMSBUFDESC) {
 		/* Translate GPP Va to DSP physical buf Ptr. */
-		pTmpBuf = CMM_XlatorTranslate(hNode->hXlator,
-			(void *)newMsg.dwArg1, CMM_VA2DSPPA);
-		if (pTmpBuf != NULL) {
+		tmp_buf = cmm_xlator_translate(hnode->xlator,
+					       (void *)new_msg.dw_arg1,
+					       CMM_VA2DSPPA);
+		if (tmp_buf != NULL) {
 			/* got translation, convert to MAUs in msg */
-			if (hNode->hNodeMgr->uDSPWordSize != 0) {
-				newMsg.dwArg1 =
-					(u32)pTmpBuf /
-					hNode->hNodeMgr->uDSPWordSize;
+			if (hnode->hnode_mgr->udsp_word_size != 0) {
+				new_msg.dw_arg1 =
+				    (u32) tmp_buf /
+				    hnode->hnode_mgr->udsp_word_size;
 				/* MAUs */
-				newMsg.dwArg2 /= hNode->hNodeMgr->uDSPWordSize;
+				new_msg.dw_arg2 /= hnode->hnode_mgr->
+				    udsp_word_size;
 			} else {
-				pr_err("%s: uDSPWordSize is zero!\n", __func__);
+				pr_err("%s: udsp_word_size is zero!\n",
+				       __func__);
 				status = DSP_EFAIL;	/* bad DSPWordSize */
 			}
 		} else {	/* failed to translate buffer address */
@@ -2125,313 +2182,312 @@ DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		pIntfFxns = hNodeMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnMsgPut)(hNode->hMsgQueue,
-			 &newMsg, uTimeout);
+		intf_fxns = hnode_mgr->intf_fxns;
+		status = (*intf_fxns->pfn_msg_put) (hnode->msg_queue_obj,
+						    &new_msg, utimeout);
 	}
 func_end:
-	dev_dbg(bridge, "%s: hNode: %p pMsg: %p uTimeout: 0x%x, "
-		"status 0x%x\n", __func__, hNode, pMsg, uTimeout, status);
+	dev_dbg(bridge, "%s: hnode: %p pmsg: %p utimeout: 0x%x, "
+		"status 0x%x\n", __func__, hnode, pmsg, utimeout, status);
 	return status;
 }
 
 /*
- *  ======== NODE_RegisterNotify ========
+ *  ======== node_register_notify ========
  *  Purpose:
  *      Register to be notified on specific events for this node.
  */
-DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode, u32 uEventMask,
-				u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification)
+dsp_status node_register_notify(struct node_object *hnode, u32 event_mask,
+				u32 notify_type,
+				struct dsp_notification *hnotification)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hNotification != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hnotification != NULL);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
 		/* Check if event mask is a valid node related event */
-		if (uEventMask & ~(DSP_NODESTATECHANGE |
-		   DSP_NODEMESSAGEREADY))
+		if (event_mask & ~(DSP_NODESTATECHANGE | DSP_NODEMESSAGEREADY))
 			status = DSP_EVALUE;
 
 		/* Check if notify type is valid */
-		if (uNotifyType != DSP_SIGNALEVENT)
+		if (notify_type != DSP_SIGNALEVENT)
 			status = DSP_EVALUE;
 
 		/* Only one Notification can be registered at a
 		 * time - Limitation */
-		if (uEventMask == (DSP_NODESTATECHANGE |
-		   DSP_NODEMESSAGEREADY))
+		if (event_mask == (DSP_NODESTATECHANGE | DSP_NODEMESSAGEREADY))
 			status = DSP_EVALUE;
 	}
 	if (DSP_SUCCEEDED(status)) {
-		if (uEventMask == DSP_NODESTATECHANGE) {
-			status = NTFY_Register(hNode->hNtfy, hNotification,
-				 uEventMask & DSP_NODESTATECHANGE, uNotifyType);
+		if (event_mask == DSP_NODESTATECHANGE) {
+			status = ntfy_register(hnode->ntfy_obj, hnotification,
+					       event_mask & DSP_NODESTATECHANGE,
+					       notify_type);
 		} else {
-			/* Send Message part of event mask to MSG */
-			pIntfFxns = hNode->hNodeMgr->pIntfFxns;
-			status = (*pIntfFxns->pfnMsgRegisterNotify)
-				 (hNode->hMsgQueue,
-				 uEventMask & DSP_NODEMESSAGEREADY, uNotifyType,
-				 hNotification);
+			/* Send Message part of event mask to msg_ctrl */
+			intf_fxns = hnode->hnode_mgr->intf_fxns;
+			status = (*intf_fxns->pfn_msg_register_notify)
+			    (hnode->msg_queue_obj,
+			     event_mask & DSP_NODEMESSAGEREADY, notify_type,
+			     hnotification);
 		}
 
 	}
-	dev_dbg(bridge, "%s: hNode: %p uEventMask: 0x%x uNotifyType: 0x%x "
-			"hNotification: %p status 0x%x\n", __func__, hNode,
-			uEventMask, uNotifyType, hNotification, status);
+	dev_dbg(bridge, "%s: hnode: %p event_mask: 0x%x notify_type: 0x%x "
+		"hnotification: %p status 0x%x\n", __func__, hnode,
+		event_mask, notify_type, hnotification, status);
 	return status;
 }
 
 /*
- *  ======== NODE_Run ========
+ *  ======== node_run ========
  *  Purpose:
  *      Start execution of a node's execute phase, or resume execution of a node
  *      that has been suspended (via NODE_NodePause()) on the DSP. Load the
  *      node's execute function if necessary.
  */
-DSP_STATUS NODE_Run(struct NODE_OBJECT *hNode)
+dsp_status node_run(struct node_object *hnode)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr;
-	enum NODE_TYPE nodeType;
-	enum NODE_STATE state;
-	u32 ulExecuteFxn;
-	u32 ulFxnAddr;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
-
-	DBC_Require(cRefs > 0);
-
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr;
+	enum node_type node_type;
+	enum node_state state;
+	u32 ul_execute_fxn;
+	u32 ul_fxn_addr;
+	dsp_status status = DSP_SOK;
+	u32 proc_id;
+	struct bridge_drv_interface *intf_fxns;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
+
+	DBC_REQUIRE(refs > 0);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hProcessor = hNode->hProcessor;
-	status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+	hprocessor = hnode->hprocessor;
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt to run the node */
-	if (procStatus.iState == PROC_ERROR) {
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	nodeType = NODE_GetType(hNode);
-	if (nodeType == NODE_DEVICE)
+	node_type = node_get_type(hnode);
+	if (node_type == NODE_DEVICE)
 		status = DSP_ENODETYPE;
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	hNodeMgr = hNode->hNodeMgr;
-	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+	hnode_mgr = hnode->hnode_mgr;
+	if (!MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	pIntfFxns = hNodeMgr->pIntfFxns;
+	intf_fxns = hnode_mgr->intf_fxns;
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
-	if (DSP_FAILED(status))
-		goto func_cont;
+	mutex_lock(&hnode_mgr->node_mgr_lock);
 
-	state = NODE_GetState(hNode);
+	state = node_get_state(hnode);
 	if (state != NODE_CREATED && state != NODE_PAUSED)
 		status = DSP_EWRONGSTATE;
 
 	if (DSP_SUCCEEDED(status))
-		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 
 	if (DSP_FAILED(status))
 		goto func_cont1;
 
-	if ((procId != DSP_UNIT) && (procId != IVA_UNIT))
+	if ((proc_id != DSP_UNIT) && (proc_id != IVA_UNIT))
 		goto func_cont1;
 
 	if (state == NODE_CREATED) {
 		/* If node's execute function is not loaded, load it */
-		if (!(hNode->fLoaded) && hNode->fPhaseSplit) {
-			status = hNodeMgr->nldrFxns.pfnLoad(hNode->hNldrNode,
-				NLDR_EXECUTE);
+		if (!(hnode->loaded) && hnode->phase_split) {
+			status =
+			    hnode_mgr->nldr_fxns.pfn_load(hnode->nldr_node_obj,
+							  NLDR_EXECUTE);
 			if (DSP_SUCCEEDED(status)) {
-				hNode->fLoaded = true;
+				hnode->loaded = true;
 			} else {
 				pr_err("%s: fail - load execute code: 0x%x\n",
-							__func__, status);
+				       __func__, status);
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Get address of node's execute function */
-			if (procId == IVA_UNIT)
-				ulExecuteFxn = (u32) hNode->nodeEnv;
+			if (proc_id == IVA_UNIT)
+				ul_execute_fxn = (u32) hnode->node_env;
 			else {
-				status = GetFxnAddress(hNode, &ulExecuteFxn,
-					 EXECUTEPHASE);
+				status = get_fxn_address(hnode, &ul_execute_fxn,
+							 EXECUTEPHASE);
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
-			ulFxnAddr = hNodeMgr->ulFxnAddrs[RMSEXECUTENODE];
-			status = DISP_NodeRun(hNodeMgr->hDisp, hNode, ulFxnAddr,
-					     ulExecuteFxn, hNode->nodeEnv);
+			ul_fxn_addr = hnode_mgr->ul_fxn_addrs[RMSEXECUTENODE];
+			status =
+			    disp_node_run(hnode_mgr->disp_obj, hnode,
+					  ul_fxn_addr, ul_execute_fxn,
+					  hnode->node_env);
 		}
 	} else if (state == NODE_PAUSED) {
-		ulFxnAddr = hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY];
-		status = DISP_NodeChangePriority(hNodeMgr->hDisp, hNode,
-						ulFxnAddr, hNode->nodeEnv,
-						NODE_GetPriority(hNode));
+		ul_fxn_addr = hnode_mgr->ul_fxn_addrs[RMSCHANGENODEPRIORITY];
+		status = disp_node_change_priority(hnode_mgr->disp_obj, hnode,
+						   ul_fxn_addr, hnode->node_env,
+						   NODE_GET_PRIORITY(hnode));
 	} else {
 		/* We should never get here */
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 	}
 func_cont1:
 	/* Update node state. */
 	if (DSP_SUCCEEDED(status))
-		NODE_SetState(hNode, NODE_RUNNING);
-	 else /* Set state back to previous value */
-		NODE_SetState(hNode, state);
-	/*End of SYNC_EnterCS */
+		NODE_SET_STATE(hnode, NODE_RUNNING);
+	else			/* Set state back to previous value */
+		NODE_SET_STATE(hnode, state);
+	/*End of sync_enter_cs */
 	/* Exit critical section */
-func_cont:
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	mutex_unlock(&hnode_mgr->node_mgr_lock);
 	if (DSP_SUCCEEDED(status)) {
-		PROC_NotifyClients(hNode->hProcessor,
-			  DSP_NODESTATECHANGE);
-		NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+		proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+		ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 	}
 func_end:
-	dev_dbg(bridge, "%s: hNode: %p status 0x%x\n", __func__, hNode, status);
+	dev_dbg(bridge, "%s: hnode: %p status 0x%x\n", __func__, hnode, status);
 	return status;
 }
 
 /*
- *  ======== NODE_Terminate ========
+ *  ======== node_terminate ========
  *  Purpose:
  *      Signal a node running on the DSP that it should exit its execute phase
  *      function.
  */
-DSP_STATUS NODE_Terminate(struct NODE_OBJECT *hNode, OUT DSP_STATUS *pStatus)
+dsp_status node_terminate(struct node_object *hnode, OUT dsp_status *pstatus)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr = NULL;
-	enum NODE_TYPE nodeType;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	enum NODE_STATE state;
-	struct DSP_MSG msg, killmsg;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId, killTimeOut;
-	struct DEH_MGR *hDehMgr;
-	struct DSP_PROCESSORSTATE procStatus;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pStatus != NULL);
-
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE) || !hNode->hNodeMgr) {
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr = NULL;
+	enum node_type node_type;
+	struct bridge_drv_interface *intf_fxns;
+	enum node_state state;
+	struct dsp_msg msg, killmsg;
+	dsp_status status = DSP_SOK;
+	u32 proc_id, kill_time_out;
+	struct deh_mgr *hdeh_mgr;
+	struct dsp_processorstate proc_state;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pstatus != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE) || !hnode->hnode_mgr) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	if (pNode->hProcessor == NULL) {
+	if (pnode->hprocessor == NULL) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 
 	if (DSP_SUCCEEDED(status)) {
-		hNodeMgr = hNode->hNodeMgr;
-		nodeType = NODE_GetType(hNode);
-		if (nodeType != NODE_TASK && nodeType !=
-			   NODE_DAISSOCKET)
-				status = DSP_ENODETYPE;
+		hnode_mgr = hnode->hnode_mgr;
+		node_type = node_get_type(hnode);
+		if (node_type != NODE_TASK && node_type != NODE_DAISSOCKET)
+			status = DSP_ENODETYPE;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Check node state */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
-		if (DSP_SUCCEEDED(status)) {
-			state = NODE_GetState(hNode);
-			if (state != NODE_RUNNING) {
-				status = DSP_EWRONGSTATE;
-				/* Set the exit status if node terminated on
-				 * its own. */
-				if (state == NODE_DONE)
-					*pStatus = hNode->nExitStatus;
+		mutex_lock(&hnode_mgr->node_mgr_lock);
+		state = node_get_state(hnode);
+		if (state != NODE_RUNNING) {
+			status = DSP_EWRONGSTATE;
+			/* Set the exit status if node terminated on
+			 * its own. */
+			if (state == NODE_DONE)
+				*pstatus = hnode->exit_status;
 
-			} else {
-				NODE_SetState(hNode, NODE_TERMINATING);
-			}
+		} else {
+			NODE_SET_STATE(hnode, NODE_TERMINATING);
 		}
-		/* end of SYNC_EnterCS */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		/* end of sync_enter_cs */
+		mutex_unlock(&hnode_mgr->node_mgr_lock);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/*
 		 *  Send exit message. Do not change state to NODE_DONE
 		 *  here. That will be done in callback.
 		 */
-		status = PROC_GetState(pNode->hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+		status = proc_get_state(pnode->hprocessor, &proc_state,
+					sizeof(struct dsp_processorstate));
 		if (DSP_FAILED(status))
 			goto func_cont;
 		/* If processor is in error state then don't attempt to send
 		 * A kill task command */
-		if (procStatus.iState == PROC_ERROR) {
+		if (proc_state.proc_state == PROC_ERROR) {
 			status = DSP_EFAIL;
 			goto func_cont;
 		}
 
-		msg.dwCmd = RMS_EXIT;
-		msg.dwArg1 = hNode->nodeEnv;
-		killmsg.dwCmd = RMS_KILLTASK;
-		killmsg.dwArg1 = hNode->nodeEnv;
-		pIntfFxns = hNodeMgr->pIntfFxns;
+		msg.dw_cmd = RMS_EXIT;
+		msg.dw_arg1 = hnode->node_env;
+		killmsg.dw_cmd = RMS_KILLTASK;
+		killmsg.dw_arg1 = hnode->node_env;
+		intf_fxns = hnode_mgr->intf_fxns;
 
-		if (hNode->uTimeout > MAXTIMEOUT)
-			killTimeOut = MAXTIMEOUT;
+		if (hnode->utimeout > MAXTIMEOUT)
+			kill_time_out = MAXTIMEOUT;
 		else
-			killTimeOut = (hNode->uTimeout)*2;
+			kill_time_out = (hnode->utimeout) * 2;
 
-		status = (*pIntfFxns->pfnMsgPut)(hNode->hMsgQueue, &msg,
-							hNode->uTimeout);
+		status = (*intf_fxns->pfn_msg_put) (hnode->msg_queue_obj, &msg,
+						    hnode->utimeout);
+		/* FIXME */
 		if (DSP_SUCCEEDED(status)) {
 			/*  Wait on synchronization object that will be
 			 *  posted in the callback on receiving RMS_EXIT
-			 *  message, or by NODE_Delete. Check for valid hNode,
-			 *  in case posted by NODE_Delete().  */
-			status = SYNC_WaitOnEvent(hNode->hSyncDone,
-							killTimeOut/2);
+			 *  message, or by node_delete. Check for valid hnode,
+			 *  in case posted by node_delete(). */
+			status = sync_wait_on_event(hnode->sync_done,
+						    kill_time_out / 2);
 			if (DSP_FAILED(status)) {
 				if (status == DSP_ETIMEOUT) {
-					status = (*pIntfFxns->pfnMsgPut)
-						 (hNode->hMsgQueue, &killmsg,
-						 hNode->uTimeout);
+					status = (*intf_fxns->pfn_msg_put)
+					    (hnode->msg_queue_obj, &killmsg,
+					     hnode->utimeout);
 					if (DSP_SUCCEEDED(status)) {
-						status = SYNC_WaitOnEvent
-							(hNode->hSyncDone,
-							killTimeOut/2);
+						status = sync_wait_on_event
+						    (hnode->sync_done,
+						     kill_time_out / 2);
 						if (DSP_FAILED(status)) {
 							/* Here it goes the part
-							* of the simulation of
-							* the DSP exception */
-						    DEV_GetDehMgr(hNodeMgr->
-							hDevObject, &hDehMgr);
-						    if (hDehMgr) {
-							(*pIntfFxns->
-							pfnDehNotify)(hDehMgr,
-							DSP_SYSERROR,
-							DSP_EXCEPTIONABORT);
-							    status = DSP_EFAIL;
-						    }
+							 * of the simulation of
+							 * the DSP exception */
+							dev_get_deh_mgr
+							   (hnode_mgr->hdev_obj,
+							    &hdeh_mgr);
+							if (hdeh_mgr) {
+								(*intf_fxns->
+								pfn_deh_notify)
+								 (hdeh_mgr,
+								  DSP_SYSERROR,
+								  DSP_EXCEPTIONABORT);
+								status =
+								    DSP_EFAIL;
+							}
 						} else
-						    status = DSP_SOK;
+							status = DSP_SOK;
 					}
 				} else
 					status = DSP_EFAIL;
-			} else 	/* Convert SYNC status to DSP status */
+			} else	/* Convert SYNC status to DSP status */
 				status = DSP_SOK;
 		}
 	}
@@ -2439,469 +2495,476 @@ func_cont:
 	if (DSP_SUCCEEDED(status)) {
 		/* Enter CS before getting exit status, in case node was
 		 * deleted. */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		mutex_lock(&hnode_mgr->node_mgr_lock);
 		/* Make sure node wasn't deleted while we blocked */
-		if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 			status = DSP_EFAIL;
 		} else {
-			*pStatus = hNode->nExitStatus;
-			dev_dbg(bridge, "%s: hNode: %p env 0x%x status 0x%x\n",
-				__func__, hNode, hNode->nodeEnv, status);
+			*pstatus = hnode->exit_status;
+			dev_dbg(bridge, "%s: hnode: %p env 0x%x status 0x%x\n",
+				__func__, hnode, hnode->node_env, status);
 		}
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
-	}		/*End of SYNC_EnterCS */
+		mutex_unlock(&hnode_mgr->node_mgr_lock);
+	}			/*End of sync_enter_cs */
 func_end:
 	return status;
 }
 
 /*
- *  ======== DeleteNode ========
+ *  ======== delete_node ========
  *  Purpose:
- *      Free GPP resources allocated in NODE_Allocate() or NODE_Connect().
+ *      Free GPP resources allocated in node_allocate() or node_connect().
  */
-static void DeleteNode(struct NODE_OBJECT *hNode,
-		struct PROCESS_CONTEXT *pr_ctxt)
+static void delete_node(struct node_object *hnode,
+			struct process_context *pr_ctxt)
 {
-	struct NODE_MGR *hNodeMgr;
-	struct CMM_XLATOROBJECT *hXlator;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct node_mgr *hnode_mgr;
+	struct cmm_xlatorobject *xlator;
+	struct bridge_drv_interface *intf_fxns;
 	u32 i;
-	enum NODE_TYPE nodeType;
-	struct STREAM stream;
-	struct NODE_MSGARGS msgArgs;
-	struct NODE_TASKARGS taskArgs;
+	enum node_type node_type;
+	struct stream_chnl stream;
+	struct node_msgargs node_msg_args;
+	struct node_taskargs task_arg_obj;
 #ifdef DSP_DMM_DEBUG
-	struct DMM_OBJECT *hDmmMgr;
-	struct PROC_OBJECT *pProcObject =
-			(struct PROC_OBJECT *)hNode->hProcessor;
+	struct dmm_object *dmm_mgr;
+	struct proc_object *p_proc_object =
+	    (struct proc_object *)hnode->hprocessor;
 #endif
-	DSP_STATUS status;
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+	dsp_status status;
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE))
 		goto func_end;
-	hNodeMgr = hNode->hNodeMgr;
-	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
+	hnode_mgr = hnode->hnode_mgr;
+	if (!MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE))
 		goto func_end;
-	hXlator = hNode->hXlator;
-	nodeType = NODE_GetType(hNode);
-	if (nodeType != NODE_DEVICE) {
-		msgArgs = hNode->createArgs.asa.msgArgs;
-		kfree(msgArgs.pData);
+	xlator = hnode->xlator;
+	node_type = node_get_type(hnode);
+	if (node_type != NODE_DEVICE) {
+		node_msg_args = hnode->create_args.asa.node_msg_args;
+		kfree(node_msg_args.pdata);
 
-		/* Free MSG queue */
-		if (hNode->hMsgQueue) {
-			pIntfFxns = hNodeMgr->pIntfFxns;
-			(*pIntfFxns->pfnMsgDeleteQueue) (hNode->hMsgQueue);
-			hNode->hMsgQueue = NULL;
+		/* Free msg_ctrl queue */
+		if (hnode->msg_queue_obj) {
+			intf_fxns = hnode_mgr->intf_fxns;
+			(*intf_fxns->pfn_msg_delete_queue) (hnode->
+							    msg_queue_obj);
+			hnode->msg_queue_obj = NULL;
 		}
-		if (hNode->hSyncDone)
-			(void) SYNC_CloseEvent(hNode->hSyncDone);
+
+		kfree(hnode->sync_done);
 
 		/* Free all stream info */
-		if (hNode->inputs) {
-			for (i = 0; i < MaxInputs(hNode); i++) {
-				stream = hNode->inputs[i];
-				FreeStream(hNodeMgr, stream);
+		if (hnode->inputs) {
+			for (i = 0; i < MAX_INPUTS(hnode); i++) {
+				stream = hnode->inputs[i];
+				free_stream(hnode_mgr, stream);
 			}
-			kfree(hNode->inputs);
-			hNode->inputs = NULL;
+			kfree(hnode->inputs);
+			hnode->inputs = NULL;
 		}
-		if (hNode->outputs) {
-			for (i = 0; i < MaxOutputs(hNode); i++) {
-				stream = hNode->outputs[i];
-				FreeStream(hNodeMgr, stream);
+		if (hnode->outputs) {
+			for (i = 0; i < MAX_OUTPUTS(hnode); i++) {
+				stream = hnode->outputs[i];
+				free_stream(hnode_mgr, stream);
 			}
-			kfree(hNode->outputs);
-			hNode->outputs = NULL;
-		}
-		taskArgs = hNode->createArgs.asa.taskArgs;
-		if (taskArgs.strmInDef) {
-			for (i = 0; i < MaxInputs(hNode); i++) {
-				kfree(taskArgs.strmInDef[i].szDevice);
-				taskArgs.strmInDef[i].szDevice = NULL;
+			kfree(hnode->outputs);
+			hnode->outputs = NULL;
+		}
+		task_arg_obj = hnode->create_args.asa.task_arg_obj;
+		if (task_arg_obj.strm_in_def) {
+			for (i = 0; i < MAX_INPUTS(hnode); i++) {
+				kfree(task_arg_obj.strm_in_def[i].sz_device);
+				task_arg_obj.strm_in_def[i].sz_device = NULL;
 			}
-			kfree(taskArgs.strmInDef);
-			taskArgs.strmInDef = NULL;
+			kfree(task_arg_obj.strm_in_def);
+			task_arg_obj.strm_in_def = NULL;
 		}
-		if (taskArgs.strmOutDef) {
-			for (i = 0; i < MaxOutputs(hNode); i++) {
-				kfree(taskArgs.strmOutDef[i].szDevice);
-				taskArgs.strmOutDef[i].szDevice = NULL;
+		if (task_arg_obj.strm_out_def) {
+			for (i = 0; i < MAX_OUTPUTS(hnode); i++) {
+				kfree(task_arg_obj.strm_out_def[i].sz_device);
+				task_arg_obj.strm_out_def[i].sz_device = NULL;
 			}
-			kfree(taskArgs.strmOutDef);
-			taskArgs.strmOutDef = NULL;
-		}
-		if (taskArgs.uDSPHeapResAddr) {
-			status = PROC_UnMap(hNode->hProcessor,
-					   (void *)taskArgs.uDSPHeapAddr,
-					   pr_ctxt);
-
-			status = PROC_UnReserveMemory(hNode->hProcessor,
-					(void *)taskArgs.uDSPHeapResAddr,
-					pr_ctxt);
+			kfree(task_arg_obj.strm_out_def);
+			task_arg_obj.strm_out_def = NULL;
+		}
+		if (task_arg_obj.udsp_heap_res_addr) {
+			status = proc_un_map(hnode->hprocessor, (void *)
+					     task_arg_obj.udsp_heap_addr,
+					     pr_ctxt);
+
+			status = proc_un_reserve_memory(hnode->hprocessor,
+							(void *)
+							task_arg_obj.
+							udsp_heap_res_addr,
+							pr_ctxt);
 #ifdef DSP_DMM_DEBUG
-			status = DMM_GetHandle(pProcObject, &hDmmMgr);
+			status = dmm_get_handle(p_proc_object, &dmm_mgr);
 			if (DSP_SUCCEEDED(status))
-				DMM_MemMapDump(hDmmMgr);
+				dmm_mem_map_dump(dmm_mgr);
 #endif
 		}
 	}
-	if (nodeType != NODE_MESSAGE) {
-		kfree(hNode->streamConnect);
-		hNode->streamConnect = NULL;
+	if (node_type != NODE_MESSAGE) {
+		kfree(hnode->stream_connect);
+		hnode->stream_connect = NULL;
 	}
-	kfree(hNode->pstrDevName);
-	hNode->pstrDevName = NULL;
+	kfree(hnode->pstr_dev_name);
+	hnode->pstr_dev_name = NULL;
 
-	if (hNode->hNtfy) {
-		NTFY_Delete(hNode->hNtfy);
-		hNode->hNtfy = NULL;
+	if (hnode->ntfy_obj) {
+		ntfy_delete(hnode->ntfy_obj);
+		kfree(hnode->ntfy_obj);
+		hnode->ntfy_obj = NULL;
 	}
 
-	/* These were allocated in DCD_GetObjectDef (via NODE_Allocate) */
-	kfree(hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn);
-	hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn = NULL;
+	/* These were allocated in dcd_get_object_def (via node_allocate) */
+	kfree(hnode->dcd_props.obj_data.node_obj.pstr_create_phase_fxn);
+	hnode->dcd_props.obj_data.node_obj.pstr_create_phase_fxn = NULL;
 
-	kfree(hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn);
-	hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn = NULL;
+	kfree(hnode->dcd_props.obj_data.node_obj.pstr_execute_phase_fxn);
+	hnode->dcd_props.obj_data.node_obj.pstr_execute_phase_fxn = NULL;
 
-	kfree(hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn);
-	hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn = NULL;
+	kfree(hnode->dcd_props.obj_data.node_obj.pstr_delete_phase_fxn);
+	hnode->dcd_props.obj_data.node_obj.pstr_delete_phase_fxn = NULL;
 
-	kfree(hNode->dcdProps.objData.nodeObj.pstrIAlgName);
-	hNode->dcdProps.objData.nodeObj.pstrIAlgName = NULL;
+	kfree(hnode->dcd_props.obj_data.node_obj.pstr_i_alg_name);
+	hnode->dcd_props.obj_data.node_obj.pstr_i_alg_name = NULL;
 
 	/* Free all SM address translator resources */
-	if (hXlator) {
-		(void) CMM_XlatorDelete(hXlator, TRUE);	/* force free */
-		hXlator = NULL;
+	if (xlator) {
+		(void)cmm_xlator_delete(xlator, TRUE);	/* force free */
+		xlator = NULL;
 	}
 
-	kfree(hNode->hNldrNode);
-	hNode->hNldrNode = NULL;
-	hNode->hNodeMgr = NULL;
-	MEM_FreeObject(hNode);
-	hNode = NULL;
+	kfree(hnode->nldr_node_obj);
+	hnode->nldr_node_obj = NULL;
+	hnode->hnode_mgr = NULL;
+	MEM_FREE_OBJECT(hnode);
+	hnode = NULL;
 func_end:
 	return;
 }
 
 /*
- *  ======== DeleteNodeMgr ========
+ *  ======== delete_node_mgr ========
  *  Purpose:
  *      Frees the node manager.
  */
-static void DeleteNodeMgr(struct NODE_MGR *hNodeMgr)
+static void delete_node_mgr(struct node_mgr *hnode_mgr)
 {
-	struct NODE_OBJECT *hNode;
+	struct node_object *hnode;
 
-	if (MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE)) {
 		/* Free resources */
-		if (hNodeMgr->hDcdMgr)
-			DCD_DestroyManager(hNodeMgr->hDcdMgr);
+		if (hnode_mgr->hdcd_mgr)
+			dcd_destroy_manager(hnode_mgr->hdcd_mgr);
 
 		/* Remove any elements remaining in lists */
-		if (hNodeMgr->nodeList) {
-			while ((hNode =
-				(struct NODE_OBJECT *)LST_GetHead(hNodeMgr->
-				nodeList)))
-					DeleteNode(hNode, NULL);
+		if (hnode_mgr->node_list) {
+			while ((hnode = (struct node_object *)
+				lst_get_head(hnode_mgr->node_list)))
+				delete_node(hnode, NULL);
 
-			DBC_Assert(LST_IsEmpty(hNodeMgr->nodeList));
-			kfree(hNodeMgr->nodeList);
+			DBC_ASSERT(LST_IS_EMPTY(hnode_mgr->node_list));
+			kfree(hnode_mgr->node_list);
+		}
+		mutex_destroy(&hnode_mgr->node_mgr_lock);
+		if (hnode_mgr->ntfy_obj) {
+			ntfy_delete(hnode_mgr->ntfy_obj);
+			kfree(hnode_mgr->ntfy_obj);
 		}
-		if (hNodeMgr->hNtfy)
-			NTFY_Delete(hNodeMgr->hNtfy);
-
-		if (hNodeMgr->pipeMap)
-			GB_delete(hNodeMgr->pipeMap);
 
-		if (hNodeMgr->pipeDoneMap)
-			GB_delete(hNodeMgr->pipeDoneMap);
+		if (hnode_mgr->pipe_map)
+			gb_delete(hnode_mgr->pipe_map);
 
-		if (hNodeMgr->chnlMap)
-			GB_delete(hNodeMgr->chnlMap);
+		if (hnode_mgr->pipe_done_map)
+			gb_delete(hnode_mgr->pipe_done_map);
 
-		if (hNodeMgr->dmaChnlMap)
-			GB_delete(hNodeMgr->dmaChnlMap);
+		if (hnode_mgr->chnl_map)
+			gb_delete(hnode_mgr->chnl_map);
 
-		if (hNodeMgr->zChnlMap)
-			GB_delete(hNodeMgr->zChnlMap);
+		if (hnode_mgr->dma_chnl_map)
+			gb_delete(hnode_mgr->dma_chnl_map);
 
-		if (hNodeMgr->hDisp)
-			DISP_Delete(hNodeMgr->hDisp);
+		if (hnode_mgr->zc_chnl_map)
+			gb_delete(hnode_mgr->zc_chnl_map);
 
-		if (hNodeMgr->hSync)
-			SYNC_DeleteCS(hNodeMgr->hSync);
+		if (hnode_mgr->disp_obj)
+			disp_delete(hnode_mgr->disp_obj);
 
-		if (hNodeMgr->hStrmMgr)
-			STRM_Delete(hNodeMgr->hStrmMgr);
+		if (hnode_mgr->strm_mgr_obj)
+			strm_delete(hnode_mgr->strm_mgr_obj);
 
 		/* Delete the loader */
-		if (hNodeMgr->hNldr)
-			hNodeMgr->nldrFxns.pfnDelete(hNodeMgr->hNldr);
+		if (hnode_mgr->nldr_obj)
+			hnode_mgr->nldr_fxns.pfn_delete(hnode_mgr->nldr_obj);
 
-		if (hNodeMgr->fLoaderInit)
-			hNodeMgr->nldrFxns.pfnExit();
+		if (hnode_mgr->loader_init)
+			hnode_mgr->nldr_fxns.pfn_exit();
 
-		MEM_FreeObject(hNodeMgr);
+		MEM_FREE_OBJECT(hnode_mgr);
 	}
 }
 
 /*
- *  ======== FillStreamConnect ========
+ *  ======== fill_stream_connect ========
  *  Purpose:
  *      Fills stream information.
  */
-static void FillStreamConnect(struct NODE_OBJECT *hNode1,
-				struct NODE_OBJECT *hNode2,
+static void fill_stream_connect(struct node_object *hNode1,
+				struct node_object *hNode2,
 				u32 uStream1, u32 uStream2)
 {
-	u32 uStrmIndex;
-	struct DSP_STREAMCONNECT *pStrm1 = NULL;
-	struct DSP_STREAMCONNECT *pStrm2 = NULL;
-	enum NODE_TYPE node1Type = NODE_TASK;
-	enum NODE_TYPE node2Type = NODE_TASK;
-
-	node1Type = NODE_GetType(hNode1);
-	node2Type = NODE_GetType(hNode2);
-	if (hNode1 != (struct NODE_OBJECT *)DSP_HGPPNODE) {
-
-		if (node1Type != NODE_DEVICE) {
-			uStrmIndex = hNode1->uNumInputs +
-					hNode1->uNumOutputs - 1;
-			pStrm1 = &(hNode1->streamConnect[uStrmIndex]);
-			pStrm1->cbStruct = sizeof(struct DSP_STREAMCONNECT);
-			pStrm1->uThisNodeStreamIndex = uStream1;
-		}
-
-		if (hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE) {
-				/* NODE == > NODE */
-			if (node1Type != NODE_DEVICE) {
-				pStrm1->hConnectedNode = hNode2;
-				pStrm1->uiConnectedNodeID = hNode2->nodeId;
-				pStrm1->uConnectedNodeStreamIndex = uStream2;
-				pStrm1->lType = CONNECTTYPE_NODEOUTPUT;
+	u32 strm_index;
+	struct dsp_streamconnect *strm1 = NULL;
+	struct dsp_streamconnect *strm2 = NULL;
+	enum node_type node1_type = NODE_TASK;
+	enum node_type node2_type = NODE_TASK;
+
+	node1_type = node_get_type(hNode1);
+	node2_type = node_get_type(hNode2);
+	if (hNode1 != (struct node_object *)DSP_HGPPNODE) {
+
+		if (node1_type != NODE_DEVICE) {
+			strm_index = hNode1->num_inputs +
+			    hNode1->num_outputs - 1;
+			strm1 = &(hNode1->stream_connect[strm_index]);
+			strm1->cb_struct = sizeof(struct dsp_streamconnect);
+			strm1->this_node_stream_index = uStream1;
+		}
+
+		if (hNode2 != (struct node_object *)DSP_HGPPNODE) {
+			/* NODE == > NODE */
+			if (node1_type != NODE_DEVICE) {
+				strm1->connected_node = hNode2;
+				strm1->ui_connected_node_id = hNode2->node_uuid;
+				strm1->connected_node_stream_index = uStream2;
+				strm1->connect_type = CONNECTTYPE_NODEOUTPUT;
 			}
-			if (node2Type != NODE_DEVICE) {
-				uStrmIndex = hNode2->uNumInputs +
-						hNode2->uNumOutputs - 1;
-				pStrm2 = &(hNode2->streamConnect[uStrmIndex]);
-				pStrm2->cbStruct =
-					sizeof(struct DSP_STREAMCONNECT);
-				pStrm2->uThisNodeStreamIndex = uStream2;
-				pStrm2->hConnectedNode = hNode1;
-				pStrm2->uiConnectedNodeID = hNode1->nodeId;
-				pStrm2->uConnectedNodeStreamIndex = uStream1;
-				pStrm2->lType = CONNECTTYPE_NODEINPUT;
+			if (node2_type != NODE_DEVICE) {
+				strm_index = hNode2->num_inputs +
+				    hNode2->num_outputs - 1;
+				strm2 = &(hNode2->stream_connect[strm_index]);
+				strm2->cb_struct =
+				    sizeof(struct dsp_streamconnect);
+				strm2->this_node_stream_index = uStream2;
+				strm2->connected_node = hNode1;
+				strm2->ui_connected_node_id = hNode1->node_uuid;
+				strm2->connected_node_stream_index = uStream1;
+				strm2->connect_type = CONNECTTYPE_NODEINPUT;
 			}
-		} else if (node1Type != NODE_DEVICE)
-				pStrm1->lType = CONNECTTYPE_GPPOUTPUT;
+		} else if (node1_type != NODE_DEVICE)
+			strm1->connect_type = CONNECTTYPE_GPPOUTPUT;
 	} else {
 		/* GPP == > NODE */
-		DBC_Assert(hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE);
-		uStrmIndex = hNode2->uNumInputs + hNode2->uNumOutputs - 1;
-		pStrm2 = &(hNode2->streamConnect[uStrmIndex]);
-		pStrm2->cbStruct = sizeof(struct DSP_STREAMCONNECT);
-		pStrm2->uThisNodeStreamIndex = uStream2;
-		pStrm2->lType = CONNECTTYPE_GPPINPUT;
+		DBC_ASSERT(hNode2 != (struct node_object *)DSP_HGPPNODE);
+		strm_index = hNode2->num_inputs + hNode2->num_outputs - 1;
+		strm2 = &(hNode2->stream_connect[strm_index]);
+		strm2->cb_struct = sizeof(struct dsp_streamconnect);
+		strm2->this_node_stream_index = uStream2;
+		strm2->connect_type = CONNECTTYPE_GPPINPUT;
 	}
 }
 
 /*
- *  ======== FillStreamDef ========
+ *  ======== fill_stream_def ========
  *  Purpose:
  *      Fills Stream attributes.
  */
-static void FillStreamDef(struct NODE_OBJECT *hNode,
-			  struct NODE_STRMDEF *pstrmDef,
-			  struct DSP_STRMATTR *pAttrs)
+static void fill_stream_def(struct node_object *hnode,
+			    struct node_strmdef *pstrm_def,
+			    struct dsp_strmattr *pattrs)
 {
-	struct NODE_MGR *hNodeMgr = hNode->hNodeMgr;
-
-	if (pAttrs != NULL) {
-		pstrmDef->uNumBufs = pAttrs->uNumBufs;
-		pstrmDef->uBufsize = pAttrs->uBufsize / hNodeMgr->
-							uDSPDataMauSize;
-		pstrmDef->uSegid = pAttrs->uSegid;
-		pstrmDef->uAlignment = pAttrs->uAlignment;
-		pstrmDef->uTimeout = pAttrs->uTimeout;
+	struct node_mgr *hnode_mgr = hnode->hnode_mgr;
+
+	if (pattrs != NULL) {
+		pstrm_def->num_bufs = pattrs->num_bufs;
+		pstrm_def->buf_size =
+		    pattrs->buf_size / hnode_mgr->udsp_data_mau_size;
+		pstrm_def->seg_id = pattrs->seg_id;
+		pstrm_def->buf_alignment = pattrs->buf_alignment;
+		pstrm_def->utimeout = pattrs->utimeout;
 	} else {
-		pstrmDef->uNumBufs = DEFAULTNBUFS;
-		pstrmDef->uBufsize = DEFAULTBUFSIZE / hNodeMgr->
-							uDSPDataMauSize;
-		pstrmDef->uSegid = DEFAULTSEGID;
-		pstrmDef->uAlignment = DEFAULTALIGNMENT;
-		pstrmDef->uTimeout = DEFAULTTIMEOUT;
+		pstrm_def->num_bufs = DEFAULTNBUFS;
+		pstrm_def->buf_size =
+		    DEFAULTBUFSIZE / hnode_mgr->udsp_data_mau_size;
+		pstrm_def->seg_id = DEFAULTSEGID;
+		pstrm_def->buf_alignment = DEFAULTALIGNMENT;
+		pstrm_def->utimeout = DEFAULTTIMEOUT;
 	}
 }
 
 /*
- *  ======== FreeStream ========
+ *  ======== free_stream ========
  *  Purpose:
  *      Updates the channel mask and frees the pipe id.
  */
-static void FreeStream(struct NODE_MGR *hNodeMgr, struct STREAM stream)
+static void free_stream(struct node_mgr *hnode_mgr, struct stream_chnl stream)
 {
 	/* Free up the pipe id unless other node has not yet been deleted. */
 	if (stream.type == NODECONNECT) {
-		if (GB_test(hNodeMgr->pipeDoneMap, stream.devId)) {
+		if (gb_test(hnode_mgr->pipe_done_map, stream.dev_id)) {
 			/* The other node has already been deleted */
-			GB_clear(hNodeMgr->pipeDoneMap, stream.devId);
-			GB_clear(hNodeMgr->pipeMap, stream.devId);
+			gb_clear(hnode_mgr->pipe_done_map, stream.dev_id);
+			gb_clear(hnode_mgr->pipe_map, stream.dev_id);
 		} else {
 			/* The other node has not been deleted yet */
-			GB_set(hNodeMgr->pipeDoneMap, stream.devId);
+			gb_set(hnode_mgr->pipe_done_map, stream.dev_id);
 		}
 	} else if (stream.type == HOSTCONNECT) {
-		if (stream.devId < hNodeMgr->ulNumChnls) {
-			GB_clear(hNodeMgr->chnlMap, stream.devId);
-		} else if (stream.devId < (2 * hNodeMgr->ulNumChnls)) {
+		if (stream.dev_id < hnode_mgr->ul_num_chnls) {
+			gb_clear(hnode_mgr->chnl_map, stream.dev_id);
+		} else if (stream.dev_id < (2 * hnode_mgr->ul_num_chnls)) {
 			/* dsp-dma */
-			GB_clear(hNodeMgr->dmaChnlMap, stream.devId -
-				(1 * hNodeMgr->ulNumChnls));
-		} else if (stream.devId < (3 * hNodeMgr->ulNumChnls)) {
+			gb_clear(hnode_mgr->dma_chnl_map, stream.dev_id -
+				 (1 * hnode_mgr->ul_num_chnls));
+		} else if (stream.dev_id < (3 * hnode_mgr->ul_num_chnls)) {
 			/* zero-copy */
-			GB_clear(hNodeMgr->zChnlMap, stream.devId -
-				(2 * hNodeMgr->ulNumChnls));
+			gb_clear(hnode_mgr->zc_chnl_map, stream.dev_id -
+				 (2 * hnode_mgr->ul_num_chnls));
 		}
 	}
 }
 
 /*
- *  ======== GetFxnAddress ========
+ *  ======== get_fxn_address ========
  *  Purpose:
  *      Retrieves the address for create, execute or delete phase for a node.
  */
-static DSP_STATUS GetFxnAddress(struct NODE_OBJECT *hNode, u32 *pulFxnAddr,
-				u32 uPhase)
+static dsp_status get_fxn_address(struct node_object *hnode, u32 * pulFxnAddr,
+				  u32 uPhase)
 {
-	char *pstrFxnName = NULL;
-	struct NODE_MGR *hNodeMgr = hNode->hNodeMgr;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(NODE_GetType(hNode) == NODE_TASK ||
-			NODE_GetType(hNode) == NODE_DAISSOCKET ||
-			NODE_GetType(hNode) == NODE_MESSAGE);
+	char *pstr_fxn_name = NULL;
+	struct node_mgr *hnode_mgr = hnode->hnode_mgr;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(node_get_type(hnode) == NODE_TASK ||
+		    node_get_type(hnode) == NODE_DAISSOCKET ||
+		    node_get_type(hnode) == NODE_MESSAGE);
 
 	switch (uPhase) {
 	case CREATEPHASE:
-		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-				pstrCreatePhaseFxn;
+		pstr_fxn_name =
+		    hnode->dcd_props.obj_data.node_obj.pstr_create_phase_fxn;
 		break;
 	case EXECUTEPHASE:
-		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-				pstrExecutePhaseFxn;
+		pstr_fxn_name =
+		    hnode->dcd_props.obj_data.node_obj.pstr_execute_phase_fxn;
 		break;
 	case DELETEPHASE:
-		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-				pstrDeletePhaseFxn;
+		pstr_fxn_name =
+		    hnode->dcd_props.obj_data.node_obj.pstr_delete_phase_fxn;
 		break;
 	default:
 		/* Should never get here */
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 		break;
 	}
 
-	status = hNodeMgr->nldrFxns.pfnGetFxnAddr(hNode->hNldrNode, pstrFxnName,
-						pulFxnAddr);
+	status =
+	    hnode_mgr->nldr_fxns.pfn_get_fxn_addr(hnode->nldr_node_obj,
+						  pstr_fxn_name, pulFxnAddr);
 
 	return status;
 }
 
 /*
- *  ======== GetNodeInfo ========
+ *  ======== get_node_info ========
  *  Purpose:
  *      Retrieves the node information.
  */
-void GetNodeInfo(struct NODE_OBJECT *hNode, struct DSP_NODEINFO *pNodeInfo)
+void get_node_info(struct node_object *hnode, struct dsp_nodeinfo *pNodeInfo)
 {
 	u32 i;
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-	DBC_Require(pNodeInfo != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
+	DBC_REQUIRE(pNodeInfo != NULL);
 
-	pNodeInfo->cbStruct = sizeof(struct DSP_NODEINFO);
-	pNodeInfo->nbNodeDatabaseProps = hNode->dcdProps.objData.nodeObj.
-					 ndbProps;
-	pNodeInfo->uExecutionPriority = hNode->nPriority;
-	pNodeInfo->hDeviceOwner = hNode->hDeviceOwner;
-	pNodeInfo->uNumberStreams = hNode->uNumInputs + hNode->uNumOutputs;
-	pNodeInfo->uNodeEnv = hNode->nodeEnv;
+	pNodeInfo->cb_struct = sizeof(struct dsp_nodeinfo);
+	pNodeInfo->nb_node_database_props =
+	    hnode->dcd_props.obj_data.node_obj.ndb_props;
+	pNodeInfo->execution_priority = hnode->prio;
+	pNodeInfo->device_owner = hnode->device_owner;
+	pNodeInfo->number_streams = hnode->num_inputs + hnode->num_outputs;
+	pNodeInfo->node_env = hnode->node_env;
 
-	pNodeInfo->nsExecutionState = NODE_GetState(hNode);
+	pNodeInfo->ns_execution_state = node_get_state(hnode);
 
 	/* Copy stream connect data */
-	for (i = 0; i < hNode->uNumInputs + hNode->uNumOutputs; i++)
-		pNodeInfo->scStreamConnection[i] = hNode->streamConnect[i];
+	for (i = 0; i < hnode->num_inputs + hnode->num_outputs; i++)
+		pNodeInfo->sc_stream_connection[i] = hnode->stream_connect[i];
 
 }
 
 /*
- *  ======== GetNodeProps ========
+ *  ======== get_node_props ========
  *  Purpose:
  *      Retrieve node properties.
  */
-static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
-				struct NODE_OBJECT *hNode,
-				CONST struct DSP_UUID *pNodeId,
-				struct DCD_GENERICOBJ *pdcdProps)
+static dsp_status get_node_props(struct dcd_manager *hdcd_mgr,
+				 struct node_object *hnode,
+				 CONST struct dsp_uuid *pNodeId,
+				 struct dcd_genericobj *pdcdProps)
 {
-	u32 uLen;
-	struct NODE_MSGARGS *pMsgArgs;
-	struct NODE_TASKARGS *pTaskArgs;
-	enum NODE_TYPE nodeType = NODE_TASK;
-	struct DSP_NDBPROPS *pndbProps = &(pdcdProps->objData.nodeObj.ndbProps);
-	DSP_STATUS status = DSP_SOK;
-	char szUuid[MAXUUIDLEN];
-
-	status = DCD_GetObjectDef(hDcdMgr, (struct DSP_UUID *)pNodeId,
-				 DSP_DCDNODETYPE, pdcdProps);
+	u32 len;
+	struct node_msgargs *pmsg_args;
+	struct node_taskargs *task_arg_obj;
+	enum node_type node_type = NODE_TASK;
+	struct dsp_ndbprops *pndb_props =
+	    &(pdcdProps->obj_data.node_obj.ndb_props);
+	dsp_status status = DSP_SOK;
+	char sz_uuid[MAXUUIDLEN];
+
+	status = dcd_get_object_def(hdcd_mgr, (struct dsp_uuid *)pNodeId,
+				    DSP_DCDNODETYPE, pdcdProps);
 
 	if (DSP_SUCCEEDED(status)) {
-		hNode->nType = nodeType = pndbProps->uNodeType;
+		hnode->ntype = node_type = pndb_props->ntype;
 
 		/* Create UUID value to set in registry. */
-		UUID_UuidToString((struct DSP_UUID *)pNodeId, szUuid,
-				 MAXUUIDLEN);
-		dev_dbg(bridge, "(node) UUID: %s\n", szUuid);
+		uuid_uuid_to_string((struct dsp_uuid *)pNodeId, sz_uuid,
+				    MAXUUIDLEN);
+		dev_dbg(bridge, "(node) UUID: %s\n", sz_uuid);
 
 		/* Fill in message args that come from NDB */
-		if (nodeType != NODE_DEVICE) {
-			pMsgArgs = &(hNode->createArgs.asa.msgArgs);
-			pMsgArgs->uSegid = pdcdProps->objData.nodeObj.uMsgSegid;
-			pMsgArgs->uNotifyType = pdcdProps->objData.nodeObj.
-						uMsgNotifyType;
-			pMsgArgs->uMaxMessages = pndbProps->uMessageDepth;
+		if (node_type != NODE_DEVICE) {
+			pmsg_args = &(hnode->create_args.asa.node_msg_args);
+			pmsg_args->seg_id =
+			    pdcdProps->obj_data.node_obj.msg_segid;
+			pmsg_args->notify_type =
+			    pdcdProps->obj_data.node_obj.msg_notify_type;
+			pmsg_args->max_msgs = pndb_props->message_depth;
 			dev_dbg(bridge, "(node) Max Number of Messages: 0x%x\n",
-				 pMsgArgs->uMaxMessages);
+				pmsg_args->max_msgs);
 		} else {
 			/* Copy device name */
-			DBC_Require(pndbProps->acName);
-			uLen = strlen(pndbProps->acName);
-			DBC_Assert(uLen < MAXDEVNAMELEN);
-			hNode->pstrDevName = MEM_Calloc(uLen + 1, MEM_PAGED);
-			if (hNode->pstrDevName == NULL) {
+			DBC_REQUIRE(pndb_props->ac_name);
+			len = strlen(pndb_props->ac_name);
+			DBC_ASSERT(len < MAXDEVNAMELEN);
+			hnode->pstr_dev_name = mem_calloc(len + 1, MEM_PAGED);
+			if (hnode->pstr_dev_name == NULL) {
 				status = DSP_EMEMORY;
 			} else {
-				strncpy(hNode->pstrDevName,
-					pndbProps->acName, uLen);
+				strncpy(hnode->pstr_dev_name,
+					pndb_props->ac_name, len);
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Fill in create args that come from NDB */
-		if (nodeType == NODE_TASK || nodeType == NODE_DAISSOCKET) {
-			pTaskArgs = &(hNode->createArgs.asa.taskArgs);
-			pTaskArgs->nPriority = pndbProps->iPriority;
-			pTaskArgs->uStackSize = pndbProps->uStackSize;
-			pTaskArgs->uSysStackSize = pndbProps->uSysStackSize;
-			pTaskArgs->uStackSeg = pndbProps->uStackSeg;
+		if (node_type == NODE_TASK || node_type == NODE_DAISSOCKET) {
+			task_arg_obj = &(hnode->create_args.asa.task_arg_obj);
+			task_arg_obj->prio = pndb_props->prio;
+			task_arg_obj->stack_size = pndb_props->stack_size;
+			task_arg_obj->sys_stack_size =
+			    pndb_props->sys_stack_size;
+			task_arg_obj->stack_seg = pndb_props->stack_seg;
 			dev_dbg(bridge, "(node) Priority: 0x%x Stack Size: "
 				"0x%x words System Stack Size: 0x%x words "
 				"Stack Segment: 0x%x profile count : 0x%x\n",
-				pTaskArgs->nPriority, pTaskArgs->uStackSize,
-				pTaskArgs->uSysStackSize,
-				pTaskArgs->uStackSeg,
-				pndbProps->uCountProfiles);
+				task_arg_obj->prio, task_arg_obj->stack_size,
+				task_arg_obj->sys_stack_size,
+				task_arg_obj->stack_seg,
+				pndb_props->count_profiles);
 		}
 	}
 
@@ -2909,149 +2972,145 @@ static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
 }
 
 /*
- *  ======== GetProcProps ========
+ *  ======== get_proc_props ========
  *  Purpose:
  *      Retrieve the processor properties.
  */
-static DSP_STATUS GetProcProps(struct NODE_MGR *hNodeMgr,
-				struct DEV_OBJECT *hDevObject)
+static dsp_status get_proc_props(struct node_mgr *hnode_mgr,
+				 struct dev_object *hdev_obj)
 {
-	struct CFG_DEVNODE *hDevNode;
-	struct CFG_HOSTRES hostRes;
-	DSP_STATUS status = DSP_SOK;
+	struct cfg_devnode *dev_node_obj;
+	struct cfg_hostres host_res;
+	dsp_status status = DSP_SOK;
 
-	status = DEV_GetDevNode(hDevObject, &hDevNode);
+	status = dev_get_dev_node(hdev_obj, &dev_node_obj);
 	if (DSP_SUCCEEDED(status))
-		status = CFG_GetHostResources(hDevNode, &hostRes);
+		status = cfg_get_host_resources(dev_node_obj, &host_res);
 
 	if (DSP_SUCCEEDED(status)) {
-		hNodeMgr->ulChnlOffset = hostRes.dwChnlOffset;
-		hNodeMgr->ulChnlBufSize = hostRes.dwChnlBufSize;
-		hNodeMgr->ulNumChnls = hostRes.dwNumChnls;
+		hnode_mgr->ul_chnl_offset = host_res.dw_chnl_offset;
+		hnode_mgr->ul_chnl_buf_size = host_res.dw_chnl_buf_size;
+		hnode_mgr->ul_num_chnls = host_res.dw_num_chnls;
 
 		/*
-		 *  PROC will add an API to get DSP_PROCESSORINFO.
+		 *  PROC will add an API to get dsp_processorinfo.
 		 *  Fill in default values for now.
 		 */
 		/* TODO -- Instead of hard coding, take from registry */
-		hNodeMgr->procFamily = 6000;
-		hNodeMgr->procType = 6410;
-		hNodeMgr->nMinPri = DSP_NODE_MIN_PRIORITY;
-		hNodeMgr->nMaxPri = DSP_NODE_MAX_PRIORITY;
-		hNodeMgr->uDSPWordSize = DSPWORDSIZE;
-		hNodeMgr->uDSPDataMauSize = DSPWORDSIZE;
-		hNodeMgr->uDSPMauSize = 1;
+		hnode_mgr->proc_family = 6000;
+		hnode_mgr->proc_type = 6410;
+		hnode_mgr->min_pri = DSP_NODE_MIN_PRIORITY;
+		hnode_mgr->max_pri = DSP_NODE_MAX_PRIORITY;
+		hnode_mgr->udsp_word_size = DSPWORDSIZE;
+		hnode_mgr->udsp_data_mau_size = DSPWORDSIZE;
+		hnode_mgr->udsp_mau_size = 1;
 
 	}
 	return status;
 }
 
-
-
 /*
- *  ======== NODE_GetUUIDProps ========
+ *  ======== node_get_uuid_props ========
  *  Purpose:
  *      Fetch Node UUID properties from DCD/DOF file.
  */
-DSP_STATUS NODE_GetUUIDProps(void *hProcessor,
-			    IN CONST struct DSP_UUID *pNodeId,
-			    OUT struct DSP_NDBPROPS *pNodeProps)
+dsp_status node_get_uuid_props(void *hprocessor,
+			       IN CONST struct dsp_uuid *pNodeId,
+			       OUT struct dsp_ndbprops *node_props)
 {
-	struct NODE_MGR *hNodeMgr = NULL;
-	struct DEV_OBJECT *hDevObject;
-	DSP_STATUS status = DSP_SOK;
-	struct DCD_NODEPROPS dcdNodeProps;
-	struct DSP_PROCESSORSTATE procStatus;
+	struct node_mgr *hnode_mgr = NULL;
+	struct dev_object *hdev_obj;
+	dsp_status status = DSP_SOK;
+	struct dcd_nodeprops dcd_node_props;
+	struct dsp_processorstate proc_state;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hProcessor != NULL);
-	DBC_Require(pNodeId != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hprocessor != NULL);
+	DBC_REQUIRE(pNodeId != NULL);
 
-	if (hProcessor == NULL || pNodeId == NULL) {
+	if (hprocessor == NULL || pNodeId == NULL) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	status = PROC_GetState(hProcessor, &procStatus,
-			sizeof(struct DSP_PROCESSORSTATE));
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt
-	    to send the message */
-	if (procStatus.iState == PROC_ERROR) {
+	   to send the message */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
 
-	status = PROC_GetDevObject(hProcessor, &hDevObject);
-	if (hDevObject)
-		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
+	status = proc_get_dev_object(hprocessor, &hdev_obj);
+	if (hdev_obj)
+ 		status = dev_get_node_manager(hdev_obj, &hnode_mgr);
 
-	if (hNodeMgr == NULL) {
+	if (hnode_mgr == NULL) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
 	/*
 	 * Enter the critical section. This is needed because
-	 * DCD_GetObjectDef will ultimately end up calling DBLL_open/close,
+	 * dcd_get_object_def will ultimately end up calling dbll_open/close,
 	 * which needs to be protected in order to not corrupt the zlib manager
 	 * (COD).
 	 */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	mutex_lock(&hnode_mgr->node_mgr_lock);
+
+	dcd_node_props.pstr_create_phase_fxn = NULL;
+	dcd_node_props.pstr_execute_phase_fxn = NULL;
+	dcd_node_props.pstr_delete_phase_fxn = NULL;
+	dcd_node_props.pstr_i_alg_name = NULL;
+
+	status = dcd_get_object_def(hnode_mgr->hdcd_mgr,
+		(struct dsp_uuid *)pNodeId, DSP_DCDNODETYPE,
+		(struct dcd_genericobj *)&dcd_node_props);
 
 	if (DSP_SUCCEEDED(status)) {
-		dcdNodeProps.pstrCreatePhaseFxn = NULL;
-		dcdNodeProps.pstrExecutePhaseFxn = NULL;
-		dcdNodeProps.pstrDeletePhaseFxn = NULL;
-		dcdNodeProps.pstrIAlgName = NULL;
-
-		status = DCD_GetObjectDef(hNodeMgr->hDcdMgr,
-				(struct DSP_UUID *) pNodeId,
-				DSP_DCDNODETYPE,
-				(struct DCD_GENERICOBJ *) &dcdNodeProps);
-		if (DSP_SUCCEEDED(status)) {
-			*pNodeProps = dcdNodeProps.ndbProps;
-			kfree(dcdNodeProps.pstrCreatePhaseFxn);
+		*node_props = dcd_node_props.ndb_props;
+		kfree(dcd_node_props.pstr_create_phase_fxn);
 
-			kfree(dcdNodeProps.pstrExecutePhaseFxn);
+		kfree(dcd_node_props.pstr_execute_phase_fxn);
 
-			kfree(dcdNodeProps.pstrDeletePhaseFxn);
+		kfree(dcd_node_props.pstr_delete_phase_fxn);
 
-			kfree(dcdNodeProps.pstrIAlgName);
-		}
-		/*  Leave the critical section, we're done.  */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		kfree(dcd_node_props.pstr_i_alg_name);
 	}
+	/*  Leave the critical section, we're done. */
+	mutex_unlock(&hnode_mgr->node_mgr_lock);
 func_end:
 	return status;
 }
 
 /*
- *  ======== GetRMSFxns ========
+ *  ======== get_rms_fxns ========
  *  Purpose:
  *      Retrieve the RMS functions.
  */
-static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr)
+static dsp_status get_rms_fxns(struct node_mgr *hnode_mgr)
 {
 	s32 i;
-	struct DEV_OBJECT *hDev = hNodeMgr->hDevObject;
-	DSP_STATUS status = DSP_SOK;
-
-	static char *pszFxns[NUMRMSFXNS] = {
-		"RMS_queryServer", 	/* RMSQUERYSERVER */
-		"RMS_configureServer", 	/* RMSCONFIGURESERVER */
-		"RMS_createNode", 	/* RMSCREATENODE */
-		"RMS_executeNode", 	/* RMSEXECUTENODE */
-		"RMS_deleteNode", 	/* RMSDELETENODE */
-		"RMS_changeNodePriority", 	/* RMSCHANGENODEPRIORITY */
-		"RMS_readMemory", 	/* RMSREADMEMORY */
-		"RMS_writeMemory", 	/* RMSWRITEMEMORY */
-		"RMS_copy", 	/* RMSCOPY */
+	struct dev_object *dev_obj = hnode_mgr->hdev_obj;
+	dsp_status status = DSP_SOK;
+
+	static char *psz_fxns[NUMRMSFXNS] = {
+		"RMS_queryServer",	/* RMSQUERYSERVER */
+		"RMS_configureServer",	/* RMSCONFIGURESERVER */
+		"RMS_createNode",	/* RMSCREATENODE */
+		"RMS_executeNode",	/* RMSEXECUTENODE */
+		"RMS_deleteNode",	/* RMSDELETENODE */
+		"RMS_changeNodePriority",	/* RMSCHANGENODEPRIORITY */
+		"RMS_readMemory",	/* RMSREADMEMORY */
+		"RMS_writeMemory",	/* RMSWRITEMEMORY */
+		"RMS_copy",	/* RMSCOPY */
 	};
 
 	for (i = 0; i < NUMRMSFXNS; i++) {
-		status = DEV_GetSymbol(hDev, pszFxns[i],
-			 &(hNodeMgr->ulFxnAddrs[i]));
+		status = dev_get_symbol(dev_obj, psz_fxns[i],
+					&(hnode_mgr->ul_fxn_addrs[i]));
 		if (DSP_FAILED(status)) {
 			if (status == COD_E_SYMBOLNOTFOUND) {
 				/*
@@ -3059,11 +3118,11 @@ static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr)
 				 *  but return an error for now.
 				 */
 				dev_dbg(bridge, "%s: RMS function: %s currently"
-					 " not loaded\n", __func__, pszFxns[i]);
+					" not loaded\n", __func__, psz_fxns[i]);
 			} else {
 				dev_dbg(bridge, "%s: Symbol not found: %s "
-						"status = 0x%x\n", __func__,
-						pszFxns[i], status);
+					"status = 0x%x\n", __func__,
+					psz_fxns[i], status);
 				break;
 			}
 		}
@@ -3073,76 +3132,77 @@ static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr)
 }
 
 /*
- *  ======== Ovly ========
+ *  ======== ovly ========
  *  Purpose:
  *      Called during overlay.Sends command to RMS to copy a block of data.
  */
-static u32 Ovly(void *pPrivRef, u32 ulDspRunAddr, u32 ulDspLoadAddr,
-			u32 ulNumBytes, u32 nMemSpace)
+static u32 ovly(void *priv_ref, u32 ulDspRunAddr, u32 ulDspLoadAddr,
+		u32 ul_num_bytes, u32 nMemSpace)
 {
-	struct NODE_OBJECT *hNode = (struct NODE_OBJECT *)pPrivRef;
-	struct NODE_MGR *hNodeMgr;
-	u32 ulBytes = 0;
-	u32 ulSize;
-	u32 ulTimeout;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *hWmdContext;
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	struct node_object *hnode = (struct node_object *)priv_ref;
+	struct node_mgr *hnode_mgr;
+	u32 ul_bytes = 0;
+	u32 ul_size;
+	u32 ul_timeout;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *hwmd_context;
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
 
-	hNodeMgr = hNode->hNodeMgr;
+	hnode_mgr = hnode->hnode_mgr;
 
-	ulSize = ulNumBytes / hNodeMgr->uDSPWordSize;
-	ulTimeout = hNode->uTimeout;
+	ul_size = ul_num_bytes / hnode_mgr->udsp_word_size;
+	ul_timeout = hnode->utimeout;
 
 	/* Call new MemCopy function */
-	pIntfFxns = hNodeMgr->pIntfFxns;
-	status = DEV_GetWMDContext(hNodeMgr->hDevObject, &hWmdContext);
+	intf_fxns = hnode_mgr->intf_fxns;
+	status = dev_get_wmd_context(hnode_mgr->hdev_obj, &hwmd_context);
 	if (DSP_SUCCEEDED(status)) {
-		status = (*pIntfFxns->pfnBrdMemCopy)(hWmdContext, ulDspRunAddr,
-			 ulDspLoadAddr,	ulNumBytes, (u32) nMemSpace);
+		status =
+		    (*intf_fxns->pfn_brd_mem_copy) (hwmd_context, ulDspRunAddr,
+						    ulDspLoadAddr, ul_num_bytes,
+						    (u32) nMemSpace);
 		if (DSP_SUCCEEDED(status))
-			ulBytes = ulNumBytes;
+			ul_bytes = ul_num_bytes;
 		else
-			pr_debug("%s: failed to copy brd memory, status 0x%x\n"
-						, __func__, status);
+			pr_debug("%s: failed to copy brd memory, status 0x%x\n",
+				 __func__, status);
 	} else {
 		pr_debug("%s: failed to get WMD context, status 0x%x\n",
-							__func__, status);
+			 __func__, status);
 	}
 
-	return ulBytes;
+	return ul_bytes;
 }
 
 /*
- *  ======== Write ========
+ *  ======== mem_write ========
  */
-static u32 Write(void *pPrivRef, u32 ulDspAddr, void *pBuf,
-			u32 ulNumBytes, u32 nMemSpace)
+static u32 mem_write(void *priv_ref, u32 ulDspAddr, void *pbuf,
+		     u32 ul_num_bytes, u32 nMemSpace)
 {
-	struct NODE_OBJECT *hNode = (struct NODE_OBJECT *) pPrivRef;
-	struct NODE_MGR *hNodeMgr;
-	u16 memType;
-	u32 ulTimeout;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *hWmdContext;
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	struct node_object *hnode = (struct node_object *)priv_ref;
+	struct node_mgr *hnode_mgr;
+	u16 mem_sect_type;
+	u32 ul_timeout;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *hwmd_context;
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-	DBC_Require(nMemSpace & DBLL_CODE || nMemSpace & DBLL_DATA);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
+	DBC_REQUIRE(nMemSpace & DBLL_CODE || nMemSpace & DBLL_DATA);
 
-	hNodeMgr = hNode->hNodeMgr;
+	hnode_mgr = hnode->hnode_mgr;
 
-	ulTimeout = hNode->uTimeout;
-	memType = (nMemSpace & DBLL_CODE) ? RMS_CODE : RMS_DATA;
+	ul_timeout = hnode->utimeout;
+	mem_sect_type = (nMemSpace & DBLL_CODE) ? RMS_CODE : RMS_DATA;
 
 	/* Call new MemWrite function */
-	pIntfFxns = hNodeMgr->pIntfFxns;
-	status = DEV_GetWMDContext(hNodeMgr->hDevObject, &hWmdContext);
-	status = (*pIntfFxns->pfnBrdMemWrite) (hWmdContext, pBuf, ulDspAddr,
-		 ulNumBytes, memType);
+	intf_fxns = hnode_mgr->intf_fxns;
+	status = dev_get_wmd_context(hnode_mgr->hdev_obj, &hwmd_context);
+	status = (*intf_fxns->pfn_brd_mem_write) (hwmd_context, pbuf, ulDspAddr,
+						  ul_num_bytes, mem_sect_type);
 
-	return ulNumBytes;
+	return ul_num_bytes;
 }
-
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index 56e89a4..44937c2 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -65,7 +65,7 @@
 #define MAXCMDLINELEN       255
 #define PROC_ENVPROCID      "PROC_ID=%d"
 #define MAXPROCIDLEN	(8 + 5)
-#define PROC_DFLT_TIMEOUT   10000	/* Time out in milliseconds  */
+#define PROC_DFLT_TIMEOUT   10000	/* Time out in milliseconds */
 #define PWR_TIMEOUT	 500	/* Sleep/wake timout in msec */
 #define EXTEND	      "_EXT_END"	/* Extmem end addr in DSP binary */
 
@@ -74,114 +74,115 @@
 #define BUFMODE_MASK	(3 << 14)
 
 /* Buffer modes from DSP perspective */
-#define RBUF		0x4000		/* Input buffer */
-#define WBUF		0x8000		/* Output Buffer */
+#define RBUF		0x4000	/* Input buffer */
+#define WBUF		0x8000	/* Output Buffer */
 
 extern char *iva_img;
 
 /*  ----------------------------------- Globals */
 
-/* The PROC_OBJECT structure.   */
-struct PROC_OBJECT {
-	struct list_head link;		/* Link to next PROC_OBJECT */
-	u32 dwSignature;		/* Used for object validation */
-	struct DEV_OBJECT *hDevObject;	/* Device this PROC represents */
-	u32 hProcess;			/* Process owning this Processor */
-	struct MGR_OBJECT *hMgrObject;	/* Manager Object Handle */
-	u32 uAttachCount;		/* Processor attach count */
-	u32 uProcessor;			/* Processor number */
-	u32 uTimeout;			/* Time out count */
-	enum DSP_PROCSTATE sState;	/* Processor state */
-	u32 ulUnit;			/* DDSP unit number */
-	bool bIsAlreadyAttached;	/*
+/* The proc_object structure. */
+struct proc_object {
+	struct list_head link;	/* Link to next proc_object */
+	u32 dw_signature;	/* Used for object validation */
+	struct dev_object *hdev_obj;	/* Device this PROC represents */
+	u32 process;		/* Process owning this Processor */
+	struct mgr_object *hmgr_obj;	/* Manager Object Handle */
+	u32 attach_count;	/* Processor attach count */
+	u32 processor_id;	/* Processor number */
+	u32 utimeout;		/* Time out count */
+	enum dsp_procstate proc_state;	/* Processor state */
+	u32 ul_unit;		/* DDSP unit number */
+	bool is_already_attached;	/*
 					 * True if the Device below has
 					 * GPP Client attached
 					 */
-	struct NTFY_OBJECT *hNtfy;	/* Manages  notifications */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
-	char *g_pszLastCoff;
-	struct list_head proc_object;
+	struct ntfy_object *ntfy_obj;	/* Manages  notifications */
+	struct wmd_dev_context *hwmd_context;	/* WMD Context Handle */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	char *psz_last_coff;
+	struct list_head proc_list;
 };
 
-static u32 cRefs;
+static u32 refs;
 
-struct SYNC_CSOBJECT *hProcLock;	/* For critical sections */
+DEFINE_MUTEX(proc_lock);	/* For critical sections */
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS PROC_Monitor(struct PROC_OBJECT *hProcessor);
-static s32 GetEnvpCount(char **envp);
-static char **PrependEnvp(char **newEnvp, char **envp, s32 cEnvp, s32 cNewEnvp,
-			 char *szVar);
+static dsp_status proc_monitor(struct proc_object *hprocessor);
+static s32 get_envp_count(char **envp);
+static char **prepend_envp(char **new_envp, char **envp, s32 envp_elems,
+			   s32 cnew_envp, char *szVar);
 
 /*
- *  ======== PROC_Attach ========
+ *  ======== proc_attach ========
  *  Purpose:
  *      Prepare for communication with a particular DSP processor, and return
  *      a handle to the processor object.
  */
-DSP_STATUS
-PROC_Attach(u32 uProcessor, OPTIONAL CONST struct DSP_PROCESSORATTRIN *pAttrIn,
-       void **phProcessor, struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status
+proc_attach(u32 processor_id,
+	    OPTIONAL CONST struct dsp_processorattrin *attr_in,
+	    void **ph_processor, struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *hDevObject;
-	struct PROC_OBJECT *pProcObject = NULL;
-	struct MGR_OBJECT *hMgrObject = NULL;
-	struct DRV_OBJECT *hDrvObject = NULL;
-	u32 devType;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phProcessor != NULL);
-
-	if (pr_ctxt->hProcessor) {
-		*phProcessor = pr_ctxt->hProcessor;
+	dsp_status status = DSP_SOK;
+	struct dev_object *hdev_obj;
+	struct proc_object *p_proc_object = NULL;
+	struct mgr_object *hmgr_obj = NULL;
+	struct drv_object *hdrv_obj = NULL;
+	u32 dev_type;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ph_processor != NULL);
+
+	if (pr_ctxt->hprocessor) {
+		*ph_processor = pr_ctxt->hprocessor;
 		return status;
 	}
 
 	/* Get the Driver and Manager Object Handles */
-	status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	status = cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status))
-		status = CFG_GetObject((u32 *)&hMgrObject, REG_MGR_OBJECT);
+		status = cfg_get_object((u32 *) &hmgr_obj, REG_MGR_OBJECT);
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Get the Device Object */
-		status = DRV_GetDevObject(uProcessor, hDrvObject, &hDevObject);
+		status = drv_get_dev_object(processor_id, hdrv_obj, &hdev_obj);
 	}
 	if (DSP_SUCCEEDED(status))
-		status = DEV_GetDevType(hDevObject, &devType);
+		status = dev_get_dev_type(hdev_obj, &dev_type);
 
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* If we made it this far, create the Proceesor object: */
-	MEM_AllocObject(pProcObject, struct PROC_OBJECT, PROC_SIGNATURE);
+	MEM_ALLOC_OBJECT(p_proc_object, struct proc_object, PROC_SIGNATURE);
 	/* Fill out the Processor Object: */
-	if (pProcObject == NULL) {
+	if (p_proc_object == NULL) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	pProcObject->hDevObject = hDevObject;
-	pProcObject->hMgrObject = hMgrObject;
-	pProcObject->uProcessor = devType;
+	p_proc_object->hdev_obj = hdev_obj;
+	p_proc_object->hmgr_obj = hmgr_obj;
+	p_proc_object->processor_id = dev_type;
 	/* Store TGID instead of process handle */
-	pProcObject->hProcess = current->tgid;
+	p_proc_object->process = current->tgid;
 
-	INIT_LIST_HEAD(&pProcObject->proc_object);
+	INIT_LIST_HEAD(&p_proc_object->proc_list);
 
-	if (pAttrIn)
-		pProcObject->uTimeout = pAttrIn->uTimeout;
+	if (attr_in)
+		p_proc_object->utimeout = attr_in->utimeout;
 	else
-		pProcObject->uTimeout = PROC_DFLT_TIMEOUT;
+		p_proc_object->utimeout = PROC_DFLT_TIMEOUT;
 
-	status = DEV_GetIntfFxns(hDevObject, &pProcObject->pIntfFxns);
+	status = dev_get_intf_fxns(hdev_obj, &p_proc_object->intf_fxns);
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetWMDContext(hDevObject,
-					 &pProcObject->hWmdContext);
+		status = dev_get_wmd_context(hdev_obj,
+					     &p_proc_object->hwmd_context);
 		if (DSP_FAILED(status))
-			MEM_FreeObject(pProcObject);
+			MEM_FREE_OBJECT(p_proc_object);
 	} else
-		MEM_FreeObject(pProcObject);
+		MEM_FREE_OBJECT(p_proc_object);
 
 	if (DSP_FAILED(status))
 		goto func_end;
@@ -189,57 +190,66 @@ PROC_Attach(u32 uProcessor, OPTIONAL CONST struct DSP_PROCESSORATTRIN *pAttrIn,
 	/* Create the Notification Object */
 	/* This is created with no event mask, no notify mask
 	 * and no valid handle to the notification. They all get
-	 * filled up when PROC_RegisterNotify is called */
-	status = NTFY_Create(&pProcObject->hNtfy);
+	 * filled up when proc_register_notify is called */
+	p_proc_object->ntfy_obj = kmalloc(sizeof(struct ntfy_object),
+							GFP_KERNEL);
+	if (p_proc_object->ntfy_obj)
+		ntfy_init(p_proc_object->ntfy_obj);
+	else
+		status = DSP_EMEMORY;
+
 	if (DSP_SUCCEEDED(status)) {
 		/* Insert the Processor Object into the DEV List.
 		 * Return handle to this Processor Object:
 		 * Find out if the Device is already attached to a
 		 * Processor. If so, return AlreadyAttached status */
-		LST_InitElem(&pProcObject->link);
-		status = DEV_InsertProcObject(pProcObject->hDevObject,
-					     (u32)pProcObject,
-					     &pProcObject->bIsAlreadyAttached);
+		lst_init_elem(&p_proc_object->link);
+		status = dev_insert_proc_object(p_proc_object->hdev_obj,
+						(u32) p_proc_object,
+						&p_proc_object->
+						is_already_attached);
 		if (DSP_SUCCEEDED(status)) {
-			if (pProcObject->bIsAlreadyAttached)
+			if (p_proc_object->is_already_attached)
 				status = DSP_SALREADYATTACHED;
 		} else {
-			if (pProcObject->hNtfy)
-				NTFY_Delete(pProcObject->hNtfy);
+			if (p_proc_object->ntfy_obj) {
+				ntfy_delete(p_proc_object->ntfy_obj);
+				kfree(p_proc_object->ntfy_obj);
+			}
 
-			MEM_FreeObject(pProcObject);
+			MEM_FREE_OBJECT(p_proc_object);
 		}
 		if (DSP_SUCCEEDED(status)) {
-			*phProcessor = (void *)pProcObject;
-			pr_ctxt->hProcessor = *phProcessor;
-			(void)PROC_NotifyClients(pProcObject,
-						 DSP_PROCESSORATTACH);
+			*ph_processor = (void *)p_proc_object;
+			pr_ctxt->hprocessor = *ph_processor;
+			(void)proc_notify_clients(p_proc_object,
+						  DSP_PROCESSORATTACH);
 		}
 	} else {
 		/* Don't leak memory if DSP_FAILED */
-		MEM_FreeObject(pProcObject);
+		MEM_FREE_OBJECT(p_proc_object);
 	}
 func_end:
-	DBC_Ensure((status == DSP_EFAIL && *phProcessor == NULL) ||
-		  (DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) ||
-		  (status == DSP_SALREADYATTACHED &&
-		  MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)));
+	DBC_ENSURE((status == DSP_EFAIL && *ph_processor == NULL) ||
+		   (DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) ||
+		   (status == DSP_SALREADYATTACHED &&
+		    MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)));
 
 	return status;
 }
 
-static DSP_STATUS GetExecFile(struct CFG_DEVNODE *hDevNode,
-			     struct DEV_OBJECT *hDevObject,
-			     u32 size, char *execFile)
+static dsp_status get_exec_file(struct cfg_devnode *dev_node_obj,
+				struct dev_object *hdev_obj,
+				u32 size, char *execFile)
 {
-	s32 devType;
+	s32 dev_type;
 	s32 len;
 
-	DEV_GetDevType(hDevObject, (u32 *) &devType);
-	if (devType == DSP_UNIT) {
-		return CFG_GetExecFile(hDevNode, size, execFile);
-	} else if (devType == IVA_UNIT) {
+	dev_get_dev_type(hdev_obj, (u32 *) &dev_type);
+	if (dev_type == DSP_UNIT) {
+		return cfg_get_exec_file(dev_node_obj, size, execFile);
+	} else if (dev_type == IVA_UNIT) {
 		if (iva_img) {
 			len = strlen(iva_img);
 			strncpy(execFile, iva_img, len + 1);
@@ -250,124 +260,123 @@ static DSP_STATUS GetExecFile(struct CFG_DEVNODE *hDevNode,
 }
 
 /*
- *  ======== PROC_AutoStart ======== =
+ *  ======== proc_auto_start ======== =
  *  Purpose:
  *      A Particular device gets loaded with the default image
  *      if the AutoStart flag is set.
  *  Parameters:
- *      hDevObject:     Handle to the Device
+ *      hdev_obj:     Handle to the Device
  *  Returns:
  *      DSP_SOK:   On Successful Loading
  *      DSP_EFAIL  General Failure
  *  Requires:
- *      hDevObject != NULL
+ *      hdev_obj != NULL
  *  Ensures:
  */
-DSP_STATUS PROC_AutoStart(struct CFG_DEVNODE *hDevNode,
-			 struct DEV_OBJECT *hDevObject)
+dsp_status proc_auto_start(struct cfg_devnode *dev_node_obj,
+			   struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct PROC_OBJECT *pProcObject;
-	char szExecFile[MAXCMDLINELEN];
+	dsp_status status = DSP_EFAIL;
+	struct proc_object *p_proc_object;
+	char sz_exec_file[MAXCMDLINELEN];
 	char *argv[2];
-	struct MGR_OBJECT *hMgrObject = NULL;
-	s32 devType;
+	struct mgr_object *hmgr_obj = NULL;
+	s32 dev_type;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hDevNode != NULL);
-	DBC_Require(hDevObject != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(dev_node_obj != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
 
 	/* Create a Dummy PROC Object */
-	status = CFG_GetObject((u32 *)&hMgrObject, REG_MGR_OBJECT);
+	status = cfg_get_object((u32 *) &hmgr_obj, REG_MGR_OBJECT);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	MEM_AllocObject(pProcObject, struct PROC_OBJECT, PROC_SIGNATURE);
-	if (pProcObject == NULL) {
+	MEM_ALLOC_OBJECT(p_proc_object, struct proc_object, PROC_SIGNATURE);
+	if (p_proc_object == NULL) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	pProcObject->hDevObject = hDevObject;
-	pProcObject->hMgrObject = hMgrObject;
-	status = DEV_GetIntfFxns(hDevObject, &pProcObject->pIntfFxns);
+	p_proc_object->hdev_obj = hdev_obj;
+	p_proc_object->hmgr_obj = hmgr_obj;
+	status = dev_get_intf_fxns(hdev_obj, &p_proc_object->intf_fxns);
 	if (DSP_SUCCEEDED(status))
-		status = DEV_GetWMDContext(hDevObject,
-					&pProcObject->hWmdContext);
+		status = dev_get_wmd_context(hdev_obj,
+					     &p_proc_object->hwmd_context);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
 	/* Stop the Device, put it into standby mode */
-	status = PROC_Stop(pProcObject);
+	status = proc_stop(p_proc_object);
 
 	if (DSP_FAILED(status))
 		goto func_cont;
 
 	/* Get the default executable for this board... */
-	DEV_GetDevType(hDevObject, (u32 *)&devType);
-	pProcObject->uProcessor = devType;
-	status = GetExecFile(hDevNode, hDevObject, sizeof(szExecFile),
-							szExecFile);
+	dev_get_dev_type(hdev_obj, (u32 *) &dev_type);
+	p_proc_object->processor_id = dev_type;
+	status = get_exec_file(dev_node_obj, hdev_obj, sizeof(sz_exec_file),
+			       sz_exec_file);
 	if (DSP_SUCCEEDED(status)) {
-		argv[0] = szExecFile;
+		argv[0] = sz_exec_file;
 		argv[1] = NULL;
 		/* ...and try to load it: */
-		status = PROC_Load(pProcObject, 1, (CONST char **)argv, NULL);
+		status = proc_load(p_proc_object, 1, (CONST char **)argv, NULL);
 		if (DSP_SUCCEEDED(status))
-			status = PROC_Start(pProcObject);
+			status = proc_start(p_proc_object);
 	}
-	kfree(pProcObject->g_pszLastCoff);
-	pProcObject->g_pszLastCoff = NULL;
+	kfree(p_proc_object->psz_last_coff);
+	p_proc_object->psz_last_coff = NULL;
 func_cont:
-	MEM_FreeObject(pProcObject);
+	MEM_FREE_OBJECT(p_proc_object);
 func_end:
 	return status;
 }
 
 /*
- *  ======== PROC_Ctrl ========
+ *  ======== proc_ctrl ========
  *  Purpose:
  *      Pass control information to the GPP device driver managing the
  *      DSP processor.
  *
  *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge
  *      application developer's API.
- *      Call the WMD_ICOTL Fxn with the Argument This is a Synchronous
+ *      Call the WMD_ICOTL fxn with the Argument This is a Synchronous
  *      Operation. arg can be null.
  */
-DSP_STATUS PROC_Ctrl(void *hProcessor, u32 dwCmd,
-		    IN struct DSP_CBDATA *arg)
+dsp_status proc_ctrl(void *hprocessor, u32 dw_cmd, IN struct dsp_cbdata * arg)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = hProcessor;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = hprocessor;
 	u32 timeout = 0;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		/* intercept PWR deep sleep command */
-		if (dwCmd == WMDIOCTL_DEEPSLEEP) {
-			timeout = arg->cbData;
-			status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
+		if (dw_cmd == WMDIOCTL_DEEPSLEEP) {
+			timeout = arg->cb_data;
+			status = pwr_sleep_dsp(PWR_DEEPSLEEP, timeout);
 		}
 		/* intercept PWR emergency sleep command */
-		else if (dwCmd == WMDIOCTL_EMERGENCYSLEEP) {
-			timeout = arg->cbData;
-			status = PWR_SleepDSP(PWR_EMERGENCYDEEPSLEEP, timeout);
-		} else if (dwCmd == PWR_DEEPSLEEP) {
-			/* timeout = arg->cbData; */
-			status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
+		else if (dw_cmd == WMDIOCTL_EMERGENCYSLEEP) {
+			timeout = arg->cb_data;
+			status = pwr_sleep_dsp(PWR_EMERGENCYDEEPSLEEP, timeout);
+		} else if (dw_cmd == PWR_DEEPSLEEP) {
+			/* timeout = arg->cb_data; */
+			status = pwr_sleep_dsp(PWR_DEEPSLEEP, timeout);
 		}
 		/* intercept PWR wake commands */
-		else if (dwCmd == WMDIOCTL_WAKEUP) {
-			timeout = arg->cbData;
-			status = PWR_WakeDSP(timeout);
-		} else if (dwCmd == PWR_WAKEUP) {
-			/* timeout = arg->cbData; */
-			status = PWR_WakeDSP(timeout);
+		else if (dw_cmd == WMDIOCTL_WAKEUP) {
+			timeout = arg->cb_data;
+			status = pwr_wake_dsp(timeout);
+		} else if (dw_cmd == PWR_WAKEUP) {
+			/* timeout = arg->cb_data; */
+			status = pwr_wake_dsp(timeout);
 		} else
-		    if (DSP_SUCCEEDED
-			((*pProcObject->pIntfFxns->pfnDevCntrl)
-				(pProcObject->hWmdContext, dwCmd, arg))) {
+		    if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_dev_cntrl)
+				      (p_proc_object->hwmd_context, dw_cmd,
+				       arg))) {
 			status = DSP_SOK;
 		} else {
 			status = DSP_EFAIL;
@@ -380,35 +389,37 @@ DSP_STATUS PROC_Ctrl(void *hProcessor, u32 dwCmd,
 }
 
 /*
- *  ======== PROC_Detach ========
+ *  ======== proc_detach ========
  *  Purpose:
  *      Destroys the  Processor Object. Removes the notification from the Dev
  *      List.
  */
-DSP_STATUS PROC_Detach(struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status proc_detach(struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = NULL;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = NULL;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	pProcObject = (struct PROC_OBJECT *)pr_ctxt->hProcessor;
+	p_proc_object = (struct proc_object *)pr_ctxt->hprocessor;
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		if (pProcObject->hNtfy) {
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
+		if (p_proc_object->ntfy_obj) {
 			/* Notify the Client */
-			NTFY_Notify(pProcObject->hNtfy, DSP_PROCESSORDETACH);
+			ntfy_notify(p_proc_object->ntfy_obj,
+				    DSP_PROCESSORDETACH);
 			/* Remove the notification memory */
-			NTFY_Delete(pProcObject->hNtfy);
+			ntfy_delete(p_proc_object->ntfy_obj);
+			kfree(p_proc_object->ntfy_obj);
 		}
-		kfree(pProcObject->g_pszLastCoff);
-		pProcObject->g_pszLastCoff = NULL;
+		kfree(p_proc_object->psz_last_coff);
+		p_proc_object->psz_last_coff = NULL;
 		/* Remove the Proc from the DEV List */
-		(void)DEV_RemoveProcObject(pProcObject->hDevObject,
-			(u32)pProcObject);
+		(void)dev_remove_proc_object(p_proc_object->hdev_obj,
+					     (u32) p_proc_object);
 		/* Free the Processor Object */
-		MEM_FreeObject(pProcObject);
-		pr_ctxt->hProcessor = NULL;
+		MEM_FREE_OBJECT(p_proc_object);
+		pr_ctxt->hprocessor = NULL;
 	} else {
 		status = DSP_EHANDLE;
 	}
@@ -417,32 +428,32 @@ DSP_STATUS PROC_Detach(struct PROCESS_CONTEXT *pr_ctxt)
 }
 
 /*
- *  ======== PROC_EnumNodes ========
+ *  ======== proc_enum_nodes ========
  *  Purpose:
  *      Enumerate and get configuration information about nodes allocated
  *      on a DSP processor.
  */
-DSP_STATUS PROC_EnumNodes(void *hProcessor, void **aNodeTab,
-		IN u32 uNodeTabSize, OUT u32 *puNumNodes,
-		OUT u32 *puAllocated)
+dsp_status proc_enum_nodes(void *hprocessor, void **node_tab,
+			   IN u32 node_tab_size, OUT u32 *pu_num_nodes,
+			   OUT u32 *pu_allocated)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct NODE_MGR *hNodeMgr = NULL;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(aNodeTab != NULL || uNodeTabSize == 0);
-	DBC_Require(puNumNodes != NULL);
-	DBC_Require(puAllocated != NULL);
-
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		if (DSP_SUCCEEDED(DEV_GetNodeManager(pProcObject->hDevObject,
-				 &hNodeMgr))) {
-			if (hNodeMgr) {
-				status = NODE_EnumNodes(hNodeMgr, aNodeTab,
-							uNodeTabSize,
-							puNumNodes,
-							puAllocated);
+	dsp_status status = DSP_EFAIL;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct node_mgr *hnode_mgr = NULL;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(node_tab != NULL || node_tab_size == 0);
+	DBC_REQUIRE(pu_num_nodes != NULL);
+	DBC_REQUIRE(pu_allocated != NULL);
+
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
+		if (DSP_SUCCEEDED(dev_get_node_manager(p_proc_object->hdev_obj,
+						       &hnode_mgr))) {
+			if (hnode_mgr) {
+				status = node_enum_nodes(hnode_mgr, node_tab,
+							 node_tab_size,
+							 pu_num_nodes,
+							 pu_allocated);
 			}
 		}
 	} else {
@@ -454,7 +465,7 @@ DSP_STATUS PROC_EnumNodes(void *hProcessor, void **aNodeTab,
 
 /* Cache operation against kernel address instead of users */
 static int memory_sync_page(struct vm_area_struct *vma, unsigned long start,
-			    ssize_t len, enum DSP_FLUSHTYPE ftype)
+			    ssize_t len, enum dsp_flushtype ftype)
 {
 	struct page *page;
 	void *kaddr;
@@ -475,7 +486,7 @@ static int memory_sync_page(struct vm_area_struct *vma, unsigned long start,
 		offset = start & ~PAGE_MASK;
 		kaddr = kmap(page) + offset;
 		rest = min_t(ssize_t, PAGE_SIZE - offset, len);
-		MEM_FlushCache(kaddr, rest, ftype);
+		mem_flush_cache(kaddr, rest, ftype);
 
 		kunmap(page);
 		put_page(page);
@@ -488,7 +499,7 @@ static int memory_sync_page(struct vm_area_struct *vma, unsigned long start,
 
 /* Check if the given area blongs to process virtul memory address space */
 static int memory_sync_vma(unsigned long start, u32 len,
-			   enum DSP_FLUSHTYPE ftype)
+			   enum dsp_flushtype ftype)
 {
 	int err = 0;
 	unsigned long end;
@@ -524,28 +535,28 @@ static int memory_sync_vma(unsigned long start, u32 len,
 	return err;
 }
 
-static DSP_STATUS proc_memory_sync(void *hProcessor, void *pMpuAddr,
-				   u32 ulSize, u32 ulFlags)
+static dsp_status proc_memory_sync(void *hprocessor, void *pmpu_addr,
+				   u32 ul_size, u32 ul_flags)
 {
 	/* Keep STATUS here for future additions to this function */
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto err_out;
 	}
 
-	if (ulFlags == 3) {
+	if (ul_flags == 3) {
 		__cpuc_flush_kern_all();
 	} else {
 		down_read(&current->mm->mmap_sem);
-		if (memory_sync_vma((u32)pMpuAddr, ulSize, ulFlags)) {
-				pr_err("%s: InValid address parameters %p %x\n",
-				__func__, pMpuAddr, ulSize);
-				status = DSP_EHANDLE;
+		if (memory_sync_vma((u32) pmpu_addr, ul_size, ul_flags)) {
+			pr_err("%s: InValid address parameters %p %x\n",
+			       __func__, pmpu_addr, ul_size);
+			status = DSP_EHANDLE;
 		}
 		up_read(&current->mm->mmap_sem);
 	}
@@ -555,69 +566,70 @@ err_out:
 }
 
 /*
- *  ======== PROC_FlushMemory ========
+ *  ======== proc_flush_memory ========
  *  Purpose:
  *     Flush cache
  */
-DSP_STATUS PROC_FlushMemory(void *hProcessor, void *pMpuAddr,
-			    u32 ulSize, u32 ulFlags)
+dsp_status proc_flush_memory(void *hprocessor, void *pmpu_addr,
+			     u32 ul_size, u32 ul_flags)
 {
-	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, ulFlags);
+	return proc_memory_sync(hprocessor, pmpu_addr, ul_size, ul_flags);
 }
 
 /*
- *  ======== PROC_InvalidateMemory ========
+ *  ======== proc_invalidate_memory ========
  *  Purpose:
  *     Invalidates the memory specified
  */
-DSP_STATUS PROC_InvalidateMemory(void *hProcessor, void *pMpuAddr,
-				 u32 ulSize)
+dsp_status proc_invalidate_memory(void *hprocessor, void *pmpu_addr,
+				  u32 ul_size)
 {
-	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, 0);
+	return proc_memory_sync(hprocessor, pmpu_addr, ul_size, 0);
 }
 
 /*
- *  ======== PROC_GetResourceInfo ========
+ *  ======== proc_get_resource_info ========
  *  Purpose:
  *      Enumerate the resources currently available on a processor.
  */
-DSP_STATUS PROC_GetResourceInfo(void *hProcessor, u32 uResourceType,
-				OUT struct DSP_RESOURCEINFO *pResourceInfo,
-				u32 uResourceInfoSize)
+dsp_status proc_get_resource_info(void *hprocessor, u32 resource_type,
+				  OUT struct dsp_resourceinfo *resource_info,
+				  u32 resource_info_size)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct NODE_MGR *hNodeMgr = NULL;
-	struct NLDR_OBJECT *hNldr = NULL;
-	struct RMM_TargetObj *rmm = NULL;
-	struct IO_MGR *hIOMgr = NULL;		/* IO manager handle */
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pResourceInfo != NULL);
-	DBC_Require(uResourceInfoSize >= sizeof(struct DSP_RESOURCEINFO));
-
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	dsp_status status = DSP_EFAIL;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct node_mgr *hnode_mgr = NULL;
+	struct nldr_object *nldr_obj = NULL;
+	struct rmm_target_obj *rmm = NULL;
+	struct io_mgr *hio_mgr = NULL;	/* IO manager handle */
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(resource_info != NULL);
+	DBC_REQUIRE(resource_info_size >= sizeof(struct dsp_resourceinfo));
+
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	switch (uResourceType) {
+	switch (resource_type) {
 	case DSP_RESOURCE_DYNDARAM:
 	case DSP_RESOURCE_DYNSARAM:
 	case DSP_RESOURCE_DYNEXTERNAL:
 	case DSP_RESOURCE_DYNSRAM:
-		status = DEV_GetNodeManager(pProcObject->hDevObject,
-								&hNodeMgr);
+		status = dev_get_node_manager(p_proc_object->hdev_obj,
+					      &hnode_mgr);
 		if (DSP_FAILED(status))
 			goto func_end;
 
-		status = NODE_GetNldrObj(hNodeMgr, &hNldr);
+		status = node_get_nldr_obj(hnode_mgr, &nldr_obj);
 		if (DSP_SUCCEEDED(status)) {
-			NLDR_GetRmmManager(hNldr, &rmm);
+			nldr_get_rmm_manager(nldr_obj, &rmm);
 			if (rmm) {
-				if (!RMM_stat(rmm,
-				   (enum DSP_MEMTYPE)uResourceType,
-				   (struct DSP_MEMSTAT *)&(pResourceInfo->
-				   result.memStat)))
+				if (!rmm_stat(rmm,
+					      (enum dsp_memtype)resource_type,
+					      (struct dsp_memstat *)
+					      &(resource_info->result.
+						mem_stat)))
 					status = DSP_EVALUE;
 			} else {
 				status = DSP_EHANDLE;
@@ -625,11 +637,14 @@ DSP_STATUS PROC_GetResourceInfo(void *hProcessor, u32 uResourceType,
 		}
 		break;
 	case DSP_RESOURCE_PROCLOAD:
-		status = DEV_GetIOMgr(pProcObject->hDevObject, &hIOMgr);
+		status = dev_get_io_mgr(p_proc_object->hdev_obj, &hio_mgr);
 		if (DSP_SUCCEEDED(status))
-			status = pProcObject->pIntfFxns->pfnIOGetProcLoad(
-				hIOMgr, (struct DSP_PROCLOADSTAT *)&
-				(pResourceInfo->result.procLoadStat));
+			status =
+			    p_proc_object->intf_fxns->
+			    pfn_io_get_proc_load(hio_mgr,
+						 (struct dsp_procloadstat *)
+						 &(resource_info->result.
+						   proc_load_stat));
 		break;
 	default:
 		status = DSP_EFAIL;
@@ -640,112 +655,109 @@ func_end:
 }
 
 /*
- *  ======== PROC_Exit ========
+ *  ======== proc_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
  */
-void PROC_Exit(void)
+void proc_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	if (hProcLock)
-		(void)SYNC_DeleteCS(hProcLock);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== PROC_GetDevObject ========
+ *  ======== proc_get_dev_object ========
  *  Purpose:
  *      Return the Dev Object handle for a given Processor.
  *
  */
-DSP_STATUS PROC_GetDevObject(void *hProcessor,
-			     struct DEV_OBJECT **phDevObject)
+dsp_status proc_get_dev_object(void *hprocessor,
+			       struct dev_object **phDevObject)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	dsp_status status = DSP_EFAIL;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDevObject != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDevObject != NULL);
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		*phDevObject = pProcObject->hDevObject;
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
+		*phDevObject = p_proc_object->hdev_obj;
 		status = DSP_SOK;
 	} else {
 		*phDevObject = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && *phDevObject != NULL) ||
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *phDevObject != NULL) ||
 		   (DSP_FAILED(status) && *phDevObject == NULL));
 
 	return status;
 }
 
 /*
- *  ======== PROC_GetState ========
+ *  ======== proc_get_state ========
  *  Purpose:
  *      Report the state of the specified DSP processor.
  */
-DSP_STATUS PROC_GetState(void *hProcessor,
-			OUT struct DSP_PROCESSORSTATE *pProcStatus,
-			u32 uStateInfoSize)
+dsp_status proc_get_state(void *hprocessor,
+			  OUT struct dsp_processorstate *proc_state_obj,
+			  u32 state_info_size)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	int brdStatus;
-	struct DEH_MGR *hDehMgr;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	int brd_status;
+	struct deh_mgr *hdeh_mgr;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pProcStatus != NULL);
-	DBC_Require(uStateInfoSize >= sizeof(struct DSP_PROCESSORSTATE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(proc_state_obj != NULL);
+	DBC_REQUIRE(state_info_size >= sizeof(struct dsp_processorstate));
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		/* First, retrieve BRD state information */
-		status = (*pProcObject->pIntfFxns->pfnBrdStatus)
-				   (pProcObject->hWmdContext, &brdStatus);
+		status = (*p_proc_object->intf_fxns->pfn_brd_status)
+		    (p_proc_object->hwmd_context, &brd_status);
 		if (DSP_SUCCEEDED(status)) {
-			switch (brdStatus) {
+			switch (brd_status) {
 			case BRD_STOPPED:
-				pProcStatus->iState = PROC_STOPPED;
+				proc_state_obj->proc_state = PROC_STOPPED;
 				break;
 			case BRD_SLEEP_TRANSITION:
 			case BRD_DSP_HIBERNATION:
 				/* Fall through */
 			case BRD_RUNNING:
-				pProcStatus->iState = PROC_RUNNING;
+				proc_state_obj->proc_state = PROC_RUNNING;
 				break;
 			case BRD_LOADED:
-				pProcStatus->iState = PROC_LOADED;
+				proc_state_obj->proc_state = PROC_LOADED;
 				break;
 			case BRD_ERROR:
-				pProcStatus->iState = PROC_ERROR;
+				proc_state_obj->proc_state = PROC_ERROR;
 				break;
 			default:
-				pProcStatus->iState = 0xFF;
+				proc_state_obj->proc_state = 0xFF;
 				status = DSP_EFAIL;
 				break;
 			}
 		}
 		/* Next, retrieve error information, if any */
-		status = DEV_GetDehMgr(pProcObject->hDevObject, &hDehMgr);
-		if (DSP_SUCCEEDED(status) && hDehMgr)
-			status = (*pProcObject->pIntfFxns->pfnDehGetInfo)
-				 (hDehMgr, &(pProcStatus->errInfo));
+		status = dev_get_deh_mgr(p_proc_object->hdev_obj, &hdeh_mgr);
+		if (DSP_SUCCEEDED(status) && hdeh_mgr)
+			status = (*p_proc_object->intf_fxns->pfn_deh_get_info)
+			    (hdeh_mgr, &(proc_state_obj->err_info));
 	} else {
 		status = DSP_EHANDLE;
 	}
-	dev_dbg(bridge, "%s, results: status: 0x%x pProcStatus: 0x%x\n",
-					__func__, status, pProcStatus->iState);
+	dev_dbg(bridge, "%s, results: status: 0x%x proc_state_obj: 0x%x\n",
+		__func__, status, proc_state_obj->proc_state);
 	return status;
 }
 
 /*
- *  ======== PROC_GetTrace ========
+ *  ======== proc_get_trace ========
  *  Purpose:
  *      Retrieve the current contents of the trace buffer, located on the
  *      Processor.  Predefined symbols for the trace buffer must have been
@@ -756,61 +768,58 @@ DSP_STATUS PROC_GetState(void *hProcessor,
  *      This call is destructive, meaning the processor is placed in the monitor
  *      state as a result of this function.
  */
-DSP_STATUS PROC_GetTrace(void *hProcessor, u8 *pBuf, u32 uMaxSize)
+dsp_status proc_get_trace(void *hprocessor, u8 * pbuf, u32 max_size)
 {
-	DSP_STATUS status;
+	dsp_status status;
 	status = DSP_ENOTIMPL;
 	return status;
 }
 
 /*
- *  ======== PROC_Init ========
+ *  ======== proc_init ========
  *  Purpose:
  *      Initialize PROC's private state, keeping a reference count on each call
  */
-bool PROC_Init(void)
+bool proc_init(void)
 {
-	bool fRetval = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0)
-		(void)SYNC_InitializeCS(&hProcLock);
+	if (ret)
+		refs++;
 
-	if (fRetval)
-		cRefs++;
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
-
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== PROC_Load ========
+ *  ======== proc_load ========
  *  Purpose:
  *      Reset a processor and load a new base program image.
  *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge
  *      application developer's API.
  */
-DSP_STATUS PROC_Load(void *hProcessor, IN CONST s32 iArgc,
-		    IN CONST char **aArgv, IN CONST char **aEnvp)
+dsp_status proc_load(void *hprocessor, IN CONST s32 argc_index,
+		     IN CONST char **user_args, IN CONST char **user_envp)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct IO_MGR *hIOMgr;		/* IO manager handle */
-	struct MSG_MGR *hMsgMgr;
-	struct COD_MANAGER *hCodMgr;	/* Code manager handle */
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct io_mgr *hio_mgr;	/* IO manager handle */
+	struct msg_mgr *hmsg_mgr;
+	struct cod_manager *cod_mgr;	/* Code manager handle */
 	char *pargv0;		/* temp argv[0] ptr */
-	char **newEnvp;		/* Updated envp[] array. */
-	char szProcID[MAXPROCIDLEN];	/* Size of "PROC_ID=<n>" */
-	s32 cEnvp;		/* Num elements in envp[]. */
-	s32 cNewEnvp;		/* "  " in newEnvp[]     */
-	s32 nProcID = 0;	/* Anticipate MP version. */
-	struct DCD_MANAGER *hDCDHandle;
-	struct DMM_OBJECT *hDmmMgr;
-	u32 dwExtEnd;
-	u32 uProcId;
-	int uBrdState;
+	char **new_envp;	/* Updated envp[] array. */
+	char sz_proc_id[MAXPROCIDLEN];	/* Size of "PROC_ID=<n>" */
+	s32 envp_elems;		/* Num elements in envp[]. */
+	s32 cnew_envp;		/* "  " in new_envp[] */
+	s32 nproc_id = 0;	/* Anticipate MP version. */
+	struct dcd_manager *hdcd_handle;
+	struct dmm_object *dmm_mgr;
+	u32 dw_ext_end;
+	u32 proc_id;
+	int brd_state;
 
 #ifdef OPT_LOAD_TIME_INSTRUMENTATION
 	struct timeval tv1;
@@ -819,74 +828,77 @@ DSP_STATUS PROC_Load(void *hProcessor, IN CONST s32 iArgc,
 
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
 	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 #endif
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(iArgc > 0);
-	DBC_Require(aArgv != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(argc_index > 0);
+	DBC_REQUIRE(user_args != NULL);
 
 #ifdef OPT_LOAD_TIME_INSTRUMENTATION
 	do_gettimeofday(&tv1);
 #endif
-	/* Call the WMD_BRD_Load Fxn */
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	/* Call the WMD_BRD_Load fxn */
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	DEV_GetCodMgr(pProcObject->hDevObject, &hCodMgr);
-	if (!hCodMgr) {
+	dev_get_cod_mgr(p_proc_object->hdev_obj, &cod_mgr);
+	if (!cod_mgr) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	status = PROC_Stop(hProcessor);
+	status = proc_stop(hprocessor);
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* Place the board in the monitor state. */
-	status = PROC_Monitor(hProcessor);
+	status = proc_monitor(hprocessor);
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* Save ptr to  original argv[0]. */
-	pargv0 = (char *)aArgv[0];
-	/*Prepend "PROC_ID=<nProcID>"to envp array for target.*/
-	cEnvp = GetEnvpCount((char **)aEnvp);
-	cNewEnvp = (cEnvp ? (cEnvp + 1) : (cEnvp + 2));
-	newEnvp = MEM_Calloc(cNewEnvp * sizeof(char **), MEM_PAGED);
-	if (newEnvp) {
-		status = snprintf(szProcID, MAXPROCIDLEN, PROC_ENVPROCID,
-				    nProcID);
+	pargv0 = (char *)user_args[0];
+	/*Prepend "PROC_ID=<nproc_id>"to envp array for target. */
+	envp_elems = get_envp_count((char **)user_envp);
+	cnew_envp = (envp_elems ? (envp_elems + 1) : (envp_elems + 2));
+	new_envp = mem_calloc(cnew_envp * sizeof(char **), MEM_PAGED);
+	if (new_envp) {
+		status = snprintf(sz_proc_id, MAXPROCIDLEN, PROC_ENVPROCID,
+				  nproc_id);
 		if (status == -1) {
 			dev_dbg(bridge, "%s: Proc ID string overflow\n",
-								__func__);
+				__func__);
 			status = DSP_EFAIL;
 		} else {
-			newEnvp = PrependEnvp(newEnvp, (char **)aEnvp, cEnvp,
-					     cNewEnvp, szProcID);
+			new_envp =
+			    prepend_envp(new_envp, (char **)user_envp,
+					 envp_elems, cnew_envp, sz_proc_id);
 			/* Get the DCD Handle */
-			status = MGR_GetDCDHandle(pProcObject->hMgrObject,
-						 (u32 *)&hDCDHandle);
+			status = mgr_get_dcd_handle(p_proc_object->hmgr_obj,
+						    (u32 *) &hdcd_handle);
 			if (DSP_SUCCEEDED(status)) {
 				/*  Before proceeding with new load,
 				 *  check if a previously registered COFF
 				 *  exists.
 				 *  If yes, unregister nodes in previously
 				 *  registered COFF.  If any error occurred,
-				 *  set previously registered COFF to NULL.  */
-				if (pProcObject->g_pszLastCoff != NULL) {
-					status = DCD_AutoUnregister(hDCDHandle,
-						 pProcObject->g_pszLastCoff);
+				 *  set previously registered COFF to NULL. */
+				if (p_proc_object->psz_last_coff != NULL) {
+					status =
+					    dcd_auto_unregister(hdcd_handle,
+								p_proc_object->
+								psz_last_coff);
 					/* Regardless of auto unregister status,
 					 *  free previously allocated
-					 *  memory.  */
-					kfree(pProcObject->g_pszLastCoff);
-					pProcObject->g_pszLastCoff = NULL;
+					 *  memory. */
+					kfree(p_proc_object->psz_last_coff);
+					p_proc_object->psz_last_coff = NULL;
 				}
 			}
-			/* On success, do COD_OpenBase() */
-			status = COD_OpenBase(hCodMgr, (char *)aArgv[0],
-					     COD_SYMB);
+			/* On success, do cod_open_base() */
+			status = cod_open_base(cod_mgr, (char *)user_args[0],
+					       COD_SYMB);
 		}
 	} else {
 		status = DSP_EMEMORY;
@@ -894,31 +906,35 @@ DSP_STATUS PROC_Load(void *hProcessor, IN CONST s32 iArgc,
 	if (DSP_SUCCEEDED(status)) {
 		/* Auto-register data base */
 		/* Get the DCD Handle */
-		status = MGR_GetDCDHandle(pProcObject->hMgrObject,
-					 (u32 *)&hDCDHandle);
+		status = mgr_get_dcd_handle(p_proc_object->hmgr_obj,
+					    (u32 *) &hdcd_handle);
 		if (DSP_SUCCEEDED(status)) {
 			/*  Auto register nodes in specified COFF
 			 *  file.  If registration did not fail,
 			 *  (status = DSP_SOK or DSP_EDCDNOAUTOREGISTER)
 			 *  save the name of the COFF file for
-			 *  de-registration in the future.  */
-			status = DCD_AutoRegister(hDCDHandle, (char *)aArgv[0]);
+			 *  de-registration in the future. */
+			status =
+			    dcd_auto_register(hdcd_handle,
+					      (char *)user_args[0]);
 			if (status == DSP_EDCDNOAUTOREGISTER)
 				status = DSP_SOK;
 
 			if (DSP_FAILED(status)) {
 				status = DSP_EFAIL;
 			} else {
-				DBC_Assert(pProcObject->g_pszLastCoff == NULL);
+				DBC_ASSERT(p_proc_object->psz_last_coff ==
+					   NULL);
 				/* Allocate memory for pszLastCoff */
-				pProcObject->g_pszLastCoff = MEM_Calloc(
-					(strlen((char *)aArgv[0]) + 1),
-					MEM_PAGED);
-				/* If memory allocated, save COFF file name*/
-				if (pProcObject->g_pszLastCoff) {
-					strncpy(pProcObject->g_pszLastCoff,
-						(char *)aArgv[0],
-						(strlen((char *)aArgv[0]) + 1));
+				p_proc_object->psz_last_coff =
+				    mem_calloc((strlen((char *)user_args[0]) +
+						1), MEM_PAGED);
+				/* If memory allocated, save COFF file name */
+				if (p_proc_object->psz_last_coff) {
+					strncpy(p_proc_object->psz_last_coff,
+						(char *)user_args[0],
+						(strlen((char *)user_args[0]) +
+						 1));
 				}
 			}
 		}
@@ -926,80 +942,83 @@ DSP_STATUS PROC_Load(void *hProcessor, IN CONST s32 iArgc,
 	/* Update shared memory address and size */
 	if (DSP_SUCCEEDED(status)) {
 		/*  Create the message manager. This must be done
-		 *  before calling the IOOnLoaded function.  */
-		DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
-		if (!hMsgMgr) {
-			status = MSG_Create(&hMsgMgr, pProcObject->hDevObject,
-					   (MSG_ONEXIT)NODE_OnExit);
-			DBC_Assert(DSP_SUCCEEDED(status));
-			DEV_SetMsgMgr(pProcObject->hDevObject, hMsgMgr);
+		 *  before calling the IOOnLoaded function. */
+		dev_get_msg_mgr(p_proc_object->hdev_obj, &hmsg_mgr);
+		if (!hmsg_mgr) {
+			status = msg_create(&hmsg_mgr, p_proc_object->hdev_obj,
+					    (msg_onexit) node_on_exit);
+			DBC_ASSERT(DSP_SUCCEEDED(status));
+			dev_set_msg_mgr(p_proc_object->hdev_obj, hmsg_mgr);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Set the Device object's message manager */
-		status = DEV_GetIOMgr(pProcObject->hDevObject, &hIOMgr);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = (*pProcObject->pIntfFxns->pfnIOOnLoaded)(hIOMgr);
+		status = dev_get_io_mgr(p_proc_object->hdev_obj, &hio_mgr);
+		DBC_ASSERT(DSP_SUCCEEDED(status));
+		status =
+		    (*p_proc_object->intf_fxns->pfn_io_on_loaded) (hio_mgr);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Now, attempt to load an exec: */
 
-	/* Boost the OPP level to Maximum level supported by baseport*/
+		/* Boost the OPP level to Maximum level supported by baseport */
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
-	if (pdata->cpu_set_freq)
-		(*pdata->cpu_set_freq)(pdata->mpu_max_speed);
+		if (pdata->cpu_set_freq)
+			(*pdata->cpu_set_freq) (pdata->mpu_max_speed);
 #endif
-		status = COD_LoadBase(hCodMgr, iArgc, (char **)aArgv,
-				     DEV_BrdWriteFxn,
-				     pProcObject->hDevObject, NULL);
+		status = cod_load_base(cod_mgr, argc_index, (char **)user_args,
+				       dev_brd_write_fxn,
+				       p_proc_object->hdev_obj, NULL);
 		if (DSP_FAILED(status)) {
 			if (status == COD_E_OPENFAILED) {
-				dev_dbg(bridge,	"%s: Failure to Load the EXE\n",
-								__func__);
+				dev_dbg(bridge, "%s: Failure to Load the EXE\n",
+					__func__);
 			}
 			if (status == COD_E_SYMBOLNOTFOUND) {
 				pr_err("%s: Couldn't parse the file\n",
-								__func__);
+				       __func__);
 			}
 		}
-	/* Requesting the lowest opp supported*/
+		/* Requesting the lowest opp supported */
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
-	if (pdata->cpu_set_freq)
-		(*pdata->cpu_set_freq)(pdata->mpu_min_speed);
+		if (pdata->cpu_set_freq)
+			(*pdata->cpu_set_freq) (pdata->mpu_min_speed);
 #endif
 
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Update the Processor status to loaded */
-		status = (*pProcObject->pIntfFxns->pfnBrdSetState)
-			 (pProcObject->hWmdContext, BRD_LOADED);
+		status = (*p_proc_object->intf_fxns->pfn_brd_set_state)
+		    (p_proc_object->hwmd_context, BRD_LOADED);
 		if (DSP_SUCCEEDED(status)) {
-			pProcObject->sState = PROC_LOADED;
-			if (pProcObject->hNtfy)
-				PROC_NotifyClients(pProcObject,
-						 DSP_PROCESSORSTATECHANGE);
+			p_proc_object->proc_state = PROC_LOADED;
+			if (p_proc_object->ntfy_obj)
+				proc_notify_clients(p_proc_object,
+						    DSP_PROCESSORSTATECHANGE);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = PROC_GetProcessorId(hProcessor, &uProcId);
-		if (uProcId == DSP_UNIT) {
+		status = proc_get_processor_id(hprocessor, &proc_id);
+		if (proc_id == DSP_UNIT) {
 			/* Use all available DSP address space after EXTMEM
 			 * for DMM */
 			if (DSP_SUCCEEDED(status))
-				status = COD_GetSymValue(hCodMgr, EXTEND,
-								&dwExtEnd);
+				status = cod_get_sym_value(cod_mgr, EXTEND,
+							   &dw_ext_end);
 
-			/* Reset DMM structs and add an initial free chunk*/
+			/* Reset DMM structs and add an initial free chunk */
 			if (DSP_SUCCEEDED(status)) {
-				DEV_GetDmmMgr(pProcObject->hDevObject,
-						      &hDmmMgr);
-				if (hDmmMgr) {
-					/* Set dwExtEnd to DMM START u8
-					  * address */
-					dwExtEnd = (dwExtEnd + 1) * DSPWORDSIZE;
-					 /* DMM memory is from EXT_END */
-					status = DMM_CreateTables(hDmmMgr,
-						dwExtEnd, DMMPOOLSIZE);
+				dev_get_dmm_mgr(p_proc_object->hdev_obj,
+						&dmm_mgr);
+				if (dmm_mgr) {
+					/* Set dw_ext_end to DMM START u8
+					 * address */
+					dw_ext_end =
+					    (dw_ext_end + 1) * DSPWORDSIZE;
+					/* DMM memory is from EXT_END */
+					status = dmm_create_tables(dmm_mgr,
+								   dw_ext_end,
+								   DMMPOOLSIZE);
 				} else {
 					status = DSP_EHANDLE;
 				}
@@ -1007,26 +1026,27 @@ DSP_STATUS PROC_Load(void *hProcessor, IN CONST s32 iArgc,
 		}
 	}
 	/* Restore the original argv[0] */
-	kfree(newEnvp);
-	aArgv[0] = pargv0;
+	kfree(new_envp);
+	user_args[0] = pargv0;
 	if (DSP_SUCCEEDED(status)) {
-		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-		   (pProcObject->hWmdContext, &uBrdState))) {
+		if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
+				  (p_proc_object->hwmd_context, &brd_state))) {
 			pr_info("%s: Processor Loaded %s\n", __func__, pargv0);
-			DBC_Assert(uBrdState == BRD_LOADED);
+			DBC_ASSERT(brd_state == BRD_LOADED);
 			/*
 			 * Save absolute path for base image so that recovery
 			 * can load it.
 			 */
-			REG_SetValue(DEFEXEC, (u8 *)pargv0,
-						 strlen(pargv0) + 1);
+			reg_set_value(DEFEXEC, (u8 *) pargv0,
+				      strlen(pargv0) + 1);
 		}
 	}
 
 func_end:
 	if (DSP_FAILED(status))
 		pr_err("%s: Processor failed to load\n", __func__);
-	DBC_Ensure((DSP_SUCCEEDED(status) && pProcObject->sState == PROC_LOADED)
+	DBC_ENSURE((DSP_SUCCEEDED(status)
+		    && p_proc_object->proc_state == PROC_LOADED)
 		   || DSP_FAILED(status));
 #ifdef OPT_LOAD_TIME_INSTRUMENTATION
 	do_gettimeofday(&tv2);
@@ -1035,72 +1055,72 @@ func_end:
 		tv2.tv_sec--;
 	}
 	dev_dbg(bridge, "%s: time to load %d sec and %d usec\n", __func__,
-		    tv2.tv_sec - tv1.tv_sec, tv2.tv_usec - tv1.tv_usec);
+		tv2.tv_sec - tv1.tv_sec, tv2.tv_usec - tv1.tv_usec);
 #endif
 	return status;
 }
 
 /*
- *  ======== PROC_Map ========
+ *  ======== proc_map ========
  *  Purpose:
  *      Maps a MPU buffer to DSP address space.
  */
-DSP_STATUS PROC_Map(void *hProcessor, void *pMpuAddr, u32 ulSize,
-		   void *pReqAddr, void **ppMapAddr, u32 ulMapAttr,
-		   struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status proc_map(void *hprocessor, void *pmpu_addr, u32 ul_size,
+		    void *req_addr, void **pp_map_addr, u32 ul_map_attr,
+		    struct process_context *pr_ctxt)
 {
-	u32 vaAlign;
-	u32 paAlign;
-	struct DMM_OBJECT *hDmmMgr;
-	u32 sizeAlign;
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct DMM_MAP_OBJECT *map_obj;
+	u32 va_align;
+	u32 pa_align;
+	struct dmm_object *dmm_mgr;
+	u32 size_align;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct dmm_map_object *map_obj;
 
 #ifdef CONFIG_BRIDGE_CACHE_LINE_CHECK
-	if ((ulMapAttr & BUFMODE_MASK) != RBUF) {
-		if (!IS_ALIGNED((u32)pMpuAddr, DSP_CACHE_LINE) ||
-		    !IS_ALIGNED(ulSize, DSP_CACHE_LINE)) {
+	if ((ul_map_attr & BUFMODE_MASK) != RBUF) {
+		if (!IS_ALIGNED((u32) pmpu_addr, DSP_CACHE_LINE) ||
+		    !IS_ALIGNED(ul_size, DSP_CACHE_LINE)) {
 			pr_err("%s: not aligned: 0x%x (%d)\n", __func__,
-						(u32)pMpuAddr, ulSize);
+			       (u32) pmpu_addr, ul_size);
 			return -EFAULT;
 		}
 	}
 #endif
 
 	/* Calculate the page-aligned PA, VA and size */
-	vaAlign = PG_ALIGN_LOW((u32) pReqAddr, PG_SIZE_4K);
-	paAlign = PG_ALIGN_LOW((u32) pMpuAddr, PG_SIZE_4K);
-	sizeAlign = PG_ALIGN_HIGH(ulSize + (u32)pMpuAddr - paAlign,
-				 PG_SIZE_4K);
+	va_align = PG_ALIGN_LOW((u32) req_addr, PG_SIZE4K);
+	pa_align = PG_ALIGN_LOW((u32) pmpu_addr, PG_SIZE4K);
+	size_align = PG_ALIGN_HIGH(ul_size + (u32) pmpu_addr - pa_align,
+				   PG_SIZE4K);
 
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 	/* Critical section */
-	(void)SYNC_EnterCS(hProcLock);
-	DMM_GetHandle(pProcObject, &hDmmMgr);
-	if (hDmmMgr)
-		status = DMM_MapMemory(hDmmMgr, vaAlign, sizeAlign);
+	mutex_lock(&proc_lock);
+	dmm_get_handle(p_proc_object, &dmm_mgr);
+	if (dmm_mgr)
+		status = dmm_map_memory(dmm_mgr, va_align, size_align);
 	else
 		status = DSP_EHANDLE;
 
 	/* Add mapping to the page tables. */
 	if (DSP_SUCCEEDED(status)) {
 
-		status = (*pProcObject->pIntfFxns->pfnBrdMemMap)
-			(pProcObject->hWmdContext, paAlign, vaAlign, sizeAlign,
-			ulMapAttr);
+		status = (*p_proc_object->intf_fxns->pfn_brd_mem_map)
+		    (p_proc_object->hwmd_context, pa_align, va_align,
+		     size_align, ul_map_attr);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Mapped address = MSB of VA | LSB of PA */
-		*ppMapAddr = (void *) (vaAlign | ((u32) pMpuAddr &
-			     (PG_SIZE_4K - 1)));
+		*pp_map_addr = (void *)(va_align | ((u32) pmpu_addr &
+						    (PG_SIZE4K - 1)));
 	} else {
-		DMM_UnMapMemory(hDmmMgr, vaAlign, &sizeAlign);
+		dmm_un_map_memory(dmm_mgr, va_align, &size_align);
 	}
-	(void)SYNC_LeaveCS(hProcLock);
+	mutex_unlock(&proc_lock);
 
 	if (DSP_FAILED(status))
 		goto func_end;
@@ -1110,90 +1130,94 @@ DSP_STATUS PROC_Map(void *hProcessor, void *pMpuAddr, u32 ulSize,
 	 * into dmm_map_list, so that mapped memory resource tracking
 	 * remains uptodate
 	 */
-	map_obj = kmalloc(sizeof(struct DMM_MAP_OBJECT), GFP_KERNEL);
+	map_obj = kmalloc(sizeof(struct dmm_map_object), GFP_KERNEL);
 	if (map_obj) {
-		map_obj->dsp_addr = (u32)*ppMapAddr;
+		map_obj->dsp_addr = (u32) *pp_map_addr;
 		spin_lock(&pr_ctxt->dmm_map_lock);
 		list_add(&map_obj->link, &pr_ctxt->dmm_map_list);
 		spin_unlock(&pr_ctxt->dmm_map_lock);
 	}
 
 func_end:
-	dev_dbg(bridge, "%s: hProcessor %p, pMpuAddr %p, ulSize %x, "
-		"pReqAddr %p, ulMapAttr %x, ppMapAddr %p, vaAlign %x, "
-		"paAlign %x, sizeAlign %x status 0x%x\n", __func__, hProcessor,
-		pMpuAddr, ulSize, pReqAddr, ulMapAttr,  ppMapAddr, vaAlign,
-		paAlign, sizeAlign, status);
+	dev_dbg(bridge, "%s: hprocessor %p, pmpu_addr %p, ul_size %x, "
+		"req_addr %p, ul_map_attr %x, pp_map_addr %p, va_align %x, "
+		"pa_align %x, size_align %x status 0x%x\n", __func__,
+		hprocessor, pmpu_addr, ul_size, req_addr, ul_map_attr,
+		pp_map_addr, va_align, pa_align, size_align, status);
 
 	return status;
 }
 
 /*
- *  ======== PROC_RegisterNotify ========
+ *  ======== proc_register_notify ========
  *  Purpose:
  *      Register to be notified of specific processor events.
  */
-DSP_STATUS PROC_RegisterNotify(void *hProcessor, u32 uEventMask,
-			      u32 uNotifyType, struct DSP_NOTIFICATION
-			      *hNotification)
+dsp_status proc_register_notify(void *hprocessor, u32 event_mask,
+				u32 notify_type, struct dsp_notification
+				* hnotification)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct DEH_MGR *hDehMgr;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct deh_mgr *hdeh_mgr;
 
-	DBC_Require(hNotification != NULL);
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(hnotification != NULL);
+	DBC_REQUIRE(refs > 0);
 
 	/* Check processor handle */
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 	/* Check if event mask is a valid processor related event */
-	if (uEventMask & ~(DSP_PROCESSORSTATECHANGE | DSP_PROCESSORATTACH |
-	   DSP_PROCESSORDETACH | DSP_PROCESSORRESTART | DSP_MMUFAULT |
-	   DSP_SYSERROR | DSP_PWRERROR | DSP_WDTOVERFLOW))
+	if (event_mask & ~(DSP_PROCESSORSTATECHANGE | DSP_PROCESSORATTACH |
+			   DSP_PROCESSORDETACH | DSP_PROCESSORRESTART |
+			   DSP_MMUFAULT | DSP_SYSERROR | DSP_PWRERROR |
+			   DSP_WDTOVERFLOW))
 		status = DSP_EVALUE;
 
 	/* Check if notify type is valid */
-	if (uNotifyType != DSP_SIGNALEVENT)
+	if (notify_type != DSP_SIGNALEVENT)
 		status = DSP_EVALUE;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* If event mask is not DSP_SYSERROR, DSP_MMUFAULT,
 		 * or DSP_PWRERROR then register event immediately. */
-		if (uEventMask &
+		if (event_mask &
 		    ~(DSP_SYSERROR | DSP_MMUFAULT | DSP_PWRERROR |
-				DSP_WDTOVERFLOW)) {
-			status = NTFY_Register(pProcObject->hNtfy,
-				 hNotification,	uEventMask, uNotifyType);
+		      DSP_WDTOVERFLOW)) {
+			status = ntfy_register(p_proc_object->ntfy_obj,
+					       hnotification, event_mask,
+					       notify_type);
 			/* Special case alert, special case alert!
-			 * If we're trying to *deregister* (i.e. uEventMask
+			 * If we're trying to *deregister* (i.e. event_mask
 			 * is 0), a DSP_SYSERROR or DSP_MMUFAULT notification,
 			 * we have to deregister with the DEH manager.
-			 * There's no way to know, based on uEventMask which
+			 * There's no way to know, based on event_mask which
 			 * manager the notification event was registered with,
-			 * so if we're trying to deregister and NTFY_Register
+			 * so if we're trying to deregister and ntfy_register
 			 * failed, we'll give the deh manager a shot.
 			 */
-			if ((uEventMask == 0) && DSP_FAILED(status)) {
-				status = DEV_GetDehMgr(pProcObject->hDevObject,
-					 &hDehMgr);
-				DBC_Assert(pProcObject->pIntfFxns->
-					   pfnDehRegisterNotify);
-				status = (*pProcObject->pIntfFxns->
-					 pfnDehRegisterNotify)
-					 (hDehMgr, uEventMask, uNotifyType,
-					 hNotification);
+			if ((event_mask == 0) && DSP_FAILED(status)) {
+				status =
+				    dev_get_deh_mgr(p_proc_object->hdev_obj,
+						    &hdeh_mgr);
+				DBC_ASSERT(p_proc_object->
+					   intf_fxns->pfn_deh_register_notify);
+				status =
+				    (*p_proc_object->
+				     intf_fxns->pfn_deh_register_notify)
+				    (hdeh_mgr, event_mask, notify_type,
+				     hnotification);
 			}
 		} else {
-			status = DEV_GetDehMgr(pProcObject->hDevObject,
-					      &hDehMgr);
-			DBC_Assert(pProcObject->pIntfFxns->
-				  pfnDehRegisterNotify);
-			status = (*pProcObject->pIntfFxns->pfnDehRegisterNotify)
-				 (hDehMgr, uEventMask, uNotifyType,
-				 hNotification);
+			status = dev_get_deh_mgr(p_proc_object->hdev_obj,
+						 &hdeh_mgr);
+			DBC_ASSERT(p_proc_object->
+				   intf_fxns->pfn_deh_register_notify);
+			status =
+			    (*p_proc_object->intf_fxns->pfn_deh_register_notify)
+			    (hdeh_mgr, event_mask, notify_type, hnotification);
 
 		}
 	}
@@ -1202,30 +1226,31 @@ func_end:
 }
 
 /*
- *  ======== PROC_ReserveMemory ========
+ *  ======== proc_reserve_memory ========
  *  Purpose:
  *      Reserve a virtually contiguous region of DSP address space.
  */
-DSP_STATUS PROC_ReserveMemory(void *hProcessor, u32 ulSize,
-		     void **ppRsvAddr, struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status proc_reserve_memory(void *hprocessor, u32 ul_size,
+			       void **pp_rsv_addr,
+			       struct process_context *pr_ctxt)
 {
-	struct DMM_OBJECT *hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct DMM_RSV_OBJECT *rsv_obj;
+	struct dmm_object *dmm_mgr;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct dmm_rsv_object *rsv_obj;
 
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
-	DMM_GetHandle(pProcObject, &hDmmMgr);
-	if (!hDmmMgr) {
+	dmm_get_handle(p_proc_object, &dmm_mgr);
+	if (!dmm_mgr) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
-	status = DMM_ReserveMemory(hDmmMgr, ulSize, (u32 *)ppRsvAddr);
+	status = dmm_reserve_memory(dmm_mgr, ul_size, (u32 *) pp_rsv_addr);
 	if (status != DSP_SOK)
 		goto func_end;
 
@@ -1234,152 +1259,155 @@ DSP_STATUS PROC_ReserveMemory(void *hProcessor, u32 ulSize,
 	 * into dmm_rsv_list, so that reserved memory resource tracking
 	 * remains uptodate
 	 */
-	rsv_obj = kmalloc(sizeof(struct DMM_RSV_OBJECT), GFP_KERNEL);
+	rsv_obj = kmalloc(sizeof(struct dmm_rsv_object), GFP_KERNEL);
 	if (rsv_obj) {
-		rsv_obj->dsp_reserved_addr = (u32) *ppRsvAddr;
+		rsv_obj->dsp_reserved_addr = (u32) *pp_rsv_addr;
 		spin_lock(&pr_ctxt->dmm_rsv_lock);
 		list_add(&rsv_obj->link, &pr_ctxt->dmm_rsv_list);
 		spin_unlock(&pr_ctxt->dmm_rsv_lock);
 	}
 
 func_end:
-	dev_dbg(bridge, "%s: hProcessor: 0x%p ulSize: 0x%x ppRsvAddr: 0x%p "
-					"status 0x%x\n", __func__, hProcessor,
-					ulSize, ppRsvAddr, status);
+	dev_dbg(bridge, "%s: hprocessor: 0x%p ul_size: 0x%x pp_rsv_addr: 0x%p "
+		"status 0x%x\n", __func__, hprocessor,
+		ul_size, pp_rsv_addr, status);
 	return status;
 }
 
 /*
- *  ======== PROC_Start ========
+ *  ======== proc_start ========
  *  Purpose:
  *      Start a processor running.
  */
-DSP_STATUS PROC_Start(void *hProcessor)
+dsp_status proc_start(void *hprocessor)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct COD_MANAGER *hCodMgr;	/* Code manager handle    */
-	u32 dwDspAddr;	/* Loaded code's entry point.    */
-	int uBrdState;
-
-	DBC_Require(cRefs > 0);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct cod_manager *cod_mgr;	/* Code manager handle */
+	u32 dw_dsp_addr;	/* Loaded code's entry point. */
+	int brd_state;
+
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	/* Call the WMD_BRD_Start */
-	if (pProcObject->sState != PROC_LOADED) {
+	/* Call the bridge_brd_start */
+	if (p_proc_object->proc_state != PROC_LOADED) {
 		status = DSP_EWRONGSTATE;
 		goto func_end;
 	}
-	DEV_GetCodMgr(pProcObject->hDevObject, &hCodMgr);
-	if (!hCodMgr) {
+	dev_get_cod_mgr(p_proc_object->hdev_obj, &cod_mgr);
+	if (!cod_mgr) {
 		status = DSP_EHANDLE;
 		goto func_cont;
 	}
 
-	status = COD_GetEntry(hCodMgr, &dwDspAddr);
+	status = cod_get_entry(cod_mgr, &dw_dsp_addr);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	status = (*pProcObject->pIntfFxns->pfnBrdStart)
-		 (pProcObject->hWmdContext, dwDspAddr);
+	status = (*p_proc_object->intf_fxns->pfn_brd_start)
+	    (p_proc_object->hwmd_context, dw_dsp_addr);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	/* Call DEV_Create2 */
-	status = DEV_Create2(pProcObject->hDevObject);
+	/* Call dev_create2 */
+	status = dev_create2(p_proc_object->hdev_obj);
 	if (DSP_SUCCEEDED(status)) {
-		pProcObject->sState = PROC_RUNNING;
+		p_proc_object->proc_state = PROC_RUNNING;
 		/* Deep sleep switces off the peripheral clocks.
 		 * we just put the DSP CPU in idle in the idle loop.
 		 * so there is no need to send a command to DSP */
 
-		if (pProcObject->hNtfy) {
-			PROC_NotifyClients(pProcObject,
-					  DSP_PROCESSORSTATECHANGE);
+		if (p_proc_object->ntfy_obj) {
+			proc_notify_clients(p_proc_object,
+					    DSP_PROCESSORSTATECHANGE);
 		}
 	} else {
 		/* Failed to Create Node Manager and DISP Object
 		 * Stop the Processor from running. Put it in STOPPED State */
-		(void)(*pProcObject->pIntfFxns->pfnBrdStop)(pProcObject->
-			hWmdContext);
-		pProcObject->sState = PROC_STOPPED;
+		(void)(*p_proc_object->intf_fxns->
+		       pfn_brd_stop) (p_proc_object->hwmd_context);
+		p_proc_object->proc_state = PROC_STOPPED;
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status)) {
-		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-		   (pProcObject->hWmdContext, &uBrdState))) {
+		if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
+				  (p_proc_object->hwmd_context, &brd_state))) {
 			pr_info("%s: dsp in running state\n", __func__);
-			DBC_Assert(uBrdState != BRD_HIBERNATION);
+			DBC_ASSERT(brd_state != BRD_HIBERNATION);
 		}
 	} else {
 		pr_err("%s: Failed to start the dsp\n", __func__);
 	}
 
 func_end:
-	DBC_Ensure((DSP_SUCCEEDED(status) && pProcObject->sState ==
-		  PROC_RUNNING)	|| DSP_FAILED(status));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && p_proc_object->proc_state ==
+		    PROC_RUNNING) || DSP_FAILED(status));
 	return status;
 }
 
 /*
- *  ======== PROC_Stop ========
+ *  ======== proc_stop ========
  *  Purpose:
  *      Stop a processor running.
  */
-DSP_STATUS PROC_Stop(void *hProcessor)
+dsp_status proc_stop(void *hprocessor)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct MSG_MGR *hMsgMgr;
-	struct NODE_MGR *hNodeMgr;
-	void *hNode;
-	u32 uNodeTabSize = 1;
-	u32 uNumNodes = 0;
-	u32 uNodesAllocated = 0;
-	int uBrdState;
-
-	DBC_Require(cRefs > 0);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct msg_mgr *hmsg_mgr;
+	struct node_mgr *hnode_mgr;
+	void *hnode;
+	u32 node_tab_size = 1;
+	u32 num_nodes = 0;
+	u32 nodes_allocated = 0;
+	int brd_state;
+
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-	   (pProcObject->hWmdContext, &uBrdState))) {
-		if (uBrdState == BRD_ERROR)
-			WMD_DEH_ReleaseDummyMem();
+	if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
+			  (p_proc_object->hwmd_context, &brd_state))) {
+		if (brd_state == BRD_ERROR)
+			bridge_deh_release_dummy_mem();
 	}
 	/* check if there are any running nodes */
-	status = DEV_GetNodeManager(pProcObject->hDevObject, &hNodeMgr);
-	if (DSP_SUCCEEDED(status) && hNodeMgr) {
-		status = NODE_EnumNodes(hNodeMgr, &hNode, uNodeTabSize,
-					&uNumNodes, &uNodesAllocated);
-		if ((status == DSP_ESIZE) || (uNodesAllocated > 0)) {
+	status = dev_get_node_manager(p_proc_object->hdev_obj, &hnode_mgr);
+	if (DSP_SUCCEEDED(status) && hnode_mgr) {
+		status = node_enum_nodes(hnode_mgr, &hnode, node_tab_size,
+					 &num_nodes, &nodes_allocated);
+		if ((status == DSP_ESIZE) || (nodes_allocated > 0)) {
 			pr_err("%s: Can't stop device, active nodes = %d \n",
-						__func__, uNodesAllocated);
+			       __func__, nodes_allocated);
 			return DSP_EWRONGSTATE;
 		}
 	}
-	/* Call the WMD_BRD_Stop */
+	/* Call the bridge_brd_stop */
 	/* It is OK to stop a device that does n't have nodes OR not started */
-	status = (*pProcObject->pIntfFxns->pfnBrdStop)(pProcObject->
-		 hWmdContext);
+	status =
+	    (*p_proc_object->intf_fxns->
+	     pfn_brd_stop) (p_proc_object->hwmd_context);
 	if (DSP_SUCCEEDED(status)) {
 		dev_dbg(bridge, "%s: processor in standby mode\n", __func__);
-		pProcObject->sState = PROC_STOPPED;
-		/* Destory the Node Manager, MSG Manager */
-		if (DSP_SUCCEEDED(DEV_Destroy2(pProcObject->hDevObject))) {
-			/* Destroy the MSG by calling MSG_Delete */
-			DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
-			if (hMsgMgr) {
-				MSG_Delete(hMsgMgr);
-				DEV_SetMsgMgr(pProcObject->hDevObject, NULL);
+		p_proc_object->proc_state = PROC_STOPPED;
+		/* Destory the Node Manager, msg_ctrl Manager */
+		if (DSP_SUCCEEDED(dev_destroy2(p_proc_object->hdev_obj))) {
+			/* Destroy the msg_ctrl by calling msg_delete */
+			dev_get_msg_mgr(p_proc_object->hdev_obj, &hmsg_mgr);
+			if (hmsg_mgr) {
+				msg_delete(hmsg_mgr);
+				dev_set_msg_mgr(p_proc_object->hdev_obj, NULL);
 			}
-			if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->
-			   pfnBrdStatus)(pProcObject->hWmdContext,
-			   &uBrdState)))
-				DBC_Assert(uBrdState == BRD_STOPPED);
+			if (DSP_SUCCEEDED
+			    ((*p_proc_object->
+			      intf_fxns->pfn_brd_status) (p_proc_object->
+							  hwmd_context,
+							  &brd_state)))
+				DBC_ASSERT(brd_state == BRD_STOPPED);
 		}
 	} else {
 		pr_err("%s: Failed to stop the processor\n", __func__);
@@ -1390,45 +1418,45 @@ func_end:
 }
 
 /*
- *  ======== PROC_UnMap ========
+ *  ======== proc_un_map ========
  *  Purpose:
  *      Removes a MPU buffer mapping from the DSP address space.
  */
-DSP_STATUS PROC_UnMap(void *hProcessor, void *pMapAddr,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status proc_un_map(void *hprocessor, void *map_addr,
+		       struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct DMM_OBJECT *hDmmMgr;
-	u32 vaAlign;
-	u32 sizeAlign;
-	struct DMM_MAP_OBJECT *map_obj;
-
-	vaAlign = PG_ALIGN_LOW((u32) pMapAddr, PG_SIZE_4K);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct dmm_object *dmm_mgr;
+	u32 va_align;
+	u32 size_align;
+	struct dmm_map_object *map_obj;
+
+	va_align = PG_ALIGN_LOW((u32) map_addr, PG_SIZE4K);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
-	DMM_GetHandle(hProcessor, &hDmmMgr);
-	if (!hDmmMgr) {
+	dmm_get_handle(hprocessor, &dmm_mgr);
+	if (!dmm_mgr) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
 	/* Critical section */
-	(void)SYNC_EnterCS(hProcLock);
+	mutex_lock(&proc_lock);
 	/*
 	 * Update DMM structures. Get the size to unmap.
 	 * This function returns error if the VA is not mapped
 	 */
-	status = DMM_UnMapMemory(hDmmMgr, (u32) vaAlign, &sizeAlign);
+	status = dmm_un_map_memory(dmm_mgr, (u32) va_align, &size_align);
 	/* Remove mapping from the page tables. */
 	if (DSP_SUCCEEDED(status)) {
-		status = (*pProcObject->pIntfFxns->pfnBrdMemUnMap)
-			 (pProcObject->hWmdContext, vaAlign, sizeAlign);
+		status = (*p_proc_object->intf_fxns->pfn_brd_mem_un_map)
+		    (p_proc_object->hwmd_context, va_align, size_align);
 	}
-	(void)SYNC_LeaveCS(hProcLock);
+	mutex_unlock(&proc_lock);
 	if (DSP_FAILED(status))
 		goto func_end;
 
@@ -1439,7 +1467,7 @@ DSP_STATUS PROC_UnMap(void *hProcessor, void *pMapAddr,
 	 */
 	spin_lock(&pr_ctxt->dmm_map_lock);
 	list_for_each_entry(map_obj, &pr_ctxt->dmm_map_list, link) {
-		if (map_obj->dsp_addr == (u32)pMapAddr) {
+		if (map_obj->dsp_addr == (u32) map_addr) {
 			list_del(&map_obj->link);
 			kfree(map_obj);
 			break;
@@ -1448,36 +1476,36 @@ DSP_STATUS PROC_UnMap(void *hProcessor, void *pMapAddr,
 	spin_unlock(&pr_ctxt->dmm_map_lock);
 
 func_end:
-	dev_dbg(bridge, "%s: hProcessor: 0x%p pMapAddr: 0x%p status: 0x%x\n",
-					__func__, hProcessor, pMapAddr, status);
+	dev_dbg(bridge, "%s: hprocessor: 0x%p map_addr: 0x%p status: 0x%x\n",
+		__func__, hprocessor, map_addr, status);
 	return status;
 }
 
 /*
- *  ======== PROC_UnReserveMemory ========
+ *  ======== proc_un_reserve_memory ========
  *  Purpose:
  *      Frees a previously reserved region of DSP address space.
  */
-DSP_STATUS PROC_UnReserveMemory(void *hProcessor, void *pRsvAddr,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status proc_un_reserve_memory(void *hprocessor, void *prsv_addr,
+				  struct process_context *pr_ctxt)
 {
-	struct DMM_OBJECT *hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct DMM_RSV_OBJECT *rsv_obj;
+	struct dmm_object *dmm_mgr;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct dmm_rsv_object *rsv_obj;
 
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
-	DMM_GetHandle(pProcObject, &hDmmMgr);
-	if (!hDmmMgr) {
+	dmm_get_handle(p_proc_object, &dmm_mgr);
+	if (!dmm_mgr) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
-	status = DMM_UnReserveMemory(hDmmMgr, (u32) pRsvAddr);
+	status = dmm_un_reserve_memory(dmm_mgr, (u32) prsv_addr);
 	if (status != DSP_SOK)
 		goto func_end;
 
@@ -1488,7 +1516,7 @@ DSP_STATUS PROC_UnReserveMemory(void *hProcessor, void *pRsvAddr,
 	 */
 	spin_lock(&pr_ctxt->dmm_rsv_lock);
 	list_for_each_entry(rsv_obj, &pr_ctxt->dmm_rsv_list, link) {
-		if (rsv_obj->dsp_reserved_addr == (u32)pRsvAddr) {
+		if (rsv_obj->dsp_reserved_addr == (u32) prsv_addr) {
 			list_del(&rsv_obj->link);
 			kfree(rsv_obj);
 			break;
@@ -1497,20 +1525,20 @@ DSP_STATUS PROC_UnReserveMemory(void *hProcessor, void *pRsvAddr,
 	spin_unlock(&pr_ctxt->dmm_rsv_lock);
 
 func_end:
-	dev_dbg(bridge, "%s: hProcessor: 0x%p pRsvAddr: 0x%p status: 0x%x\n",
-					__func__, hProcessor, pRsvAddr, status);
+	dev_dbg(bridge, "%s: hprocessor: 0x%p prsv_addr: 0x%p status: 0x%x\n",
+		__func__, hprocessor, prsv_addr, status);
 	return status;
 }
 
 /*
- *  ======== = PROC_Monitor ======== ==
+ *  ======== = proc_monitor ======== ==
  *  Purpose:
  *      Place the Processor in Monitor State. This is an internal
  *      function and a requirement before Processor is loaded.
- *      This does a WMD_BRD_Stop, DEV_Destroy2 and WMD_BRD_Monitor.
- *      In DEV_Destroy2 we delete the node manager.
+ *      This does a bridge_brd_stop, dev_destroy2 and bridge_brd_monitor.
+ *      In dev_destroy2 we delete the node manager.
  *  Parameters:
- *      pProcObject:    Pointer to Processor Object
+ *      p_proc_object:    Pointer to Processor Object
  *  Returns:
  *      DSP_SOK:	Processor placed in monitor mode.
  *      !DSP_SOK:       Failed to place processor in monitor mode.
@@ -1519,149 +1547,148 @@ func_end:
  *  Ensures:
  *      Success:	ProcObject state is PROC_IDLE
  */
-static DSP_STATUS PROC_Monitor(struct PROC_OBJECT *pProcObject)
+static dsp_status proc_monitor(struct proc_object *p_proc_object)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct MSG_MGR *hMsgMgr;
-	int uBrdState;
+	dsp_status status = DSP_EFAIL;
+	struct msg_mgr *hmsg_mgr;
+	int brd_state;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE));
 
 	/* This is needed only when Device is loaded when it is
 	 * already 'ACTIVE' */
-	/* Destory the Node Manager, MSG Manager */
-	if (DSP_SUCCEEDED(DEV_Destroy2(pProcObject->hDevObject))) {
-		/* Destroy the MSG by calling MSG_Delete */
-		DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
-		if (hMsgMgr) {
-			MSG_Delete(hMsgMgr);
-			DEV_SetMsgMgr(pProcObject->hDevObject, NULL);
+	/* Destory the Node Manager, msg_ctrl Manager */
+	if (DSP_SUCCEEDED(dev_destroy2(p_proc_object->hdev_obj))) {
+		/* Destroy the msg_ctrl by calling msg_delete */
+		dev_get_msg_mgr(p_proc_object->hdev_obj, &hmsg_mgr);
+		if (hmsg_mgr) {
+			msg_delete(hmsg_mgr);
+			dev_set_msg_mgr(p_proc_object->hdev_obj, NULL);
 		}
 	}
 	/* Place the Board in the Monitor State */
-	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdMonitor)
-	   (pProcObject->hWmdContext))) {
+	if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_monitor)
+			  (p_proc_object->hwmd_context))) {
 		status = DSP_SOK;
-		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-		   (pProcObject->hWmdContext, &uBrdState)))
-			DBC_Assert(uBrdState == BRD_IDLE);
+		if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
+				  (p_proc_object->hwmd_context, &brd_state)))
+			DBC_ASSERT(brd_state == BRD_IDLE);
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && uBrdState == BRD_IDLE) ||
-		  DSP_FAILED(status));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && brd_state == BRD_IDLE) ||
+		   DSP_FAILED(status));
 	return status;
 }
 
 /*
- *  ======== GetEnvpCount ========
+ *  ======== get_envp_count ========
  *  Purpose:
  *      Return the number of elements in the envp array, including the
  *      terminating NULL element.
  */
-static s32 GetEnvpCount(char **envp)
+static s32 get_envp_count(char **envp)
 {
-	s32 cRetval = 0;
+	s32 ret = 0;
 	if (envp) {
 		while (*envp++)
-			cRetval++;
+			ret++;
 
-		cRetval += 1;	/* Include the terminating NULL in the count. */
+		ret += 1;	/* Include the terminating NULL in the count. */
 	}
 
-	return cRetval;
+	return ret;
 }
 
 /*
- *  ======== PrependEnvp ========
+ *  ======== prepend_envp ========
  *  Purpose:
  *      Prepend an environment variable=value pair to the new envp array, and
  *      copy in the existing var=value pairs in the old envp array.
  */
-static char **PrependEnvp(char **newEnvp, char **envp, s32 cEnvp, s32 cNewEnvp,
-			 char *szVar)
+static char **prepend_envp(char **new_envp, char **envp, s32 envp_elems,
+			   s32 cnew_envp, char *szVar)
 {
-	char **ppEnvp = newEnvp;
+	char **pp_envp = new_envp;
 
-	DBC_Require(newEnvp);
+	DBC_REQUIRE(new_envp);
 
 	/* Prepend new environ var=value string */
-	*newEnvp++ = szVar;
+	*new_envp++ = szVar;
 
 	/* Copy user's environment into our own. */
-	while (cEnvp--)
-		*newEnvp++ = *envp++;
+	while (envp_elems--)
+		*new_envp++ = *envp++;
 
 	/* Ensure NULL terminates the new environment strings array. */
-	if (cEnvp == 0)
-		*newEnvp = NULL;
+	if (envp_elems == 0)
+		*new_envp = NULL;
 
-	return ppEnvp;
+	return pp_envp;
 }
 
 /*
- *  ======== PROC_NotifyClients ========
+ *  ======== proc_notify_clients ========
  *  Purpose:
  *      Notify the processor the events.
  */
-DSP_STATUS PROC_NotifyClients(void *hProc, u32 uEvents)
+dsp_status proc_notify_clients(void *hProc, u32 uEvents)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hProc;
 
-	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
-	DBC_Require(IsValidProcEvent(uEvents));
-	DBC_Require(cRefs > 0);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE));
+	DBC_REQUIRE(IS_VALID_PROC_EVENT(uEvents));
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
-	NTFY_Notify(pProcObject->hNtfy, uEvents);
+	ntfy_notify(p_proc_object->ntfy_obj, uEvents);
 func_end:
 	return status;
 }
 
 /*
- *  ======== PROC_NotifyAllClients ========
+ *  ======== proc_notify_all_clients ========
  *  Purpose:
  *      Notify the processor the events. This includes notifying all clients
  *      attached to a particulat DSP.
  */
-DSP_STATUS PROC_NotifyAllClients(void *hProc, u32 uEvents)
+dsp_status proc_notify_all_clients(void *hProc, u32 uEvents)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hProc;
 
-	DBC_Require(IsValidProcEvent(uEvents));
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(IS_VALID_PROC_EVENT(uEvents));
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
-	DEV_NotifyClients(pProcObject->hDevObject, uEvents);
+	dev_notify_clients(p_proc_object->hdev_obj, uEvents);
 
 func_end:
 	return status;
 }
 
 /*
- *  ======== PROC_GetProcessorId ========
+ *  ======== proc_get_processor_id ========
  *  Purpose:
  *      Retrieves the processor ID.
  */
-DSP_STATUS PROC_GetProcessorId(void *hProc, u32 *procID)
+dsp_status proc_get_processor_id(void *hProc, u32 * procID)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hProc;
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE))
-		*procID = pProcObject->uProcessor;
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE))
+		*procID = p_proc_object->processor_id;
 	else
 		status = DSP_EHANDLE;
 
 	return status;
 }
-
diff --git a/drivers/dsp/bridge/rmgr/pwr.c b/drivers/dsp/bridge/rmgr/pwr.c
index 3494314..278f4f7 100644
--- a/drivers/dsp/bridge/rmgr/pwr.c
+++ b/drivers/dsp/bridge/rmgr/pwr.c
@@ -33,30 +33,30 @@
 #include <dspbridge/wmdioctl.h>
 
 /*
- *  ======== PWR_SleepDSP ========
+ *  ======== pwr_sleep_dsp ========
  *    Send command to DSP to enter sleep state.
  */
-DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode, IN CONST u32 timeout)
+dsp_status pwr_sleep_dsp(IN CONST u32 sleepCode, IN CONST u32 timeout)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct WMD_DEV_CONTEXT *dwContext;
-	DSP_STATUS status = DSP_EFAIL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct wmd_dev_context *dw_context;
+	dsp_status status = DSP_EFAIL;
+	struct dev_object *hdev_obj = NULL;
 	u32 ioctlcode = 0;
 	u32 arg = timeout;
 
-	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-			  hDevObject != NULL;
-			hDevObject =
-				(struct DEV_OBJECT *)DRV_GetNextDevObject
-				((u32)hDevObject)) {
-		if (DSP_FAILED(DEV_GetWMDContext(hDevObject,
-		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
+	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	     hdev_obj != NULL;
+	     hdev_obj =
+	     (struct dev_object *)drv_get_next_dev_object((u32) hdev_obj)) {
+		if (DSP_FAILED(dev_get_wmd_context(hdev_obj,
+						   (struct wmd_dev_context **)
+						   &dw_context))) {
 			continue;
 		}
-		DEV_GetIntfFxns(hDevObject,
-				(struct WMD_DRV_INTERFACE **)&pIntfFxns);
-		if (!pIntfFxns)
+		dev_get_intf_fxns(hdev_obj,
+				  (struct bridge_drv_interface **)&intf_fxns);
+		if (!intf_fxns)
 			continue;
 		if (sleepCode == PWR_DEEPSLEEP)
 			ioctlcode = WMDIOCTL_DEEPSLEEP;
@@ -66,36 +66,41 @@ DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode, IN CONST u32 timeout)
 			status = DSP_EINVALIDARG;
 
 		if (status != DSP_EINVALIDARG) {
-			status = (*pIntfFxns->pfnDevCntrl)(dwContext,
-				 ioctlcode, (void *)&arg);
+			status = (*intf_fxns->pfn_dev_cntrl) (dw_context,
+							      ioctlcode,
+							      (void *)&arg);
 		}
 	}
 	return status;
 }
 
 /*
- *  ======== PWR_WakeDSP ========
+ *  ======== pwr_wake_dsp ========
  *    Send command to DSP to wake it from sleep.
  */
-DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout)
+dsp_status pwr_wake_dsp(IN CONST u32 timeout)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct WMD_DEV_CONTEXT *dwContext;
-	DSP_STATUS status = DSP_EFAIL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct wmd_dev_context *dw_context;
+	dsp_status status = DSP_EFAIL;
+	struct dev_object *hdev_obj = NULL;
 	u32 arg = timeout;
 
-	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	     hDevObject != NULL;
-	     hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
-			  ((u32)hDevObject)) {
-		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
-		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
-			DEV_GetIntfFxns(hDevObject,
-				(struct WMD_DRV_INTERFACE **)&pIntfFxns);
-			if (pIntfFxns) {
-				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
-					 WMDIOCTL_WAKEUP, (void *)&arg);
+	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	     hdev_obj != NULL;
+	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
+	     ((u32) hdev_obj)) {
+		if (DSP_SUCCEEDED(dev_get_wmd_context(hdev_obj,
+						      (struct wmd_dev_context
+						       **)&dw_context))) {
+			dev_get_intf_fxns(hdev_obj,
+					  (struct bridge_drv_interface **)
+					  &intf_fxns);
+			if (intf_fxns) {
+				status =
+				    (*intf_fxns->pfn_dev_cntrl) (dw_context,
+							WMDIOCTL_WAKEUP,
+							(void *)&arg);
 			}
 		}
 	}
@@ -103,32 +108,35 @@ DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout)
 }
 
 /*
- *  ======== PWR_PM_PreScale========
+ *  ======== pwr_pm_pre_scale========
  *    Sends pre-notification message to DSP.
  */
-DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level)
+dsp_status pwr_pm_pre_scale(IN u16 voltage_domain, u32 level)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct WMD_DEV_CONTEXT *dwContext;
-	DSP_STATUS status = DSP_EFAIL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct wmd_dev_context *dw_context;
+	dsp_status status = DSP_EFAIL;
+	struct dev_object *hdev_obj = NULL;
 	u32 arg[2];
 
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
-	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	    hDevObject != NULL;
-	    hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
-			 ((u32)hDevObject)) {
-		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
-		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
-			DEV_GetIntfFxns(hDevObject,
-				(struct WMD_DRV_INTERFACE **)&pIntfFxns);
-			if (pIntfFxns) {
-				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
-					 WMDIOCTL_PRESCALE_NOTIFY,
-					 (void *)&arg);
+	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	     hdev_obj != NULL;
+	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
+	     ((u32) hdev_obj)) {
+		if (DSP_SUCCEEDED(dev_get_wmd_context(hdev_obj,
+						      (struct wmd_dev_context
+						       **)&dw_context))) {
+			dev_get_intf_fxns(hdev_obj,
+					  (struct bridge_drv_interface **)
+					  &intf_fxns);
+			if (intf_fxns) {
+				status =
+				    (*intf_fxns->pfn_dev_cntrl) (dw_context,
+						WMDIOCTL_PRESCALE_NOTIFY,
+						(void *)&arg);
 			}
 		}
 	}
@@ -136,37 +144,38 @@ DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level)
 }
 
 /*
- *  ======== PWR_PM_PostScale========
+ *  ======== pwr_pm_post_scale========
  *    Sends post-notification message to DSP.
  */
-DSP_STATUS PWR_PM_PostScale(IN u16 voltage_domain, u32 level)
+dsp_status pwr_pm_post_scale(IN u16 voltage_domain, u32 level)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct WMD_DEV_CONTEXT *dwContext;
-	DSP_STATUS status = DSP_EFAIL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct wmd_dev_context *dw_context;
+	dsp_status status = DSP_EFAIL;
+	struct dev_object *hdev_obj = NULL;
 	u32 arg[2];
 
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
-	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	     hDevObject != NULL;
-	     hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
-			  ((u32)hDevObject)) {
-		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
-		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
-			DEV_GetIntfFxns(hDevObject,
-				(struct WMD_DRV_INTERFACE **)&pIntfFxns);
-			if (pIntfFxns) {
-				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
-					WMDIOCTL_POSTSCALE_NOTIFY,
-					(void *)&arg);
+	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	     hdev_obj != NULL;
+	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
+	     ((u32) hdev_obj)) {
+		if (DSP_SUCCEEDED(dev_get_wmd_context(hdev_obj,
+						      (struct wmd_dev_context
+						       **)&dw_context))) {
+			dev_get_intf_fxns(hdev_obj,
+					  (struct bridge_drv_interface **)
+					  &intf_fxns);
+			if (intf_fxns) {
+				status =
+				    (*intf_fxns->pfn_dev_cntrl) (dw_context,
+						WMDIOCTL_POSTSCALE_NOTIFY,
+						(void *)&arg);
 			}
 		}
 	}
 	return status;
 
 }
-
-
diff --git a/drivers/dsp/bridge/rmgr/rmm.c b/drivers/dsp/bridge/rmgr/rmm.c
index 506bc57..7031862 100644
--- a/drivers/dsp/bridge/rmgr/rmm.c
+++ b/drivers/dsp/bridge/rmgr/rmm.c
@@ -31,8 +31,8 @@
  *  and the start of the allocated block - the memory manager must free
  *  this memory to prevent a memory leak.
  *
- *  Overlay memory is managed by reserving through RMM_alloc, and freeing
- *  it through RMM_free. The memory manager prevents DSP code/data that is
+ *  Overlay memory is managed by reserving through rmm_alloc, and freeing
+ *  it through rmm_free. The memory manager prevents DSP code/data that is
  *  overlayed from being overwritten as long as the memory it runs at has
  *  been allocated, and not yet freed.
  */
@@ -55,110 +55,113 @@
 #define RMM_TARGSIGNATURE   0x544d4d52	/* "TMMR" */
 
 /*
- *  ======== RMM_Header ========
+ *  ======== rmm_header ========
  *  This header is used to maintain a list of free memory blocks.
  */
-struct RMM_Header {
-	struct RMM_Header *next;	/* form a free memory link list */
+struct rmm_header {
+	struct rmm_header *next;	/* form a free memory link list */
 	u32 size;		/* size of the free memory */
 	u32 addr;		/* DSP address of memory block */
-} ;
+};
 
 /*
- *  ======== RMM_OvlySect ========
+ *  ======== rmm_ovly_sect ========
  *  Keeps track of memory occupied by overlay section.
  */
-struct RMM_OvlySect {
-	struct list_head listElem;
+struct rmm_ovly_sect {
+	struct list_head list_elem;
 	u32 addr;		/* Start of memory section */
 	u32 size;		/* Length (target MAUs) of section */
 	s32 page;		/* Memory page */
 };
 
 /*
- *  ======== RMM_TargetObj ========
+ *  ======== rmm_target_obj ========
  */
-struct RMM_TargetObj {
-	u32 dwSignature;
-	struct RMM_Segment *segTab;
-	struct RMM_Header **freeList;
-	u32 numSegs;
-	struct LST_LIST *ovlyList;	/* List of overlay memory in use */
+struct rmm_target_obj {
+	u32 dw_signature;
+	struct rmm_segment *seg_tab;
+	struct rmm_header **free_list;
+	u32 num_segs;
+	struct lst_list *ovly_list;	/* List of overlay memory in use */
 };
 
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
-static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
-		      u32 align, u32 *dspAddr);
-static bool freeBlock(struct RMM_TargetObj *target, u32 segid, u32 addr,
-		     u32 size);
+static bool alloc_block(struct rmm_target_obj *target, u32 segid, u32 size,
+			u32 align, u32 *dspAddr);
+static bool free_block(struct rmm_target_obj *target, u32 segid, u32 addr,
+		       u32 size);
 
 /*
- *  ======== RMM_alloc ========
+ *  ======== rmm_alloc ========
  */
-DSP_STATUS RMM_alloc(struct RMM_TargetObj *target, u32 segid, u32 size,
-		    u32 align, u32 *dspAddr, bool reserve)
+dsp_status rmm_alloc(struct rmm_target_obj *target, u32 segid, u32 size,
+		     u32 align, u32 *dspAddr, bool reserve)
 {
-	struct RMM_OvlySect *sect;
-	struct RMM_OvlySect *prevSect = NULL;
-	struct RMM_OvlySect *newSect;
+	struct rmm_ovly_sect *sect;
+	struct rmm_ovly_sect *prev_sect = NULL;
+	struct rmm_ovly_sect *new_sect;
 	u32 addr;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
-	DBC_Require(dspAddr != NULL);
-	DBC_Require(size > 0);
-	DBC_Require(reserve || (target->numSegs > 0));
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(target, RMM_TARGSIGNATURE));
+	DBC_REQUIRE(dspAddr != NULL);
+	DBC_REQUIRE(size > 0);
+	DBC_REQUIRE(reserve || (target->num_segs > 0));
+	DBC_REQUIRE(refs > 0);
 
 	if (!reserve) {
-		if (!allocBlock(target, segid, size, align, dspAddr)) {
+		if (!alloc_block(target, segid, size, align, dspAddr)) {
 			status = DSP_EMEMORY;
 		} else {
 			/* Increment the number of allocated blocks in this
 			 * segment */
-			target->segTab[segid].number++;
+			target->seg_tab[segid].number++;
 		}
 		goto func_end;
 	}
 	/* An overlay section - See if block is already in use. If not,
-	 * insert into the list in ascending address size.  */
+	 * insert into the list in ascending address size. */
 	addr = *dspAddr;
-	sect = (struct RMM_OvlySect *)LST_First(target->ovlyList);
+	sect = (struct rmm_ovly_sect *)lst_first(target->ovly_list);
 	/*  Find place to insert new list element. List is sorted from
 	 *  smallest to largest address. */
 	while (sect != NULL) {
 		if (addr <= sect->addr) {
 			/* Check for overlap with sect */
-			if ((addr + size > sect->addr) || (prevSect &&
-			   (prevSect->addr + prevSect->size > addr))) {
+			if ((addr + size > sect->addr) || (prev_sect &&
+							   (prev_sect->addr +
+							    prev_sect->size >
+							    addr))) {
 				status = DSP_EOVERLAYMEMORY;
 			}
 			break;
 		}
-		prevSect = sect;
-		sect = (struct RMM_OvlySect *)LST_Next(target->ovlyList,
-			(struct list_head *)sect);
+		prev_sect = sect;
+		sect = (struct rmm_ovly_sect *)lst_next(target->ovly_list,
+							(struct list_head *)
+							sect);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* No overlap - allocate list element for new section. */
-		newSect = MEM_Calloc(sizeof(struct RMM_OvlySect), MEM_PAGED);
-		if (newSect == NULL) {
+		new_sect = mem_calloc(sizeof(struct rmm_ovly_sect), MEM_PAGED);
+		if (new_sect == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			LST_InitElem((struct list_head *)newSect);
-			newSect->addr = addr;
-			newSect->size = size;
-			newSect->page = segid;
+			lst_init_elem((struct list_head *)new_sect);
+			new_sect->addr = addr;
+			new_sect->size = size;
+			new_sect->page = segid;
 			if (sect == NULL) {
 				/* Put new section at the end of the list */
-				LST_PutTail(target->ovlyList,
-					   (struct list_head *)newSect);
+				lst_put_tail(target->ovly_list,
+					     (struct list_head *)new_sect);
 			} else {
 				/* Put new section just before sect */
-				LST_InsertBefore(target->ovlyList,
-						(struct list_head *)newSect,
-						(struct list_head *)sect);
+				lst_insert_before(target->ovly_list,
+						  (struct list_head *)new_sect,
+						  (struct list_head *)sect);
 			}
 		}
 	}
@@ -167,22 +170,22 @@ func_end:
 }
 
 /*
- *  ======== RMM_create ========
+ *  ======== rmm_create ========
  */
-DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
-		     struct RMM_Segment segTab[], u32 numSegs)
+dsp_status rmm_create(struct rmm_target_obj **target_obj,
+		      struct rmm_segment seg_tab[], u32 num_segs)
 {
-	struct RMM_Header *hptr;
-	struct RMM_Segment *sptr, *tmp;
-	struct RMM_TargetObj *target;
+	struct rmm_header *hptr;
+	struct rmm_segment *sptr, *tmp;
+	struct rmm_target_obj *target;
 	s32 i;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(pTarget != NULL);
-	DBC_Require(numSegs == 0 || segTab != NULL);
+	DBC_REQUIRE(target_obj != NULL);
+	DBC_REQUIRE(num_segs == 0 || seg_tab != NULL);
 
 	/* Allocate DBL target object */
-	MEM_AllocObject(target, struct RMM_TargetObj, RMM_TARGSIGNATURE);
+	MEM_ALLOC_OBJECT(target, struct rmm_target_obj, RMM_TARGSIGNATURE);
 
 	if (target == NULL)
 		status = DSP_EMEMORY;
@@ -190,37 +193,38 @@ DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	target->numSegs = numSegs;
-	if (!(numSegs > 0))
+	target->num_segs = num_segs;
+	if (!(num_segs > 0))
 		goto func_cont;
 
 	/* Allocate the memory for freelist from host's memory */
-	target->freeList = MEM_Calloc(numSegs * sizeof(struct RMM_Header *),
-				     MEM_PAGED);
-	if (target->freeList == NULL) {
+	target->free_list = mem_calloc(num_segs * sizeof(struct rmm_header *),
+				       MEM_PAGED);
+	if (target->free_list == NULL) {
 		status = DSP_EMEMORY;
 	} else {
 		/* Allocate headers for each element on the free list */
-		for (i = 0; i < (s32) numSegs; i++) {
-			target->freeList[i] =
-					MEM_Calloc(sizeof(struct RMM_Header),
-					MEM_PAGED);
-			if (target->freeList[i] == NULL) {
+		for (i = 0; i < (s32) num_segs; i++) {
+			target->free_list[i] =
+			    mem_calloc(sizeof(struct rmm_header), MEM_PAGED);
+			if (target->free_list[i] == NULL) {
 				status = DSP_EMEMORY;
 				break;
 			}
 		}
 		/* Allocate memory for initial segment table */
-		target->segTab = MEM_Calloc(numSegs *
-				 sizeof(struct RMM_Segment), MEM_PAGED);
-		if (target->segTab == NULL) {
+		target->seg_tab = mem_calloc(num_segs *
+					     sizeof(struct rmm_segment),
+					     MEM_PAGED);
+		if (target->seg_tab == NULL) {
 			status = DSP_EMEMORY;
 		} else {
 			/* Initialize segment table and free list */
-			sptr = target->segTab;
-			for (i = 0, tmp = segTab; numSegs > 0; numSegs--, i++) {
+			sptr = target->seg_tab;
+			for (i = 0, tmp = seg_tab; num_segs > 0;
+			     num_segs--, i++) {
 				*sptr = *tmp;
-				hptr = target->freeList[i];
+				hptr = target->free_list[i];
 				hptr->addr = tmp->base;
 				hptr->size = tmp->length;
 				hptr->next = NULL;
@@ -232,186 +236,189 @@ DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
 func_cont:
 	/* Initialize overlay memory list */
 	if (DSP_SUCCEEDED(status)) {
-		target->ovlyList = MEM_Calloc(sizeof(struct LST_LIST),
-			MEM_NONPAGED);
-		if (target->ovlyList == NULL) {
+		target->ovly_list = mem_calloc(sizeof(struct lst_list),
+					       MEM_NONPAGED);
+		if (target->ovly_list == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			INIT_LIST_HEAD(&target->ovlyList->head);
+			INIT_LIST_HEAD(&target->ovly_list->head);
 		}
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		*pTarget = target;
+		*target_obj = target;
 	} else {
-		*pTarget = NULL;
+		*target_obj = NULL;
 		if (target)
-			RMM_delete(target);
+			rmm_delete(target);
 
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && MEM_IsValidHandle((*pTarget),
-		  RMM_TARGSIGNATURE)) || (DSP_FAILED(status) && *pTarget ==
-		  NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && MEM_IS_VALID_HANDLE((*target_obj),
+							RMM_TARGSIGNATURE))
+		   || (DSP_FAILED(status) && *target_obj == NULL));
 
 	return status;
 }
 
 /*
- *  ======== RMM_delete ========
+ *  ======== rmm_delete ========
  */
-void RMM_delete(struct RMM_TargetObj *target)
+void rmm_delete(struct rmm_target_obj *target)
 {
-	struct RMM_OvlySect *pSect;
-	struct RMM_Header *hptr;
-	struct RMM_Header *next;
+	struct rmm_ovly_sect *ovly_section;
+	struct rmm_header *hptr;
+	struct rmm_header *next;
 	u32 i;
 
-	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(target, RMM_TARGSIGNATURE));
 
-	kfree(target->segTab);
+	kfree(target->seg_tab);
 
-	if (target->ovlyList) {
-		while ((pSect = (struct RMM_OvlySect *)LST_GetHead
-		      (target->ovlyList))) {
-			kfree(pSect);
+	if (target->ovly_list) {
+		while ((ovly_section = (struct rmm_ovly_sect *)lst_get_head
+			(target->ovly_list))) {
+			kfree(ovly_section);
 		}
-		DBC_Assert(LST_IsEmpty(target->ovlyList));
-		kfree(target->ovlyList);
+		DBC_ASSERT(LST_IS_EMPTY(target->ovly_list));
+		kfree(target->ovly_list);
 	}
 
-	if (target->freeList != NULL) {
+	if (target->free_list != NULL) {
 		/* Free elements on freelist */
-		for (i = 0; i < target->numSegs; i++) {
-			hptr = next = target->freeList[i];
+		for (i = 0; i < target->num_segs; i++) {
+			hptr = next = target->free_list[i];
 			while (next) {
 				hptr = next;
 				next = hptr->next;
 				kfree(hptr);
 			}
 		}
-		kfree(target->freeList);
+		kfree(target->free_list);
 	}
 
-	MEM_FreeObject(target);
+	MEM_FREE_OBJECT(target);
 }
 
 /*
- *  ======== RMM_exit ========
+ *  ======== rmm_exit ========
  */
-void RMM_exit(void)
+void rmm_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== RMM_free ========
+ *  ======== rmm_free ========
  */
-bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 addr, u32 size,
-	bool reserved)
-
+bool rmm_free(struct rmm_target_obj *target, u32 segid, u32 addr, u32 size,
+	      bool reserved)
 {
-	struct RMM_OvlySect *sect;
-	bool retVal = true;
+	struct rmm_ovly_sect *sect;
+	bool ret = true;
 
-	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(target, RMM_TARGSIGNATURE));
 
-	DBC_Require(reserved || segid < target->numSegs);
-	DBC_Require(reserved || (addr >= target->segTab[segid].base &&
-		   (addr + size) <= (target->segTab[segid].base +
-		   target->segTab[segid].length)));
+	DBC_REQUIRE(reserved || segid < target->num_segs);
+	DBC_REQUIRE(reserved || (addr >= target->seg_tab[segid].base &&
+				 (addr + size) <= (target->seg_tab[segid].base +
+						   target->seg_tab[segid].
+						   length)));
 
 	/*
 	 *  Free or unreserve memory.
 	 */
 	if (!reserved) {
-		retVal = freeBlock(target, segid, addr, size);
-		if (retVal)
-			target->segTab[segid].number--;
+		ret = free_block(target, segid, addr, size);
+		if (ret)
+			target->seg_tab[segid].number--;
 
 	} else {
 		/* Unreserve memory */
-		sect = (struct RMM_OvlySect *)LST_First(target->ovlyList);
+		sect = (struct rmm_ovly_sect *)lst_first(target->ovly_list);
 		while (sect != NULL) {
 			if (addr == sect->addr) {
-				DBC_Assert(size == sect->size);
+				DBC_ASSERT(size == sect->size);
 				/* Remove from list */
-				LST_RemoveElem(target->ovlyList,
-					      (struct list_head *)sect);
+				lst_remove_elem(target->ovly_list,
+						(struct list_head *)sect);
 				kfree(sect);
 				break;
 			}
-			sect = (struct RMM_OvlySect *)LST_Next(target->ovlyList,
-			       (struct list_head *)sect);
+			sect =
+			    (struct rmm_ovly_sect *)lst_next(target->ovly_list,
+							     (struct list_head
+							      *)sect);
 		}
 		if (sect == NULL)
-			retVal = false;
+			ret = false;
 
 	}
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== RMM_init ========
+ *  ======== rmm_init ========
  */
-bool RMM_init(void)
+bool rmm_init(void)
 {
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	cRefs++;
+	refs++;
 
 	return true;
 }
 
 /*
- *  ======== RMM_stat ========
+ *  ======== rmm_stat ========
  */
-bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
-	     struct DSP_MEMSTAT *pMemStatBuf)
+bool rmm_stat(struct rmm_target_obj *target, enum dsp_memtype segid,
+	      struct dsp_memstat *pMemStatBuf)
 {
-	struct RMM_Header *head;
-	bool retVal = false;
-	u32 maxFreeSize = 0;
-	u32 totalFreeSize = 0;
-	u32 freeBlocks = 0;
+	struct rmm_header *head;
+	bool ret = false;
+	u32 max_free_size = 0;
+	u32 total_free_size = 0;
+	u32 free_blocks = 0;
 
-	DBC_Require(pMemStatBuf != NULL);
-	DBC_Assert(target != NULL);
+	DBC_REQUIRE(pMemStatBuf != NULL);
+	DBC_ASSERT(target != NULL);
 
-	if ((u32) segid < target->numSegs) {
-		head = target->freeList[segid];
+	if ((u32) segid < target->num_segs) {
+		head = target->free_list[segid];
 
-		/* Collect data from freeList */
+		/* Collect data from free_list */
 		while (head != NULL) {
-			maxFreeSize = max(maxFreeSize, head->size);
-			totalFreeSize += head->size;
-			freeBlocks++;
+			max_free_size = max(max_free_size, head->size);
+			total_free_size += head->size;
+			free_blocks++;
 			head = head->next;
 		}
 
-		/* ulSize */
-		pMemStatBuf->ulSize = target->segTab[segid].length;
+		/* ul_size */
+		pMemStatBuf->ul_size = target->seg_tab[segid].length;
 
-		/* ulNumFreeBlocks */
-		pMemStatBuf->ulNumFreeBlocks = freeBlocks;
+		/* ul_num_free_blocks */
+		pMemStatBuf->ul_num_free_blocks = free_blocks;
 
-		/* ulTotalFreeSize */
-		pMemStatBuf->ulTotalFreeSize = totalFreeSize;
+		/* ul_total_free_size */
+		pMemStatBuf->ul_total_free_size = total_free_size;
 
-		/* ulLenMaxFreeBlock */
-		pMemStatBuf->ulLenMaxFreeBlock = maxFreeSize;
+		/* ul_len_max_free_block */
+		pMemStatBuf->ul_len_max_free_block = max_free_size;
 
-		/* ulNumAllocBlocks */
-		pMemStatBuf->ulNumAllocBlocks = target->segTab[segid].number;
+		/* ul_num_alloc_blocks */
+		pMemStatBuf->ul_num_alloc_blocks =
+		    target->seg_tab[segid].number;
 
-		retVal = true;
+		ret = true;
 	}
 
-	return retVal;
+	return ret;
 }
 
 /*
@@ -419,12 +426,12 @@ bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
  *  This allocation function allocates memory from the lowest addresses
  *  first.
  */
-static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
-		      u32 align, u32 *dspAddr)
+static bool alloc_block(struct rmm_target_obj *target, u32 segid, u32 size,
+			u32 align, u32 *dspAddr)
 {
-	struct RMM_Header *head;
-	struct RMM_Header *prevhead = NULL;
-	struct RMM_Header *next;
+	struct rmm_header *head;
+	struct rmm_header *prevhead = NULL;
+	struct rmm_header *next;
 	u32 tmpalign;
 	u32 alignbytes;
 	u32 hsize;
@@ -433,7 +440,7 @@ static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
 
 	alignbytes = (align == 0) ? 1 : align;
 	prevhead = NULL;
-	head = target->freeList[segid];
+	head = target->free_list[segid];
 
 	do {
 		hsize = head->size;
@@ -459,7 +466,7 @@ static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
 
 			/* free up any hole created by alignment */
 			if (tmpalign)
-				freeBlock(target, segid, addr, tmpalign);
+				free_block(target, segid, addr, tmpalign);
 
 			*dspAddr = addr + tmpalign;
 			return true;
@@ -474,27 +481,27 @@ static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
 }
 
 /*
- *  ======== freeBlock ========
- *  TO DO: freeBlock() allocates memory, which could result in failure.
- *  Could allocate an RMM_Header in RMM_alloc(), to be kept in a pool.
- *  freeBlock() could use an RMM_Header from the pool, freeing as blocks
+ *  ======== free_block ========
+ *  TO DO: free_block() allocates memory, which could result in failure.
+ *  Could allocate an rmm_header in rmm_alloc(), to be kept in a pool.
+ *  free_block() could use an rmm_header from the pool, freeing as blocks
  *  are coalesced.
  */
-static bool freeBlock(struct RMM_TargetObj *target, u32 segid, u32 addr,
-		     u32 size)
+static bool free_block(struct rmm_target_obj *target, u32 segid, u32 addr,
+		       u32 size)
 {
-	struct RMM_Header *head;
-	struct RMM_Header *thead;
-	struct RMM_Header *rhead;
-	bool retVal = true;
+	struct rmm_header *head;
+	struct rmm_header *thead;
+	struct rmm_header *rhead;
+	bool ret = true;
 
 	/* Create a memory header to hold the newly free'd block. */
-	rhead = MEM_Calloc(sizeof(struct RMM_Header), MEM_PAGED);
+	rhead = mem_calloc(sizeof(struct rmm_header), MEM_PAGED);
 	if (rhead == NULL) {
-		retVal = false;
+		ret = false;
 	} else {
 		/* search down the free list to find the right place for addr */
-		head = target->freeList[segid];
+		head = target->free_list[segid];
 
 		if (addr >= head->addr) {
 			while (head->next != NULL && addr > head->next->addr)
@@ -516,7 +523,7 @@ static bool freeBlock(struct RMM_TargetObj *target, u32 segid, u32 addr,
 
 		/* join with upper block, if possible */
 		if (thead != NULL && (rhead->addr + rhead->size) ==
-		   thead->addr) {
+		    thead->addr) {
 			head->next = rhead->next;
 			thead->size = size + thead->size;
 			thead->addr = addr;
@@ -532,6 +539,5 @@ static bool freeBlock(struct RMM_TargetObj *target, u32 segid, u32 addr,
 		}
 	}
 
-	return retVal;
+	return ret;
 }
-
diff --git a/drivers/dsp/bridge/rmgr/strm.c b/drivers/dsp/bridge/rmgr/strm.c
index 370a44d..699f2dc 100644
--- a/drivers/dsp/bridge/rmgr/strm.c
+++ b/drivers/dsp/bridge/rmgr/strm.c
@@ -54,71 +54,72 @@
 #define DEFAULTNUMBUFS      2
 
 /*
- *  ======== STRM_MGR ========
- *  The STRM_MGR contains device information needed to open the underlying
+ *  ======== strm_mgr ========
+ *  The strm_mgr contains device information needed to open the underlying
  *  channels of a stream.
  */
-struct STRM_MGR {
-	u32 dwSignature;
-	struct DEV_OBJECT *hDev;	/* Device for this processor */
-	struct CHNL_MGR *hChnlMgr;	/* Channel manager */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
-	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
-} ;
+struct strm_mgr {
+	u32 dw_signature;
+	struct dev_object *dev_obj;	/* Device for this processor */
+	struct chnl_mgr *hchnl_mgr;	/* Channel manager */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+};
 
 /*
- *  ======== STRM_OBJECT ========
- *  This object is allocated in STRM_Open().
+ *  ======== strm_object ========
+ *  This object is allocated in strm_open().
  */
- struct STRM_OBJECT {
-	u32 dwSignature;
-	struct STRM_MGR *hStrmMgr;
-	struct CHNL_OBJECT *hChnl;
-	u32 uDir;		/* DSP_TONODE or DSP_FROMNODE */
-	u32 uTimeout;
-	u32 uNumBufs;		/* Max # of bufs allowed in stream */
-	u32 uNBufsInStrm;	/* Current # of bufs in stream */
-	u32 ulNBytes;		/* bytes transferred since idled */
-	enum DSP_STREAMSTATE strmState;	/* STREAM_IDLE, STREAM_READY, ... */
-	HANDLE hUserEvent;	/* Saved for STRM_GetInfo() */
-	enum DSP_STRMMODE lMode;	/* STRMMODE_[PROCCOPY][ZEROCOPY]... */
-	u32 uDMAChnlId;	/* DMA chnl id */
-	u32 uDMAPriority;	/* DMA priority:DMAPRI_[LOW][HIGH] */
-	u32 uSegment;		/* >0 is SM segment.=0 is local heap */
-	u32 uAlignment;	/* Alignment for stream bufs */
-	struct CMM_XLATOROBJECT *hXlator;  /* Stream's SM address translator */
-} ;
+struct strm_object {
+	u32 dw_signature;
+	struct strm_mgr *strm_mgr_obj;
+	struct chnl_object *chnl_obj;
+	u32 dir;		/* DSP_TONODE or DSP_FROMNODE */
+	u32 utimeout;
+	u32 num_bufs;		/* Max # of bufs allowed in stream */
+	u32 un_bufs_in_strm;	/* Current # of bufs in stream */
+	u32 ul_n_bytes;		/* bytes transferred since idled */
+	/* STREAM_IDLE, STREAM_READY, ... */
+	enum dsp_streamstate strm_state;
+	bhandle user_event;	/* Saved for strm_get_info() */
+	enum dsp_strmmode strm_mode;	/* STRMMODE_[PROCCOPY][ZEROCOPY]... */
+	u32 udma_chnl_id;	/* DMA chnl id */
+	u32 udma_priority;	/* DMA priority:DMAPRI_[LOW][HIGH] */
+	u32 segment_id;		/* >0 is SM segment.=0 is local heap */
+	u32 buf_alignment;	/* Alignment for stream bufs */
+	/* Stream's SM address translator */
+	struct cmm_xlatorobject *xlator;
+};
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS DeleteStrm(struct STRM_OBJECT *hStrm);
-static void DeleteStrmMgr(struct STRM_MGR *hStrmMgr);
+static dsp_status delete_strm(struct strm_object *hStrm);
+static void delete_strm_mgr(struct strm_mgr *strm_mgr_obj);
 
 /*
- *  ======== STRM_AllocateBuffer ========
+ *  ======== strm_allocate_buffer ========
  *  Purpose:
  *      Allocates buffers for a stream.
  */
-DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm, u32 uSize,
-				OUT u8 **apBuffer, u32 uNumBufs,
-				struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status strm_allocate_buffer(struct strm_object *hStrm, u32 usize,
+				OUT u8 **ap_buffer, u32 num_bufs,
+				struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 uAllocated = 0;
+	dsp_status status = DSP_SOK;
+	u32 alloc_cnt = 0;
 	u32 i;
 
-	HANDLE hSTRMRes;
+	bhandle hstrm_res;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(apBuffer != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ap_buffer != NULL);
 
-	if (MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		/*
 		 * Allocate from segment specified at time of stream open.
 		 */
-		if (uSize == 0)
+		if (usize == 0)
 			status = DSP_ESIZE;
 
 	} else {
@@ -128,206 +129,209 @@ DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm, u32 uSize,
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	for (i = 0; i < uNumBufs; i++) {
-		DBC_Assert(hStrm->hXlator != NULL);
-		(void)CMM_XlatorAllocBuf(hStrm->hXlator, &apBuffer[i], uSize);
-		if (apBuffer[i] == NULL) {
+	for (i = 0; i < num_bufs; i++) {
+		DBC_ASSERT(hStrm->xlator != NULL);
+		(void)cmm_xlator_alloc_buf(hStrm->xlator, &ap_buffer[i], usize);
+		if (ap_buffer[i] == NULL) {
 			status = DSP_EMEMORY;
-			uAllocated = i;
+			alloc_cnt = i;
 			break;
 		}
 	}
 	if (DSP_FAILED(status))
-		STRM_FreeBuffer(hStrm, apBuffer, uAllocated, pr_ctxt);
+		strm_free_buffer(hStrm, ap_buffer, alloc_cnt, pr_ctxt);
 
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND)
-		DRV_ProcUpdateSTRMRes(uNumBufs, hSTRMRes);
+	if (drv_get_strm_res_element(hStrm, &hstrm_res, pr_ctxt) !=
+	    DSP_ENOTFOUND)
+		drv_proc_update_strm_res(num_bufs, hstrm_res);
 
 func_end:
 	return status;
 }
 
 /*
- *  ======== STRM_Close ========
+ *  ======== strm_close ========
  *  Purpose:
- *      Close a stream opened with STRM_Open().
+ *      Close a stream opened with strm_open().
  */
-DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status strm_close(struct strm_object *hStrm,
+		      struct process_context *pr_ctxt)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_INFO chnlInfo;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	struct chnl_info chnl_info_obj;
+	dsp_status status = DSP_SOK;
 
-	HANDLE	      hSTRMRes;
+	bhandle hstrm_res;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
 		/* Have all buffers been reclaimed? If not, return
 		 * DSP_EPENDING */
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnChnlGetInfo) (hStrm->hChnl, &chnlInfo);
-		DBC_Assert(DSP_SUCCEEDED(status));
+		intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
+		status =
+		    (*intf_fxns->pfn_chnl_get_info) (hStrm->chnl_obj,
+						     &chnl_info_obj);
+		DBC_ASSERT(DSP_SUCCEEDED(status));
 
-		if (chnlInfo.cIOCs > 0 || chnlInfo.cIOReqs > 0)
+		if (chnl_info_obj.cio_cs > 0 || chnl_info_obj.cio_reqs > 0)
 			status = DSP_EPENDING;
 		else
-			status = DeleteStrm(hStrm);
+			status = delete_strm(hStrm);
 	}
 
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND)
-		DRV_ProcRemoveSTRMResElement(hSTRMRes, pr_ctxt);
+	if (drv_get_strm_res_element(hStrm, &hstrm_res, pr_ctxt) !=
+	    DSP_ENOTFOUND)
+		drv_proc_remove_strm_res_element(hstrm_res, pr_ctxt);
 func_end:
-	DBC_Ensure(status == DSP_SOK || status == DSP_EHANDLE ||
-		  status == DSP_EPENDING || status == DSP_EFAIL);
+	DBC_ENSURE(status == DSP_SOK || status == DSP_EHANDLE ||
+		   status == DSP_EPENDING || status == DSP_EFAIL);
 
 	dev_dbg(bridge, "%s: hStrm: %p, status 0x%x\n", __func__,
-							hStrm, status);
+		hStrm, status);
 	return status;
 }
 
 /*
- *  ======== STRM_Create ========
+ *  ======== strm_create ========
  *  Purpose:
  *      Create a STRM manager object.
  */
-DSP_STATUS STRM_Create(OUT struct STRM_MGR **phStrmMgr, struct DEV_OBJECT *hDev)
+dsp_status strm_create(OUT struct strm_mgr **phStrmMgr,
+		       struct dev_object *dev_obj)
 {
-	struct STRM_MGR *pStrmMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct strm_mgr *strm_mgr_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phStrmMgr != NULL);
-	DBC_Require(hDev != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phStrmMgr != NULL);
+	DBC_REQUIRE(dev_obj != NULL);
 
 	*phStrmMgr = NULL;
 	/* Allocate STRM manager object */
-	MEM_AllocObject(pStrmMgr, struct STRM_MGR, STRMMGR_SIGNATURE);
-	if (pStrmMgr == NULL)
+	MEM_ALLOC_OBJECT(strm_mgr_obj, struct strm_mgr, STRMMGR_SIGNATURE);
+	if (strm_mgr_obj == NULL)
 		status = DSP_EMEMORY;
 	else
-		pStrmMgr->hDev = hDev;
+		strm_mgr_obj->dev_obj = dev_obj;
 
 	/* Get Channel manager and WMD function interface */
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetChnlMgr(hDev, &(pStrmMgr->hChnlMgr));
+		status = dev_get_chnl_mgr(dev_obj, &(strm_mgr_obj->hchnl_mgr));
 		if (DSP_SUCCEEDED(status)) {
-			(void) DEV_GetIntfFxns(hDev, &(pStrmMgr->pIntfFxns));
-			DBC_Assert(pStrmMgr->pIntfFxns != NULL);
+			(void)dev_get_intf_fxns(dev_obj,
+						&(strm_mgr_obj->intf_fxns));
+			DBC_ASSERT(strm_mgr_obj->intf_fxns != NULL);
 		}
 	}
-	if (DSP_SUCCEEDED(status))
-		status = SYNC_InitializeCS(&pStrmMgr->hSync);
 
 	if (DSP_SUCCEEDED(status))
-		*phStrmMgr = pStrmMgr;
+		*phStrmMgr = strm_mgr_obj;
 	else
-		DeleteStrmMgr(pStrmMgr);
+		delete_strm_mgr(strm_mgr_obj);
 
-	DBC_Ensure(DSP_SUCCEEDED(status) &&
-		  (MEM_IsValidHandle((*phStrmMgr), STRMMGR_SIGNATURE) ||
-		  (DSP_FAILED(status) && *phStrmMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) &&
+		   (MEM_IS_VALID_HANDLE((*phStrmMgr), STRMMGR_SIGNATURE) ||
+		    (DSP_FAILED(status) && *phStrmMgr == NULL)));
 
 	return status;
 }
 
 /*
- *  ======== STRM_Delete ========
+ *  ======== strm_delete ========
  *  Purpose:
  *      Delete the STRM Manager Object.
  */
-void STRM_Delete(struct STRM_MGR *hStrmMgr)
+void strm_delete(struct strm_mgr *strm_mgr_obj)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(strm_mgr_obj, STRMMGR_SIGNATURE));
 
-	DeleteStrmMgr(hStrmMgr);
+	delete_strm_mgr(strm_mgr_obj);
 
-	DBC_Ensure(!MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE));
+	DBC_ENSURE(!MEM_IS_VALID_HANDLE(strm_mgr_obj, STRMMGR_SIGNATURE));
 }
 
 /*
- *  ======== STRM_Exit ========
+ *  ======== strm_exit ========
  *  Purpose:
  *      Discontinue usage of STRM module.
  */
-void STRM_Exit(void)
+void strm_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== STRM_FreeBuffer ========
+ *  ======== strm_free_buffer ========
  *  Purpose:
  *      Frees the buffers allocated for a stream.
  */
-DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm, u8 **apBuffer,
-		u32 uNumBufs, struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status strm_free_buffer(struct strm_object *hStrm, u8 ** ap_buffer,
+			    u32 num_bufs, struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	u32 i = 0;
 
-	HANDLE hSTRMRes = NULL;
+	bhandle hstrm_res = NULL;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(apBuffer != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ap_buffer != NULL);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE))
 		status = DSP_EHANDLE;
 
 	if (DSP_SUCCEEDED(status)) {
-		for (i = 0; i < uNumBufs; i++) {
-			DBC_Assert(hStrm->hXlator != NULL);
-			status = CMM_XlatorFreeBuf(hStrm->hXlator, apBuffer[i]);
+		for (i = 0; i < num_bufs; i++) {
+			DBC_ASSERT(hStrm->xlator != NULL);
+			status =
+			    cmm_xlator_free_buf(hStrm->xlator, ap_buffer[i]);
 			if (DSP_FAILED(status))
 				break;
-			apBuffer[i] = NULL;
+			ap_buffer[i] = NULL;
 		}
 	}
-	if (DRV_GetSTRMResElement(hStrm, hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND)
-		DRV_ProcUpdateSTRMRes(uNumBufs-i, hSTRMRes);
+	if (drv_get_strm_res_element(hStrm, hstrm_res, pr_ctxt) !=
+	    DSP_ENOTFOUND)
+		drv_proc_update_strm_res(num_bufs - i, hstrm_res);
 
 	return status;
 }
 
 /*
- *  ======== STRM_GetInfo ========
+ *  ======== strm_get_info ========
  *  Purpose:
  *      Retrieves information about a stream.
  */
-DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
-			OUT struct STRM_INFO *pStreamInfo,
-			u32 uStreamInfoSize)
+dsp_status strm_get_info(struct strm_object *hStrm,
+			 OUT struct stream_info *stream_info,
+			 u32 stream_info_size)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_INFO chnlInfo;
-	DSP_STATUS status = DSP_SOK;
-	void *pVirtBase = NULL;	/* NULL if no SM used */
+	struct bridge_drv_interface *intf_fxns;
+	struct chnl_info chnl_info_obj;
+	dsp_status status = DSP_SOK;
+	void *virt_base = NULL;	/* NULL if no SM used */
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pStreamInfo != NULL);
-	DBC_Require(uStreamInfoSize >= sizeof(struct STRM_INFO));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(stream_info != NULL);
+	DBC_REQUIRE(stream_info_size >= sizeof(struct stream_info));
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		if (uStreamInfoSize < sizeof(struct STRM_INFO)) {
+		if (stream_info_size < sizeof(struct stream_info)) {
 			/* size of users info */
 			status = DSP_ESIZE;
 		}
@@ -335,36 +339,38 @@ DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
-	status = (*pIntfFxns->pfnChnlGetInfo) (hStrm->hChnl, &chnlInfo);
+	intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
+	status =
+	    (*intf_fxns->pfn_chnl_get_info) (hStrm->chnl_obj, &chnl_info_obj);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (hStrm->hXlator) {
+	if (hStrm->xlator) {
 		/* We have a translator */
-		DBC_Assert(hStrm->uSegment > 0);
-		CMM_XlatorInfo(hStrm->hXlator, (u8 **)&pVirtBase, 0,
-			      hStrm->uSegment, false);
+		DBC_ASSERT(hStrm->segment_id > 0);
+		cmm_xlator_info(hStrm->xlator, (u8 **) &virt_base, 0,
+				hStrm->segment_id, false);
 	}
-	pStreamInfo->uSegment = hStrm->uSegment;
-	pStreamInfo->lMode = hStrm->lMode;
-	pStreamInfo->pVirtBase = pVirtBase;
-	pStreamInfo->pUser->uNumberBufsAllowed = hStrm->uNumBufs;
-	pStreamInfo->pUser->uNumberBufsInStream = chnlInfo.cIOCs +
-						 chnlInfo.cIOReqs;
+	stream_info->segment_id = hStrm->segment_id;
+	stream_info->strm_mode = hStrm->strm_mode;
+	stream_info->virt_base = virt_base;
+	stream_info->user_strm->number_bufs_allowed = hStrm->num_bufs;
+	stream_info->user_strm->number_bufs_in_stream = chnl_info_obj.cio_cs +
+	    chnl_info_obj.cio_reqs;
 	/* # of bytes transferred since last call to DSPStream_Idle() */
-	pStreamInfo->pUser->ulNumberBytes = chnlInfo.cPosition;
-	pStreamInfo->pUser->hSyncObjectHandle = chnlInfo.hEvent;
+	stream_info->user_strm->ul_number_bytes = chnl_info_obj.bytes_tx;
+	stream_info->user_strm->sync_object_handle = chnl_info_obj.event_obj;
 	/* Determine stream state based on channel state and info */
-	if (chnlInfo.dwState & CHNL_STATEEOS) {
-		pStreamInfo->pUser->ssStreamState = STREAM_DONE;
+	if (chnl_info_obj.dw_state & CHNL_STATEEOS) {
+		stream_info->user_strm->ss_stream_state = STREAM_DONE;
 	} else {
-		if (chnlInfo.cIOCs > 0)
-			pStreamInfo->pUser->ssStreamState = STREAM_READY;
-		else if (chnlInfo.cIOReqs > 0)
-			pStreamInfo->pUser->ssStreamState = STREAM_PENDING;
+		if (chnl_info_obj.cio_cs > 0)
+			stream_info->user_strm->ss_stream_state = STREAM_READY;
+		else if (chnl_info_obj.cio_reqs > 0)
+			stream_info->user_strm->ss_stream_state =
+			    STREAM_PENDING;
 		else
-			pStreamInfo->pUser->ssStreamState = STREAM_IDLE;
+			stream_info->user_strm->ss_stream_state = STREAM_IDLE;
 
 	}
 func_end:
@@ -372,214 +378,220 @@ func_end:
 }
 
 /*
- *  ======== STRM_Idle ========
+ *  ======== strm_idle ========
  *  Purpose:
  *      Idles a particular stream.
  */
-DSP_STATUS STRM_Idle(struct STRM_OBJECT *hStrm, bool fFlush)
+dsp_status strm_idle(struct strm_object *hStrm, bool fFlush)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+		intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 
-		status = (*pIntfFxns->pfnChnlIdle) (hStrm->hChnl,
-			 hStrm->uTimeout, fFlush);
+		status = (*intf_fxns->pfn_chnl_idle) (hStrm->chnl_obj,
+						      hStrm->utimeout, fFlush);
 	}
 
 	dev_dbg(bridge, "%s: hStrm: %p fFlush: 0x%x status: 0x%x\n",
-					__func__, hStrm, fFlush, status);
+		__func__, hStrm, fFlush, status);
 	return status;
 }
 
 /*
- *  ======== STRM_Init ========
+ *  ======== strm_init ========
  *  Purpose:
  *      Initialize the STRM module.
  */
-bool STRM_Init(void)
+bool strm_init(void)
 {
-	bool fRetVal = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (fRetVal)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetVal && (cRefs > 0)) || (!fRetVal && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetVal;
+	return ret;
 }
 
 /*
- *  ======== STRM_Issue ========
+ *  ======== strm_issue ========
  *  Purpose:
  *      Issues a buffer on a stream
  */
-DSP_STATUS STRM_Issue(struct STRM_OBJECT *hStrm, IN u8 *pBuf, u32 ulBytes,
-		     u32 ulBufSize, u32 dwArg)
+dsp_status strm_issue(struct strm_object *hStrm, IN u8 *pbuf, u32 ul_bytes,
+		      u32 ul_buf_size, u32 dw_arg)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-	void *pTmpBuf = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
+	void *tmp_buf = NULL;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBuf != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pbuf != NULL);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+		intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 
-		if (hStrm->uSegment != 0) {
-			pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
-					(void *)pBuf, CMM_VA2DSPPA);
-			if (pTmpBuf == NULL)
+		if (hStrm->segment_id != 0) {
+			tmp_buf = cmm_xlator_translate(hStrm->xlator,
+						       (void *)pbuf,
+						       CMM_VA2DSPPA);
+			if (tmp_buf == NULL)
 				status = DSP_ETRANSLATE;
 
 		}
 		if (DSP_SUCCEEDED(status)) {
-			status = (*pIntfFxns->pfnChnlAddIOReq)
-				 (hStrm->hChnl, pBuf, ulBytes, ulBufSize,
-				 (u32) pTmpBuf, dwArg);
+			status = (*intf_fxns->pfn_chnl_add_io_req)
+			    (hStrm->chnl_obj, pbuf, ul_bytes, ul_buf_size,
+			     (u32) tmp_buf, dw_arg);
 		}
 		if (status == CHNL_E_NOIORPS)
 			status = DSP_ESTREAMFULL;
 	}
 
-	dev_dbg(bridge, "%s: hStrm: %p pBuf: %p ulBytes: 0x%x dwArg: 0x%x "
-					"status: 0x%x\n", __func__, hStrm, pBuf,
-					ulBytes, dwArg, status);
+	dev_dbg(bridge, "%s: hStrm: %p pbuf: %p ul_bytes: 0x%x dw_arg: 0x%x "
+		"status: 0x%x\n", __func__, hStrm, pbuf,
+		ul_bytes, dw_arg, status);
 	return status;
 }
 
 /*
- *  ======== STRM_Open ========
+ *  ======== strm_open ========
  *  Purpose:
  *      Open a stream for sending/receiving data buffers to/from a task or
  *      XDAIS socket node on the DSP.
  */
-DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
-		IN struct STRM_ATTR *pAttr,
-		OUT struct STRM_OBJECT **phStrm,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status strm_open(struct node_object *hnode, u32 dir, u32 index,
+		     IN struct strm_attr *pattr,
+		     OUT struct strm_object **phStrm,
+		     struct process_context *pr_ctxt)
 {
-	struct STRM_MGR *hStrmMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	u32 ulChnlId;
-	struct STRM_OBJECT *pStrm = NULL;
-	short int uMode;
-	struct CHNL_ATTRS chnlAttrs;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_OBJECT *hCmmMgr = NULL;	/* Shared memory manager hndl */
-
-	HANDLE hSTRMRes;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phStrm != NULL);
-	DBC_Require(pAttr != NULL);
+	struct strm_mgr *strm_mgr_obj;
+	struct bridge_drv_interface *intf_fxns;
+	u32 ul_chnl_id;
+	struct strm_object *strm_obj = NULL;
+	short int chnl_mode;
+	struct chnl_attr chnl_attr_obj;
+	dsp_status status = DSP_SOK;
+	struct cmm_object *hcmm_mgr = NULL;	/* Shared memory manager hndl */
+
+	bhandle hstrm_res;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phStrm != NULL);
+	DBC_REQUIRE(pattr != NULL);
 	*phStrm = NULL;
-	if (uDir != DSP_TONODE && uDir != DSP_FROMNODE) {
+	if (dir != DSP_TONODE && dir != DSP_FROMNODE) {
 		status = DSP_EDIRECTION;
 	} else {
-		/* Get the channel id from the node (set in NODE_Connect()) */
-		status = NODE_GetChannelId(hNode, uDir, uIndex, &ulChnlId);
+		/* Get the channel id from the node (set in node_connect()) */
+		status = node_get_channel_id(hnode, dir, index, &ul_chnl_id);
 	}
 	if (DSP_SUCCEEDED(status))
-		status = NODE_GetStrmMgr(hNode, &hStrmMgr);
+		status = node_get_strm_mgr(hnode, &strm_mgr_obj);
 
 	if (DSP_SUCCEEDED(status)) {
-		MEM_AllocObject(pStrm, struct STRM_OBJECT, STRM_SIGNATURE);
-		if (pStrm == NULL) {
+		MEM_ALLOC_OBJECT(strm_obj, struct strm_object, STRM_SIGNATURE);
+		if (strm_obj == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			pStrm->hStrmMgr = hStrmMgr;
-			pStrm->uDir = uDir;
-			pStrm->strmState = STREAM_IDLE;
-			pStrm->hUserEvent = pAttr->hUserEvent;
-			if (pAttr->pStreamAttrIn != NULL) {
-				pStrm->uTimeout = pAttr->pStreamAttrIn->
-						  uTimeout;
-				pStrm->uNumBufs = pAttr->pStreamAttrIn->
-						  uNumBufs;
-				pStrm->lMode = pAttr->pStreamAttrIn->lMode;
-				pStrm->uSegment = pAttr->pStreamAttrIn->
-						  uSegment;
-				pStrm->uAlignment = pAttr->pStreamAttrIn->
-						    uAlignment;
-				pStrm->uDMAChnlId = pAttr->pStreamAttrIn->
-						    uDMAChnlId;
-				pStrm->uDMAPriority = pAttr->pStreamAttrIn->
-						      uDMAPriority;
-				chnlAttrs.uIOReqs = pAttr->pStreamAttrIn->
-						    uNumBufs;
+			strm_obj->strm_mgr_obj = strm_mgr_obj;
+			strm_obj->dir = dir;
+			strm_obj->strm_state = STREAM_IDLE;
+			strm_obj->user_event = pattr->user_event;
+			if (pattr->stream_attr_in != NULL) {
+				strm_obj->utimeout =
+				    pattr->stream_attr_in->utimeout;
+				strm_obj->num_bufs =
+				    pattr->stream_attr_in->num_bufs;
+				strm_obj->strm_mode =
+				    pattr->stream_attr_in->strm_mode;
+				strm_obj->segment_id =
+				    pattr->stream_attr_in->segment_id;
+				strm_obj->buf_alignment =
+				    pattr->stream_attr_in->buf_alignment;
+				strm_obj->udma_chnl_id =
+				    pattr->stream_attr_in->udma_chnl_id;
+				strm_obj->udma_priority =
+				    pattr->stream_attr_in->udma_priority;
+				chnl_attr_obj.uio_reqs =
+				    pattr->stream_attr_in->num_bufs;
 			} else {
-				pStrm->uTimeout = DEFAULTTIMEOUT;
-				pStrm->uNumBufs = DEFAULTNUMBUFS;
-				pStrm->lMode = STRMMODE_PROCCOPY;
-				pStrm->uSegment = 0;	/* local memory */
-				pStrm->uAlignment = 0;
-				pStrm->uDMAChnlId = 0;
-				pStrm->uDMAPriority = 0;
-				chnlAttrs.uIOReqs = DEFAULTNUMBUFS;
+				strm_obj->utimeout = DEFAULTTIMEOUT;
+				strm_obj->num_bufs = DEFAULTNUMBUFS;
+				strm_obj->strm_mode = STRMMODE_PROCCOPY;
+				strm_obj->segment_id = 0;	/* local mem */
+				strm_obj->buf_alignment = 0;
+				strm_obj->udma_chnl_id = 0;
+				strm_obj->udma_priority = 0;
+				chnl_attr_obj.uio_reqs = DEFAULTNUMBUFS;
 			}
-			chnlAttrs.hReserved1 = NULL;
+			chnl_attr_obj.reserved1 = NULL;
 			/* DMA chnl flush timeout */
-			chnlAttrs.hReserved2 = pStrm->uTimeout;
-			chnlAttrs.hEvent = NULL;
-			if (pAttr->hUserEvent != NULL)
-				chnlAttrs.hEvent = pAttr->hUserEvent;
+			chnl_attr_obj.reserved2 = strm_obj->utimeout;
+			chnl_attr_obj.event_obj = NULL;
+			if (pattr->user_event != NULL)
+				chnl_attr_obj.event_obj = pattr->user_event;
 
 		}
 	}
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	if ((pAttr->pVirtBase == NULL) || !(pAttr->ulVirtSize > 0))
+	if ((pattr->virt_base == NULL) || !(pattr->ul_virt_size > 0))
 		goto func_cont;
 
-	DBC_Assert(pStrm->lMode != STRMMODE_LDMA);	/* no System DMA */
+	/* No System DMA */
+	DBC_ASSERT(strm_obj->strm_mode != STRMMODE_LDMA);
 	/* Get the shared mem mgr for this streams dev object */
-	status = DEV_GetCmmMgr(hStrmMgr->hDev, &hCmmMgr);
+	status = dev_get_cmm_mgr(strm_mgr_obj->dev_obj, &hcmm_mgr);
 	if (DSP_SUCCEEDED(status)) {
-		/*Allocate a SM addr translator for this strm.*/
-		status = CMM_XlatorCreate(&pStrm->hXlator, hCmmMgr, NULL);
+		/*Allocate a SM addr translator for this strm. */
+		status = cmm_xlator_create(&strm_obj->xlator, hcmm_mgr, NULL);
 		if (DSP_SUCCEEDED(status)) {
-			DBC_Assert(pStrm->uSegment > 0);
+			DBC_ASSERT(strm_obj->segment_id > 0);
 			/*  Set translators Virt Addr attributes */
-			status = CMM_XlatorInfo(pStrm->hXlator,
-				 (u8 **)&pAttr->pVirtBase, pAttr->ulVirtSize,
-				 pStrm->uSegment, true);
+			status = cmm_xlator_info(strm_obj->xlator,
+						 (u8 **) &pattr->virt_base,
+						 pattr->ul_virt_size,
+						 strm_obj->segment_id, true);
 		}
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status)) {
 		/* Open channel */
-		uMode = (uDir == DSP_TONODE) ?
-			CHNL_MODETODSP : CHNL_MODEFROMDSP;
-		pIntfFxns = hStrmMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnChnlOpen) (&(pStrm->hChnl),
-			 hStrmMgr->hChnlMgr, uMode, ulChnlId, &chnlAttrs);
+		chnl_mode = (dir == DSP_TONODE) ?
+		    CHNL_MODETODSP : CHNL_MODEFROMDSP;
+		intf_fxns = strm_mgr_obj->intf_fxns;
+		status = (*intf_fxns->pfn_chnl_open) (&(strm_obj->chnl_obj),
+						      strm_mgr_obj->hchnl_mgr,
+						      chnl_mode, ul_chnl_id,
+						      &chnl_attr_obj);
 		if (DSP_FAILED(status)) {
 			/*
 			 * over-ride non-returnable status codes so we return
 			 * something documented
 			 */
 			if (status != DSP_EMEMORY && status !=
-			   DSP_EINVALIDARG && status != DSP_EFAIL) {
+			    DSP_EINVALIDARG && status != DSP_EFAIL) {
 				/*
 				 * We got a status that's not return-able.
 				 * Assert that we got something we were
 				 * expecting (DSP_EHANDLE isn't acceptable,
-				 * hStrmMgr->hChnlMgr better be valid or we
+				 * strm_mgr_obj->hchnl_mgr better be valid or we
 				 * assert here), and then return DSP_EFAIL.
 				 */
-				DBC_Assert(status == CHNL_E_OUTOFSTREAMS ||
+				DBC_ASSERT(status == CHNL_E_OUTOFSTREAMS ||
 					   status == CHNL_E_BADCHANID ||
 					   status == CHNL_E_CHANBUSY ||
 					   status == CHNL_E_NOIORPS);
@@ -588,164 +600,172 @@ func_cont:
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		*phStrm = pStrm;
-		DRV_ProcInsertSTRMResElement(*phStrm, &hSTRMRes, pr_ctxt);
+		*phStrm = strm_obj;
+		drv_proc_insert_strm_res_element(*phStrm, &hstrm_res, pr_ctxt);
 	} else {
-		(void)DeleteStrm(pStrm);
+		(void)delete_strm(strm_obj);
 	}
 
-	 /* ensure we return a documented error code */
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle((*phStrm), STRM_SIGNATURE)) ||
-		  (*phStrm == NULL && (status == DSP_EHANDLE ||
-		  status == DSP_EDIRECTION || status == DSP_EVALUE ||
-		  status == DSP_EFAIL)));
-
-	dev_dbg(bridge, "%s: hNode: %p uDir: 0x%x uIndex: 0x%x pAttr: %p "
-				"phStrm: %p status: 0x%x\n", __func__,
-				hNode, uDir, uIndex, pAttr, phStrm, status);
+	/* ensure we return a documented error code */
+	DBC_ENSURE((DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE((*phStrm), STRM_SIGNATURE)) ||
+		   (*phStrm == NULL && (status == DSP_EHANDLE ||
+					status == DSP_EDIRECTION
+					|| status == DSP_EVALUE
+					|| status == DSP_EFAIL)));
+
+	dev_dbg(bridge, "%s: hnode: %p dir: 0x%x index: 0x%x pattr: %p "
+		"phStrm: %p status: 0x%x\n", __func__,
+		hnode, dir, index, pattr, phStrm, status);
 	return status;
 }
 
 /*
- *  ======== STRM_Reclaim ========
+ *  ======== strm_reclaim ========
  *  Purpose:
  *      Relcaims a buffer from a stream.
  */
-DSP_STATUS STRM_Reclaim(struct STRM_OBJECT *hStrm, OUT u8 **pBufPtr,
-			u32 *pulBytes, u32 *pulBufSize, u32 *pdwArg)
+dsp_status strm_reclaim(struct strm_object *hStrm, OUT u8 ** buf_ptr,
+			u32 *pulBytes, u32 *pulBufSize, u32 *pdw_arg)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_IOC chnlIOC;
-	DSP_STATUS status = DSP_SOK;
-	void *pTmpBuf = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct chnl_ioc chnl_ioc_obj;
+	dsp_status status = DSP_SOK;
+	void *tmp_buf = NULL;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBufPtr != NULL);
-	DBC_Require(pulBytes != NULL);
-	DBC_Require(pdwArg != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(buf_ptr != NULL);
+	DBC_REQUIRE(pulBytes != NULL);
+	DBC_REQUIRE(pdw_arg != NULL);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+	intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 
-	status = (*pIntfFxns->pfnChnlGetIOC)(hStrm->hChnl, hStrm->uTimeout,
-		 &chnlIOC);
+	status =
+	    (*intf_fxns->pfn_chnl_get_ioc) (hStrm->chnl_obj, hStrm->utimeout,
+					    &chnl_ioc_obj);
 	if (DSP_SUCCEEDED(status)) {
-		*pulBytes = chnlIOC.cBytes;
+		*pulBytes = chnl_ioc_obj.byte_size;
 		if (pulBufSize)
-			*pulBufSize = chnlIOC.cBufSize;
+			*pulBufSize = chnl_ioc_obj.buf_size;
 
-		*pdwArg = chnlIOC.dwArg;
-		if (!CHNL_IsIOComplete(chnlIOC)) {
-			if (CHNL_IsTimedOut(chnlIOC)) {
+		*pdw_arg = chnl_ioc_obj.dw_arg;
+		if (!CHNL_IS_IO_COMPLETE(chnl_ioc_obj)) {
+			if (CHNL_IS_TIMED_OUT(chnl_ioc_obj)) {
 				status = DSP_ETIMEOUT;
 			} else {
 				/* Allow reclaims after idle to succeed */
-				if (!CHNL_IsIOCancelled(chnlIOC))
+				if (!CHNL_IS_IO_CANCELLED(chnl_ioc_obj))
 					status = DSP_EFAIL;
 
 			}
 		}
 		/* Translate zerocopy buffer if channel not canceled. */
-		if (DSP_SUCCEEDED(status) && (!CHNL_IsIOCancelled(chnlIOC)) &&
-		   (hStrm->lMode == STRMMODE_ZEROCOPY)) {
+		if (DSP_SUCCEEDED(status)
+		    && (!CHNL_IS_IO_CANCELLED(chnl_ioc_obj))
+		    && (hStrm->strm_mode == STRMMODE_ZEROCOPY)) {
 			/*
-			 *  This is a zero-copy channel so chnlIOC.pBuf
+			 *  This is a zero-copy channel so chnl_ioc_obj.pbuf
 			 *  contains the DSP address of SM. We need to
 			 *  translate it to a virtual address for the user
 			 *  thread to access.
 			 *  Note: Could add CMM_DSPPA2VA to CMM in the future.
 			 */
-			pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
-					chnlIOC.pBuf, CMM_DSPPA2PA);
-			if (pTmpBuf != NULL) {
+			tmp_buf = cmm_xlator_translate(hStrm->xlator,
+						       chnl_ioc_obj.pbuf,
+						       CMM_DSPPA2PA);
+			if (tmp_buf != NULL) {
 				/* now convert this GPP Pa to Va */
-				pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
-					  pTmpBuf, CMM_PA2VA);
+				tmp_buf = cmm_xlator_translate(hStrm->xlator,
+							       tmp_buf,
+							       CMM_PA2VA);
 			}
-			if (pTmpBuf == NULL)
+			if (tmp_buf == NULL)
 				status = DSP_ETRANSLATE;
 
-			chnlIOC.pBuf = pTmpBuf;
+			chnl_ioc_obj.pbuf = tmp_buf;
 		}
-		*pBufPtr = chnlIOC.pBuf;
+		*buf_ptr = chnl_ioc_obj.pbuf;
 	}
 func_end:
 	/* ensure we return a documented return code */
-	DBC_Ensure(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
-		  status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
-		  status == DSP_EFAIL);
+	DBC_ENSURE(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
+		   status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
+		   status == DSP_EFAIL);
 
-	dev_dbg(bridge, "%s: hStrm: %p pBufPtr: %p pulBytes: %p pdwArg: %p "
-					"status 0x%x\n", __func__, hStrm,
-					pBufPtr, pulBytes, pdwArg, status);
+	dev_dbg(bridge, "%s: hStrm: %p buf_ptr: %p pulBytes: %p pdw_arg: %p "
+		"status 0x%x\n", __func__, hStrm,
+		buf_ptr, pulBytes, pdw_arg, status);
 	return status;
 }
 
 /*
- *  ======== STRM_RegisterNotify ========
+ *  ======== strm_register_notify ========
  *  Purpose:
  *      Register to be notified on specific events for this stream.
  */
-DSP_STATUS STRM_RegisterNotify(struct STRM_OBJECT *hStrm, u32 uEventMask,
-			      u32 uNotifyType, struct DSP_NOTIFICATION
-			      *hNotification)
+dsp_status strm_register_notify(struct strm_object *hStrm, u32 event_mask,
+				u32 notify_type, struct dsp_notification
+				* hnotification)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hNotification != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hnotification != NULL);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
-	} else if ((uEventMask & ~((DSP_STREAMIOCOMPLETION) |
-		 DSP_STREAMDONE)) != 0) {
+	} else if ((event_mask & ~((DSP_STREAMIOCOMPLETION) |
+				   DSP_STREAMDONE)) != 0) {
 		status = DSP_EVALUE;
 	} else {
-		if (uNotifyType != DSP_SIGNALEVENT)
+		if (notify_type != DSP_SIGNALEVENT)
 			status = DSP_ENOTIMPL;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+		intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 
-		status = (*pIntfFxns->pfnChnlRegisterNotify)(hStrm->hChnl,
-			 uEventMask, uNotifyType, hNotification);
+		status =
+		    (*intf_fxns->pfn_chnl_register_notify) (hStrm->chnl_obj,
+							    event_mask,
+							    notify_type,
+							    hnotification);
 	}
 	/* ensure we return a documented return code */
-	DBC_Ensure(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
-		  status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
-		  status == DSP_ENOTIMPL || status == DSP_EFAIL);
+	DBC_ENSURE(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
+		   status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
+		   status == DSP_ENOTIMPL || status == DSP_EFAIL);
 	return status;
 }
 
 /*
- *  ======== STRM_Select ========
+ *  ======== strm_select ========
  *  Purpose:
  *      Selects a ready stream.
  */
-DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab, u32 nStrms,
-		      OUT u32 *pMask, u32 uTimeout)
+dsp_status strm_select(IN struct strm_object **strm_tab, u32 nStrms,
+		       OUT u32 *pmask, u32 utimeout)
 {
-	u32 uIndex;
-	struct CHNL_INFO chnlInfo;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct SYNC_OBJECT **hSyncEvents = NULL;
+	u32 index;
+	struct chnl_info chnl_info_obj;
+	struct bridge_drv_interface *intf_fxns;
+	struct sync_object **sync_events = NULL;
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(aStrmTab != NULL);
-	DBC_Require(pMask != NULL);
-	DBC_Require(nStrms > 0);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(strm_tab != NULL);
+	DBC_REQUIRE(pmask != NULL);
+	DBC_REQUIRE(nStrms > 0);
 
-	*pMask = 0;
+	*pmask = 0;
 	for (i = 0; i < nStrms; i++) {
-		if (!MEM_IsValidHandle(aStrmTab[i], STRM_SIGNATURE)) {
+		if (!MEM_IS_VALID_HANDLE(strm_tab[i], STRM_SIGNATURE)) {
 			status = DSP_EHANDLE;
 			break;
 		}
@@ -755,81 +775,85 @@ DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab, u32 nStrms,
 
 	/* Determine which channels have IO ready */
 	for (i = 0; i < nStrms; i++) {
-		pIntfFxns = aStrmTab[i]->hStrmMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnChnlGetInfo)(aStrmTab[i]->hChnl,
-			 &chnlInfo);
+		intf_fxns = strm_tab[i]->strm_mgr_obj->intf_fxns;
+		status = (*intf_fxns->pfn_chnl_get_info) (strm_tab[i]->chnl_obj,
+							  &chnl_info_obj);
 		if (DSP_FAILED(status)) {
 			break;
 		} else {
-			if (chnlInfo.cIOCs > 0)
-				*pMask |= (1 << i);
+			if (chnl_info_obj.cio_cs > 0)
+				*pmask |= (1 << i);
 
 		}
 	}
-	if (DSP_SUCCEEDED(status) && uTimeout > 0 && *pMask == 0) {
+	if (DSP_SUCCEEDED(status) && utimeout > 0 && *pmask == 0) {
 		/* Non-zero timeout */
-		hSyncEvents = (struct SYNC_OBJECT **)MEM_Alloc(nStrms *
-			      sizeof(struct SYNC_OBJECT *), MEM_PAGED);
-		if (hSyncEvents == NULL) {
+		sync_events = (struct sync_object **)mem_alloc(nStrms *
+			      sizeof(struct sync_object *), MEM_PAGED);
+
+		if (sync_events == NULL) {
 			status = DSP_EMEMORY;
 		} else {
 			for (i = 0; i < nStrms; i++) {
-				pIntfFxns = aStrmTab[i]->hStrmMgr->pIntfFxns;
-				status = (*pIntfFxns->pfnChnlGetInfo)
-					 (aStrmTab[i]->hChnl, &chnlInfo);
+				intf_fxns =
+				    strm_tab[i]->strm_mgr_obj->intf_fxns;
+				status = (*intf_fxns->pfn_chnl_get_info)
+				    (strm_tab[i]->chnl_obj, &chnl_info_obj);
 				if (DSP_FAILED(status))
 					break;
 				else
-					hSyncEvents[i] = chnlInfo.hSyncEvent;
+					sync_events[i] =
+					    chnl_info_obj.sync_event;
 
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
-			status = SYNC_WaitOnMultipleEvents(hSyncEvents, nStrms,
-				uTimeout, &uIndex);
+			status =
+			    sync_wait_on_multiple_events(sync_events, nStrms,
+							 utimeout, &index);
 			if (DSP_SUCCEEDED(status)) {
 				/* Since we waited on the event, we have to
 				 * reset it */
-				SYNC_SetEvent(hSyncEvents[uIndex]);
-				*pMask = 1 << uIndex;
+				sync_set_event(sync_events[index]);
+				*pmask = 1 << index;
 			}
 		}
 	}
 func_end:
-	kfree(hSyncEvents);
+	kfree(sync_events);
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && (*pMask != 0 || uTimeout == 0)) ||
-		  (DSP_FAILED(status) && *pMask == 0));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && (*pmask != 0 || utimeout == 0)) ||
+		   (DSP_FAILED(status) && *pmask == 0));
 
 	return status;
 }
 
 /*
- *  ======== DeleteStrm ========
+ *  ======== delete_strm ========
  *  Purpose:
  *      Frees the resources allocated for a stream.
  */
-static DSP_STATUS DeleteStrm(struct STRM_OBJECT *hStrm)
+static dsp_status delete_strm(struct strm_object *hStrm)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
 
-	if (MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		if (hStrm->hChnl) {
-			pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+	if (MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
+		if (hStrm->chnl_obj) {
+			intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 			/* Channel close can fail only if the channel handle
 			 * is invalid. */
-			status = (*pIntfFxns->pfnChnlClose) (hStrm->hChnl);
+			status = (*intf_fxns->pfn_chnl_close) (hStrm->chnl_obj);
 			/* Free all SM address translator resources */
 			if (DSP_SUCCEEDED(status)) {
-				if (hStrm->hXlator) {
+				if (hStrm->xlator) {
 					/* force free */
-					(void)CMM_XlatorDelete(hStrm->hXlator,
-					true);
+					(void)cmm_xlator_delete(hStrm->xlator,
+								true);
 				}
 			}
 		}
-		MEM_FreeObject(hStrm);
+		MEM_FREE_OBJECT(hStrm);
 	} else {
 		status = DSP_EHANDLE;
 	}
@@ -837,18 +861,12 @@ static DSP_STATUS DeleteStrm(struct STRM_OBJECT *hStrm)
 }
 
 /*
- *  ======== DeleteStrmMgr ========
+ *  ======== delete_strm_mgr ========
  *  Purpose:
  *      Frees stream manager.
  */
-static void DeleteStrmMgr(struct STRM_MGR *hStrmMgr)
+static void delete_strm_mgr(struct strm_mgr *strm_mgr_obj)
 {
-	if (MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE)) {
-
-		if (hStrmMgr->hSync)
-			SYNC_DeleteCS(hStrmMgr->hSync);
-
-		MEM_FreeObject(hStrmMgr);
-	}
+	if (MEM_IS_VALID_HANDLE(strm_mgr_obj, STRMMGR_SIGNATURE))
+		MEM_FREE_OBJECT(strm_mgr_obj);
 }
-
diff --git a/drivers/dsp/bridge/services/cfg.c b/drivers/dsp/bridge/services/cfg.c
index 1fd7a57..a307730 100644
--- a/drivers/dsp/bridge/services/cfg.c
+++ b/drivers/dsp/bridge/services/cfg.c
@@ -30,74 +30,78 @@
 /*  ----------------------------------- This */
 #include <dspbridge/cfg.h>
 
-struct DRV_EXT {
+struct drv_ext {
 	struct list_head link;
-	char szString[MAXREGPATHLENGTH];
+	char sz_string[MAXREGPATHLENGTH];
 };
 
 /*
- *  ======== CFG_Exit ========
+ *  ======== cfg_exit ========
  *  Purpose:
  *      Discontinue usage of the CFG module.
  */
-void CFG_Exit(void)
+void cfg_exit(void)
 {
 	/* Do nothing */
 }
 
 /*
- *  ======== CFG_GetAutoStart ========
+ *  ======== cfg_get_auto_start ========
  *  Purpose:
  *      Retreive the autostart mask, if any, for this board.
  */
-DSP_STATUS CFG_GetAutoStart(struct CFG_DEVNODE *hDevNode,
-			    OUT u32 *pdwAutoStart)
+dsp_status cfg_get_auto_start(struct cfg_devnode *dev_node_obj,
+			      OUT u32 *pdwAutoStart)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 dwBufSize;
+	dsp_status status = DSP_SOK;
+	u32 dw_buf_size;
 
-	dwBufSize = sizeof(*pdwAutoStart);
-	if (!hDevNode)
+	dw_buf_size = sizeof(*pdwAutoStart);
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 	if (!pdwAutoStart)
 		status = CFG_E_INVALIDPOINTER;
 	if (DSP_SUCCEEDED(status)) {
-		status = REG_GetValue(AUTOSTART, (u8 *)pdwAutoStart,
-				      &dwBufSize);
+		status = reg_get_value(AUTOSTART, (u8 *) pdwAutoStart,
+				       &dw_buf_size);
 		if (DSP_FAILED(status))
 			status = CFG_E_RESOURCENOTAVAIL;
 	}
 
-	DBC_Ensure((status == DSP_SOK &&
-		(*pdwAutoStart == 0 || *pdwAutoStart == 1))
-		|| status != DSP_SOK);
+	DBC_ENSURE((status == DSP_SOK &&
+		    (*pdwAutoStart == 0 || *pdwAutoStart == 1))
+		   || status != DSP_SOK);
 	return status;
 }
 
 /*
- *  ======== CFG_GetDevObject ========
+ *  ======== cfg_get_dev_object ========
  *  Purpose:
  *      Retrieve the Device Object handle for a given devnode.
  */
-DSP_STATUS CFG_GetDevObject(struct CFG_DEVNODE *hDevNode, OUT u32 *pdwValue)
+dsp_status cfg_get_dev_object(struct cfg_devnode *dev_node_obj,
+			      OUT u32 *pdwValue)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 dwBufSize;
+	dsp_status status = DSP_SOK;
+	u32 dw_buf_size;
 
-	if (!hDevNode)
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 
 	if (!pdwValue)
 		status = CFG_E_INVALIDHDEVNODE;
 
-	dwBufSize = sizeof(pdwValue);
+	dw_buf_size = sizeof(pdwValue);
 	if (DSP_SUCCEEDED(status)) {
 
-		/* check the device string and then call the REG_SetValue*/
-		if (!(strcmp((char *)((struct DRV_EXT *)hDevNode)->szString,
-							"TIOMAP1510")))
-			status = REG_GetValue("DEVICE_DSP", (u8 *)pdwValue,
-					      &dwBufSize);
+		/* check the device string and then call the reg_set_value */
+		if (!
+		    (strcmp
+		     ((char *)((struct drv_ext *)dev_node_obj)->sz_string,
+		      "TIOMAP1510")))
+			status =
+			    reg_get_value("DEVICE_DSP", (u8 *) pdwValue,
+					  &dw_buf_size);
 	}
 	if (DSP_FAILED(status))
 		pr_err("%s: Failed, status 0x%x\n", __func__, status);
@@ -105,87 +109,90 @@ DSP_STATUS CFG_GetDevObject(struct CFG_DEVNODE *hDevNode, OUT u32 *pdwValue)
 }
 
 /*
- *  ======== CFG_GetDSPResources ========
+ *  ======== cfg_get_dsp_resources ========
  *  Purpose:
  *      Get the DSP resources available to a given device.
  */
-DSP_STATUS CFG_GetDSPResources(struct CFG_DEVNODE *hDevNode,
-			       OUT struct CFG_DSPRES *pDSPResTable)
+dsp_status cfg_get_dsp_resources(struct cfg_devnode *dev_node_obj,
+				 OUT struct cfg_dspres *pDSPResTable)
 {
-	DSP_STATUS status = DSP_SOK;	/* return value */
-	u32 dwResSize;
-	if (!hDevNode)
+	dsp_status status = DSP_SOK;	/* return value */
+	u32 dw_res_size;
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 	else if (!pDSPResTable)
 		status = CFG_E_INVALIDPOINTER;
 	else
-		status = REG_GetValue(DSPRESOURCES, (u8 *)pDSPResTable,
-				     &dwResSize);
+		status = reg_get_value(DSPRESOURCES, (u8 *) pDSPResTable,
+				       &dw_res_size);
 	if (DSP_FAILED(status)) {
 		status = CFG_E_RESOURCENOTAVAIL;
 		pr_err("%s: Failed, status 0x%x\n", __func__, status);
 	}
 	/* assert that resource values are reasonable */
-	DBC_Assert(pDSPResTable->uChipType < 256);
-	DBC_Assert(pDSPResTable->uWordSize > 0);
-	DBC_Assert(pDSPResTable->uWordSize < 32);
-	DBC_Assert(pDSPResTable->cChips > 0);
-	DBC_Assert(pDSPResTable->cChips < 256);
+	DBC_ASSERT(pDSPResTable->chip_type < 256);
+	DBC_ASSERT(pDSPResTable->word_size > 0);
+	DBC_ASSERT(pDSPResTable->word_size < 32);
+	DBC_ASSERT(pDSPResTable->chip_number > 0);
+	DBC_ASSERT(pDSPResTable->chip_number < 256);
 	return status;
 }
 
 /*
- *  ======== CFG_GetExecFile ========
+ *  ======== cfg_get_exec_file ========
  *  Purpose:
  *      Retreive the default executable, if any, for this board.
  */
-DSP_STATUS CFG_GetExecFile(struct CFG_DEVNODE *hDevNode, u32 ulBufSize,
-			   OUT char *pstrExecFile)
+dsp_status cfg_get_exec_file(struct cfg_devnode *dev_node_obj, u32 ul_buf_size,
+			     OUT char *pstrExecFile)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 cExecSize = ulBufSize;
+	dsp_status status = DSP_SOK;
+	u32 exec_size = ul_buf_size;
 
-	if (!hDevNode)
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 	else if (!pstrExecFile)
 		status = CFG_E_INVALIDPOINTER;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = REG_GetValue(DEFEXEC, (u8 *)pstrExecFile, &cExecSize);
+		status =
+		    reg_get_value(DEFEXEC, (u8 *) pstrExecFile, &exec_size);
 		if (DSP_FAILED(status))
 			status = CFG_E_RESOURCENOTAVAIL;
-		else if (cExecSize > ulBufSize)
+		else if (exec_size > ul_buf_size)
 			status = DSP_ESIZE;
 
 	}
 	if (DSP_FAILED(status))
 		pr_err("%s: Failed, status 0x%x\n", __func__, status);
-	DBC_Ensure(((status == DSP_SOK) &&
-		(strlen(pstrExecFile) <= ulBufSize)) || (status != DSP_SOK));
+	DBC_ENSURE(((status == DSP_SOK) &&
+		    (strlen(pstrExecFile) <= ul_buf_size))
+		   || (status != DSP_SOK));
 	return status;
 }
 
 /*
- *  ======== CFG_GetHostResources ========
+ *  ======== cfg_get_host_resources ========
  *  Purpose:
  *      Get the Host allocated resources assigned to a given device.
  */
-DSP_STATUS CFG_GetHostResources(struct CFG_DEVNODE *hDevNode,
-				OUT struct CFG_HOSTRES *pHostResTable)
+dsp_status cfg_get_host_resources(struct cfg_devnode *dev_node_obj,
+				  OUT struct cfg_hostres *pHostResTable)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 dwBufSize;
+	dsp_status status = DSP_SOK;
+	u32 dw_buf_size;
 
-	if (!hDevNode)
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 
 	if (!pHostResTable)
 		status = CFG_E_INVALIDPOINTER;
 
 	if (DSP_SUCCEEDED(status)) {
-		dwBufSize = sizeof(struct CFG_HOSTRES);
-		if (DSP_FAILED(REG_GetValue(CURRENTCONFIG, (u8 *)pHostResTable,
-					    &dwBufSize))) {
+		dw_buf_size = sizeof(struct cfg_hostres);
+		if (DSP_FAILED
+		    (reg_get_value
+		     (CURRENTCONFIG, (u8 *) pHostResTable, &dw_buf_size))) {
 			status = CFG_E_RESOURCENOTAVAIL;
 		}
 	}
@@ -195,25 +202,27 @@ DSP_STATUS CFG_GetHostResources(struct CFG_DEVNODE *hDevNode,
 }
 
 /*
- *  ======== CFG_GetObject ========
+ *  ======== cfg_get_object ========
  *  Purpose:
  *      Retrieve the Object handle from the Registry
  */
-DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType)
+dsp_status cfg_get_object(OUT u32 *pdwValue, u32 dw_type)
 {
-	DSP_STATUS status = DSP_EINVALIDARG;
-	u32 dwBufSize;
-	DBC_Require(pdwValue != NULL);
+	dsp_status status = DSP_EINVALIDARG;
+	u32 dw_buf_size;
+	DBC_REQUIRE(pdwValue != NULL);
 
-	dwBufSize = sizeof(pdwValue);
-	switch (dwType) {
+	dw_buf_size = sizeof(pdwValue);
+	switch (dw_type) {
 	case (REG_DRV_OBJECT):
-		status = REG_GetValue(DRVOBJECT, (u8 *)pdwValue, &dwBufSize);
+		status =
+		    reg_get_value(DRVOBJECT, (u8 *) pdwValue, &dw_buf_size);
 		if (DSP_FAILED(status))
 			status = CFG_E_RESOURCENOTAVAIL;
 		break;
 	case (REG_MGR_OBJECT):
-		status = REG_GetValue(MGROBJECT, (u8 *)pdwValue, &dwBufSize);
+		status =
+		    reg_get_value(MGROBJECT, (u8 *) pdwValue, &dw_buf_size);
 		if (DSP_FAILED(status))
 			status = CFG_E_RESOURCENOTAVAIL;
 		break;
@@ -224,54 +233,54 @@ DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType)
 		*pdwValue = 0;
 		pr_err("%s: Failed, status 0x%x\n", __func__, status);
 	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && *pdwValue != 0) ||
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *pdwValue != 0) ||
 		   (DSP_FAILED(status) && *pdwValue == 0));
 	return status;
 }
 
 /*
- *  ======== CFG_Init ========
+ *  ======== cfg_init ========
  *  Purpose:
  *      Initialize the CFG module's private state.
  */
-bool CFG_Init(void)
+bool cfg_init(void)
 {
-	struct CFG_DSPRES dspResources;
-
-	dspResources.uChipType = DSPTYPE_64;
-	dspResources.cChips = 1;
-	dspResources.uWordSize = DSPWORDSIZE;
-	dspResources.cMemTypes = 0;
-	dspResources.aMemDesc[0].uMemType = 0;
-	dspResources.aMemDesc[0].ulMin = 0;
-	dspResources.aMemDesc[0].ulMax = 0;
-	if (DSP_FAILED(REG_SetValue(DSPRESOURCES, (u8 *)&dspResources,
-				       sizeof(struct CFG_DSPRES))))
+	struct cfg_dspres dsp_resources;
+
+	dsp_resources.chip_type = DSPTYPE64;
+	dsp_resources.chip_number = 1;
+	dsp_resources.word_size = DSPWORDSIZE;
+	dsp_resources.mem_types = 0;
+	dsp_resources.mem_desc[0].mem_type = 0;
+	dsp_resources.mem_desc[0].ul_min = 0;
+	dsp_resources.mem_desc[0].ul_max = 0;
+	if (DSP_FAILED(reg_set_value(DSPRESOURCES, (u8 *) &dsp_resources,
+				     sizeof(struct cfg_dspres))))
 		pr_err("Failed to initialize DSP resources in registry\n");
 
 	return true;
 }
 
 /*
- *  ======== CFG_SetDevObject ========
+ *  ======== cfg_set_dev_object ========
  *  Purpose:
- *      Store the Device Object handle and devNode pointer for a given devnode.
+ *      Store the Device Object handle and dev_node pointer for a given devnode.
  */
-DSP_STATUS CFG_SetDevObject(struct CFG_DEVNODE *hDevNode, u32 dwValue)
+dsp_status cfg_set_dev_object(struct cfg_devnode *dev_node_obj, u32 dwValue)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 dwBuffSize;
+	dsp_status status = DSP_SOK;
+	u32 dw_buff_size;
 
-	if (!hDevNode)
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 
-	dwBuffSize = sizeof(dwValue);
+	dw_buff_size = sizeof(dwValue);
 	if (DSP_SUCCEEDED(status)) {
 		/* Store the WCD device object in the Registry */
 
-		if (!(strcmp((char *)hDevNode, "TIOMAP1510"))) {
-			status = REG_SetValue("DEVICE_DSP", (u8 *)&dwValue,
-						dwBuffSize);
+		if (!(strcmp((char *)dev_node_obj, "TIOMAP1510"))) {
+			status = reg_set_value("DEVICE_DSP", (u8 *) &dwValue,
+					       dw_buff_size);
 		}
 	}
 	if (DSP_FAILED(status))
@@ -281,22 +290,24 @@ DSP_STATUS CFG_SetDevObject(struct CFG_DEVNODE *hDevNode, u32 dwValue)
 }
 
 /*
- *  ======== CFG_SetObject ========
+ *  ======== cfg_set_object ========
  *  Purpose:
  *      Store the Driver Object handle
  */
-DSP_STATUS CFG_SetObject(u32 dwValue, u32 dwType)
+dsp_status cfg_set_object(u32 dwValue, u32 dw_type)
 {
-	DSP_STATUS status = DSP_EINVALIDARG;
-	u32 dwBuffSize;
+	dsp_status status = DSP_EINVALIDARG;
+	u32 dw_buff_size;
 
-	dwBuffSize = sizeof(dwValue);
-	switch (dwType) {
+	dw_buff_size = sizeof(dwValue);
+	switch (dw_type) {
 	case (REG_DRV_OBJECT):
-		status = REG_SetValue(DRVOBJECT, (u8 *)&dwValue, dwBuffSize);
+		status =
+		    reg_set_value(DRVOBJECT, (u8 *) &dwValue, dw_buff_size);
 		break;
 	case (REG_MGR_OBJECT):
-		status = REG_SetValue(MGROBJECT, (u8 *) &dwValue, dwBuffSize);
+		status =
+		    reg_set_value(MGROBJECT, (u8 *) &dwValue, dw_buff_size);
 		break;
 	default:
 		break;
diff --git a/drivers/dsp/bridge/services/clk.c b/drivers/dsp/bridge/services/clk.c
index e2e0bfe..2df3d5d 100644
--- a/drivers/dsp/bridge/services/clk.c
+++ b/drivers/dsp/bridge/services/clk.c
@@ -35,7 +35,7 @@
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 
-typedef volatile unsigned long  REG_UWORD32;
+typedef volatile unsigned long reg_uword32;
 
 #define OMAP_SSI_OFFSET			0x58000
 #define OMAP_SSI_SIZE			0x1000
@@ -45,16 +45,16 @@ typedef volatile unsigned long  REG_UWORD32;
 #define SSI_SIDLE_SMARTIDLE		(2 << 3)
 #define SSI_MIDLE_NOIDLE		(1 << 12)
 
-struct SERVICES_Clk_t {
+struct services_clk_t {
 	struct clk *clk_handle;
 	const char *clk_name;
 	const char *dev;
 };
 
 /* The row order of the below array needs to match with the clock enumerations
- * 'SERVICES_ClkId' provided in the header file.. any changes in the
+ * 'services_clk_id' provided in the header file.. any changes in the
  * enumerations needs to be fixed in the array as well */
-static struct SERVICES_Clk_t SERVICES_Clks[] = {
+static struct services_clk_t services_clks[] = {
 	{NULL, "iva2_ck", NULL},
 	{NULL, "gpt5_fck", NULL},
 	{NULL, "gpt5_ick", NULL},
@@ -84,36 +84,36 @@ static struct SERVICES_Clk_t SERVICES_Clks[] = {
 };
 
 /* Generic TIMER object: */
-struct TIMER_OBJECT {
+struct timer_object {
 	struct timer_list timer;
 };
 
 /*
- *  ======== CLK_Exit ========
+ *  ======== clk_exit ========
  *  Purpose:
  *      Cleanup CLK module.
  */
-void CLK_Exit(void)
+void clk_exit(void)
 {
 	int i = 0;
 
 	/* Relinquish the clock handles */
 	while (i < SERVICESCLK_NOT_DEFINED) {
-		if (SERVICES_Clks[i].clk_handle)
-			clk_put(SERVICES_Clks[i].clk_handle);
+		if (services_clks[i].clk_handle)
+			clk_put(services_clks[i].clk_handle);
 
-		SERVICES_Clks[i].clk_handle = NULL;
+		services_clks[i].clk_handle = NULL;
 		i++;
 	}
 
 }
 
 /*
- *  ======== CLK_Init ========
+ *  ======== services_clk_init ========
  *  Purpose:
  *      Initialize CLK module.
  */
-bool CLK_Init(void)
+bool services_clk_init(void)
 {
 	static struct platform_device dspbridge_device;
 	struct clk *clk_handle;
@@ -124,16 +124,16 @@ bool CLK_Init(void)
 	/* Get the clock handles from base port and store locally */
 	while (i < SERVICESCLK_NOT_DEFINED) {
 		/* get the handle from BP */
-		clk_handle = clk_get_sys(SERVICES_Clks[i].dev,
-			     SERVICES_Clks[i].clk_name);
+		clk_handle = clk_get_sys(services_clks[i].dev,
+					 services_clks[i].clk_name);
 
 		if (!clk_handle) {
 			pr_err("%s: failed to get clk handle %s, dev id = %s\n",
-				  __func__, SERVICES_Clks[i].clk_name,
-				  SERVICES_Clks[i].dev);
+			       __func__, services_clks[i].clk_name,
+			       services_clks[i].dev);
 			/* should we fail here?? */
 		}
-		SERVICES_Clks[i].clk_handle = clk_handle;
+		services_clks[i].clk_handle = clk_handle;
 		i++;
 	}
 
@@ -141,31 +141,30 @@ bool CLK_Init(void)
 }
 
 /*
- *  ======== CLK_Enable ========
+ *  ======== services_clk_enable ========
  *  Purpose:
  *      Enable Clock .
  *
-*/
-DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id)
+ */
+dsp_status services_clk_enable(IN enum services_clk_id clk_id)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
-
-	pClk = SERVICES_Clks[clk_id].clk_handle;
-	if (pClk) {
-		if (clk_enable(pClk)) {
-			pr_err("CLK_Enable: failed to Enable CLK %s, "
-					"CLK dev id = %s\n",
-					SERVICES_Clks[clk_id].clk_name,
-					SERVICES_Clks[clk_id].dev);
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
+
+	clk_handle = services_clks[clk_id].clk_handle;
+	if (clk_handle) {
+		if (clk_enable(clk_handle)) {
+			pr_err("services_clk_enable: failed to Enable CLK %s, "
+			       "CLK dev id = %s\n",
+			       services_clks[clk_id].clk_name,
+			       services_clks[clk_id].dev);
 			status = DSP_EFAIL;
 		}
 	} else {
-		pr_err("CLK_Enable: failed to get CLK %s, CLK dev id = %s\n",
-					SERVICES_Clks[clk_id].clk_name,
-					SERVICES_Clks[clk_id].dev);
+		pr_err("%s: failed to get CLK %s, CLK dev id = %s\n", __func__,
+		     services_clks[clk_id].clk_name, services_clks[clk_id].dev);
 		status = DSP_EFAIL;
 	}
 	/* The SSI module need to configured not to have the Forced idle for
@@ -173,32 +172,33 @@ DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id)
 	 * transitioning to standby thereby causing the client in the DSP hang
 	 * waiting for the SSI module to be active after enabling the clocks
 	 */
-	if (clk_id == SERVICESCLK_ssi_fck)
-		SSI_Clk_Prepare(true);
+	if (clk_id == SERVICESCLK_SSI_FCK)
+		ssi_clk_prepare(true);
 
 	return status;
 }
+
 /*
- *  ======== CLK_Set_32KHz ========
+ *  ======== clk_set32k_hz ========
  *  Purpose:
  *      To Set parent of a clock to 32KHz.
  */
 
-DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id)
+dsp_status clk_set32k_hz(IN enum services_clk_id clk_id)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-	struct clk *pClkParent;
-	pClkParent =  SERVICES_Clks[SERVICESCLK_sys_32k_ck].clk_handle;
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+	struct clk *clk_parent;
+	clk_parent = services_clks[SERVICESCLK_SYS32K_CK].clk_handle;
 
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
 
-	pClk = SERVICES_Clks[clk_id].clk_handle;
-	if (pClk) {
-		if (!(clk_set_parent(pClk, pClkParent) == 0x0)) {
+	clk_handle = services_clks[clk_id].clk_handle;
+	if (clk_handle) {
+		if (!(clk_set_parent(clk_handle, clk_parent) == 0x0)) {
 			pr_err("%s: failed for %s, dev id = %s\n", __func__,
-				SERVICES_Clks[clk_id].clk_name,
-				SERVICES_Clks[clk_id].dev);
+			       services_clks[clk_id].clk_name,
+			       services_clks[clk_id].dev);
 			status = DSP_EFAIL;
 		}
 	}
@@ -206,98 +206,97 @@ DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id)
 }
 
 /*
- *  ======== CLK_Disable ========
+ *  ======== services_clk_disable ========
  *  Purpose:
  *      Disable the clock.
  *
-*/
-DSP_STATUS CLK_Disable(IN enum SERVICES_ClkId clk_id)
+ */
+dsp_status services_clk_disable(IN enum services_clk_id clk_id)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-	s32 clkUseCnt;
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+	s32 clk_use_cnt;
 
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
 
-	pClk = SERVICES_Clks[clk_id].clk_handle;
+	clk_handle = services_clks[clk_id].clk_handle;
 
-	clkUseCnt = CLK_Get_UseCnt(clk_id);
-	if (clkUseCnt == -1) {
-		pr_err("CLK_Disable: failed to get CLK Use count for CLK %s,"
-				"CLK dev id = %s\n",
-				SERVICES_Clks[clk_id].clk_name,
-				SERVICES_Clks[clk_id].dev);
-	} else if (clkUseCnt == 0) {
+	clk_use_cnt = clk_get_use_cnt(clk_id);
+	if (clk_use_cnt == -1) {
+		pr_err("%s: failed to get CLK Use count for CLK %s, CLK dev id"
+		       " = %s\n", __func__, services_clks[clk_id].clk_name,
+		       services_clks[clk_id].dev);
+	} else if (clk_use_cnt == 0) {
 		return status;
 	}
-	if (clk_id == SERVICESCLK_ssi_ick)
-		SSI_Clk_Prepare(false);
-
-		if (pClk) {
-			clk_disable(pClk);
-		} else {
-			pr_err("CLK_Disable: failed to get CLK %s,"
-					"CLK dev id = %s\n",
-					SERVICES_Clks[clk_id].clk_name,
-					SERVICES_Clks[clk_id].dev);
-			status = DSP_EFAIL;
-		}
+	if (clk_id == SERVICESCLK_SSI_ICK)
+		ssi_clk_prepare(false);
+
+	if (clk_handle) {
+		clk_disable(clk_handle);
+	} else {
+		pr_err("services_clk_disable: failed to get CLK %s,"
+		       "CLK dev id = %s\n",
+		       services_clks[clk_id].clk_name,
+		       services_clks[clk_id].dev);
+		status = DSP_EFAIL;
+	}
 	return status;
 }
 
 /*
- *  ======== CLK_GetRate ========
+ *  ======== services_clk_get_rate ========
  *  Purpose:
  *      GetClock Speed.
  *
  */
 
-DSP_STATUS CLK_GetRate(IN enum SERVICES_ClkId clk_id, u32 *speedKhz)
+dsp_status services_clk_get_rate(IN enum services_clk_id clk_id, u32 *speedKhz)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-	u32 clkSpeedHz;
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+	u32 clk_speed_hz;
 
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
 	*speedKhz = 0x0;
 
-	pClk = SERVICES_Clks[clk_id].clk_handle;
-	if (pClk) {
-		clkSpeedHz = clk_get_rate(pClk);
-		*speedKhz = clkSpeedHz / 1000;
-		dev_dbg(bridge, "%s: clkSpeedHz = %d, speedinKhz = %d\n",
-					__func__, clkSpeedHz, *speedKhz);
+	clk_handle = services_clks[clk_id].clk_handle;
+	if (clk_handle) {
+		clk_speed_hz = clk_get_rate(clk_handle);
+		*speedKhz = clk_speed_hz / 1000;
+		dev_dbg(bridge, "%s: clk_speed_hz = %d, speedinKhz = %d\n",
+			__func__, clk_speed_hz, *speedKhz);
 	} else {
 		pr_err("%s: failed to get %s, dev Id = %s\n", __func__,
-						SERVICES_Clks[clk_id].clk_name,
-						SERVICES_Clks[clk_id].dev);
+		       services_clks[clk_id].clk_name,
+		       services_clks[clk_id].dev);
 		status = DSP_EFAIL;
 	}
 	return status;
 }
 
-s32 CLK_Get_UseCnt(IN enum SERVICES_ClkId clk_id)
+s32 clk_get_use_cnt(IN enum services_clk_id clk_id)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-	s32 useCount = -1;
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+	s32 use_count = -1;
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
 
-	pClk = SERVICES_Clks[clk_id].clk_handle;
+	clk_handle = services_clks[clk_id].clk_handle;
 
-	if (pClk) {
+	if (clk_handle) {
 		/* FIXME: usecount shouldn't be used */
-		useCount = pClk->usecount;
+		use_count = clk_handle->usecount;
 	} else {
 		pr_err("%s: failed to get %s, dev Id = %s\n", __func__,
-						SERVICES_Clks[clk_id].clk_name,
-						SERVICES_Clks[clk_id].dev);
+		       services_clks[clk_id].clk_name,
+		       services_clks[clk_id].dev);
 		status = DSP_EFAIL;
 	}
-	return useCount;
+	return use_count;
 }
 
-void SSI_Clk_Prepare(bool FLAG)
+void ssi_clk_prepare(bool FLAG)
 {
 	void __iomem *ssi_base;
 	unsigned int value;
diff --git a/drivers/dsp/bridge/services/mem.c b/drivers/dsp/bridge/services/mem.c
index c752080..2dc8429 100644
--- a/drivers/dsp/bridge/services/mem.c
+++ b/drivers/dsp/bridge/services/mem.c
@@ -32,81 +32,84 @@
 #include <dspbridge/list.h>
 
 /*  ----------------------------------- Defines */
-#define MEM_512MB   0x1fffffff
+#define MEM512MB   0x1fffffff
 
 /*  ----------------------------------- Globals */
-static bool extPhysMemPoolEnabled;
+static bool ext_phys_mem_pool_enabled;
 
-struct extPhysMemPool {
-	u32 physMemBase;
-	u32 physMemSize;
-	u32 virtMemBase;
-	u32 nextPhysAllocPtr;
+struct ext_phys_mem_pool {
+	u32 phys_mem_base;
+	u32 phys_mem_size;
+	u32 virt_mem_base;
+	u32 next_phys_alloc_ptr;
 };
 
-static struct extPhysMemPool extMemPool;
+static struct ext_phys_mem_pool ext_mem_pool;
 
-void MEM_ExtPhysPoolInit(u32 poolPhysBase, u32 poolSize)
+void mem_ext_phys_pool_init(u32 poolPhysBase, u32 poolSize)
 {
-	u32 poolVirtBase;
+	u32 pool_virt_base;
 
 	/* get the virtual address for the physical memory pool passed */
-	poolVirtBase = (u32)ioremap(poolPhysBase, poolSize);
+	pool_virt_base = (u32) ioremap(poolPhysBase, poolSize);
 
-	if ((void **)poolVirtBase == NULL) {
+	if ((void **)pool_virt_base == NULL) {
 		pr_err("%s: external physical memory map failed\n", __func__);
-		extPhysMemPoolEnabled = false;
+		ext_phys_mem_pool_enabled = false;
 	} else {
-		extMemPool.physMemBase = poolPhysBase;
-		extMemPool.physMemSize = poolSize;
-		extMemPool.virtMemBase = poolVirtBase;
-		extMemPool.nextPhysAllocPtr = poolPhysBase;
-		extPhysMemPoolEnabled = true;
+		ext_mem_pool.phys_mem_base = poolPhysBase;
+		ext_mem_pool.phys_mem_size = poolSize;
+		ext_mem_pool.virt_mem_base = pool_virt_base;
+		ext_mem_pool.next_phys_alloc_ptr = poolPhysBase;
+		ext_phys_mem_pool_enabled = true;
 	}
 }
 
-void MEM_ExtPhysPoolRelease(void)
+void mem_ext_phys_pool_release(void)
 {
-	if (extPhysMemPoolEnabled) {
-		iounmap((void *)(extMemPool.virtMemBase));
-		extPhysMemPoolEnabled = false;
+	if (ext_phys_mem_pool_enabled) {
+		iounmap((void *)(ext_mem_pool.virt_mem_base));
+		ext_phys_mem_pool_enabled = false;
 	}
 }
 
 /*
- *  ======== MEM_ExtPhysMemAlloc ========
+ *  ======== mem_ext_phys_mem_alloc ========
  *  Purpose:
  *     Allocate physically contiguous, uncached memory from external memory pool
  */
 
-static void *MEM_ExtPhysMemAlloc(u32 bytes, u32 align, OUT u32 *pPhysAddr)
+static void *mem_ext_phys_mem_alloc(u32 bytes, u32 align, OUT u32 * pPhysAddr)
 {
-	u32 newAllocPtr;
+	u32 new_alloc_ptr;
 	u32 offset;
-	u32 virtAddr;
+	u32 virt_addr;
 
 	if (align == 0)
 		align = 1;
 
-	if (bytes > ((extMemPool.physMemBase + extMemPool.physMemSize)
-	    - extMemPool.nextPhysAllocPtr)) {
+	if (bytes > ((ext_mem_pool.phys_mem_base + ext_mem_pool.phys_mem_size)
+		     - ext_mem_pool.next_phys_alloc_ptr)) {
 		pPhysAddr = NULL;
 		return NULL;
 	} else {
-		offset = (extMemPool.nextPhysAllocPtr & (align - 1));
+		offset = (ext_mem_pool.next_phys_alloc_ptr & (align - 1));
 		if (offset == 0)
-			newAllocPtr = extMemPool.nextPhysAllocPtr;
+			new_alloc_ptr = ext_mem_pool.next_phys_alloc_ptr;
 		else
-			newAllocPtr = (extMemPool.nextPhysAllocPtr) +
-				      (align - offset);
-		if ((newAllocPtr + bytes) <=
-		    (extMemPool.physMemBase + extMemPool.physMemSize)) {
+			new_alloc_ptr = (ext_mem_pool.next_phys_alloc_ptr) +
+			    (align - offset);
+		if ((new_alloc_ptr + bytes) <=
+		    (ext_mem_pool.phys_mem_base + ext_mem_pool.phys_mem_size)) {
 			/* we can allocate */
-			*pPhysAddr = newAllocPtr;
-			extMemPool.nextPhysAllocPtr = newAllocPtr + bytes;
-			virtAddr = extMemPool.virtMemBase + (newAllocPtr -
-				   extMemPool.physMemBase);
-			return (void *)virtAddr;
+			*pPhysAddr = new_alloc_ptr;
+			ext_mem_pool.next_phys_alloc_ptr =
+			    new_alloc_ptr + bytes;
+			virt_addr =
+			    ext_mem_pool.virt_mem_base + (new_alloc_ptr -
+							  ext_mem_pool.
+							  phys_mem_base);
+			return (void *)virt_addr;
 		} else {
 			*pPhysAddr = 0;
 			return NULL;
@@ -115,24 +118,24 @@ static void *MEM_ExtPhysMemAlloc(u32 bytes, u32 align, OUT u32 *pPhysAddr)
 }
 
 /*
- *  ======== MEM_Alloc ========
+ *  ======== mem_alloc ========
  *  Purpose:
  *      Allocate memory from the paged or non-paged pools.
  */
-void *MEM_Alloc(u32 cBytes, enum MEM_POOLATTRS type)
+void *mem_alloc(u32 byte_size, enum mem_poolattrs type)
 {
-	void *pMem = NULL;
+	void *mem = NULL;
 
-	if (cBytes > 0) {
+	if (byte_size > 0) {
 		switch (type) {
 		case MEM_NONPAGED:
-		/* If non-paged memory required, see note at top of file. */
+			/* Fall through */
 		case MEM_PAGED:
-			pMem = kmalloc(cBytes,
-				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+			mem = kmalloc(byte_size,
+				      (in_atomic())? GFP_ATOMIC : GFP_KERNEL);
 			break;
 		case MEM_LARGEVIRTMEM:
-			pMem = vmalloc(cBytes);
+			mem = vmalloc(byte_size);
 			break;
 
 		default:
@@ -140,104 +143,105 @@ void *MEM_Alloc(u32 cBytes, enum MEM_POOLATTRS type)
 		}
 	}
 
-	return pMem;
+	return mem;
 }
 
 /*
- *  ======== MEM_AllocPhysMem ========
+ *  ======== mem_alloc_phys_mem ========
  *  Purpose:
  *      Allocate physically contiguous, uncached memory
  */
-void *MEM_AllocPhysMem(u32 cBytes, u32 ulAlign, OUT u32 *pPhysicalAddress)
+void *mem_alloc_phys_mem(u32 byte_size, u32 ulAlign, OUT u32 * pPhysicalAddress)
 {
-	void *pVaMem = NULL;
-	dma_addr_t paMem;
+	void *va_mem = NULL;
+	dma_addr_t pa_mem;
 
-	if (cBytes > 0) {
-		if (extPhysMemPoolEnabled) {
-			pVaMem = MEM_ExtPhysMemAlloc(cBytes, ulAlign,
-						    (u32 *)&paMem);
+	if (byte_size > 0) {
+		if (ext_phys_mem_pool_enabled) {
+			va_mem = mem_ext_phys_mem_alloc(byte_size, ulAlign,
+							(u32 *) &pa_mem);
 		} else
-			pVaMem = dma_alloc_coherent(NULL, cBytes, &paMem,
-				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
-		if (pVaMem == NULL) {
+			va_mem = dma_alloc_coherent(NULL, byte_size, &pa_mem,
+						    (in_atomic())? GFP_ATOMIC :
+						    GFP_KERNEL);
+		if (va_mem == NULL) {
 			*pPhysicalAddress = 0;
 		} else {
-			*pPhysicalAddress = paMem;
+			*pPhysicalAddress = pa_mem;
 		}
 	}
-	return pVaMem;
+	return va_mem;
 }
 
 /*
- *  ======== MEM_Calloc ========
+ *  ======== mem_calloc ========
  *  Purpose:
  *      Allocate zero-initialized memory from the paged or non-paged pools.
  */
-void *MEM_Calloc(u32 cBytes, enum MEM_POOLATTRS type)
+void *mem_calloc(u32 byte_size, enum mem_poolattrs type)
 {
-	void *pMem = NULL;
+	void *mem = NULL;
 
-	if (cBytes > 0) {
+	if (byte_size > 0) {
 		switch (type) {
 		case MEM_NONPAGED:
-		/* If non-paged memory required, see note at top of file. */
+			/*  Fall through */
 		case MEM_PAGED:
-			pMem = kzalloc(cBytes,
-				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+			mem = kzalloc(byte_size,
+				      (in_atomic())? GFP_ATOMIC : GFP_KERNEL);
 			break;
 		case MEM_LARGEVIRTMEM:
-			pMem = __vmalloc(cBytes,
-				GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,
-				PAGE_KERNEL);
+			mem = __vmalloc(byte_size,
+					GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,
+					PAGE_KERNEL);
 			break;
 		default:
 			break;
 		}
 	}
 
-	return pMem;
+	return mem;
 }
 
 /*
- *  ======== MEM_Exit ========
+ *  ======== mem_exit ========
  *  Purpose:
  *      Discontinue usage of the MEM module.
  */
-void MEM_Exit(void)
+void mem_exit(void)
 {
 }
 
 /*
- *  ======== MEM_FlushCache ========
+ *  ======== mem_flush_cache ========
  *  Purpose:
  *      Flush cache
  */
-void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType)
+void mem_flush_cache(void *pMemBuf, u32 byte_size, u32 FlushType)
 {
 	if (!pMemBuf)
 		return;
 
 	switch (FlushType) {
-	/* invalidate only */
+		/* invalidate only */
 	case PROC_INVALIDATE_MEM:
-		dmac_inv_range(pMemBuf, pMemBuf + cBytes);
-		outer_inv_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
-				cBytes));
-	break;
-	/* writeback only */
+		dmac_inv_range(pMemBuf, pMemBuf + byte_size);
+		outer_inv_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							  byte_size));
+		break;
+		/* writeback only */
 	case PROC_WRITEBACK_MEM:
-		dmac_clean_range(pMemBuf, pMemBuf + cBytes);
-		outer_clean_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
-				  cBytes));
-	break;
-	/* writeback and invalidate */
+		dmac_clean_range(pMemBuf, pMemBuf + byte_size);
+		outer_clean_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							    byte_size));
+		break;
+		/* writeback and invalidate */
 	case PROC_WRITEBACK_INVALIDATE_MEM:
-		dmac_flush_range(pMemBuf, pMemBuf + cBytes);
-		outer_flush_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
-				  cBytes));
-	break;
-	/* Writeback and Invalidate all */
+		dmac_flush_range(pMemBuf, pMemBuf + byte_size);
+		outer_flush_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							    byte_size));
+		break;
+		/* Writeback and Invalidate all */
 	case PROC_WRBK_INV_ALL:
 		__cpuc_flush_kern_all();
 		break;
@@ -246,26 +250,26 @@ void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType)
 }
 
 /*
- *  ======== MEM_FreePhysMem ========
+ *  ======== mem_free_phys_mem ========
  *  Purpose:
  *      Free the given block of physically contiguous memory.
  */
-void MEM_FreePhysMem(void *pVirtualAddress, u32 pPhysicalAddress,
-		     u32 cBytes)
+void mem_free_phys_mem(void *pVirtualAddress, u32 pPhysicalAddress,
+		       u32 byte_size)
 {
-	DBC_Require(pVirtualAddress != NULL);
+	DBC_REQUIRE(pVirtualAddress != NULL);
 
-	if (!extPhysMemPoolEnabled)
-		dma_free_coherent(NULL, cBytes, pVirtualAddress,
-				 pPhysicalAddress);
+	if (!ext_phys_mem_pool_enabled)
+		dma_free_coherent(NULL, byte_size, pVirtualAddress,
+				  pPhysicalAddress);
 }
 
 /*
- *  ======== MEM_Init ========
+ *  ======== services_mem_init ========
  *  Purpose:
  *      Initialize MEM module private state.
  */
-bool MEM_Init(void)
+bool services_mem_init(void)
 {
 	return true;
 }
diff --git a/drivers/dsp/bridge/services/ntfy.c b/drivers/dsp/bridge/services/ntfy.c
index 4e73c5f..69615d0 100644
--- a/drivers/dsp/bridge/services/ntfy.c
+++ b/drivers/dsp/bridge/services/ntfy.c
@@ -16,281 +16,16 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/list.h>
-#include <dspbridge/mem.h>
-#include <dspbridge/sync.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/ntfy.h>
 
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
-#define NTFY_SIGNATURE      0x5946544e	/* "YFTN" */
-
-/*
- *  ======== NTFY_OBJECT ========
- */
-struct NTFY_OBJECT {
-	u32 dwSignature;	/* For object validation */
-	struct LST_LIST *notifyList;	/* List of NOTIFICATION objects */
-	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
-};
-
-/*
- *  ======== NOTIFICATION ========
- *  This object will be created when a client registers for events.
- */
-struct NOTIFICATION {
-	struct list_head listElem;
-	u32 uEventMask;	/* Events to be notified about */
-	u32 uNotifyType;	/* Type of notification to be sent */
-
-	/*
-	 *  We keep a copy of the event name to check if the event has
-	 *  already been registered. (SYNC also keeps a copy of the name).
-	 */
-	char *pstrName;		/* Name of event */
-	HANDLE hEvent;		/* Handle for notification */
-	struct SYNC_OBJECT *hSync;
-};
-
-/*  ----------------------------------- Function Prototypes */
-static void DeleteNotify(struct NOTIFICATION *pNotify);
-
-/*
- *  ======== NTFY_Create ========
- *  Purpose:
- *      Create an empty list of notifications.
- */
-DSP_STATUS NTFY_Create(struct NTFY_OBJECT **phNtfy)
-{
-	struct NTFY_OBJECT *pNtfy;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(phNtfy != NULL);
-
-	*phNtfy = NULL;
-	MEM_AllocObject(pNtfy, struct NTFY_OBJECT, NTFY_SIGNATURE);
-
-	if (pNtfy) {
-
-		status = SYNC_InitializeDPCCS(&pNtfy->hSync);
-		if (DSP_SUCCEEDED(status)) {
-			pNtfy->notifyList = MEM_Calloc(sizeof(struct LST_LIST),
-							MEM_NONPAGED);
-			if (pNtfy->notifyList == NULL) {
-				(void) SYNC_DeleteCS(pNtfy->hSync);
-				MEM_FreeObject(pNtfy);
-				status = DSP_EMEMORY;
-			} else {
-				INIT_LIST_HEAD(&pNtfy->notifyList->head);
-				*phNtfy = pNtfy;
-			}
-		}
-	} else {
-		status = DSP_EMEMORY;
-	}
-
-	DBC_Ensure((DSP_FAILED(status) && *phNtfy == NULL) ||
-		  (DSP_SUCCEEDED(status) && MEM_IsValidHandle((*phNtfy),
-		  NTFY_SIGNATURE)));
-
-	return status;
-}
-
-/*
- *  ======== NTFY_Delete ========
- *  Purpose:
- *      Free resources allocated in NTFY_Create.
- */
-void NTFY_Delete(struct NTFY_OBJECT *hNtfy)
-{
-	struct NOTIFICATION *pNotify;
-
-	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
-
-	/* Remove any elements remaining in list */
-	if (hNtfy->notifyList) {
-		while ((pNotify = (struct NOTIFICATION *)LST_GetHead(hNtfy->
-								notifyList))) {
-			DeleteNotify(pNotify);
-		}
-		DBC_Assert(LST_IsEmpty(hNtfy->notifyList));
-		kfree(hNtfy->notifyList);
-	}
-	if (hNtfy->hSync)
-		(void)SYNC_DeleteCS(hNtfy->hSync);
-
-	MEM_FreeObject(hNtfy);
-}
-
-/*
- *  ======== NTFY_Exit ========
- *  Purpose:
- *      Discontinue usage of NTFY module.
- */
-void NTFY_Exit(void)
-{
-	/* Do nothing */
-}
-
-/*
- *  ======== NTFY_Init ========
- *  Purpose:
- *      Initialize the NTFY module.
- */
-bool NTFY_Init(void)
-{
-	return true;
-}
-
-/*
- *  ======== NTFY_Notify ========
- *  Purpose:
- *      Execute notify function (signal event) for every
- *      element in the notification list that is to be notified about the
- *      event specified in uEventMask.
- */
-void NTFY_Notify(struct NTFY_OBJECT *hNtfy, u32 uEventMask)
-{
-	struct NOTIFICATION *pNotify;
-
-	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
-
-	/*
-	 *  Go through notifyList and notify all clients registered for
-	 *  uEventMask events.
-	 */
-
-	(void) SYNC_EnterCS(hNtfy->hSync);
-
-	pNotify = (struct NOTIFICATION *)LST_First(hNtfy->notifyList);
-	while (pNotify != NULL) {
-		if (pNotify->uEventMask & uEventMask) {
-			/* Notify */
-			if (pNotify->uNotifyType == DSP_SIGNALEVENT)
-				(void)SYNC_SetEvent(pNotify->hSync);
-
-		}
-		pNotify = (struct NOTIFICATION *)LST_Next(hNtfy->notifyList,
-			  (struct list_head *)pNotify);
-	}
-
-	(void) SYNC_LeaveCS(hNtfy->hSync);
-}
-
-/*
- *  ======== NTFY_Register ========
- *  Purpose:
- *      Add a notification element to the list. If the notification is already
- *      registered, and uEventMask != 0, the notification will get posted for
- *      events specified in the new event mask. If the notification is already
- *      registered and uEventMask == 0, the notification will be unregistered.
- */
-DSP_STATUS NTFY_Register(struct NTFY_OBJECT *hNtfy,
-			 struct DSP_NOTIFICATION *hNotification,
-			 u32 uEventMask, u32 uNotifyType)
-{
-	struct NOTIFICATION *pNotify;
-	struct SYNC_ATTRS syncAttrs;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
-
-	if (hNotification == NULL)
-		status = DSP_EHANDLE;
-
-	/* Return DSP_ENOTIMPL if uNotifyType is not supported */
-	if (DSP_SUCCEEDED(status)) {
-		if (!IsValidNotifyMask(uNotifyType))
-			status = DSP_ENOTIMPL;
-
-	}
-
-	if (DSP_FAILED(status))
-		return status;
-
-	(void)SYNC_EnterCS(hNtfy->hSync);
-
-	pNotify = (struct NOTIFICATION *)LST_First(hNtfy->notifyList);
-	while (pNotify != NULL) {
-		/* If there is more than one notification type, each
-		 * type may require its own handler code.  */
-
-		if (hNotification->handle == pNotify->hSync) {
-			/* found */
-			break;
-		}
-		pNotify = (struct NOTIFICATION *)LST_Next(hNtfy->notifyList,
-			  (struct list_head *)pNotify);
-	}
-	if (pNotify == NULL) {
-		/* Not registered */
-		if (uEventMask == 0) {
-			status = DSP_EVALUE;
-		} else {
-			/* Allocate NOTIFICATION object, add to list */
-			pNotify = MEM_Calloc(sizeof(struct NOTIFICATION),
-					     MEM_PAGED);
-			if (pNotify == NULL)
-				status = DSP_EMEMORY;
-
-		}
-		if (DSP_SUCCEEDED(status)) {
-			LST_InitElem((struct list_head *)pNotify);
-			 /* If there is more than one notification type, each
-			 * type may require its own handler code. */
-			status = SYNC_OpenEvent(&pNotify->hSync, &syncAttrs);
-			hNotification->handle = pNotify->hSync;
-
-			if (DSP_SUCCEEDED(status)) {
-				pNotify->uEventMask = uEventMask;
-				pNotify->uNotifyType = uNotifyType;
-				LST_PutTail(hNtfy->notifyList,
-					   (struct list_head *)pNotify);
-			} else {
-				DeleteNotify(pNotify);
-			}
-		}
-	} else {
-		/* Found in list */
-		if (uEventMask == 0) {
-			/* Remove from list and free */
-			LST_RemoveElem(hNtfy->notifyList,
-				      (struct list_head *)pNotify);
-			DeleteNotify(pNotify);
-		} else {
-			/* Update notification mask (type shouldn't change) */
-			pNotify->uEventMask = uEventMask;
-		}
-	}
-	(void)SYNC_LeaveCS(hNtfy->hSync);
-	return status;
-}
-
-/*
- *  ======== DeleteNotify ========
- *  Purpose:
- *      Free the notification object.
- */
-static void DeleteNotify(struct NOTIFICATION *pNotify)
+int dsp_notifier_event(struct notifier_block *this, unsigned long event,
+			   void *data)
 {
-	if (pNotify->hSync)
-		(void) SYNC_CloseEvent(pNotify->hSync);
-
-	kfree(pNotify->pstrName);
-
-	kfree(pNotify);
+	struct ntfy_event *ne = container_of(this, struct ntfy_event,
+							noti_block);
+	if (ne->event & event)
+		sync_set_event(&ne->sync_obj);
+	return NOTIFY_OK;
 }
 
diff --git a/drivers/dsp/bridge/services/reg.c b/drivers/dsp/bridge/services/reg.c
index 2187aed..e7f15cf 100644
--- a/drivers/dsp/bridge/services/reg.c
+++ b/drivers/dsp/bridge/services/reg.c
@@ -35,69 +35,69 @@
 #include <regsup.h>
 
 /*
- *  ======== REG_DeleteValue ========
+ *  ======== reg_delete_value ========
  *  Deletes a registry entry value.  NOTE:  A registry entry value is not the
  *  same as *  a registry key.
  */
-DSP_STATUS REG_DeleteValue(IN CONST char *pstrValue)
+dsp_status reg_delete_value(IN CONST char *pstrValue)
 {
-	DSP_STATUS status;
-	DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+	dsp_status status;
+	DBC_REQUIRE(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
 
-	status = regsupDeleteValue(pstrValue);
+	status = regsup_delete_value(pstrValue);
 
 	return status;
 }
 
 /*
- *  ======== REG_EnumValue ========
+ *  ======== reg_enum_value ========
  *  Enumerates a registry key and retrieve values stored under the key.
  *  We will assume the input pdwValueSize is smaller than
  *  REG_MAXREGPATHLENGTH for implementation purposes.
  */
-DSP_STATUS REG_EnumValue(IN u32 dwIndex,
-			 IN CONST char *pstrKey, IN OUT char *pstrValue,
-			 IN OUT u32 *pdwValueSize, IN OUT char *pstrData,
-			 IN OUT u32 *pdwDataSize)
+dsp_status reg_enum_value(IN u32 dw_index,
+			  IN CONST char *pstrKey, IN OUT char *pstrValue,
+			  IN OUT u32 *pdwValueSize, IN OUT char *pstrData,
+			  IN OUT u32 *pdwDataSize)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	DBC_Require(pstrKey && pstrValue && pdwValueSize && pstrData &&
+	DBC_REQUIRE(pstrKey && pstrValue && pdwValueSize && pstrData &&
 		    pdwDataSize);
-	DBC_Require(*pdwValueSize <= REG_MAXREGPATHLENGTH);
-       DBC_Require(strlen(pstrKey) < REG_MAXREGPATHLENGTH);
+	DBC_REQUIRE(*pdwValueSize <= REG_MAXREGPATHLENGTH);
+	DBC_REQUIRE(strlen(pstrKey) < REG_MAXREGPATHLENGTH);
 
-	status = regsupEnumValue(dwIndex, pstrKey, pstrValue, pdwValueSize,
-				 pstrData, pdwDataSize);
+	status = regsup_enum_value(dw_index, pstrKey, pstrValue, pdwValueSize,
+				   pstrData, pdwDataSize);
 
 	return status;
 }
 
 /*
- *  ======== REG_Exit ========
+ *  ======== reg_exit ========
  *  Discontinue usage of the REG module.
  */
-void REG_Exit(void)
+void reg_exit(void)
 {
-	regsupExit();
+	regsup_exit();
 }
 
 /*
- *  ======== REG_GetValue ========
+ *  ======== reg_get_value ========
  *  Retrieve a value from the registry.
  */
-DSP_STATUS REG_GetValue(IN CONST char *pstrValue, OUT u8 *pbData,
-			IN OUT u32 *pdwDataSize)
+dsp_status reg_get_value(IN CONST char *pstrValue, OUT u8 * pbData,
+			 IN OUT u32 *pdwDataSize)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	DBC_Require(pstrValue && pbData);
-       DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+	DBC_REQUIRE(pstrValue && pbData);
+	DBC_REQUIRE(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
 
-	/*  We need to use regsup calls...  */
-	/*  ...for now we don't need the key handle or  */
-	/*  the subkey, all we need is the value to lookup.  */
-	if (regsupGetValue((char *)pstrValue, pbData, pdwDataSize) == DSP_SOK)
+	/*  We need to use regsup calls... */
+	/*  ...for now we don't need the key handle or */
+	/*  the subkey, all we need is the value to lookup. */
+	if (regsup_get_value((char *)pstrValue, pbData, pdwDataSize) == DSP_SOK)
 		status = DSP_SOK;
 	else
 		status = DSP_EFAIL;
@@ -106,38 +106,37 @@ DSP_STATUS REG_GetValue(IN CONST char *pstrValue, OUT u8 *pbData,
 }
 
 /*
- *  ======== REG_Init ========
+ *  ======== reg_init ========
  *  Initialize the REG module's private state.
  */
-bool REG_Init(void)
+bool reg_init(void)
 {
-	bool fInit;
+	bool ret;
 
-	fInit = regsupInit();
+	ret = regsup_init();
 
-	return fInit;
+	return ret;
 }
 
 /*
- *  ======== REG_SetValue ========
+ *  ======== reg_set_value ========
  *  Set a value in the registry.
  */
-DSP_STATUS REG_SetValue(IN CONST char *pstrValue, IN u8 *pbData,
-			IN u32 dwDataSize)
+dsp_status reg_set_value(IN CONST char *pstrValue, IN u8 * pbData,
+			 IN u32 dw_data_size)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	DBC_Require(pstrValue && pbData);
-	DBC_Require(dwDataSize > 0);
-	DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+	DBC_REQUIRE(pstrValue && pbData);
+	DBC_REQUIRE(dw_data_size > 0);
+	DBC_REQUIRE(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
 
 	/*
 	 * We need to use regsup calls
 	 * for now we don't need the key handle or
 	 * the subkey, all we need is the value to lookup.
 	 */
-	status = regsupSetValue((char *)pstrValue, pbData, dwDataSize);
+	status = regsup_set_value((char *)pstrValue, pbData, dw_data_size);
 
 	return status;
 }
-
diff --git a/drivers/dsp/bridge/services/regsup.c b/drivers/dsp/bridge/services/regsup.c
index 8df6fec..275d91c 100644
--- a/drivers/dsp/bridge/services/regsup.c
+++ b/drivers/dsp/bridge/services/regsup.c
@@ -34,191 +34,191 @@
 /*  ----------------------------------- This */
 #include <regsup.h>
 
-struct RegValue {
+struct reg_value {
 	struct list_head link;	/* Make it linked to a list */
-	char name[MAXREGPATHLENGTH];   /*  Name of a given value entry  */
-	u32 dataSize;		/*  Size of the data  */
-	void *pData;		/*  Pointer to the actual data  */
+	char name[MAXREGPATHLENGTH];	/*  Name of a given value entry */
+	u32 data_size;		/*  Size of the data */
+	void *pdata;		/*  Pointer to the actual data */
 };
 
-/*  Pointer to the registry support key  */
-static struct LST_LIST regKey, *pRegKey = &regKey;
+/*  Pointer to the registry support key */
+static struct lst_list reg_key, *reg_key_list = &reg_key;
 
 /*
- *  ======== regsupInit ========
+ *  ======== regsup_init ========
  *  Purpose:
  *      Initialize the Registry Support module's private state.
  */
-bool regsupInit(void)
+bool regsup_init(void)
 {
-	INIT_LIST_HEAD(&pRegKey->head);
+	INIT_LIST_HEAD(&reg_key_list->head);
 	return true;
 }
 
 /*
- *  ======== regsupExit ========
+ *  ======== regsup_exit ========
  *  Purpose:
  *      Release all registry support allocations.
  */
-void regsupExit(void)
+void regsup_exit(void)
 {
-	struct RegValue *rv;
-	/*  Now go through each entry and free all resources.  */
-	while (!LST_IsEmpty(pRegKey)) {
-		rv = (struct RegValue *) LST_GetHead(pRegKey);
+	struct reg_value *rv;
+	/*  Now go through each entry and free all resources. */
+	while (!LST_IS_EMPTY(reg_key_list)) {
+		rv = (struct reg_value *)lst_get_head(reg_key_list);
 
-		kfree(rv->pData);
+		kfree(rv->pdata);
 		kfree(rv);
 	}
 }
 
 /*
- *  ======== regsupGetValue ========
+ *  ======== regsup_get_value ========
  *  Purpose:
  *      Get the value of the entry having the given name.
  */
-DSP_STATUS regsupGetValue(char *valName, void *pBuf, u32 *dataSize)
+dsp_status regsup_get_value(char *valName, void *pbuf, u32 * data_size)
 {
-	DSP_STATUS retVal = DSP_EFAIL;
-	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
+	dsp_status ret = DSP_EFAIL;
+	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
-	/*  Need to search through the entries looking for the right one.  */
+	/*  Need to search through the entries looking for the right one. */
 	while (rv) {
-		/*  See if the name matches.  */
+		/*  See if the name matches. */
 		if (strncmp(rv->name, valName, MAXREGPATHLENGTH) == 0) {
-			/*  We have a match!  Copy out the data.  */
-			memcpy(pBuf, rv->pData, rv->dataSize);
+			/*  We have a match!  Copy out the data. */
+			memcpy(pbuf, rv->pdata, rv->data_size);
 
-			/*  Get the size for the caller.  */
-			*dataSize = rv->dataSize;
+			/*  Get the size for the caller. */
+			*data_size = rv->data_size;
 
-			/*  Set our status to good and exit.  */
-			retVal = DSP_SOK;
+			/*  Set our status to good and exit. */
+			ret = DSP_SOK;
 			break;
 		}
-		rv = (struct RegValue *) LST_Next(pRegKey,
-						(struct list_head *) rv);
+		rv = (struct reg_value *)lst_next(reg_key_list,
+						  (struct list_head *)rv);
 	}
 
-	dev_dbg(bridge, "REG: get %s, status = 0x%x\n", valName, retVal);
+	dev_dbg(bridge, "REG: get %s, status = 0x%x\n", valName, ret);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== regsupSetValue ========
+ *  ======== regsup_set_value ========
  *  Purpose:
  *      Sets the value of the entry having the given name.
  */
-DSP_STATUS regsupSetValue(char *valName, void *pBuf, u32 dataSize)
+dsp_status regsup_set_value(char *valName, void *pbuf, u32 data_size)
 {
-	DSP_STATUS retVal = DSP_EFAIL;
-	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
+	dsp_status ret = DSP_EFAIL;
+	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
-	/*  Need to search through the entries looking for the right one.  */
+	/*  Need to search through the entries looking for the right one. */
 	while (rv) {
-		/*  See if the name matches.  */
+		/*  See if the name matches. */
 		if (strncmp(rv->name, valName, MAXREGPATHLENGTH) == 0) {
-			/*  Make sure the new data size is the same.  */
-			if (dataSize != rv->dataSize) {
-				/*  The caller needs a different data size!  */
-				kfree(rv->pData);
-				rv->pData = MEM_Alloc(dataSize, MEM_NONPAGED);
-				if (rv->pData == NULL)
+			/*  Make sure the new data size is the same. */
+			if (data_size != rv->data_size) {
+				/*  The caller needs a different data size! */
+				kfree(rv->pdata);
+				rv->pdata = mem_alloc(data_size, MEM_NONPAGED);
+				if (rv->pdata == NULL)
 					break;
 			}
 
-			/*  We have a match!  Copy out the data.  */
-			memcpy(rv->pData, pBuf, dataSize);
+			/*  We have a match!  Copy out the data. */
+			memcpy(rv->pdata, pbuf, data_size);
 
 			/* Reset datasize - overwrite if new or same */
-			rv->dataSize = dataSize;
+			rv->data_size = data_size;
 
-			/*  Set our status to good and exit.  */
-			retVal = DSP_SOK;
+			/*  Set our status to good and exit. */
+			ret = DSP_SOK;
 			break;
 		}
-	       rv = (struct RegValue *) LST_Next(pRegKey,
-					(struct list_head *) rv);
+		rv = (struct reg_value *)lst_next(reg_key_list,
+						  (struct list_head *)rv);
 	}
 
-	/*  See if we found a match or if this is a new entry  */
+	/*  See if we found a match or if this is a new entry */
 	if (!rv) {
-		/*  No match, need to make a new entry  */
-		struct RegValue *new = MEM_Calloc(sizeof(struct RegValue),
-						MEM_NONPAGED);
+		/*  No match, need to make a new entry */
+		struct reg_value *new = mem_calloc(sizeof(struct reg_value),
+						   MEM_NONPAGED);
 
 		strncat(new->name, valName, MAXREGPATHLENGTH - 1);
-		new->pData = MEM_Alloc(dataSize, MEM_NONPAGED);
-		if (new->pData != NULL) {
-			memcpy(new->pData, pBuf, dataSize);
-			new->dataSize = dataSize;
-			LST_PutTail(pRegKey, (struct list_head *) new);
-			retVal = DSP_SOK;
+		new->pdata = mem_alloc(data_size, MEM_NONPAGED);
+		if (new->pdata != NULL) {
+			memcpy(new->pdata, pbuf, data_size);
+			new->data_size = data_size;
+			lst_put_tail(reg_key_list, (struct list_head *)new);
+			ret = DSP_SOK;
 		}
 	}
 
-	dev_dbg(bridge, "REG: set %s, status = 0x%x", valName, retVal);
+	dev_dbg(bridge, "REG: set %s, status = 0x%x", valName, ret);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== regsupEnumValue ========
+ *  ======== regsup_enum_value ========
  *  Purpose:
  *      Returns registry "values" and their "data" under a (sub)key.
  */
-DSP_STATUS regsupEnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
-			   IN OUT char *pstrValue, IN OUT u32 *pdwValueSize,
-			   IN OUT char *pstrData, IN OUT u32 *pdwDataSize)
+dsp_status regsup_enum_value(IN u32 dw_index, IN CONST char *pstrKey,
+			     IN OUT char *pstrValue, IN OUT u32 * pdwValueSize,
+			     IN OUT char *pstrData, IN OUT u32 * pdwDataSize)
 {
-	DSP_STATUS retVal = REG_E_INVALIDSUBKEY;
-	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
-       u32 dwKeyLen;
+	dsp_status ret = REG_E_INVALIDSUBKEY;
+	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
+	u32 dw_key_len;
 	u32 count = 0;
 
-       DBC_Require(pstrKey);
-       dwKeyLen = strlen(pstrKey);
+	DBC_REQUIRE(pstrKey);
+	dw_key_len = strlen(pstrKey);
 
-	/*  Need to search through the entries looking for the right one.  */
+	/*  Need to search through the entries looking for the right one. */
 	while (rv) {
-		/*  See if the name matches.  */
-		if (strncmp(rv->name, pstrKey, dwKeyLen) == 0 &&
-			count++ == dwIndex) {
-			/*  We have a match!  Copy out the data.  */
-			memcpy(pstrData, rv->pData, rv->dataSize);
-			/*  Get the size for the caller.  */
-			*pdwDataSize = rv->dataSize;
-			*pdwValueSize = strlen(&(rv->name[dwKeyLen]));
-			strncpy(pstrValue, &(rv->name[dwKeyLen]),
-				    *pdwValueSize + 1);
-			/*  Set our status to good and exit.  */
-			retVal = DSP_SOK;
+		/*  See if the name matches. */
+		if (strncmp(rv->name, pstrKey, dw_key_len) == 0 &&
+		    count++ == dw_index) {
+			/*  We have a match!  Copy out the data. */
+			memcpy(pstrData, rv->pdata, rv->data_size);
+			/*  Get the size for the caller. */
+			*pdwDataSize = rv->data_size;
+			*pdwValueSize = strlen(&(rv->name[dw_key_len]));
+			strncpy(pstrValue, &(rv->name[dw_key_len]),
+				*pdwValueSize + 1);
+			/*  Set our status to good and exit. */
+			ret = DSP_SOK;
 			break;
 		}
-	       rv = (struct RegValue *) LST_Next(pRegKey,
-						(struct list_head *) rv);
+		rv = (struct reg_value *)lst_next(reg_key_list,
+						  (struct list_head *)rv);
 	}
 
-	if (count && DSP_FAILED(retVal))
-		retVal = REG_E_NOMOREITEMS;
+	if (count && DSP_FAILED(ret))
+		ret = REG_E_NOMOREITEMS;
 
 	dev_dbg(bridge, "REG: enum Key %s, Value %s, status = 0x%x",
-					pstrKey, pstrValue, retVal);
+		pstrKey, pstrValue, ret);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== regsupDeleteValue ========
+ *  ======== regsup_delete_value ========
  */
-DSP_STATUS regsupDeleteValue(IN CONST char *pstrValue)
+dsp_status regsup_delete_value(IN CONST char *pstrValue)
 {
-	DSP_STATUS retVal = DSP_EFAIL;
-	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
+	dsp_status ret = DSP_EFAIL;
+	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
 	while (rv) {
-		/*  See if the name matches.  */
+		/*  See if the name matches. */
 		if (strncmp(rv->name, pstrValue, MAXREGPATHLENGTH) == 0) {
 			/* We have a match!  Delete this key.  To delete a
 			 * key, we free all resources associated with this
@@ -226,21 +226,20 @@ DSP_STATUS regsupDeleteValue(IN CONST char *pstrValue)
 			 * the array, we copy that entry into this deleted
 			 * key.
 			 */
-			LST_RemoveElem(pRegKey, (struct list_head *)rv);
-			kfree(rv->pData);
+			lst_remove_elem(reg_key_list, (struct list_head *)rv);
+			kfree(rv->pdata);
 			kfree(rv);
 
-			/*  Set our status to good and exit...  */
-			retVal = DSP_SOK;
+			/*  Set our status to good and exit... */
+			ret = DSP_SOK;
 			break;
 		}
-		rv = (struct RegValue *)LST_Next(pRegKey,
-				(struct list_head *)rv);
+		rv = (struct reg_value *)lst_next(reg_key_list,
+						  (struct list_head *)rv);
 	}
 
-	dev_dbg(bridge, "REG: del %s, status = 0x%x", pstrValue, retVal);
+	dev_dbg(bridge, "REG: del %s, status = 0x%x", pstrValue, ret);
 
-	return retVal;
+	return ret;
 
 }
-
diff --git a/drivers/dsp/bridge/services/regsup.h b/drivers/dsp/bridge/services/regsup.h
index 7e09c51..3577c0b 100644
--- a/drivers/dsp/bridge/services/regsup.h
+++ b/drivers/dsp/bridge/services/regsup.h
@@ -17,31 +17,32 @@
 #ifndef _REGSUP_H_
 #define _REGSUP_H_
 
-/*  Init function. MUST be called BEFORE any calls are  */
-/*  made into this psuedo-registry!!!  Returns TRUE/FALSE for SUCCESS/ERROR  */
-extern bool regsupInit(void);
+/*  Init function. MUST be called BEFORE any calls are */
+/*  made into this psuedo-registry!!!  Returns TRUE/FALSE for SUCCESS/ERROR */
+extern bool regsup_init(void);
 
-/*  Release all registry support allocations.  */
-extern void regsupExit(void);
+/*  Release all registry support allocations. */
+extern void regsup_exit(void);
 
 /*
- *  ======== regsupDeleteValue ========
+ *  ======== regsup_delete_value ========
  */
-extern DSP_STATUS regsupDeleteValue(IN CONST char *pstrValue);
+extern dsp_status regsup_delete_value(IN CONST char *pstrValue);
 
-/*  Get the value of the entry having the given name.  Returns DSP_SOK  */
+/*  Get the value of the entry having the given name.  Returns DSP_SOK */
 /*  if an entry was found and the value retrieved.  Returns DSP_EFAIL
- *  otherwise.*/
-extern DSP_STATUS regsupGetValue(char *valName, void *pBuf, u32 *dataSize);
+ *  otherwise. */
+extern dsp_status regsup_get_value(char *valName, void *pbuf, u32 * data_size);
 
-/*  Sets the value of the entry having the given name.  Returns DSP_SOK  */
-/*  if an entry was found and the value set.  Returns DSP_EFAIL otherwise.  */
-extern DSP_STATUS regsupSetValue(char *valName, void *pBuf, u32 dataSize);
+/*  Sets the value of the entry having the given name.  Returns DSP_SOK */
+/*  if an entry was found and the value set.  Returns DSP_EFAIL otherwise. */
+extern dsp_status regsup_set_value(char *valName, void *pbuf, u32 data_size);
 
 /*  Returns registry "values" and their "data" under a (sub)key. */
-extern DSP_STATUS regsupEnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
-			IN OUT char *pstrValue, IN OUT u32 *pdwValueSize,
-			IN OUT char *pstrData, IN OUT u32 *pdwDataSize);
+extern dsp_status regsup_enum_value(IN u32 dw_index, IN CONST char *pstrKey,
+				    IN OUT char *pstrValue,
+				    IN OUT u32 *pdwValueSize,
+				    IN OUT char *pstrData,
+				    IN OUT u32 *pdwDataSize);
 
 #endif
-
diff --git a/drivers/dsp/bridge/services/services.c b/drivers/dsp/bridge/services/services.c
index dac0b39..df3de5f 100644
--- a/drivers/dsp/bridge/services/services.c
+++ b/drivers/dsp/bridge/services/services.c
@@ -37,64 +37,54 @@
 #include <dspbridge/services.h>
 
 /*
- *  ======== SERVICES_Exit ========
+ *  ======== services_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
  */
-void SERVICES_Exit(void)
+void services_exit(void)
 {
 	/* Uninitialize all SERVICES modules here */
-	NTFY_Exit();
-	SYNC_Exit();
-	CLK_Exit();
-	REG_Exit();
-	CFG_Exit();
-	MEM_Exit();
+	clk_exit();
+	reg_exit();
+	cfg_exit();
+	mem_exit();
 }
 
 /*
- *  ======== SERVICES_Init ========
+ *  ======== services_init ========
  *  Purpose:
  *      Initializes SERVICES modules.
  */
-bool SERVICES_Init(void)
+bool services_init(void)
 {
-	bool fInit = true;
-	bool fCFG, fMEM;
-	bool fREG, fSYNC, fCLK, fNTFY;
+	bool ret = true;
+	bool fcfg, fmem;
+	bool freg, fclk;
 
 	/* Perform required initialization of SERVICES modules. */
-	fMEM = MEM_Init();
-	fREG = REG_Init();
-	fCFG = CFG_Init();
-	fSYNC = SYNC_Init();
-	fCLK  = CLK_Init();
-	fNTFY = NTFY_Init();
+	fmem = services_mem_init();
+	freg = reg_init();
+	fcfg = cfg_init();
+	fclk = services_clk_init();
 
-	fInit = fCFG && fMEM && fREG && fSYNC && fCLK;
+	ret = fcfg && fmem && freg && fclk;
 
-	if (!fInit) {
-		if (fNTFY)
-			NTFY_Exit();
+	if (!ret) {
 
-		if (fSYNC)
-			SYNC_Exit();
+		if (fclk)
+			clk_exit();
 
-		if (fCLK)
-			CLK_Exit();
+		if (freg)
+			reg_exit();
 
-		if (fREG)
-			REG_Exit();
+		if (fcfg)
+			cfg_exit();
 
-		if (fCFG)
-			CFG_Exit();
-
-		if (fMEM)
-			MEM_Exit();
+		if (fmem)
+			mem_exit();
 
 	}
 
-	return fInit;
+	return ret;
 }
-
diff --git a/drivers/dsp/bridge/services/sync.c b/drivers/dsp/bridge/services/sync.c
index bd07938..e54b500 100644
--- a/drivers/dsp/bridge/services/sync.c
+++ b/drivers/dsp/bridge/services/sync.c
@@ -19,435 +19,86 @@
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/mem.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/sync.h>
 
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
-#define SIGNATURE       0x434e5953	/* "SYNC" (in reverse) */
-
-enum wait_state {
-	wo_waiting,
-	wo_signalled
-} ;
-
-enum sync_state {
-	so_reset,
-	so_signalled
-} ;
-
-struct WAIT_OBJECT {
-	enum wait_state state;
-	struct SYNC_OBJECT *signalling_event;
-	struct semaphore sem;
-};
-
-/* Generic SYNC object: */
-struct SYNC_OBJECT {
-	u32 dwSignature;	/* Used for object validation. */
-	enum sync_state state;
-	spinlock_t sync_lock;
-	struct WAIT_OBJECT *pWaitObj;
-};
-
-struct SYNC_DPCCSOBJECT {
-	u32 dwSignature;	/* used for object validation */
-	spinlock_t sync_dpccs_lock;
-	s32 count;
-} ;
-
-static int test_and_set(volatile void *ptr, int val)
-{
-	int ret = val;
-	asm volatile (" swp %0, %0, [%1]" : "+r" (ret) : "r"(ptr) : "memory");
-	return ret;
-}
-
-static void timeout_callback(unsigned long hWaitObj);
-
-/*
- *  ======== SYNC_CloseEvent ========
- *  Purpose:
- *      Close an existing SYNC event object.
- */
-DSP_STATUS SYNC_CloseEvent(struct SYNC_OBJECT *hEvent)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
-
-	DBC_Require(pEvent != NULL && pEvent->pWaitObj == NULL);
+DEFINE_SPINLOCK(sync_lock);
 
-	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
-		if (pEvent->pWaitObj)
-			status = DSP_EFAIL;
-
-		MEM_FreeObject(pEvent);
-
-	} else {
-		status = DSP_EHANDLE;
-	}
-
-	return status;
-}
-
-/*
- *  ======== SYNC_Exit ========
- *  Purpose:
- *      Cleanup SYNC module.
- */
-void SYNC_Exit(void)
-{
-	/* Do nothing */
-}
-
-/*
- *  ======== SYNC_Init ========
- *  Purpose:
- *      Initialize SYNC module.
- */
-bool SYNC_Init(void)
-{
-	return true;
-}
-
-/*
- *  ======== SYNC_OpenEvent ========
- *  Purpose:
- *      Open a new synchronization event object.
+/**
+ * sync_set_event() - set or signal and specified event
+ * @event:	Event to be set..
+ *
+ * set the @event, if there is an thread waiting for the event
+ * it will be waken up, this function only wakes one thread.
  */
-DSP_STATUS SYNC_OpenEvent(OUT struct SYNC_OBJECT **phEvent,
-			  IN OPTIONAL struct SYNC_ATTRS *pAttrs)
-{
-	struct SYNC_OBJECT *pEvent = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(phEvent != NULL);
-
-	/* Allocate memory for sync object */
-	MEM_AllocObject(pEvent, struct SYNC_OBJECT, SIGNATURE);
-	if (pEvent != NULL) {
-		pEvent->state = so_reset;
-		pEvent->pWaitObj = NULL;
-		spin_lock_init(&pEvent->sync_lock);
-	} else {
-		status = DSP_EMEMORY;
-	}
-
-	*phEvent = pEvent;
 
-	return status;
-}
-
-/*
- *  ======== SYNC_ResetEvent ========
- *  Purpose:
- *      Reset an event to non-signalled.
- */
-DSP_STATUS SYNC_ResetEvent(struct SYNC_OBJECT *hEvent)
+void sync_set_event(struct sync_object *event)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
-
-	if (MEM_IsValidHandle(hEvent, SIGNATURE))
-		pEvent->state = so_reset;
-	else
-		status = DSP_EHANDLE;
-
-	return status;
+	spin_lock_bh(&sync_lock);
+	complete(&event->comp);
+	if (event->multi_comp)
+		complete(event->multi_comp);
+	spin_unlock_bh(&sync_lock);
 }
 
-/*
- *  ======== SYNC_SetEvent ========
- *  Purpose:
- *      Set an event to signaled and unblock one waiting thread.
+/**
+ * sync_wait_on_multiple_events() - waits for multiple events to be set.
+ * @events:	Array of events to wait for them.
+ * @count:	number of elements of the array.
+ * @timeout	timeout on waiting for the evetns.
+ * @pu_index	index of the event set.
  *
- *  This function is called from ISR, DPC and user context. Hence interrupts
- *  are disabled to ensure atomicity.
+ * This functios will wait until any of the array element is set or until
+ * timeout. In case of success the function will return DSP_SOK and
+ * @pu_index will store the index of the array element set or in case
+ * of timeout the function will return DSP_ETIMEOUT or in case of
+ * interrupting by a signal it will return DSP_EFAIL.
  */
 
-DSP_STATUS SYNC_SetEvent(struct SYNC_OBJECT *hEvent)
+dsp_status sync_wait_on_multiple_events(struct sync_object **events,
+				     unsigned count, unsigned timeout,
+				     unsigned *index)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
-	unsigned long flags;
-
-	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
-		spin_lock_irqsave(&hEvent->sync_lock, flags);
-
-		if (pEvent->pWaitObj != NULL &&
-		   test_and_set(&pEvent->pWaitObj->state,
-		   wo_signalled) == wo_waiting) {
-			pEvent->state = so_reset;
-			pEvent->pWaitObj->signalling_event = pEvent;
-			up(&pEvent->pWaitObj->sem);
-		} else {
-			pEvent->state = so_signalled;
+	unsigned i;
+	dsp_status status = DSP_EFAIL;
+	struct completion m_comp;
+
+	init_completion(&m_comp);
+
+	if (SYNC_INFINITE == timeout)
+		timeout = MAX_SCHEDULE_TIMEOUT;
+
+	spin_lock_bh(&sync_lock);
+	for (i = 0; i < count; i++) {
+		if (completion_done(&events[i]->comp)) {
+			INIT_COMPLETION(events[i]->comp);
+			*index = i;
+			spin_unlock_bh(&sync_lock);
+			status = DSP_SOK;
+			goto func_end;
 		}
-		spin_unlock_irqrestore(&hEvent->sync_lock, flags);
-	} else {
-		status = DSP_EHANDLE;
 	}
-	return status;
-}
-
-/*
- *  ======== SYNC_WaitOnEvent ========
- *  Purpose:
- *      Wait for an event to be signalled, up to the specified timeout.
- *      Note: dwTimeOut must be 0xffffffff to signal infinite wait.
- */
-DSP_STATUS SYNC_WaitOnEvent(struct SYNC_OBJECT *hEvent, u32 dwTimeout)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
-	u32 temp;
-
-	if (MEM_IsValidHandle(hEvent, SIGNATURE))
-		status = SYNC_WaitOnMultipleEvents(&pEvent, 1, dwTimeout,
-						  &temp);
-	else
-		status = DSP_EHANDLE;
-
-	return status;
-}
 
-/*
- *  ======== SYNC_WaitOnMultipleEvents ========
- *  Purpose:
- *      Wait for any of an array of events to be signalled, up to the
- *      specified timeout.
- */
-DSP_STATUS SYNC_WaitOnMultipleEvents(struct SYNC_OBJECT **hSyncEvents,
-				     u32 uCount, u32 dwTimeout,
-				     OUT u32 *puIndex)
-{
-	u32 i;
-	DSP_STATUS status = DSP_SOK;
-	u32 curr;
-	struct WAIT_OBJECT *Wp;
+	for (i = 0; i < count; i++)
+		events[i]->multi_comp = &m_comp;
 
-	DBC_Require(uCount > 0);
-	DBC_Require(hSyncEvents != NULL);
-	DBC_Require(puIndex != NULL);
+	spin_unlock_bh(&sync_lock);
 
-	for (i = 0; i < uCount; i++)
-		DBC_Require(MEM_IsValidHandle(hSyncEvents[i], SIGNATURE));
-
-	Wp = MEM_Calloc(sizeof(struct WAIT_OBJECT), MEM_NONPAGED);
-	if (Wp == NULL)
-		return DSP_EMEMORY;
-
-	Wp->state = wo_waiting;
-	Wp->signalling_event = NULL;
-	init_MUTEX_LOCKED(&(Wp->sem));
-
-	for (curr = 0; curr < uCount; curr++) {
-		hSyncEvents[curr]->pWaitObj = Wp;
-		if (hSyncEvents[curr]->state == so_signalled) {
-			if (test_and_set(&(Wp->state), wo_signalled) ==
-			   wo_waiting) {
-				hSyncEvents[curr]->state = so_reset;
-				Wp->signalling_event = hSyncEvents[curr];
-			}
-		curr++;	/* Will try optimizing later */
-		break;
-		}
-	}
-
-	curr--;			/* Will try optimizing later */
-	if (Wp->state != wo_signalled && dwTimeout > 0) {
-		struct timer_list timeout;
-		if (dwTimeout != SYNC_INFINITE) {
-			init_timer_on_stack(&timeout);
-			timeout.function = timeout_callback;
-			timeout.data = (unsigned long)Wp;
-			timeout.expires = jiffies + dwTimeout * HZ / 1000;
-			add_timer(&timeout);
-		}
-		if (down_interruptible(&(Wp->sem))) {
-			/*
-			 * Most probably we are interrupted by a fake signal
-			 * from freezer. Return -ERESTARTSYS so that this
-			 * ioctl is restarted, and user space doesn't notice
-			 * it.
-			 */
-			status = -ERESTARTSYS;
-		}
-		if (dwTimeout != SYNC_INFINITE) {
-			if (in_interrupt()) {
-				del_timer(&timeout);
-			} else {
-				del_timer_sync(&timeout);
-			}
-		}
-	}
-	for (i = 0; i <= curr; i++) {
-		if (MEM_IsValidHandle(hSyncEvents[i], SIGNATURE)) {
-			/*  Memory corruption here if hSyncEvents[i] is
-			 *  freed before following statememt. */
-			hSyncEvents[i]->pWaitObj = NULL;
-		}
-		if (hSyncEvents[i] == Wp->signalling_event)
-			*puIndex = i;
-
-	}
-	if (Wp->signalling_event == NULL && DSP_SUCCEEDED(status))
+	if (!wait_for_completion_interruptible_timeout(&m_comp,
+					msecs_to_jiffies(timeout)))
 		status = DSP_ETIMEOUT;
-	kfree(Wp);
-	return status;
-}
-
-static void timeout_callback(unsigned long hWaitObj)
-{
-	struct WAIT_OBJECT *pWaitObj = (struct WAIT_OBJECT *)hWaitObj;
-	if (test_and_set(&pWaitObj->state, wo_signalled) == wo_waiting)
-		up(&pWaitObj->sem);
-
-}
-
-/*
- *  ======== SYNC_DeleteCS ========
- */
-DSP_STATUS SYNC_DeleteCS(struct SYNC_CSOBJECT *hCSObj)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
-
-	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
-		if (down_trylock(&pCSObj->sem) != 0)
-			DBC_Assert(0);
-
-		MEM_FreeObject(hCSObj);
-	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
-		struct SYNC_DPCCSOBJECT *pDPCCSObj =
-					 (struct SYNC_DPCCSOBJECT *)hCSObj;
-		if (pDPCCSObj->count != 1)
-			DBC_Assert(0);
-
-		MEM_FreeObject(pDPCCSObj);
-	} else {
-		status = DSP_EHANDLE;
-	}
-
-	return status;
-}
-
-/*
- *  ======== SYNC_EnterCS ========
- */
-DSP_STATUS SYNC_EnterCS(struct SYNC_CSOBJECT *hCSObj)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
-
-	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
-		if (in_interrupt()) {
-			status = DSP_EFAIL;
-			DBC_Assert(0);
-		} else if (down_interruptible(&pCSObj->sem)) {
-			status = DSP_EFAIL;
-		}
-	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
-		struct SYNC_DPCCSOBJECT *pDPCCSObj =
-					(struct SYNC_DPCCSOBJECT *)hCSObj;
-		spin_lock_bh(&pDPCCSObj->sync_dpccs_lock);
-		pDPCCSObj->count--;
-		if (pDPCCSObj->count != 0) {
-			/* FATAL ERROR : Failed to acquire DPC CS */
-			spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
-			DBC_Assert(0);
-		}
-	} else {
-		status = DSP_EHANDLE;
-	}
-
-	return status;
-}
-
-/*
- *  ======== SYNC_InitializeCS ========
- */
-DSP_STATUS SYNC_InitializeCS(OUT struct SYNC_CSOBJECT **phCSObj)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_CSOBJECT *pCSObj = NULL;
-
-	/* Allocate memory for sync CS object */
-	MEM_AllocObject(pCSObj, struct SYNC_CSOBJECT, SIGNATURECS);
-	if (pCSObj != NULL)
-		init_MUTEX(&pCSObj->sem);
-	else
-		status = DSP_EMEMORY;
-
-	/* return CS object */
-	*phCSObj = pCSObj;
-	DBC_Assert(DSP_FAILED(status) || (pCSObj));
-	return status;
-}
-
-DSP_STATUS SYNC_InitializeDPCCS(OUT struct SYNC_CSOBJECT **phCSObj)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_DPCCSOBJECT *pCSObj = NULL;
-
-	DBC_Require(phCSObj);
 
-	if (phCSObj) {
-		/* Allocate memory for sync CS object */
-		MEM_AllocObject(pCSObj, struct SYNC_DPCCSOBJECT,
-				SIGNATUREDPCCS);
-		if (pCSObj != NULL) {
-			pCSObj->count = 1;
-			spin_lock_init(&pCSObj->sync_dpccs_lock);
-		} else {
-			status = DSP_EMEMORY;
+	spin_lock_bh(&sync_lock);
+	for (i = 0; i < count; i++) {
+		if (completion_done(&events[i]->comp)) {
+			INIT_COMPLETION(events[i]->comp);
+			*index = i;
+			status = DSP_SOK;
 		}
-
-		/* return CS object */
-		*phCSObj = (struct SYNC_CSOBJECT *)pCSObj;
-	} else {
-		status = DSP_EPOINTER;
+		events[i]->multi_comp = NULL;
 	}
-
-	DBC_Assert(DSP_FAILED(status) || (pCSObj));
-
+	spin_unlock_bh(&sync_lock);
+func_end:
 	return status;
 }
 
-/*
- *  ======== SYNC_LeaveCS ========
- */
-DSP_STATUS SYNC_LeaveCS(struct SYNC_CSOBJECT *hCSObj)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
-
-	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
-		up(&pCSObj->sem);
-	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
-		struct SYNC_DPCCSOBJECT *pDPCCSObj =
-					(struct SYNC_DPCCSOBJECT *)hCSObj;
-		pDPCCSObj->count++;
-		if (pDPCCSObj->count != 1) {
-			/* FATAL ERROR : Invalid DPC CS count */
-			spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
-			DBC_Assert(0);
-			spin_lock_bh(&pDPCCSObj->sync_dpccs_lock);
-		}
-		spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
-	} else {
-		status = DSP_EHANDLE;
-	}
-
-	return status;
-}
diff --git a/drivers/dsp/bridge/wmd/_cmm.h b/drivers/dsp/bridge/wmd/_cmm.h
index 60784fd..7660bef 100644
--- a/drivers/dsp/bridge/wmd/_cmm.h
+++ b/drivers/dsp/bridge/wmd/_cmm.h
@@ -5,7 +5,7 @@
  *
  * Private header file defining CMM manager objects and defines needed
  * by IO manager to register shared memory regions when DSP base image
- * is loaded(WMD_IO_OnLoaded).
+ * is loaded(bridge_io_on_loaded).
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
@@ -42,4 +42,4 @@
  *
  */
 
-#endif				/* _CMM_ */
+#endif /* _CMM_ */
diff --git a/drivers/dsp/bridge/wmd/_deh.h b/drivers/dsp/bridge/wmd/_deh.h
index aadb9fa..214ac7d 100644
--- a/drivers/dsp/bridge/wmd/_deh.h
+++ b/drivers/dsp/bridge/wmd/_deh.h
@@ -25,14 +25,14 @@
 #define SIGNATURE       0x5f484544	/* "DEH_" backwards */
 
 /* DEH Manager: only one created per board: */
-struct DEH_MGR {
-	u32 dwSignature;	/* Used for object validation.  */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD device context. */
-	struct NTFY_OBJECT *hNtfy;	/* NTFY object                  */
-	struct DSP_ERRORINFO errInfo;	/* DSP exception info.          */
+struct deh_mgr {
+	u32 dw_signature;	/* Used for object validation. */
+	struct wmd_dev_context *hwmd_context;	/* WMD device context. */
+	struct ntfy_object *ntfy_obj;	/* NTFY object */
+	struct dsp_errorinfo err_info;	/* DSP exception info. */
 
 	/* MMU Fault DPC */
 	struct tasklet_struct dpc_tasklet;
-} ;
+};
 
-#endif				/* _DEH_ */
+#endif /* _DEH_ */
diff --git a/drivers/dsp/bridge/wmd/_msg_sm.h b/drivers/dsp/bridge/wmd/_msg_sm.h
index 7de632b..bb28d4f 100644
--- a/drivers/dsp/bridge/wmd/_msg_sm.h
+++ b/drivers/dsp/bridge/wmd/_msg_sm.h
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * Private header file defining MSG manager objects and defines needed
+ * Private header file defining msg_ctrl manager objects and defines needed
  * by IO manager.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
@@ -36,7 +36,7 @@
 #endif
 
 /*
- *  ======== MSG ========
+ *  ======== msg_ctrl ========
  *  There is a control structure for messages to the DSP, and a control
  *  structure for messages from the DSP. The shared memory region for
  *  transferring messages is partitioned as follows:
@@ -45,99 +45,98 @@
  *  |Control | Messages from DSP | Control | Messages to DSP |
  *  ----------------------------------------------------------
  *
- *  MSG control structure for messages to the DSP is used in the following
+ *  msg_ctrl control structure for messages to the DSP is used in the following
  *  way:
  *
- *  bufEmpty -      This flag is set to FALSE by the GPP after it has output
+ *  buf_empty -      This flag is set to FALSE by the GPP after it has output
  *                  messages for the DSP. The DSP host driver sets it to
  *                  TRUE after it has copied the messages.
- *  postSWI -       Set to 1 by the GPP after it has written the messages,
- *                  set the size, and set bufEmpty to FALSE.
- *                  The DSP Host driver uses SWI_andn of the postSWI field
+ *  post_swi -       Set to 1 by the GPP after it has written the messages,
+ *                  set the size, and set buf_empty to FALSE.
+ *                  The DSP Host driver uses SWI_andn of the post_swi field
  *                  when a host interrupt occurs. The host driver clears
  *                  this after posting the SWI.
  *  size -          Number of messages to be read by the DSP.
  *
  *  For messages from the DSP:
- *  bufEmpty -      This flag is set to FALSE by the DSP after it has output
+ *  buf_empty -      This flag is set to FALSE by the DSP after it has output
  *                  messages for the GPP. The DPC on the GPP sets it to
  *                  TRUE after it has copied the messages.
- *  postSWI -       Set to 1 the DPC on the GPP after copying the messages.
+ *  post_swi -       Set to 1 the DPC on the GPP after copying the messages.
  *  size -          Number of messages to be read by the GPP.
  */
-struct MSG {
-	u32 bufEmpty;	/* to/from DSP buffer is empty */
-	u32 postSWI;	/* Set to "1" to post MSG SWI */
-	u32 size;	/* Number of messages to/from the DSP */
+struct msg_ctrl {
+	u32 buf_empty;		/* to/from DSP buffer is empty */
+	u32 post_swi;		/* Set to "1" to post msg_ctrl SWI */
+	u32 size;		/* Number of messages to/from the DSP */
 	u32 resvd;
-} ;
+};
 
 /*
- *  ======== MSG_MGR ========
- *  The MSG_MGR maintains a list of all MSG_QUEUEs. Each NODE object can
- *  have MSG_QUEUE to hold all messages that come up from the corresponding
- *  node on the DSP. The MSG_MGR also has a shared queue of messages
+ *  ======== msg_mgr ========
+ *  The msg_mgr maintains a list of all MSG_QUEUEs. Each NODE object can
+ *  have msg_queue to hold all messages that come up from the corresponding
+ *  node on the DSP. The msg_mgr also has a shared queue of messages
  *  ready to go to the DSP.
  */
-struct MSG_MGR {
+struct msg_mgr {
 	/* The first two fields must match those in msgobj.h */
-	u32 dwSignature;
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
+	u32 dw_signature;
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD. */
 
-	struct IO_MGR *hIOMgr;	/* IO manager */
-	struct LST_LIST *queueList;	/* List of MSG_QUEUEs */
-	struct SYNC_CSOBJECT *hSyncCS;	/* For critical sections */
+	struct io_mgr *hio_mgr;	/* IO manager */
+	struct lst_list *queue_list;	/* List of MSG_QUEUEs */
+	spinlock_t msg_mgr_lock;	/* For critical sections */
 	/* Signalled when MsgFrame is available */
-	struct SYNC_OBJECT *hSyncEvent;
-	struct LST_LIST *msgFreeList;	/* Free MsgFrames ready to be filled */
-	struct LST_LIST *msgUsedList;	/* MsgFrames ready to go to DSP */
-	u32 uMsgsPending;	/* # of queued messages to go to DSP */
-	u32 uMaxMsgs;	/* Max # of msgs that fit in buffer */
-	MSG_ONEXIT onExit;	/* called when RMS_EXIT is received */
-} ;
+	struct sync_object *sync_event;
+	struct lst_list *msg_free_list;	/* Free MsgFrames ready to be filled */
+	struct lst_list *msg_used_list;	/* MsgFrames ready to go to DSP */
+	u32 msgs_pending;	/* # of queued messages to go to DSP */
+	u32 max_msgs;		/* Max # of msgs that fit in buffer */
+	msg_onexit on_exit;	/* called when RMS_EXIT is received */
+};
 
 /*
- *  ======== MSG_QUEUE ========
- *  Each NODE has a MSG_QUEUE for receiving messages from the
- *  corresponding node on the DSP. The MSG_QUEUE object maintains a list
+ *  ======== msg_queue ========
+ *  Each NODE has a msg_queue for receiving messages from the
+ *  corresponding node on the DSP. The msg_queue object maintains a list
  *  of messages that have been sent to the host, but not yet read (MSG_Get),
  *  and a list of free frames that can be filled when new messages arrive
  *  from the DSP.
- *  The MSG_QUEUE's hSynEvent gets posted when a message is ready.
+ *  The msg_queue's hSynEvent gets posted when a message is ready.
  */
-struct MSG_QUEUE {
-	struct list_head listElem;
-	u32 dwSignature;
-	struct MSG_MGR *hMsgMgr;
-	u32 uMaxMsgs;	/* Node message depth */
-	u32 dwId;	/* Node environment pointer */
-	struct LST_LIST *msgFreeList;	/* Free MsgFrames ready to be filled */
+struct msg_queue {
+	struct list_head list_elem;
+	u32 dw_signature;
+	struct msg_mgr *hmsg_mgr;
+	u32 max_msgs;		/* Node message depth */
+	u32 msgq_id;		/* Node environment pointer */
+	struct lst_list *msg_free_list;	/* Free MsgFrames ready to be filled */
 	/* Filled MsgFramess waiting to be read */
-	struct LST_LIST *msgUsedList;
-	HANDLE hArg;	/* Handle passed to mgr onExit callback */
-	struct SYNC_OBJECT *hSyncEvent;	/* Signalled when message is ready */
-	struct SYNC_OBJECT *hSyncDone;	/* For synchronizing cleanup */
-	struct SYNC_OBJECT *hSyncDoneAck;	/* For synchronizing cleanup */
-	struct NTFY_OBJECT *hNtfy;	/* For notification of message ready */
-	bool fDone;	/* TRUE <==> deleting the object */
-	u32 refCount;	/* Number of pending MSG_get/put calls */
+	struct lst_list *msg_used_list;
+	bhandle arg;		/* Handle passed to mgr on_exit callback */
+	struct sync_object *sync_event;	/* Signalled when message is ready */
+	struct sync_object *sync_done;	/* For synchronizing cleanup */
+	struct sync_object *sync_done_ack;	/* For synchronizing cleanup */
+	struct ntfy_object *ntfy_obj;	/* For notification of message ready */
+	bool done;		/* TRUE <==> deleting the object */
+	u32 io_msg_pend;	/* Number of pending MSG_get/put calls */
 };
 
 /*
- *  ======== MSG_DSPMSG ========
+ *  ======== msg_dspmsg ========
  */
-struct MSG_DSPMSG {
-	struct DSP_MSG msg;
-	u32 dwId;	/* Identifies the node the message goes to */
-} ;
+struct msg_dspmsg {
+	struct dsp_msg msg;
+	u32 msgq_id;		/* Identifies the node the message goes to */
+};
 
 /*
- *  ======== MSG_FRAME ========
+ *  ======== msg_frame ========
  */
-struct MSG_FRAME {
-	struct list_head listElem;
-	struct MSG_DSPMSG msgData;
-} ;
-
-#endif				/* _MSG_SM_ */
+struct msg_frame {
+	struct list_head list_elem;
+	struct msg_dspmsg msg_data;
+};
 
+#endif /* _MSG_SM_ */
diff --git a/drivers/dsp/bridge/wmd/_tiomap.h b/drivers/dsp/bridge/wmd/_tiomap.h
index fd60f38..10bfae6 100644
--- a/drivers/dsp/bridge/wmd/_tiomap.h
+++ b/drivers/dsp/bridge/wmd/_tiomap.h
@@ -21,14 +21,14 @@
 
 #include <dspbridge/devdefs.h>
 #include <hw_defs.h>
-#include <dspbridge/wmdioctl.h>		/* for WMDIOCTL_EXTPROC defn */
+#include <dspbridge/wmdioctl.h>	/* for wmdioctl_extproc defn */
 #include <dspbridge/sync.h>
 #include <dspbridge/clk.h>
 
-struct MAP_L4PERIPHERAL {
-	u32 physAddr;
-	u32 dspVirtAddr;
-} ;
+struct map_l4_peripheral {
+	u32 phys_addr;
+	u32 dsp_virt_addr;
+};
 
 #define ARM_MAILBOX_START               0xfffcf000
 #define ARM_MAILBOX_LENGTH              0x800
@@ -45,22 +45,22 @@ struct MAP_L4PERIPHERAL {
 #define API_CLKM_DPLL_DMA               0xfffec000
 #define ARM_INTERRUPT_OFFSET            0xb00
 
-#define BIOS_24XX
+#define BIOS24XX
 
 #define L4_PERIPHERAL_NULL          0x0
 #define DSPVA_PERIPHERAL_NULL       0x0
 
 #define MAX_LOCK_TLB_ENTRIES 15
 
-#define L4_PERIPHERAL_PRM        0x48306000  /*PRM L4 Peripheral */
+#define L4_PERIPHERAL_PRM        0x48306000	/*PRM L4 Peripheral */
 #define DSPVA_PERIPHERAL_PRM     0x1181e000
-#define L4_PERIPHERAL_SCM        0x48002000  /*SCM L4 Peripheral */
+#define L4_PERIPHERAL_SCM        0x48002000	/*SCM L4 Peripheral */
 #define DSPVA_PERIPHERAL_SCM     0x1181f000
-#define L4_PERIPHERAL_MMU        0x5D000000  /*MMU L4 Peripheral */
+#define L4_PERIPHERAL_MMU        0x5D000000	/*MMU L4 Peripheral */
 #define DSPVA_PERIPHERAL_MMU     0x11820000
-#define L4_PERIPHERAL_CM        0x48004000       /* Core L4, Clock Management */
+#define L4_PERIPHERAL_CM        0x48004000	/* Core L4, Clock Management */
 #define DSPVA_PERIPHERAL_CM     0x1181c000
-#define L4_PERIPHERAL_PER        0x48005000       /*  PER */
+#define L4_PERIPHERAL_PER        0x48005000	/*  PER */
 #define DSPVA_PERIPHERAL_PER     0x1181d000
 
 #define L4_PERIPHERAL_GPIO1       0x48310000
@@ -93,7 +93,7 @@ struct MAP_L4PERIPHERAL {
 #define DSPVA_PERIPHERAL_CAMERA   0x11819000
 
 #define L4_PERIPHERAL_SDMA        0x48056000
-#define DSPVA_PERIPHERAL_SDMA     0x11810000 /*0x1181d000 conflicts with PER */
+#define DSPVA_PERIPHERAL_SDMA     0x11810000	/* 0x1181d000 conflict w/ PER */
 
 #define L4_PERIPHERAL_UART1             0x4806a000
 #define DSPVA_PERIPHERAL_UART1          0x11811000
@@ -139,7 +139,7 @@ struct MAP_L4PERIPHERAL {
 #define DSPVA_PERIPHERAL_SIDETONE_MCBSP3 0x11825000
 
 /* define a static array with L4 mappings */
-static const struct MAP_L4PERIPHERAL L4PeripheralTable[] = {
+static const struct map_l4_peripheral l4_peripheral_table[] = {
 	{L4_PERIPHERAL_MBOX, DSPVA_PERIPHERAL_MBOX},
 	{L4_PERIPHERAL_SCM, DSPVA_PERIPHERAL_SCM},
 	{L4_PERIPHERAL_MMU, DSPVA_PERIPHERAL_MMU},
@@ -208,30 +208,30 @@ static const struct MAP_L4PERIPHERAL L4PeripheralTable[] = {
 #define MBX_PM_MAX_RESOURCES 11
 
 /*  Power Management Commands */
-#define BPWR_DisableClock	0
-#define BPWR_EnableClock	1
+#define BPWR_DISABLE_CLOCK	0
+#define BPWR_ENABLE_CLOCK	1
 
 /* OMAP242x specific resources */
-enum BPWR_ExtClockId {
-	BPWR_GPTimer5 = 0x10,
-	BPWR_GPTimer6,
-	BPWR_GPTimer7,
-	BPWR_GPTimer8,
-	BPWR_WDTimer3,
+enum bpwr_ext_clock_id {
+	BPWR_GP_TIMER5 = 0x10,
+	BPWR_GP_TIMER6,
+	BPWR_GP_TIMER7,
+	BPWR_GP_TIMER8,
+	BPWR_WD_TIMER3,
 	BPWR_MCBSP1,
 	BPWR_MCBSP2,
 	BPWR_MCBSP3,
 	BPWR_MCBSP4,
 	BPWR_MCBSP5,
 	BPWR_SSI = 0x20
-} ;
-
-static const u32 BPWR_CLKID[] = {
-	(u32) BPWR_GPTimer5,
-	(u32) BPWR_GPTimer6,
-	(u32) BPWR_GPTimer7,
-	(u32) BPWR_GPTimer8,
-	(u32) BPWR_WDTimer3,
+};
+
+static const u32 bpwr_clkid[] = {
+	(u32) BPWR_GP_TIMER5,
+	(u32) BPWR_GP_TIMER6,
+	(u32) BPWR_GP_TIMER7,
+	(u32) BPWR_GP_TIMER8,
+	(u32) BPWR_WD_TIMER3,
 	(u32) BPWR_MCBSP1,
 	(u32) BPWR_MCBSP2,
 	(u32) BPWR_MCBSP3,
@@ -240,29 +240,29 @@ static const u32 BPWR_CLKID[] = {
 	(u32) BPWR_SSI
 };
 
-struct BPWR_Clk_t {
-	u32 clkId;
-	enum SERVICES_ClkId funClk;
-	enum SERVICES_ClkId intClk;
-} ;
-
-static const struct BPWR_Clk_t BPWR_Clks[] = {
-	{(u32) BPWR_GPTimer5, SERVICESCLK_gpt5_fck, SERVICESCLK_gpt5_ick},
-	{(u32) BPWR_GPTimer6, SERVICESCLK_gpt6_fck, SERVICESCLK_gpt6_ick},
-	{(u32) BPWR_GPTimer7, SERVICESCLK_gpt7_fck, SERVICESCLK_gpt7_ick},
-	{(u32) BPWR_GPTimer8, SERVICESCLK_gpt8_fck, SERVICESCLK_gpt8_ick},
-	{(u32) BPWR_WDTimer3, SERVICESCLK_wdt3_fck, SERVICESCLK_wdt3_ick},
-	{(u32) BPWR_MCBSP1, SERVICESCLK_mcbsp1_fck, SERVICESCLK_mcbsp1_ick},
-	{(u32) BPWR_MCBSP2, SERVICESCLK_mcbsp2_fck, SERVICESCLK_mcbsp2_ick},
-	{(u32) BPWR_MCBSP3, SERVICESCLK_mcbsp3_fck, SERVICESCLK_mcbsp3_ick},
-	{(u32) BPWR_MCBSP4, SERVICESCLK_mcbsp4_fck, SERVICESCLK_mcbsp4_ick},
-	{(u32) BPWR_MCBSP5, SERVICESCLK_mcbsp5_fck, SERVICESCLK_mcbsp5_ick},
-	{(u32) BPWR_SSI, SERVICESCLK_ssi_fck, SERVICESCLK_ssi_ick}
+struct bpwr_clk_t {
+	u32 clk_id;
+	enum services_clk_id fun_clk;
+	enum services_clk_id int_clk;
+};
+
+static const struct bpwr_clk_t bpwr_clks[] = {
+	{(u32) BPWR_GP_TIMER5, SERVICESCLK_GPT5_FCK, SERVICESCLK_GPT5_ICK},
+	{(u32) BPWR_GP_TIMER6, SERVICESCLK_GPT6_FCK, SERVICESCLK_GPT6_ICK},
+	{(u32) BPWR_GP_TIMER7, SERVICESCLK_GPT7_FCK, SERVICESCLK_GPT7_ICK},
+	{(u32) BPWR_GP_TIMER8, SERVICESCLK_GPT8_FCK, SERVICESCLK_GPT8_ICK},
+	{(u32) BPWR_WD_TIMER3, SERVICESCLK_WDT3_FCK, SERVICESCLK_WDT3_ICK},
+	{(u32) BPWR_MCBSP1, SERVICESCLK_MCBSP1_FCK, SERVICESCLK_MCBSP1_ICK},
+	{(u32) BPWR_MCBSP2, SERVICESCLK_MCBSP2_FCK, SERVICESCLK_MCBSP2_ICK},
+	{(u32) BPWR_MCBSP3, SERVICESCLK_MCBSP3_FCK, SERVICESCLK_MCBSP3_ICK},
+	{(u32) BPWR_MCBSP4, SERVICESCLK_MCBSP4_FCK, SERVICESCLK_MCBSP4_ICK},
+	{(u32) BPWR_MCBSP5, SERVICESCLK_MCBSP5_FCK, SERVICESCLK_MCBSP5_ICK},
+	{(u32) BPWR_SSI, SERVICESCLK_SSI_FCK, SERVICESCLK_SSI_ICK}
 };
 
 /* Interrupt Register Offsets */
-#define INTH_IT_REG_OFFSET              0x00	/* Interrupt register offset  */
-#define INTH_MASK_IT_REG_OFFSET         0x04	/* Mask Interrupt reg offset  */
+#define INTH_IT_REG_OFFSET              0x00	/* Interrupt register offset */
+#define INTH_MASK_IT_REG_OFFSET         0x04	/* Mask Interrupt reg offset */
 
 #define   DSP_MAILBOX1_INT              10
 /*
@@ -280,8 +280,8 @@ static const struct BPWR_Clk_t BPWR_Clks[] = {
 
 #define MB_ARM2DSP_FLAG                 0x0001
 
-#define MBOX_ARM2DSP HW_MBOX_ID_0
-#define MBOX_DSP2ARM HW_MBOX_ID_1
+#define MBOX_ARM2DSP HW_MBOX_ID0
+#define MBOX_DSP2ARM HW_MBOX_ID1
 #define MBOX_ARM HW_MBOX_U0_ARM
 #define MBOX_DSP HW_MBOX_U1_DSP1
 
@@ -297,70 +297,70 @@ static const struct BPWR_Clk_t BPWR_Clks[] = {
 #define LOW_LEVEL                       false
 
 /* Macro's */
-#define REG16(A)    (*(REG_UWORD16 *)(A))
+#define REG16(A)    (*(reg_uword16 *)(A))
 
-#define ClearBit(reg, mask)             (reg &= ~mask)
-#define SetBit(reg, mask)               (reg |= mask)
+#define CLEAR_BIT(reg, mask)             (reg &= ~mask)
+#define SET_BIT(reg, mask)               (reg |= mask)
 
-#define SetGroupBits16(reg, position, width, value)			     \
+#define SET_GROUP_BITS16(reg, position, width, value)			     \
 	do {								     \
 		reg &= ~((0xFFFF >> (16 - (width))) << (position));	     \
 		reg |= ((value & (0xFFFF >> (16 - (width)))) << (position)); \
 	} while (0);
 
-#define ClearBitIndex(reg, index)   (reg &= ~(1 << (index)))
+#define CLEAR_BIT_INDEX(reg, index)   (reg &= ~(1 << (index)))
 
 /* This mini driver's device context: */
-struct WMD_DEV_CONTEXT {
-	struct DEV_OBJECT *hDevObject;	/* Handle to WCD device object. */
-	u32 dwDspBaseAddr; 		/* Arm's API to DSP virt base addr */
+struct wmd_dev_context {
+	struct dev_object *hdev_obj;	/* Handle to WCD device object. */
+	u32 dw_dsp_base_addr;	/* Arm's API to DSP virt base addr */
 	/*
 	 * DSP External memory prog address as seen virtually by the OS on
 	 * the host side.
 	 */
-	u32 dwDspExtBaseAddr;		/* See the comment above */
-	u32 dwAPIRegBase;		/* API mem map'd registers */
-	void __iomem *dwDSPMmuBase;	/* DSP MMU Mapped registers */
-	void __iomem *wdt3_base;		/* WDT3 mapped registers */
-	u32 dwAPIClkBase;		/* CLK Registers */
-	u32 dwDSPClkM2Base;		/* DSP Clock Module m2 */
-	u32 dwPublicRhea;		/* Pub Rhea */
-	u32 dwIntAddr;			/* MB INTR reg */
-	u32 dwTCEndianism;		/* TC Endianism register */
-	u32 dwTestBase;			/* DSP MMU Mapped registers */
-	u32 dwSelfLoop;			/* Pointer to the selfloop */
-	u32 dwDSPStartAdd;		/* API Boot vector */
-	u32 dwInternalSize;		/* Internal memory size */
-
-	struct omap_mbox *mbox;		/* Mail box handle*/
+	u32 dw_dsp_ext_base_addr;	/* See the comment above */
+	u32 dw_api_reg_base;	/* API mem map'd registers */
+	void __iomem *dw_dsp_mmu_base;	/* DSP MMU Mapped registers */
+	void __iomem *wdt3_base;	/* WDT3 mapped registers */
+	u32 dw_api_clk_base;	/* CLK Registers */
+	u32 dw_dsp_clk_m2_base;	/* DSP Clock Module m2 */
+	u32 dw_public_rhea;	/* Pub Rhea */
+	u32 dw_int_addr;	/* MB INTR reg */
+	u32 dw_tc_endianism;	/* TC Endianism register */
+	u32 dw_test_base;	/* DSP MMU Mapped registers */
+	u32 dw_self_loop;	/* Pointer to the selfloop */
+	u32 dw_dsp_start_add;	/* API Boot vector */
+	u32 dw_internal_size;	/* Internal memory size */
+
+	struct omap_mbox *mbox;	/* Mail box handle */
 
 	/*
 	 * Processor specific info is set when prog loaded and read from DCD.
 	 * [See WMD_BRD_Ctrl()]  PROC info contains DSP-MMU TLB entries.
 	 */
 	/* DMMU TLB entries */
-	struct WMDIOCTL_EXTPROC aTLBEntry[WMDIOCTL_NUMOFMMUTLB];
-	u32 dwBrdState;			/* Last known board state. */
-	u32 ulIntMask;			/* int mask */
-	u16 ioBase;			/* Board I/O base */
-	u32 numTLBEntries;		/* DSP MMU TLB entry counter */
-	u32 fixedTLBEntries;		/* Fixed DSPMMU TLB entry count */
+	struct wmdioctl_extproc atlb_entry[WMDIOCTL_NUMOFMMUTLB];
+	u32 dw_brd_state;	/* Last known board state. */
+	u32 ul_int_mask;	/* int mask */
+	u16 io_base;		/* Board I/O base */
+	u32 num_tlb_entries;	/* DSP MMU TLB entry counter */
+	u32 fixed_tlb_entries;	/* Fixed DSPMMU TLB entry count */
 
 	/* TC Settings */
-	bool tcWordSwapOn;		/* Traffic Controller Word Swap */
-	struct PgTableAttrs *pPtAttrs;
-	u32 uDspPerClks;
-} ;
+	bool tc_word_swap_on;	/* Traffic Controller Word Swap */
+	struct pg_table_attrs *pt_attrs;
+	u32 dsp_per_clks;
+};
 
 	/*
-	 * ======== WMD_TLB_DspVAToMpuPA ========
+	 * ======== wmd_tlb_dsp_va_to_mpu_pa ========
 	 *     Given a DSP virtual address, traverse the page table and return
 	 *     a corresponding MPU physical address and size.
 	 */
-extern DSP_STATUS WMD_TLB_DspVAToMpuPA(struct WMD_DEV_CONTEXT *pDevContext,
-				       IN u32 ulVirtAddr,
-				       OUT u32 *ulPhysAddr,
-				       OUT u32 *sizeTlb);
+extern dsp_status wmd_tlb_dsp_va_to_mpu_pa(struct wmd_dev_context *dev_context,
+					   IN u32 ulVirtAddr,
+					   OUT u32 *ulPhysAddr,
+					   OUT u32 *sizeTlb);
 
 /*
  *  ======== sm_interrupt_dsp ========
@@ -370,15 +370,14 @@ extern DSP_STATUS WMD_TLB_DspVAToMpuPA(struct WMD_DEV_CONTEXT *pDevContext,
  *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
- *      wMbVal:         Value associated with interrupt(e.g. mailbox value).
+ *      mb_val:         Value associated with interrupt(e.g. mailbox value).
  *  Returns:
  *      DSP_SOK:        Interrupt sent;
  *      else:           Unable to send interrupt.
  *  Requires:
  *  Ensures:
  */
-       extern DSP_STATUS sm_interrupt_dsp(struct WMD_DEV_CONTEXT*
-						     hDevContext, u16 wMbVal);
-
-#endif				/* _TIOMAP_ */
+extern dsp_status sm_interrupt_dsp(struct wmd_dev_context *hDevContext,
+				   u16 mb_val);
 
+#endif /* _TIOMAP_ */
diff --git a/drivers/dsp/bridge/wmd/_tiomap_mmu.h b/drivers/dsp/bridge/wmd/_tiomap_mmu.h
index b605847..7af9e5e 100644
--- a/drivers/dsp/bridge/wmd/_tiomap_mmu.h
+++ b/drivers/dsp/bridge/wmd/_tiomap_mmu.h
@@ -22,20 +22,20 @@
 #include "_tiomap.h"
 
 /*
- *  ======== configureDspMmu ========
+ *  ======== configure_dsp_mmu ========
  *
  *  Make DSP MMu page table entries.
  *  Note: Not utilizing Coarse / Fine page tables.
  *  SECTION = 1MB, LARGE_PAGE = 64KB, SMALL_PAGE = 4KB, TINY_PAGE = 1KB.
  *  DSP Byte address 0x40_0000 is word addr 0x20_0000.
  */
-extern void configureDspMmu(struct WMD_DEV_CONTEXT *pDevContext,
-			    u32 dataBasePhys,
-			    u32 dspBaseVirt,
-			    u32 sizeInBytes,
-			    s32 nEntryStart,
-			    enum HW_Endianism_t endianism,
-			    enum HW_ElementSize_t elemSize,
-			    enum HW_MMUMixedSize_t mixedSize);
+extern void configure_dsp_mmu(struct wmd_dev_context *dev_context,
+			      u32 dataBasePhys,
+			      u32 dspBaseVirt,
+			      u32 sizeInBytes,
+			      s32 nEntryStart,
+			      enum hw_endianism_t endianism,
+			      enum hw_element_size_t elem_size,
+			      enum hw_mmu_mixed_size_t mixed_size);
 
-#endif				/* _TIOMAP_MMU_ */
+#endif /* _TIOMAP_MMU_ */
diff --git a/drivers/dsp/bridge/wmd/_tiomap_pwr.h b/drivers/dsp/bridge/wmd/_tiomap_pwr.h
index da2e7d9..a7a4fc2 100644
--- a/drivers/dsp/bridge/wmd/_tiomap_pwr.h
+++ b/drivers/dsp/bridge/wmd/_tiomap_pwr.h
@@ -20,74 +20,73 @@
 #define _TIOMAP_PWR_
 
 /*
- * ======== WakeDSP =========
+ * ======== wake_dsp =========
  * Wakes up the DSP from DeepSleep
  */
-extern DSP_STATUS WakeDSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+extern dsp_status wake_dsp(struct wmd_dev_context *dev_context, IN void *pargs);
 
 /*
- * ======== SleepDSP =========
+ * ======== sleep_dsp =========
  * Places the DSP in DeepSleep.
  */
-extern DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext,
-			   IN u32 dwCmd, IN void *pArgs);
+extern dsp_status sleep_dsp(struct wmd_dev_context *dev_context,
+			    IN u32 dw_cmd, IN void *pargs);
 /*
- *  ========InterruptDSP========
+ *  ========interrupt_dsp========
  *  	  Sends an interrupt to DSP unconditionally.
  */
-extern void InterruptDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u16 wMbVal);
+extern void interrupt_dsp(struct wmd_dev_context *dev_context, IN u16 mb_val);
 
 /*
- * ======== WakeDSP =========
+ * ======== wake_dsp =========
  * Wakes up the DSP from DeepSleep
  */
-extern DSP_STATUS DSPPeripheralClkCtrl(struct WMD_DEV_CONTEXT *pDevContext,
-				       IN void *pArgs);
+extern dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
+					  IN void *pargs);
 /*
- *  ======== handle_hibernation_fromDSP ========
+ *  ======== handle_hibernation_from_dsp ========
  *  	Handle Hibernation requested from DSP
  */
-DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext);
+dsp_status handle_hibernation_from_dsp(struct wmd_dev_context *dev_context);
 /*
- *  ======== PostScale_DSP ========
+ *  ======== post_scale_dsp ========
  *  	Handle Post Scale notification to DSP
  */
-DSP_STATUS PostScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+dsp_status post_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs);
 /*
- *  ======== PreScale_DSP ========
+ *  ======== pre_scale_dsp ========
  *  	Handle Pre Scale notification to DSP
  */
-DSP_STATUS PreScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+dsp_status pre_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs);
 /*
  *  ======== handle_constraints_set ========
  *  	Handle constraints request from DSP
  */
-DSP_STATUS handle_constraints_set(struct WMD_DEV_CONTEXT *pDevContext,
-				 IN void *pArgs);
+dsp_status handle_constraints_set(struct wmd_dev_context *dev_context,
+				  IN void *pargs);
 /*
- *  ======== DSP_PeripheralClocks_Disable ========
+ *  ======== dsp_peripheral_clocks_disable ========
  *  	This function disables all the peripheral clocks that
  *	were enabled by DSP. Call this function only when
  *	DSP is entering Hibernation or when DSP is in
  *	Error state
  */
-DSP_STATUS DSP_PeripheralClocks_Disable(struct WMD_DEV_CONTEXT *pDevContext,
-					IN void *pArgs);
+dsp_status dsp_peripheral_clocks_disable(struct wmd_dev_context *dev_context,
+					 IN void *pargs);
 
 /*
- *  ======== DSP_PeripheralClocks_Enable ========
+ *  ======== dsp_peripheral_clocks_enable ========
  *  	This function enables all the peripheral clocks that
  *	were requested by DSP.
  */
-DSP_STATUS DSP_PeripheralClocks_Enable(struct WMD_DEV_CONTEXT *pDevContext,
-				       IN void *pArgs);
+dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
+					IN void *pargs);
 
 /*
- *  ======== DSPClkWakeupEventCtrl ========
+ *  ======== dsp_clk_wakeup_event_ctrl ========
  *     This function sets the group selction bits for while
  *     enabling/disabling.
  */
-void DSPClkWakeupEventCtrl(u32 ClkId, bool enable);
-
-#endif				/* _TIOMAP_PWR_ */
+void dsp_clk_wakeup_event_ctrl(u32 ClkId, bool enable);
 
+#endif /* _TIOMAP_PWR_ */
diff --git a/drivers/dsp/bridge/wmd/_tiomap_util.h b/drivers/dsp/bridge/wmd/_tiomap_util.h
index 98fbbd4..e449946 100644
--- a/drivers/dsp/bridge/wmd/_tiomap_util.h
+++ b/drivers/dsp/bridge/wmd/_tiomap_util.h
@@ -19,7 +19,7 @@
 #ifndef _TIOMAP_UTIL_
 #define _TIOMAP_UTIL_
 
-/* Time out Values in uSeconds*/
+/* Time out Values in uSeconds */
 #define TIHELEN_ACKTIMEOUT  10000
 
 /*
@@ -32,12 +32,12 @@
 #define  WAIT_SAM   1000000	/* in usec (1000 millisec) */
 
 /*
- *  ======== WaitForStart ========
+ *  ======== wait_for_start ========
  *  Wait for the singal from DSP that it has started, or time out.
- *  The argument dwSyncAddr is set to 1 before releasing the DSP.
+ *  The argument dw_sync_addr is set to 1 before releasing the DSP.
  *  If the DSP starts running, it will clear this location.
  */
-extern bool WaitForStart(struct WMD_DEV_CONTEXT *pDevContext, u32 dwSyncAddr);
-
-#endif				/* _TIOMAP_UTIL_ */
+extern bool wait_for_start(struct wmd_dev_context *dev_context,
+			   u32 dw_sync_addr);
 
+#endif /* _TIOMAP_UTIL_ */
diff --git a/drivers/dsp/bridge/wmd/chnl_sm.c b/drivers/dsp/bridge/wmd/chnl_sm.c
index 77ed591..7894dfb 100644
--- a/drivers/dsp/bridge/wmd/chnl_sm.c
+++ b/drivers/dsp/bridge/wmd/chnl_sm.c
@@ -23,7 +23,7 @@
  *      Care is taken in this code to prevent simulataneous access to channel
  *      queues from
  *      1. Threads.
- *      2. IO_DPC(), scheduled from the IO_ISR() as an event.
+ *      2. io_dpc(), scheduled from the io_isr() as an event.
  *
  *      This is done primarily by:
  *      - Semaphores.
@@ -33,13 +33,13 @@
  *
  *  Channel Invariant:
  *      There is an important invariant condition which must be maintained per
- *      channel outside of WMD_CHNL_GetIOC() and IO_Dispatch(), violation of
- *      which may cause timeouts and/or failure offunction SYNC_WaitOnEvent.
+ *      channel outside of bridge_chnl_get_ioc() and IO_Dispatch(), violation of
+ *      which may cause timeouts and/or failure offunction sync_wait_on_event.
  *      This invariant condition is:
  *
- *          LST_Empty(pChnl->pIOCompletions) ==> pChnl->hSyncEvent is reset
+ *          LST_Empty(pchnl->pio_completions) ==> pchnl->sync_event is reset
  *      and
- *          !LST_Empty(pChnl->pIOCompletions) ==> pChnl->hSyncEvent is set.
+ *          !LST_Empty(pchnl->pio_completions) ==> pchnl->sync_event is set.
  */
 
 /*  ----------------------------------- OS */
@@ -75,87 +75,87 @@
 #define MAILBOX_IRQ INT_MAIL_MPU_IRQ
 
 /*  ----------------------------------- Function Prototypes */
-static struct LST_LIST *CreateChirpList(u32 uChirps);
+static struct lst_list *create_chirp_list(u32 uChirps);
 
-static void FreeChirpList(struct LST_LIST *pList);
+static void free_chirp_list(struct lst_list *pList);
 
-static struct CHNL_IRP *MakeNewChirp(void);
+static struct chnl_irp *make_new_chirp(void);
 
-static DSP_STATUS SearchFreeChannel(struct CHNL_MGR *pChnlMgr,
-				   OUT u32 *pdwChnl);
+static dsp_status search_free_channel(struct chnl_mgr *chnl_mgr_obj,
+				      OUT u32 *pdwChnl);
 
 /*
- *  ======== WMD_CHNL_AddIOReq ========
+ *  ======== bridge_chnl_add_io_req ========
  *      Enqueue an I/O request for data transfer on a channel to the DSP.
  *      The direction (mode) is specified in the channel object. Note the DSP
  *      address is specified for channels opened in direct I/O mode.
  */
-DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl, void *pHostBuf,
-			    u32 cBytes, u32 cBufSize,
-			    OPTIONAL u32 dwDspAddr, u32 dwArg)
+dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj, void *pHostBuf,
+			       u32 byte_size, u32 buf_size,
+			       OPTIONAL u32 dw_dsp_addr, u32 dw_arg)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	struct CHNL_IRP *pChirp = NULL;
-	struct WMD_DEV_CONTEXT *dev_ctxt;
-	struct DEV_OBJECT *dev_obj;
-	u32 dwState;
-	bool fIsEOS;
-	struct CHNL_MGR *pChnlMgr = pChnl->pChnlMgr;
-	u8 *pHostSysBuf = NULL;
-	bool fSchedDPC = false;
-	u16 wMbVal = 0;
-
-	fIsEOS = (cBytes == 0);
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
+	struct chnl_irp *chnl_packet_obj = NULL;
+	struct wmd_dev_context *dev_ctxt;
+	struct dev_object *dev_obj;
+	u32 dw_state;
+	bool is_eos;
+	struct chnl_mgr *chnl_mgr_obj = pchnl->chnl_mgr_obj;
+	u8 *host_sys_buf = NULL;
+	bool sched_dpc = false;
+	u16 mb_val = 0;
+
+	is_eos = (byte_size == 0);
 
 	/* Validate args:  */
 	if (pHostBuf == NULL) {
 		status = DSP_EPOINTER;
-	} else if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+	} else if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		status = DSP_EHANDLE;
-	} else if (fIsEOS && CHNL_IsInput(pChnl->uMode)) {
+	} else if (is_eos && CHNL_IS_INPUT(pchnl->chnl_mode)) {
 		status = CHNL_E_NOEOS;
 	} else {
 		/* Check the channel state: only queue chirp if channel state
 		 * allows */
-		dwState = pChnl->dwState;
-		if (dwState != CHNL_STATEREADY) {
-			if (dwState & CHNL_STATECANCEL)
+		dw_state = pchnl->dw_state;
+		if (dw_state != CHNL_STATEREADY) {
+			if (dw_state & CHNL_STATECANCEL)
 				status = CHNL_E_CANCELLED;
-			else if ((dwState & CHNL_STATEEOS)
-				   && CHNL_IsOutput(pChnl->uMode))
+			else if ((dw_state & CHNL_STATEEOS)
+				 && CHNL_IS_OUTPUT(pchnl->chnl_mode))
 				status = CHNL_E_EOS;
 			else
 				/* No other possible states left: */
-				DBC_Assert(0);
+				DBC_ASSERT(0);
 		}
 	}
 
-	dev_obj = DEV_GetFirst();
-	DEV_GetWMDContext(dev_obj, &dev_ctxt);
+	dev_obj = dev_get_first();
+	dev_get_wmd_context(dev_obj, &dev_ctxt);
 	if (!dev_ctxt)
 		status = DSP_EHANDLE;
 
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1 && pHostBuf) {
+	if (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1 && pHostBuf) {
 		if (!(pHostBuf < (void *)USERMODE_ADDR)) {
-			pHostSysBuf = pHostBuf;
+			host_sys_buf = pHostBuf;
 			goto func_cont;
 		}
 		/* if addr in user mode, then copy to kernel space */
-		pHostSysBuf = MEM_Alloc(cBufSize, MEM_NONPAGED);
-		if (pHostSysBuf == NULL) {
+		host_sys_buf = mem_alloc(buf_size, MEM_NONPAGED);
+		if (host_sys_buf == NULL) {
 			status = DSP_EMEMORY;
 			goto func_end;
 		}
-		if (CHNL_IsOutput(pChnl->uMode)) {
-			status = copy_from_user(pHostSysBuf, pHostBuf,
-						cBufSize);
+		if (CHNL_IS_OUTPUT(pchnl->chnl_mode)) {
+			status = copy_from_user(host_sys_buf, pHostBuf,
+						buf_size);
 			if (status) {
-				kfree(pHostSysBuf);
-				pHostSysBuf = NULL;
+				kfree(host_sys_buf);
+				host_sys_buf = NULL;
 				status = DSP_EPOINTER;
 				goto func_end;
 			}
@@ -164,258 +164,265 @@ DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl, void *pHostBuf,
 func_cont:
 	/* Mailbox IRQ is disabled to avoid race condition with DMA/ZCPY
 	 * channels. DPCCS is held to avoid race conditions with PCPY channels.
-	 * If DPC is scheduled in process context (IO_Schedule) and any
+	 * If DPC is scheduled in process context (iosm_schedule) and any
 	 * non-mailbox interrupt occurs, that DPC will run and break CS. Hence
-	 * we disable ALL DPCs. We will try to disable ONLY IO DPC later.  */
-	SYNC_EnterCS(pChnlMgr->hCSObj);
+	 * we disable ALL DPCs. We will try to disable ONLY IO DPC later. */
+	spin_lock_bh(&chnl_mgr_obj->chnl_mgr_lock);
 	omap_mbox_disable_irq(dev_ctxt->mbox, IRQ_RX);
-	if (pChnl->uChnlType == CHNL_PCPY) {
+	if (pchnl->chnl_type == CHNL_PCPY) {
 		/* This is a processor-copy channel. */
-		if (DSP_SUCCEEDED(status) && CHNL_IsOutput(pChnl->uMode)) {
+		if (DSP_SUCCEEDED(status) && CHNL_IS_OUTPUT(pchnl->chnl_mode)) {
 			/* Check buffer size on output channels for fit. */
-			if (cBytes > IO_BufSize(pChnl->pChnlMgr->hIOMgr))
+			if (byte_size >
+			    io_buf_size(pchnl->chnl_mgr_obj->hio_mgr))
 				status = CHNL_E_BUFSIZE;
 
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Get a free chirp: */
-		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pFreeList);
-		if (pChirp == NULL)
+		chnl_packet_obj =
+		    (struct chnl_irp *)lst_get_head(pchnl->free_packets_list);
+		if (chnl_packet_obj == NULL)
 			status = CHNL_E_NOIORPS;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Enqueue the chirp on the chnl's IORequest queue: */
-		pChirp->pHostUserBuf = pChirp->pHostSysBuf = pHostBuf;
-		if (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1)
-			pChirp->pHostSysBuf = pHostSysBuf;
+		chnl_packet_obj->host_user_buf = chnl_packet_obj->host_sys_buf =
+		    pHostBuf;
+		if (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1)
+			chnl_packet_obj->host_sys_buf = host_sys_buf;
 
 		/*
-		 * Note: for dma chans dwDspAddr contains dsp address
+		 * Note: for dma chans dw_dsp_addr contains dsp address
 		 * of SM buffer.
 		 */
-		DBC_Assert(pChnlMgr->uWordSize != 0);
+		DBC_ASSERT(chnl_mgr_obj->word_size != 0);
 		/* DSP address */
-		pChirp->uDspAddr = dwDspAddr / pChnlMgr->uWordSize;
-		pChirp->cBytes = cBytes;
-		pChirp->cBufSize = cBufSize;
+		chnl_packet_obj->dsp_tx_addr =
+		    dw_dsp_addr / chnl_mgr_obj->word_size;
+		chnl_packet_obj->byte_size = byte_size;
+		chnl_packet_obj->buf_size = buf_size;
 		/* Only valid for output channel */
-		pChirp->dwArg = dwArg;
-		pChirp->status = (fIsEOS ? CHNL_IOCSTATEOS :
-						CHNL_IOCSTATCOMPLETE);
-		LST_PutTail(pChnl->pIORequests, (struct list_head *)pChirp);
-		pChnl->cIOReqs++;
-		DBC_Assert(pChnl->cIOReqs <= pChnl->cChirps);
+		chnl_packet_obj->dw_arg = dw_arg;
+		chnl_packet_obj->status = (is_eos ? CHNL_IOCSTATEOS :
+					   CHNL_IOCSTATCOMPLETE);
+		lst_put_tail(pchnl->pio_requests,
+			     (struct list_head *)chnl_packet_obj);
+		pchnl->cio_reqs++;
+		DBC_ASSERT(pchnl->cio_reqs <= pchnl->chnl_packets);
 		/* If end of stream, update the channel state to prevent
 		 * more IOR's: */
-		if (fIsEOS)
-			pChnl->dwState |= CHNL_STATEEOS;
+		if (is_eos)
+			pchnl->dw_state |= CHNL_STATEEOS;
 
 		/* Legacy DSM Processor-Copy */
-		DBC_Assert(pChnl->uChnlType == CHNL_PCPY);
+		DBC_ASSERT(pchnl->chnl_type == CHNL_PCPY);
 		/* Request IO from the DSP */
-		IO_RequestChnl(pChnlMgr->hIOMgr, pChnl,
-			(CHNL_IsInput(pChnl->uMode) ? IO_INPUT : IO_OUTPUT),
-								&wMbVal);
-		fSchedDPC = true;
-
+		io_request_chnl(chnl_mgr_obj->hio_mgr, pchnl,
+				(CHNL_IS_INPUT(pchnl->chnl_mode) ? IO_INPUT :
+				 IO_OUTPUT), &mb_val);
+		sched_dpc = true;
 
 	}
 	omap_mbox_enable_irq(dev_ctxt->mbox, IRQ_RX);
-	SYNC_LeaveCS(pChnlMgr->hCSObj);
-	if (wMbVal != 0)
-		IO_IntrDSP2(pChnlMgr->hIOMgr, wMbVal);
+	spin_unlock_bh(&chnl_mgr_obj->chnl_mgr_lock);
+	if (mb_val != 0)
+		io_intr_dsp2(chnl_mgr_obj->hio_mgr, mb_val);
 
 	/* Schedule a DPC, to do the actual data transfer: */
-	if (fSchedDPC)
-		IO_Schedule(pChnlMgr->hIOMgr);
+	if (sched_dpc)
+		iosm_schedule(chnl_mgr_obj->hio_mgr);
 
 func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_CancelIO ========
+ *  ======== bridge_chnl_cancel_io ========
  *      Return all I/O requests to the client which have not yet been
  *      transferred.  The channel's I/O completion object is
  *      signalled, and all the I/O requests are queued as IOC's, with the
  *      status field set to CHNL_IOCSTATCANCEL.
  *      This call is typically used in abort situations, and is a prelude to
- *      CHNL_Close();
+ *      chnl_close();
  */
-DSP_STATUS WMD_CHNL_CancelIO(struct CHNL_OBJECT *hChnl)
+dsp_status bridge_chnl_cancel_io(struct chnl_object *chnl_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	u32 iChnl = -1;
-	short int uMode;
-	struct CHNL_IRP *pChirp;
-	struct CHNL_MGR *pChnlMgr = NULL;
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
+	u32 chnl_id = -1;
+	short int chnl_mode;
+	struct chnl_irp *chnl_packet_obj;
+	struct chnl_mgr *chnl_mgr_obj = NULL;
 
 	/* Check args: */
-	if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE) && pChnl->pChnlMgr) {
-		iChnl = pChnl->uId;
-		uMode = pChnl->uMode;
-		pChnlMgr = pChnl->pChnlMgr;
+	if (MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE) && pchnl->chnl_mgr_obj) {
+		chnl_id = pchnl->chnl_id;
+		chnl_mode = pchnl->chnl_mode;
+		chnl_mgr_obj = pchnl->chnl_mgr_obj;
 	} else {
 		status = DSP_EHANDLE;
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	 /*  Mark this channel as cancelled, to prevent further IORequests or
-	 *  IORequests or dispatching.  */
-	SYNC_EnterCS(pChnlMgr->hCSObj);
-	pChnl->dwState |= CHNL_STATECANCEL;
-	if (LST_IsEmpty(pChnl->pIORequests))
+	/*  Mark this channel as cancelled, to prevent further IORequests or
+	 *  IORequests or dispatching. */
+	spin_lock_bh(&chnl_mgr_obj->chnl_mgr_lock);
+	pchnl->dw_state |= CHNL_STATECANCEL;
+	if (LST_IS_EMPTY(pchnl->pio_requests))
 		goto func_cont;
 
-	if (pChnl->uChnlType == CHNL_PCPY) {
+	if (pchnl->chnl_type == CHNL_PCPY) {
 		/* Indicate we have no more buffers available for transfer: */
-		if (CHNL_IsInput(pChnl->uMode)) {
-			IO_CancelChnl(pChnlMgr->hIOMgr, iChnl);
+		if (CHNL_IS_INPUT(pchnl->chnl_mode)) {
+			io_cancel_chnl(chnl_mgr_obj->hio_mgr, chnl_id);
 		} else {
 			/* Record that we no longer have output buffers
 			 * available: */
-			pChnlMgr->dwOutputMask &= ~(1 << iChnl);
+			chnl_mgr_obj->dw_output_mask &= ~(1 << chnl_id);
 		}
 	}
-	/* Move all IOR's to IOC queue:  */
-	while (!LST_IsEmpty(pChnl->pIORequests)) {
-		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIORequests);
-		if (pChirp) {
-			pChirp->cBytes = 0;
-			pChirp->status |= CHNL_IOCSTATCANCEL;
-			LST_PutTail(pChnl->pIOCompletions,
-				   (struct list_head *)pChirp);
-			pChnl->cIOCs++;
-			pChnl->cIOReqs--;
-			DBC_Assert(pChnl->cIOReqs >= 0);
+	/* Move all IOR's to IOC queue: */
+	while (!LST_IS_EMPTY(pchnl->pio_requests)) {
+		chnl_packet_obj =
+		    (struct chnl_irp *)lst_get_head(pchnl->pio_requests);
+		if (chnl_packet_obj) {
+			chnl_packet_obj->byte_size = 0;
+			chnl_packet_obj->status |= CHNL_IOCSTATCANCEL;
+			lst_put_tail(pchnl->pio_completions,
+				     (struct list_head *)chnl_packet_obj);
+			pchnl->cio_cs++;
+			pchnl->cio_reqs--;
+			DBC_ASSERT(pchnl->cio_reqs >= 0);
 		}
 	}
 func_cont:
-		SYNC_LeaveCS(pChnlMgr->hCSObj);
+	spin_unlock_bh(&chnl_mgr_obj->chnl_mgr_lock);
 func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_Close ========
+ *  ======== bridge_chnl_close ========
  *  Purpose:
  *      Ensures all pending I/O on this channel is cancelled, discards all
  *      queued I/O completion notifications, then frees the resources allocated
  *      for this channel, and makes the corresponding logical channel id
  *      available for subsequent use.
  */
-DSP_STATUS WMD_CHNL_Close(struct CHNL_OBJECT *hChnl)
+dsp_status bridge_chnl_close(struct chnl_object *chnl_obj)
 {
-	DSP_STATUS status;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	dsp_status status;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
 
 	/* Check args: */
-	if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_cont;
 	}
 	{
 		/* Cancel IO: this ensures no further IO requests or
-		 * notifications.*/
-		status = WMD_CHNL_CancelIO(hChnl);
+		 * notifications. */
+		status = bridge_chnl_cancel_io(chnl_obj);
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status)) {
 		/* Assert I/O on this channel is now cancelled: Protects
-		 * from IO_DPC. */
-		DBC_Assert((pChnl->dwState & CHNL_STATECANCEL));
+		 * from io_dpc. */
+		DBC_ASSERT((pchnl->dw_state & CHNL_STATECANCEL));
 		/* Invalidate channel object: Protects from
 		 * CHNL_GetIOCompletion(). */
-		pChnl->dwSignature = 0x0000;
+		pchnl->dw_signature = 0x0000;
 		/* Free the slot in the channel manager: */
-		pChnl->pChnlMgr->apChannel[pChnl->uId] = NULL;
-		pChnl->pChnlMgr->cOpenChannels -= 1;
-		if (pChnl->hNtfy) {
-			NTFY_Delete(pChnl->hNtfy);
-			pChnl->hNtfy = NULL;
+		pchnl->chnl_mgr_obj->ap_channel[pchnl->chnl_id] = NULL;
+		spin_lock_bh(&pchnl->chnl_mgr_obj->chnl_mgr_lock);
+		pchnl->chnl_mgr_obj->open_channels -= 1;
+		spin_unlock_bh(&pchnl->chnl_mgr_obj->chnl_mgr_lock);
+		if (pchnl->ntfy_obj) {
+			ntfy_delete(pchnl->ntfy_obj);
+			kfree(pchnl->ntfy_obj);
+			pchnl->ntfy_obj = NULL;
 		}
-		/* Reset channel event: (NOTE: hUserEvent freed in user
+		/* Reset channel event: (NOTE: user_event freed in user
 		 * context.). */
-		if (pChnl->hSyncEvent) {
-			SYNC_ResetEvent(pChnl->hSyncEvent);
-			SYNC_CloseEvent(pChnl->hSyncEvent);
-			pChnl->hSyncEvent = NULL;
+		if (pchnl->sync_event) {
+			sync_reset_event(pchnl->sync_event);
+			kfree(pchnl->sync_event);
+			pchnl->sync_event = NULL;
 		}
-		/* Free I/O request and I/O completion queues:  */
-		if (pChnl->pIOCompletions) {
-			FreeChirpList(pChnl->pIOCompletions);
-			pChnl->pIOCompletions = NULL;
-			pChnl->cIOCs = 0;
+		/* Free I/O request and I/O completion queues: */
+		if (pchnl->pio_completions) {
+			free_chirp_list(pchnl->pio_completions);
+			pchnl->pio_completions = NULL;
+			pchnl->cio_cs = 0;
 		}
-		if (pChnl->pIORequests) {
-			FreeChirpList(pChnl->pIORequests);
-			pChnl->pIORequests = NULL;
-			pChnl->cIOReqs = 0;
+		if (pchnl->pio_requests) {
+			free_chirp_list(pchnl->pio_requests);
+			pchnl->pio_requests = NULL;
+			pchnl->cio_reqs = 0;
 		}
-		if (pChnl->pFreeList) {
-			FreeChirpList(pChnl->pFreeList);
-			pChnl->pFreeList = NULL;
+		if (pchnl->free_packets_list) {
+			free_chirp_list(pchnl->free_packets_list);
+			pchnl->free_packets_list = NULL;
 		}
 		/* Release channel object. */
-		MEM_FreeObject(pChnl);
-		pChnl = NULL;
+		MEM_FREE_OBJECT(pchnl);
+		pchnl = NULL;
 	}
-	DBC_Ensure(DSP_FAILED(status) ||
-		  !MEM_IsValidHandle(pChnl, CHNL_SIGNATURE));
+	DBC_ENSURE(DSP_FAILED(status) ||
+		   !MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE));
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_Create ========
+ *  ======== bridge_chnl_create ========
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given board.
  */
-DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-			  struct DEV_OBJECT *hDevObject,
-			  IN CONST struct CHNL_MGRATTRS *pMgrAttrs)
+dsp_status bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
+			      struct dev_object *hdev_obj,
+			      IN CONST struct chnl_mgrattrs *pMgrAttrs)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR *pChnlMgr = NULL;
-	s32 cChannels;
+	dsp_status status = DSP_SOK;
+	struct chnl_mgr *chnl_mgr_obj = NULL;
+	s32 max_channels;
 
-	/* Check DBC requirements:  */
-	DBC_Require(phChnlMgr != NULL);
-	DBC_Require(pMgrAttrs != NULL);
-	DBC_Require(pMgrAttrs->cChannels > 0);
-	DBC_Require(pMgrAttrs->cChannels <= CHNL_MAXCHANNELS);
-	DBC_Require(pMgrAttrs->uWordSize != 0);
+	/* Check DBC requirements: */
+	DBC_REQUIRE(phChnlMgr != NULL);
+	DBC_REQUIRE(pMgrAttrs != NULL);
+	DBC_REQUIRE(pMgrAttrs->max_channels > 0);
+	DBC_REQUIRE(pMgrAttrs->max_channels <= CHNL_MAXCHANNELS);
+	DBC_REQUIRE(pMgrAttrs->word_size != 0);
 
 	/* Allocate channel manager object: */
-	MEM_AllocObject(pChnlMgr, struct CHNL_MGR, CHNL_MGRSIGNATURE);
-	if (pChnlMgr) {
-		/* The cChannels attr must equal the # of supported
+	MEM_ALLOC_OBJECT(chnl_mgr_obj, struct chnl_mgr, CHNL_MGRSIGNATURE);
+	if (chnl_mgr_obj) {
+		/* The max_channels attr must equal the # of supported
 		 * chnls for each transport(# chnls for PCPY = DDMA =
-		 * ZCPY): i.e. pMgrAttrs->cChannels = CHNL_MAXCHANNELS =
+		 * ZCPY): i.e. pMgrAttrs->max_channels = CHNL_MAXCHANNELS =
 		 * DDMA_MAXDDMACHNLS = DDMA_MAXZCPYCHNLS.  */
-		DBC_Assert(pMgrAttrs->cChannels == CHNL_MAXCHANNELS);
-		cChannels = CHNL_MAXCHANNELS + CHNL_MAXCHANNELS * CHNL_PCPY;
+		DBC_ASSERT(pMgrAttrs->max_channels == CHNL_MAXCHANNELS);
+		max_channels = CHNL_MAXCHANNELS + CHNL_MAXCHANNELS * CHNL_PCPY;
 		/* Create array of channels: */
-		pChnlMgr->apChannel = MEM_Calloc(
-				sizeof(struct CHNL_OBJECT *) *
-				cChannels, MEM_NONPAGED);
-		if (pChnlMgr->apChannel) {
-			/* Initialize CHNL_MGR object: */
+		chnl_mgr_obj->ap_channel =
+		    mem_calloc(sizeof(struct chnl_object *) * max_channels,
+			       MEM_NONPAGED);
+		if (chnl_mgr_obj->ap_channel) {
+			/* Initialize chnl_mgr object: */
 			/* Shared memory driver. */
-			pChnlMgr->dwType = CHNL_TYPESM;
-			pChnlMgr->uWordSize = pMgrAttrs->uWordSize;
+			chnl_mgr_obj->dw_type = CHNL_TYPESM;
+			chnl_mgr_obj->word_size = pMgrAttrs->word_size;
 			/* total # chnls supported */
-			pChnlMgr->cChannels = cChannels;
-			pChnlMgr->cOpenChannels = 0;
-			pChnlMgr->dwOutputMask = 0;
-			pChnlMgr->dwLastOutput = 0;
-			pChnlMgr->hDevObject = hDevObject;
+			chnl_mgr_obj->max_channels = max_channels;
+			chnl_mgr_obj->open_channels = 0;
+			chnl_mgr_obj->dw_output_mask = 0;
+			chnl_mgr_obj->dw_last_output = 0;
+			chnl_mgr_obj->hdev_obj = hdev_obj;
 			if (DSP_SUCCEEDED(status))
-				status = SYNC_InitializeDPCCS(
-							&pChnlMgr->hCSObj);
+				spin_lock_init(&chnl_mgr_obj->chnl_mgr_lock);
 		} else {
 			status = DSP_EMEMORY;
 		}
@@ -424,45 +431,45 @@ DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
 	}
 
 	if (DSP_FAILED(status)) {
-		WMD_CHNL_Destroy(pChnlMgr);
+		bridge_chnl_destroy(chnl_mgr_obj);
 		*phChnlMgr = NULL;
 	} else {
 		/* Return channel manager object to caller... */
-		*phChnlMgr = pChnlMgr;
+		*phChnlMgr = chnl_mgr_obj;
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_Destroy ========
+ *  ======== bridge_chnl_destroy ========
  *  Purpose:
  *      Close all open channels, and destroy the channel manager.
  */
-DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr)
+dsp_status bridge_chnl_destroy(struct chnl_mgr *hchnl_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR *pChnlMgr = hChnlMgr;
-	u32 iChnl;
+	dsp_status status = DSP_SOK;
+	struct chnl_mgr *chnl_mgr_obj = hchnl_mgr;
+	u32 chnl_id;
 
-	if (MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(hchnl_mgr, CHNL_MGRSIGNATURE)) {
 		/* Close all open channels: */
-		for (iChnl = 0; iChnl < pChnlMgr->cChannels; iChnl++) {
-			status = WMD_CHNL_Close(pChnlMgr->apChannel[iChnl]);
+		for (chnl_id = 0; chnl_id < chnl_mgr_obj->max_channels;
+		     chnl_id++) {
+			status =
+			    bridge_chnl_close(chnl_mgr_obj->ap_channel
+					      [chnl_id]);
 			if (DSP_FAILED(status))
 				dev_dbg(bridge, "%s: Error status 0x%x\n",
-							__func__, status);
+					__func__, status);
 		}
-		/* release critical section */
-		if (pChnlMgr->hCSObj)
-			SYNC_DeleteCS(pChnlMgr->hCSObj);
 
 		/* Free channel manager object: */
-		kfree(pChnlMgr->apChannel);
+		kfree(chnl_mgr_obj->ap_channel);
 
-		/* Set hChnlMgr to NULL in device object. */
-		DEV_SetChnlMgr(pChnlMgr->hDevObject, NULL);
+		/* Set hchnl_mgr to NULL in device object. */
+		dev_set_chnl_mgr(chnl_mgr_obj->hdev_obj, NULL);
 		/* Free this Chnl Mgr object: */
-		MEM_FreeObject(hChnlMgr);
+		MEM_FREE_OBJECT(hchnl_mgr);
 	} else {
 		status = DSP_EHANDLE;
 	}
@@ -470,25 +477,25 @@ DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr)
 }
 
 /*
- *  ======== WMD_CHNL_FlushIO ========
+ *  ======== bridge_chnl_flush_io ========
  *  purpose:
  *      Flushes all the outstanding data requests on a channel.
  */
-DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl, u32 dwTimeOut)
+dsp_status bridge_chnl_flush_io(struct chnl_object *chnl_obj, u32 dwTimeOut)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	short int uMode = -1;
-	struct CHNL_MGR *pChnlMgr;
-	struct CHNL_IOC chnlIOC;
-	/* Check args:  */
-	if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
+	short int chnl_mode = -1;
+	struct chnl_mgr *chnl_mgr_obj;
+	struct chnl_ioc chnl_ioc_obj;
+	/* Check args: */
+	if (MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		if ((dwTimeOut == CHNL_IOCNOWAIT)
-		    && CHNL_IsOutput(pChnl->uMode)) {
+		    && CHNL_IS_OUTPUT(pchnl->chnl_mode)) {
 			status = DSP_EINVALIDARG;
 		} else {
-			uMode = pChnl->uMode;
-			pChnlMgr = pChnl->pChnlMgr;
+			chnl_mode = pchnl->chnl_mode;
+			chnl_mgr_obj = pchnl->chnl_mgr_obj;
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -496,54 +503,55 @@ DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl, u32 dwTimeOut)
 	if (DSP_SUCCEEDED(status)) {
 		/* Note: Currently, if another thread continues to add IO
 		 * requests to this channel, this function will continue to
-		 * flush all such queued IO requests.  */
-		if (CHNL_IsOutput(uMode) && (pChnl->uChnlType == CHNL_PCPY)) {
+		 * flush all such queued IO requests. */
+		if (CHNL_IS_OUTPUT(chnl_mode)
+		    && (pchnl->chnl_type == CHNL_PCPY)) {
 			/* Wait for IO completions, up to the specified
 			 * timeout: */
-			while (!LST_IsEmpty(pChnl->pIORequests) &&
-			      DSP_SUCCEEDED(status)) {
-				status = WMD_CHNL_GetIOC(hChnl, dwTimeOut,
-							 &chnlIOC);
+			while (!LST_IS_EMPTY(pchnl->pio_requests) &&
+			       DSP_SUCCEEDED(status)) {
+				status = bridge_chnl_get_ioc(chnl_obj, dwTimeOut,
+							  &chnl_ioc_obj);
 				if (DSP_FAILED(status))
 					continue;
 
-				if (chnlIOC.status & CHNL_IOCSTATTIMEOUT)
+				if (chnl_ioc_obj.status & CHNL_IOCSTATTIMEOUT)
 					status = CHNL_E_WAITTIMEOUT;
 
 			}
 		} else {
-			status = WMD_CHNL_CancelIO(hChnl);
+			status = bridge_chnl_cancel_io(chnl_obj);
 			/* Now, leave the channel in the ready state: */
-			pChnl->dwState &= ~CHNL_STATECANCEL;
+			pchnl->dw_state &= ~CHNL_STATECANCEL;
 		}
 	}
-	DBC_Ensure(DSP_FAILED(status) || LST_IsEmpty(pChnl->pIORequests));
+	DBC_ENSURE(DSP_FAILED(status) || LST_IS_EMPTY(pchnl->pio_requests));
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_GetInfo ========
+ *  ======== bridge_chnl_get_info ========
  *  Purpose:
  *      Retrieve information related to a channel.
  */
-DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
-			   OUT struct CHNL_INFO *pInfo)
+dsp_status bridge_chnl_get_info(struct chnl_object *chnl_obj,
+			     OUT struct chnl_info *pInfo)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
 	if (pInfo != NULL) {
-		if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
-			/* Return the requested information:  */
-			pInfo->hChnlMgr = pChnl->pChnlMgr;
-			pInfo->hEvent = pChnl->hUserEvent;
-			pInfo->dwID = pChnl->uId;
-			pInfo->dwMode = pChnl->uMode;
-			pInfo->cPosition = pChnl->cBytesMoved;
-			pInfo->hProcess = pChnl->hProcess;
-			pInfo->hSyncEvent = pChnl->hSyncEvent;
-			pInfo->cIOCs = pChnl->cIOCs;
-			pInfo->cIOReqs = pChnl->cIOReqs;
-			pInfo->dwState = pChnl->dwState;
+		if (MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
+			/* Return the requested information: */
+			pInfo->hchnl_mgr = pchnl->chnl_mgr_obj;
+			pInfo->event_obj = pchnl->user_event;
+			pInfo->cnhl_id = pchnl->chnl_id;
+			pInfo->dw_mode = pchnl->chnl_mode;
+			pInfo->bytes_tx = pchnl->bytes_moved;
+			pInfo->process = pchnl->process;
+			pInfo->sync_event = pchnl->sync_event;
+			pInfo->cio_cs = pchnl->cio_cs;
+			pInfo->cio_reqs = pchnl->cio_reqs;
+			pInfo->dw_state = pchnl->dw_state;
 		} else {
 			status = DSP_EHANDLE;
 		}
@@ -554,38 +562,38 @@ DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
 }
 
 /*
- *  ======== WMD_CHNL_GetIOC ========
+ *  ======== bridge_chnl_get_ioc ========
  *      Optionally wait for I/O completion on a channel.  Dequeue an I/O
  *      completion record, which contains information about the completed
  *      I/O request.
  *      Note: Ensures Channel Invariant (see notes above).
  */
-DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
-			  OUT struct CHNL_IOC *pIOC)
+dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj, u32 dwTimeOut,
+			    OUT struct chnl_ioc *pIOC)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	struct CHNL_IRP *pChirp;
-	DSP_STATUS statSync;
-	bool fDequeueIOC = true;
-	struct CHNL_IOC ioc = { NULL, 0, 0, 0, 0 };
-	u8 *pHostSysBuf = NULL;
-	struct WMD_DEV_CONTEXT *dev_ctxt;
-	struct DEV_OBJECT *dev_obj;
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
+	struct chnl_irp *chnl_packet_obj;
+	dsp_status stat_sync;
+	bool dequeue_ioc = true;
+	struct chnl_ioc ioc = { NULL, 0, 0, 0, 0 };
+	u8 *host_sys_buf = NULL;
+	struct wmd_dev_context *dev_ctxt;
+	struct dev_object *dev_obj;
 
 	/* Check args: */
 	if (pIOC == NULL) {
 		status = DSP_EPOINTER;
-	} else if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+	} else if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else if (dwTimeOut == CHNL_IOCNOWAIT) {
-		if (LST_IsEmpty(pChnl->pIOCompletions))
+		if (LST_IS_EMPTY(pchnl->pio_completions))
 			status = CHNL_E_NOIOC;
 
 	}
 
-	dev_obj = DEV_GetFirst();
-	DEV_GetWMDContext(dev_obj, &dev_ctxt);
+	dev_obj = dev_get_first();
+	dev_get_wmd_context(dev_obj, &dev_ctxt);
 	if (!dev_ctxt)
 		status = DSP_EHANDLE;
 
@@ -593,95 +601,98 @@ DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
 		goto func_end;
 
 	ioc.status = CHNL_IOCSTATCOMPLETE;
-	if (dwTimeOut != CHNL_IOCNOWAIT && LST_IsEmpty(pChnl->pIOCompletions)) {
+	if (dwTimeOut !=
+	    CHNL_IOCNOWAIT && LST_IS_EMPTY(pchnl->pio_completions)) {
 		if (dwTimeOut == CHNL_IOCINFINITE)
 			dwTimeOut = SYNC_INFINITE;
 
-		statSync = SYNC_WaitOnEvent(pChnl->hSyncEvent, dwTimeOut);
-		if (statSync == DSP_ETIMEOUT) {
+		stat_sync = sync_wait_on_event(pchnl->sync_event, dwTimeOut);
+		if (stat_sync == DSP_ETIMEOUT) {
 			/* No response from DSP */
 			ioc.status |= CHNL_IOCSTATTIMEOUT;
-			fDequeueIOC = false;
-		} else if (statSync == DSP_EFAIL) {
+			dequeue_ioc = false;
+		} else if (stat_sync == DSP_EFAIL) {
 			/* This can occur when the user mode thread is
 			 * aborted (^C), or when _VWIN32_WaitSingleObject()
-			 * fails due to unkown causes.  */
+			 * fails due to unkown causes. */
 			/* Even though Wait failed, there may be something in
 			 * the Q: */
-			if (LST_IsEmpty(pChnl->pIOCompletions)) {
+			if (LST_IS_EMPTY(pchnl->pio_completions)) {
 				ioc.status |= CHNL_IOCSTATCANCEL;
-				fDequeueIOC = false;
+				dequeue_ioc = false;
 			}
 		}
 	}
 	/* See comment in AddIOReq */
-	SYNC_EnterCS(pChnl->pChnlMgr->hCSObj);
+	spin_lock_bh(&pchnl->chnl_mgr_obj->chnl_mgr_lock);
 	omap_mbox_disable_irq(dev_ctxt->mbox, IRQ_RX);
-	if (fDequeueIOC) {
+	if (dequeue_ioc) {
 		/* Dequeue IOC and set pIOC; */
-		DBC_Assert(!LST_IsEmpty(pChnl->pIOCompletions));
-		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIOCompletions);
+		DBC_ASSERT(!LST_IS_EMPTY(pchnl->pio_completions));
+		chnl_packet_obj =
+		    (struct chnl_irp *)lst_get_head(pchnl->pio_completions);
 		/* Update pIOC from channel state and chirp: */
-		if (pChirp) {
-			pChnl->cIOCs--;
-			/*  If this is a zero-copy channel, then set IOC's pBuf
+		if (chnl_packet_obj) {
+			pchnl->cio_cs--;
+			/*  If this is a zero-copy channel, then set IOC's pbuf
 			 *  to the DSP's address. This DSP address will get
-			 *  translated to user's virtual addr later.  */
+			 *  translated to user's virtual addr later. */
 			{
-				pHostSysBuf = pChirp->pHostSysBuf;
-				ioc.pBuf = pChirp->pHostUserBuf;
+				host_sys_buf = chnl_packet_obj->host_sys_buf;
+				ioc.pbuf = chnl_packet_obj->host_user_buf;
 			}
-			ioc.cBytes = pChirp->cBytes;
-			ioc.cBufSize = pChirp->cBufSize;
-			ioc.dwArg = pChirp->dwArg;
-			ioc.status |= pChirp->status;
+			ioc.byte_size = chnl_packet_obj->byte_size;
+			ioc.buf_size = chnl_packet_obj->buf_size;
+			ioc.dw_arg = chnl_packet_obj->dw_arg;
+			ioc.status |= chnl_packet_obj->status;
 			/* Place the used chirp on the free list: */
-			LST_PutTail(pChnl->pFreeList,
-					(struct list_head *)pChirp);
+			lst_put_tail(pchnl->free_packets_list,
+				     (struct list_head *)chnl_packet_obj);
 		} else {
-			ioc.pBuf = NULL;
-			ioc.cBytes = 0;
+			ioc.pbuf = NULL;
+			ioc.byte_size = 0;
 		}
 	} else {
-		ioc.pBuf = NULL;
-		ioc.cBytes = 0;
-		ioc.dwArg = 0;
-		ioc.cBufSize = 0;
+		ioc.pbuf = NULL;
+		ioc.byte_size = 0;
+		ioc.dw_arg = 0;
+		ioc.buf_size = 0;
 	}
 	/* Ensure invariant: If any IOC's are queued for this channel... */
-	if (!LST_IsEmpty(pChnl->pIOCompletions)) {
+	if (!LST_IS_EMPTY(pchnl->pio_completions)) {
 		/*  Since DSPStream_Reclaim() does not take a timeout
 		 *  parameter, we pass the stream's timeout value to
-		 *  WMD_CHNL_GetIOC. We cannot determine whether or not
+		 *  bridge_chnl_get_ioc. We cannot determine whether or not
 		 *  we have waited in User mode. Since the stream's timeout
 		 *  value may be non-zero, we still have to set the event.
 		 *  Therefore, this optimization is taken out.
 		 *
 		 *  if (dwTimeOut == CHNL_IOCNOWAIT) {
 		 *    ... ensure event is set..
-		 *      SYNC_SetEvent(pChnl->hSyncEvent);
+		 *      sync_set_event(pchnl->sync_event);
 		 *  } */
-		SYNC_SetEvent(pChnl->hSyncEvent);
+		sync_set_event(pchnl->sync_event);
 	} else {
 		/* else, if list is empty, ensure event is reset. */
-		SYNC_ResetEvent(pChnl->hSyncEvent);
+		sync_reset_event(pchnl->sync_event);
 	}
 	omap_mbox_enable_irq(dev_ctxt->mbox, IRQ_RX);
-	SYNC_LeaveCS(pChnl->pChnlMgr->hCSObj);
-	if (fDequeueIOC && (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1)) {
-		if (!(ioc.pBuf < (void *) USERMODE_ADDR))
+	spin_unlock_bh(&pchnl->chnl_mgr_obj->chnl_mgr_lock);
+	if (dequeue_ioc
+	    && (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1)) {
+		if (!(ioc.pbuf < (void *)USERMODE_ADDR))
 			goto func_cont;
 
 		/* If the addr is in user mode, then copy it */
-		if (!pHostSysBuf || !ioc.pBuf) {
+		if (!host_sys_buf || !ioc.pbuf) {
 			status = DSP_EPOINTER;
 			goto func_cont;
 		}
-		if (!CHNL_IsInput(pChnl->uMode))
+		if (!CHNL_IS_INPUT(pchnl->chnl_mode))
 			goto func_cont1;
 
-		/*pHostUserBuf */
-		status = copy_to_user(ioc.pBuf, pHostSysBuf, ioc.cBytes);
+		/*host_user_buf */
+		status = copy_to_user(ioc.pbuf, host_sys_buf, ioc.byte_size);
 		if (status) {
 			if (current->flags & PF_EXITING)
 				status = 0;
@@ -689,7 +700,7 @@ DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
 		if (status)
 			status = DSP_EPOINTER;
 func_cont1:
-		kfree(pHostSysBuf);
+		kfree(host_sys_buf);
 	}
 func_cont:
 	/* Update User's IOC block: */
@@ -699,25 +710,27 @@ func_end:
 }
 
 /*
- *  ======== WMD_CHNL_GetMgrInfo ========
+ *  ======== bridge_chnl_get_mgr_info ========
  *      Retrieve information related to the channel manager.
  */
-DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr, u32 uChnlID,
-			      OUT struct CHNL_MGRINFO *pMgrInfo)
+dsp_status bridge_chnl_get_mgr_info(struct chnl_mgr *hchnl_mgr, u32 uChnlID,
+				 OUT struct chnl_mgrinfo *pMgrInfo)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR *pChnlMgr = (struct CHNL_MGR *)hChnlMgr;
+	dsp_status status = DSP_SOK;
+	struct chnl_mgr *chnl_mgr_obj = (struct chnl_mgr *)hchnl_mgr;
 
 	if (pMgrInfo != NULL) {
 		if (uChnlID <= CHNL_MAXCHANNELS) {
-			if (MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
-				/* Return the requested information:  */
-				pMgrInfo->hChnl = pChnlMgr->apChannel[uChnlID];
-				pMgrInfo->cOpenChannels = pChnlMgr->
-							  cOpenChannels;
-				pMgrInfo->dwType = pChnlMgr->dwType;
+			if (MEM_IS_VALID_HANDLE(hchnl_mgr, CHNL_MGRSIGNATURE)) {
+				/* Return the requested information: */
+				pMgrInfo->chnl_obj =
+				    chnl_mgr_obj->ap_channel[uChnlID];
+				pMgrInfo->open_channels =
+				    chnl_mgr_obj->open_channels;
+				pMgrInfo->dw_type = chnl_mgr_obj->dw_type;
 				/* total # of chnls */
-				pMgrInfo->cChannels = pChnlMgr->cChannels;
+				pMgrInfo->max_channels =
+				    chnl_mgr_obj->max_channels;
 			} else {
 				status = DSP_EHANDLE;
 			}
@@ -732,111 +745,122 @@ DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr, u32 uChnlID,
 }
 
 /*
- *  ======== WMD_CHNL_Idle ========
+ *  ======== bridge_chnl_idle ========
  *      Idles a particular channel.
  */
-DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
-			 bool fFlush)
+dsp_status bridge_chnl_idle(struct chnl_object *chnl_obj, u32 dwTimeOut,
+			    bool fFlush)
 {
-	short int uMode;
-	struct CHNL_MGR *pChnlMgr;
-	DSP_STATUS status = DSP_SOK;
+	short int chnl_mode;
+	struct chnl_mgr *chnl_mgr_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(hChnl, CHNL_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(chnl_obj, CHNL_SIGNATURE));
 
-	uMode = hChnl->uMode;
-	pChnlMgr = hChnl->pChnlMgr;
+	chnl_mode = chnl_obj->chnl_mode;
+	chnl_mgr_obj = chnl_obj->chnl_mgr_obj;
 
-	if (CHNL_IsOutput(uMode) && !fFlush) {
+	if (CHNL_IS_OUTPUT(chnl_mode) && !fFlush) {
 		/* Wait for IO completions, up to the specified timeout: */
-		status = WMD_CHNL_FlushIO(hChnl, dwTimeOut);
+		status = bridge_chnl_flush_io(chnl_obj, dwTimeOut);
 	} else {
-		status = WMD_CHNL_CancelIO(hChnl);
+		status = bridge_chnl_cancel_io(chnl_obj);
 
 		/* Reset the byte count and put channel back in ready state. */
-		hChnl->cBytesMoved = 0;
-		hChnl->dwState &= ~CHNL_STATECANCEL;
+		chnl_obj->bytes_moved = 0;
+		chnl_obj->dw_state &= ~CHNL_STATECANCEL;
 	}
 
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_Open ========
+ *  ======== bridge_chnl_open ========
  *      Open a new half-duplex channel to the DSP board.
  */
-DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
-			 struct CHNL_MGR *hChnlMgr, short int uMode,
-			 u32 uChnlId, CONST IN struct CHNL_ATTRS *pAttrs)
+dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
+			    struct chnl_mgr *hchnl_mgr, short int chnl_mode,
+			    u32 uChnlId, CONST IN struct chnl_attr *pattrs)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR *pChnlMgr = hChnlMgr;
-	struct CHNL_OBJECT *pChnl = NULL;
-	struct SYNC_ATTRS *pSyncAttrs = NULL;
-	struct SYNC_OBJECT *hSyncEvent = NULL;
-	/* Ensure DBC requirements:  */
-	DBC_Require(phChnl != NULL);
-	DBC_Require(pAttrs != NULL);
-	DBC_Require(hChnlMgr != NULL);
+	dsp_status status = DSP_SOK;
+	struct chnl_mgr *chnl_mgr_obj = hchnl_mgr;
+	struct chnl_object *pchnl = NULL;
+	struct sync_object *sync_event = NULL;
+	/* Ensure DBC requirements: */
+	DBC_REQUIRE(phChnl != NULL);
+	DBC_REQUIRE(pattrs != NULL);
+	DBC_REQUIRE(hchnl_mgr != NULL);
 	*phChnl = NULL;
 
-	/* Validate Args:  */
-	if (pAttrs->uIOReqs == 0) {
+	/* Validate Args: */
+	if (pattrs->uio_reqs == 0) {
 		status = DSP_EINVALIDARG;
 	} else {
-		if (!MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
+		if (!MEM_IS_VALID_HANDLE(hchnl_mgr, CHNL_MGRSIGNATURE)) {
 			status = DSP_EHANDLE;
 		} else {
 			if (uChnlId != CHNL_PICKFREE) {
-				if (uChnlId >= pChnlMgr->cChannels)
+				if (uChnlId >= chnl_mgr_obj->max_channels)
 					status = CHNL_E_BADCHANID;
-				else if (pChnlMgr->apChannel[uChnlId] !=
-					  NULL)
+				else if (chnl_mgr_obj->ap_channel[uChnlId] !=
+					 NULL)
 					status = CHNL_E_CHANBUSY;
 			} else {
 				/* Check for free channel */
-				status = SearchFreeChannel(pChnlMgr, &uChnlId);
+				status =
+				    search_free_channel(chnl_mgr_obj, &uChnlId);
 			}
 		}
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	DBC_Assert(uChnlId < pChnlMgr->cChannels);
-	/* Create channel object:  */
-	MEM_AllocObject(pChnl, struct CHNL_OBJECT, 0x0000);
-	if (!pChnl) {
+	DBC_ASSERT(uChnlId < chnl_mgr_obj->max_channels);
+	/* Create channel object: */
+	MEM_ALLOC_OBJECT(pchnl, struct chnl_object, 0x0000);
+	if (!pchnl) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	/* Protect queues from IO_DPC: */
-	pChnl->dwState = CHNL_STATECANCEL;
+	/* Protect queues from io_dpc: */
+	pchnl->dw_state = CHNL_STATECANCEL;
 	/* Allocate initial IOR and IOC queues: */
-	pChnl->pFreeList = CreateChirpList(pAttrs->uIOReqs);
-	pChnl->pIORequests = CreateChirpList(0);
-	pChnl->pIOCompletions = CreateChirpList(0);
-	pChnl->cChirps = pAttrs->uIOReqs;
-	pChnl->cIOCs = 0;
-	pChnl->cIOReqs = 0;
-	status = SYNC_OpenEvent(&hSyncEvent, pSyncAttrs);
-	if (DSP_SUCCEEDED(status))
-		status = NTFY_Create(&pChnl->hNtfy);
+	pchnl->free_packets_list = create_chirp_list(pattrs->uio_reqs);
+	pchnl->pio_requests = create_chirp_list(0);
+	pchnl->pio_completions = create_chirp_list(0);
+	pchnl->chnl_packets = pattrs->uio_reqs;
+	pchnl->cio_cs = 0;
+	pchnl->cio_reqs = 0;
+	sync_event = kzalloc(sizeof(struct sync_object), GFP_KERNEL);
+	if (sync_event)
+		sync_init_event(sync_event);
+	else
+		status = DSP_EMEMORY;
+
+	if (DSP_SUCCEEDED(status)) {
+		pchnl->ntfy_obj = kmalloc(sizeof(struct ntfy_object),
+							GFP_KERNEL);
+		if (pchnl->ntfy_obj)
+			ntfy_init(pchnl->ntfy_obj);
+		else
+			status = DSP_EMEMORY;
+	}
 
 	if (DSP_SUCCEEDED(status)) {
-		if (pChnl->pIOCompletions && pChnl->pIORequests &&
-		   pChnl->pFreeList) {
-			/* Initialize CHNL object fields:    */
-			pChnl->pChnlMgr = pChnlMgr;
-			pChnl->uId = uChnlId;
-			pChnl->uMode = uMode;
-			pChnl->hUserEvent = hSyncEvent;	/* for Linux */
-			pChnl->hSyncEvent = hSyncEvent;
+		if (pchnl->pio_completions && pchnl->pio_requests &&
+		    pchnl->free_packets_list) {
+			/* Initialize CHNL object fields: */
+			pchnl->chnl_mgr_obj = chnl_mgr_obj;
+			pchnl->chnl_id = uChnlId;
+			pchnl->chnl_mode = chnl_mode;
+			pchnl->user_event = sync_event;	/* for Linux */
+			pchnl->sync_event = sync_event;
 			/* Get the process handle */
-			pChnl->hProcess = current->tgid;
-			pChnl->pCBArg = 0;
-			pChnl->cBytesMoved = 0;
+			pchnl->process = current->tgid;
+			pchnl->pcb_arg = 0;
+			pchnl->bytes_moved = 0;
 			/* Default to proc-copy */
-			pChnl->uChnlType = CHNL_PCPY;
+			pchnl->chnl_type = CHNL_PCPY;
 		} else {
 			status = DSP_EMEMORY;
 		}
@@ -844,66 +868,69 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
 
 	if (DSP_FAILED(status)) {
 		/* Free memory */
-		if (pChnl->pIOCompletions) {
-			FreeChirpList(pChnl->pIOCompletions);
-			pChnl->pIOCompletions = NULL;
-			pChnl->cIOCs = 0;
-		}
-		if (pChnl->pIORequests) {
-			FreeChirpList(pChnl->pIORequests);
-			pChnl->pIORequests = NULL;
+		if (pchnl->pio_completions) {
+			free_chirp_list(pchnl->pio_completions);
+			pchnl->pio_completions = NULL;
+			pchnl->cio_cs = 0;
 		}
-		if (pChnl->pFreeList) {
-			FreeChirpList(pChnl->pFreeList);
-			pChnl->pFreeList = NULL;
+		if (pchnl->pio_requests) {
+			free_chirp_list(pchnl->pio_requests);
+			pchnl->pio_requests = NULL;
 		}
-		if (hSyncEvent) {
-			SYNC_CloseEvent(hSyncEvent);
-			hSyncEvent = NULL;
+		if (pchnl->free_packets_list) {
+			free_chirp_list(pchnl->free_packets_list);
+			pchnl->free_packets_list = NULL;
 		}
-		if (pChnl->hNtfy) {
-			NTFY_Delete(pChnl->hNtfy);
-			pChnl->hNtfy = NULL;
+		kfree(sync_event);
+		sync_event = NULL;
+
+		if (pchnl->ntfy_obj) {
+			ntfy_delete(pchnl->ntfy_obj);
+			kfree(pchnl->ntfy_obj);
+			pchnl->ntfy_obj = NULL;
 		}
-		MEM_FreeObject(pChnl);
+		MEM_FREE_OBJECT(pchnl);
 	} else {
 		/* Insert channel object in channel manager: */
-		pChnlMgr->apChannel[pChnl->uId] = pChnl;
-		SYNC_EnterCS(pChnlMgr->hCSObj);
-		pChnlMgr->cOpenChannels++;
-		SYNC_LeaveCS(pChnlMgr->hCSObj);
+		chnl_mgr_obj->ap_channel[pchnl->chnl_id] = pchnl;
+		spin_lock_bh(&chnl_mgr_obj->chnl_mgr_lock);
+		chnl_mgr_obj->open_channels++;
+		spin_unlock_bh(&chnl_mgr_obj->chnl_mgr_lock);
 		/* Return result... */
-		pChnl->dwSignature = CHNL_SIGNATURE;
-		pChnl->dwState = CHNL_STATEREADY;
-		*phChnl = pChnl;
+		pchnl->dw_signature = CHNL_SIGNATURE;
+		pchnl->dw_state = CHNL_STATEREADY;
+		*phChnl = pchnl;
 	}
 func_end:
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) ||
-		  (*phChnl == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) ||
+		   (*phChnl == NULL));
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_RegisterNotify ========
+ *  ======== bridge_chnl_register_notify ========
  *      Registers for events on a particular channel.
  */
-DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl, u32 uEventMask,
-				  u32 uNotifyType,
-				  struct DSP_NOTIFICATION *hNotification)
+dsp_status bridge_chnl_register_notify(struct chnl_object *chnl_obj,
+				    u32 event_mask, u32 notify_type,
+				    struct dsp_notification *hnotification)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Assert(!(uEventMask & ~(DSP_STREAMDONE | DSP_STREAMIOCOMPLETION)));
+	DBC_ASSERT(!(event_mask & ~(DSP_STREAMDONE | DSP_STREAMIOCOMPLETION)));
 
-	status = NTFY_Register(hChnl->hNtfy, hNotification, uEventMask,
-			      uNotifyType);
+	if (event_mask)
+		status = ntfy_register(chnl_obj->ntfy_obj, hnotification,
+						event_mask, notify_type);
+	else
+		status = ntfy_unregister(chnl_obj->ntfy_obj, hnotification);
 
 	return status;
 }
 
 /*
- *  ======== CreateChirpList ========
+ *  ======== create_chirp_list ========
  *  Purpose:
  *      Initialize a queue of channel I/O Request/Completion packets.
  *  Parameters:
@@ -913,79 +940,81 @@ DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl, u32 uEventMask,
  *  Requires:
  *  Ensures:
  */
-static struct LST_LIST *CreateChirpList(u32 uChirps)
+static struct lst_list *create_chirp_list(u32 uChirps)
 {
-	struct LST_LIST *pChirpList;
-	struct CHNL_IRP *pChirp;
+	struct lst_list *chirp_list;
+	struct chnl_irp *chnl_packet_obj;
 	u32 i;
 
-	pChirpList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
+	chirp_list = mem_calloc(sizeof(struct lst_list), MEM_NONPAGED);
 
-	if (pChirpList) {
-		INIT_LIST_HEAD(&pChirpList->head);
+	if (chirp_list) {
+		INIT_LIST_HEAD(&chirp_list->head);
 		/* Make N chirps and place on queue. */
-		for (i = 0; (i < uChirps) && ((pChirp = MakeNewChirp()) !=
-		    NULL); i++) {
-			LST_PutTail(pChirpList, (struct list_head *)pChirp);
+		for (i = 0; (i < uChirps)
+		     && ((chnl_packet_obj = make_new_chirp()) != NULL); i++) {
+			lst_put_tail(chirp_list,
+				     (struct list_head *)chnl_packet_obj);
 		}
 
 		/* If we couldn't allocate all chirps, free those allocated: */
 		if (i != uChirps) {
-			FreeChirpList(pChirpList);
-			pChirpList = NULL;
+			free_chirp_list(chirp_list);
+			chirp_list = NULL;
 		}
 	}
 
-	return pChirpList;
+	return chirp_list;
 }
 
 /*
- *  ======== FreeChirpList ========
+ *  ======== free_chirp_list ========
  *  Purpose:
  *      Free the queue of Chirps.
  */
-static void FreeChirpList(struct LST_LIST *pChirpList)
+static void free_chirp_list(struct lst_list *chirp_list)
 {
-	DBC_Require(pChirpList != NULL);
+	DBC_REQUIRE(chirp_list != NULL);
 
-	while (!LST_IsEmpty(pChirpList))
-		kfree(LST_GetHead(pChirpList));
+	while (!LST_IS_EMPTY(chirp_list))
+		kfree(lst_get_head(chirp_list));
 
-	kfree(pChirpList);
+	kfree(chirp_list);
 }
 
 /*
- *  ======== MakeNewChirp ========
+ *  ======== make_new_chirp ========
  *      Allocate the memory for a new channel IRP.
  */
-static struct CHNL_IRP *MakeNewChirp(void)
+static struct chnl_irp *make_new_chirp(void)
 {
-	struct CHNL_IRP *pChirp;
-
-	pChirp = (struct CHNL_IRP *)MEM_Calloc(
-		 sizeof(struct CHNL_IRP), MEM_NONPAGED);
-	if (pChirp != NULL) {
-		/* LST_InitElem only resets the list's member values. */
-		LST_InitElem(&pChirp->link);
+	struct chnl_irp *chnl_packet_obj;
+
+	chnl_packet_obj =
+	    (struct chnl_irp *)mem_calloc(sizeof(struct chnl_irp),
+					  MEM_NONPAGED);
+	if (chnl_packet_obj != NULL) {
+		/* lst_init_elem only resets the list's member values. */
+		lst_init_elem(&chnl_packet_obj->link);
 	}
 
-	return pChirp;
+	return chnl_packet_obj;
 }
 
 /*
- *  ======== SearchFreeChannel ========
+ *  ======== search_free_channel ========
  *      Search for a free channel slot in the array of channel pointers.
  */
-static DSP_STATUS SearchFreeChannel(struct CHNL_MGR *pChnlMgr,
-				   OUT u32 *pdwChnl)
+static dsp_status search_free_channel(struct chnl_mgr *chnl_mgr_obj,
+				      OUT u32 *pdwChnl)
 {
-	DSP_STATUS status = CHNL_E_OUTOFSTREAMS;
+	dsp_status status = CHNL_E_OUTOFSTREAMS;
 	u32 i;
 
-	DBC_Require(MEM_IsValidHandle(pChnlMgr, CHNL_MGRSIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(chnl_mgr_obj, CHNL_MGRSIGNATURE));
 
-	for (i = 0; i < pChnlMgr->cChannels; i++) {
-		if (pChnlMgr->apChannel[i] == NULL) {
+	for (i = 0; i < chnl_mgr_obj->max_channels; i++) {
+		if (chnl_mgr_obj->ap_channel[i] == NULL) {
 			status = DSP_SOK;
 			*pdwChnl = i;
 			break;
diff --git a/drivers/dsp/bridge/wmd/io_sm.c b/drivers/dsp/bridge/wmd/io_sm.c
index 8279df4..0a33678 100644
--- a/drivers/dsp/bridge/wmd/io_sm.c
+++ b/drivers/dsp/bridge/wmd/io_sm.c
@@ -19,8 +19,8 @@
 /*
  * Channel Invariant:
  * There is an important invariant condition which must be maintained per
- * channel outside of WMD_CHNL_GetIOC() and IO_Dispatch(), violation of
- * which may cause timeouts and/or failure of the SYNC_WaitOnEvent
+ * channel outside of bridge_chnl_get_ioc() and IO_Dispatch(), violation of
+ * which may cause timeouts and/or failure of the sync_wait_on_event
  * function.
  */
 
@@ -75,80 +75,82 @@
 
 #define EXTEND      "_EXT_END"
 
-#define SwapWord(x)     (x)
-#define ulPageAlignSize 0x10000   /* Page Align Size */
+#define SWAP_WORD(x)     (x)
+#define UL_PAGE_ALIGN_SIZE 0x10000	/* Page Align Size */
 
 #define MAX_PM_REQS 32
 
 /* IO Manager: only one created per board */
-struct IO_MGR {
-	/* These four fields must be the first fields in a IO_MGR_ struct */
-	u32 dwSignature; 	/* Used for object validation */
-	struct WMD_DEV_CONTEXT *hWmdContext; 	/* WMD device context */
-	struct WMD_DRV_INTERFACE *pIntfFxns; 	/* Function interface to WMD */
-	struct DEV_OBJECT *hDevObject; 	/* Device this board represents */
-
-	/* These fields initialized in WMD_IO_Create() */
-	struct CHNL_MGR *hChnlMgr;
-	struct SHM *pSharedMem; 	/* Shared Memory control */
-	u8 *pInput; 		/* Address of input channel */
-	u8 *pOutput; 		/* Address of output channel */
-	struct MSG_MGR *hMsgMgr; 	/* Message manager */
-	struct MSG *pMsgInputCtrl; 	/* Msg control for from DSP messages */
-	struct MSG *pMsgOutputCtrl; 	/* Msg control for to DSP messages */
-	u8 *pMsgInput; 	/* Address of input messages */
-	u8 *pMsgOutput; 	/* Address of output messages */
-	u32 uSMBufSize; 	/* Size of a shared memory I/O channel */
-	bool fSharedIRQ; 	/* Is this IRQ shared? */
-	struct SYNC_CSOBJECT *hCSObj; 	/* Critical section object handle */
-	u32 uWordSize; 	/* Size in bytes of DSP word */
-	u16 wIntrVal; 		/* Interrupt value */
+struct io_mgr {
+	/* These four fields must be the first fields in a io_mgr_ struct */
+	u32 dw_signature;	/* Used for object validation */
+	struct wmd_dev_context *hwmd_context;	/* WMD device context */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	struct dev_object *hdev_obj;	/* Device this board represents */
+
+	/* These fields initialized in bridge_io_create() */
+	struct chnl_mgr *hchnl_mgr;
+	struct shm *shared_mem;	/* Shared Memory control */
+	u8 *input;		/* Address of input channel */
+	u8 *output;		/* Address of output channel */
+	struct msg_mgr *hmsg_mgr;	/* Message manager */
+	/* Msg control for from DSP messages */
+	struct msg_ctrl *msg_input_ctrl;
+	/* Msg control for to DSP messages */
+	struct msg_ctrl *msg_output_ctrl;
+	u8 *msg_input;		/* Address of input messages */
+	u8 *msg_output;		/* Address of output messages */
+	u32 usm_buf_size;	/* Size of a shared memory I/O channel */
+	bool shared_irq;	/* Is this IRQ shared? */
+	u32 word_size;		/* Size in bytes of DSP word */
+	u16 intr_val;		/* Interrupt value */
 	/* Private extnd proc info; mmu setup */
-	struct MGR_PROCESSOREXTINFO extProcInfo;
-	struct CMM_OBJECT *hCmmMgr; 	/* Shared Mem Mngr */
-	struct work_struct io_workq;     /* workqueue */
+	struct mgr_processorextinfo ext_proc_info;
+	struct cmm_object *hcmm_mgr;	/* Shared Mem Mngr */
+	struct work_struct io_workq;	/* workqueue */
 #ifndef DSP_TRACEBUF_DISABLED
-	u32 ulTraceBufferBegin; 	/* Trace message start address */
-	u32 ulTraceBufferEnd; 	/* Trace message end address */
-	u32 ulTraceBufferCurrent; 	/* Trace message current address */
-	u32 ulGPPReadPointer; 	/* GPP Read pointer to Trace buffer */
-	u8 *pMsg;
-	u32 ulGppVa;
-	u32 ulDspVa;
+	u32 ul_trace_buffer_begin;	/* Trace message start address */
+	u32 ul_trace_buffer_end;	/* Trace message end address */
+	u32 ul_trace_buffer_current;	/* Trace message current address */
+	u32 ul_gpp_read_pointer;	/* GPP Read pointer to Trace buffer */
+	u8 *pmsg;
+	u32 ul_gpp_va;
+	u32 ul_dsp_va;
 #endif
 	/* IO Dpc */
-	u32 dpc_req;				/* Number of requested DPC's. */
-	u32 dpc_sched;				/* Number of executed DPC's. */
+	u32 dpc_req;		/* Number of requested DPC's. */
+	u32 dpc_sched;		/* Number of executed DPC's. */
 	struct tasklet_struct dpc_tasklet;
 #ifdef CONFIG_BRIDGE_WDT3
 	struct tasklet_struct wdt3_tasklet;
 #endif
 	spinlock_t dpc_lock;
 
-} ;
+};
 
 /* Function Prototypes */
-static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
-			   IN OUT struct CHNL_OBJECT *pChnl, u32 iMode);
-static void IO_DispatchMsg(IN struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
-static void IO_DispatchPM(struct IO_MGR *pIOMgr);
-static void NotifyChnlComplete(struct CHNL_OBJECT *pChnl,
-				struct CHNL_IRP *pChirp);
-static void InputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+static void io_dispatch_chnl(IN struct io_mgr *pio_mgr,
+			     IN OUT struct chnl_object *pchnl, u32 iMode);
+static void io_dispatch_msg(IN struct io_mgr *pio_mgr,
+			    struct msg_mgr *hmsg_mgr);
+static void io_dispatch_pm(struct io_mgr *pio_mgr);
+static void notify_chnl_complete(struct chnl_object *pchnl,
+				 struct chnl_irp *chnl_packet_obj);
+static void input_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
+		       u32 iMode);
+static void output_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
 			u32 iMode);
-static void OutputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
-			u32 iMode);
-static void InputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
-static void OutputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
-static u32 FindReadyOutput(struct CHNL_MGR *pChnlMgr,
-			     struct CHNL_OBJECT *pChnl, u32 dwMask);
-static u32 ReadData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-			void *pSrc, u32 uSize);
-static u32 WriteData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-			void *pSrc, u32 uSize);
+static void input_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr);
+static void output_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr);
+static u32 find_ready_output(struct chnl_mgr *chnl_mgr_obj,
+			     struct chnl_object *pchnl, u32 dwMask);
+static u32 read_data(struct wmd_dev_context *hDevContext, void *dest,
+		     void *pSrc, u32 usize);
+static u32 write_data(struct wmd_dev_context *hDevContext, void *dest,
+		      void *pSrc, u32 usize);
 
 #ifndef DSP_TRACEBUF_DISABLED
-void PrintDSPDebugTrace(struct IO_MGR *hIOMgr);
+void print_dsp_debug_trace(struct io_mgr *hio_mgr);
 #endif
 
 #ifdef CONFIG_BRIDGE_WDT3
@@ -157,33 +159,33 @@ static void io_wdt3_ovf(unsigned long);
 #endif
 
 /* Bus Addr (cached kernel) */
-static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
-				  struct COD_MANAGER *hCodMan,
-				  u32 dwGPPBasePA);
+static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
+				    struct cod_manager *cod_man,
+				    u32 dw_gpp_base_pa);
 
 /*
- *  ======== WMD_IO_Create ========
+ *  ======== bridge_io_create ========
  *      Create an IO manager object.
  */
-DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
-			 struct DEV_OBJECT *hDevObject,
-			 IN CONST struct IO_ATTRS *pMgrAttrs)
+dsp_status bridge_io_create(OUT struct io_mgr **phIOMgr,
+			    struct dev_object *hdev_obj,
+			    IN CONST struct io_attrs *pMgrAttrs)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct IO_MGR *pIOMgr = NULL;
-	struct SHM *pSharedMem = NULL;
-	struct WMD_DEV_CONTEXT *hWmdContext = NULL;
-	struct CFG_HOSTRES hostRes;
-	struct CFG_DEVNODE *hDevNode;
-	struct CHNL_MGR *hChnlMgr;
-	u32 devType;
+	dsp_status status = DSP_SOK;
+	struct io_mgr *pio_mgr = NULL;
+	struct shm *shared_mem = NULL;
+	struct wmd_dev_context *hwmd_context = NULL;
+	struct cfg_hostres host_res;
+	struct cfg_devnode *dev_node_obj;
+	struct chnl_mgr *hchnl_mgr;
+	u32 dev_type;
 	/* Check requirements */
-	if (!phIOMgr || !pMgrAttrs || pMgrAttrs->uWordSize == 0) {
+	if (!phIOMgr || !pMgrAttrs || pMgrAttrs->word_size == 0) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	DEV_GetChnlMgr(hDevObject, &hChnlMgr);
-	if (!hChnlMgr || hChnlMgr->hIOMgr) {
+	dev_get_chnl_mgr(hdev_obj, &hchnl_mgr);
+	if (!hchnl_mgr || hchnl_mgr->hio_mgr) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
@@ -192,61 +194,60 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
 	 * size of message buffer in shared memory is configurable in
 	 * the base image.
 	 */
-	DEV_GetWMDContext(hDevObject, &hWmdContext);
-	if (!hWmdContext) {
+	dev_get_wmd_context(hdev_obj, &hwmd_context);
+	if (!hwmd_context) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	DEV_GetDevType(hDevObject, &devType);
+	dev_get_dev_type(hdev_obj, &dev_type);
 	/*
 	 * DSP shared memory area will get set properly when
 	 * a program is loaded. They are unknown until a COFF file is
 	 * loaded. I chose the value -1 because it was less likely to be
 	 * a valid address than 0.
 	 */
-	pSharedMem = (struct SHM *) -1;
+	shared_mem = (struct shm *)-1;
 
 	/* Allocate IO manager object */
-	MEM_AllocObject(pIOMgr, struct IO_MGR, IO_MGRSIGNATURE);
-	if (pIOMgr == NULL) {
+	MEM_ALLOC_OBJECT(pio_mgr, struct io_mgr, IO_MGRSIGNATURE);
+	if (pio_mgr == NULL) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
 
-
-	/* Initialize CHNL_MGR object */
+	/* Initialize chnl_mgr object */
 #ifndef DSP_TRACEBUF_DISABLED
-	pIOMgr->pMsg = NULL;
+	pio_mgr->pmsg = NULL;
 #endif
-	pIOMgr->hChnlMgr = hChnlMgr;
-	pIOMgr->uWordSize = pMgrAttrs->uWordSize;
-	pIOMgr->pSharedMem = pSharedMem;
-	if (DSP_SUCCEEDED(status))
-		status = SYNC_InitializeCS(&pIOMgr->hCSObj);
+	pio_mgr->hchnl_mgr = hchnl_mgr;
+	pio_mgr->word_size = pMgrAttrs->word_size;
+	pio_mgr->shared_mem = shared_mem;
 
-	if (devType == DSP_UNIT) {
+	if (dev_type == DSP_UNIT) {
 		/* Create an IO DPC */
-		tasklet_init(&pIOMgr->dpc_tasklet, IO_DPC, (u32)pIOMgr);
+		tasklet_init(&pio_mgr->dpc_tasklet, io_dpc, (u32) pio_mgr);
 #ifdef CONFIG_BRIDGE_WDT3
-		tasklet_init(&pIOMgr->wdt3_tasklet, io_wdt3_ovf, (u32)pIOMgr);
+		tasklet_init(&pio_mgr->wdt3_tasklet, io_wdt3_ovf,
+			     (u32) pio_mgr);
 #endif
 		/* Initialize DPC counters */
-		pIOMgr->dpc_req = 0;
-		pIOMgr->dpc_sched = 0;
+		pio_mgr->dpc_req = 0;
+		pio_mgr->dpc_sched = 0;
 
-		spin_lock_init(&pIOMgr->dpc_lock);
+		spin_lock_init(&pio_mgr->dpc_lock);
 
 		if (DSP_SUCCEEDED(status))
-			status = DEV_GetDevNode(hDevObject, &hDevNode);
+			status = dev_get_dev_node(hdev_obj, &dev_node_obj);
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = CFG_GetHostResources((struct CFG_DEVNODE *)
-				DRV_GetFirstDevExtension() , &hostRes);
+		status = cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&host_res);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		pIOMgr->hWmdContext = hWmdContext;
-		pIOMgr->fSharedIRQ = pMgrAttrs->fShared;
+		pio_mgr->hwmd_context = hwmd_context;
+		pio_mgr->shared_irq = pMgrAttrs->irq_shared;
 
 	} else {
 		status = CHNL_E_ISR;
@@ -254,7 +255,7 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
 #ifdef CONFIG_BRIDGE_WDT3
 	if (DSP_SUCCEEDED(status)) {
 		if ((request_irq(INT_34XX_WDT3_IRQ, io_isr_wdt3, 0,
-			  "dsp_wdt", (void *)pIOMgr)) != 0)
+				 "dsp_wdt", (void *)pio_mgr)) != 0)
 			status = DSP_EFAIL;
 		else
 			/*
@@ -267,44 +268,43 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
 func_end:
 	if (DSP_FAILED(status)) {
 		/* Cleanup */
-		WMD_IO_Destroy(pIOMgr);
+		bridge_io_destroy(pio_mgr);
 		if (phIOMgr)
 			*phIOMgr = NULL;
 	} else {
 		/* Return IO manager object to caller... */
-		hChnlMgr->hIOMgr = pIOMgr;
-		*phIOMgr = pIOMgr;
+		hchnl_mgr->hio_mgr = pio_mgr;
+		*phIOMgr = pio_mgr;
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_IO_Destroy ========
+ *  ======== bridge_io_destroy ========
  *  Purpose:
  *      Disable interrupts, destroy the IO manager.
  */
-DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr)
+dsp_status bridge_io_destroy(struct io_mgr *hio_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *hWmdContext;
-	if (MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE)) {
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *hwmd_context;
+	if (MEM_IS_VALID_HANDLE(hio_mgr, IO_MGRSIGNATURE)) {
 		/* Disable interrupts from the board */
-		status = DEV_GetWMDContext(hIOMgr->hDevObject, &hWmdContext);
+		status = dev_get_wmd_context(hio_mgr->hdev_obj, &hwmd_context);
 
 #ifdef CONFIG_BRIDGE_WDT3
-		free_irq(INT_34XX_WDT3_IRQ, (void *)hIOMgr);
+		free_irq(INT_34XX_WDT3_IRQ, (void *)hio_mgr);
 #endif
 		/* Free IO DPC object */
-		tasklet_kill(&hIOMgr->dpc_tasklet);
+		tasklet_kill(&hio_mgr->dpc_tasklet);
 #ifdef CONFIG_BRIDGE_WDT3
-		tasklet_kill(&hIOMgr->wdt3_tasklet);
+		tasklet_kill(&hio_mgr->wdt3_tasklet);
 #endif
 #ifndef DSP_TRACEBUF_DISABLED
-		kfree(hIOMgr->pMsg);
+		kfree(hio_mgr->pmsg);
 #endif
-		SYNC_DeleteCS(hIOMgr->hCSObj); 	/* Leak Fix. */
 		/* Free this IO manager object */
-		MEM_FreeObject(hIOMgr);
+		MEM_FREE_OBJECT(hio_mgr);
 	} else {
 		status = DSP_EHANDLE;
 	}
@@ -313,113 +313,115 @@ DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr)
 }
 
 /*
- *  ======== WMD_IO_OnLoaded ========
+ *  ======== bridge_io_on_loaded ========
  *  Purpose:
  *      Called when a new program is loaded to get shared memory buffer
  *      parameters from COFF file. ulSharedBufferBase and ulSharedBufferLimit
  *      are in DSP address units.
  */
-DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr)
+dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr)
 {
-	struct COD_MANAGER *hCodMan;
-	struct CHNL_MGR *hChnlMgr;
-	struct MSG_MGR *hMsgMgr;
-	u32 ulShmBase;
-	u32 ulShmBaseOffset;
-	u32 ulShmLimit;
-	u32 ulShmLength = -1;
-	u32 ulMemLength = -1;
-	u32 ulMsgBase;
-	u32 ulMsgLimit;
-	u32 ulMsgLength = -1;
-	u32 ulExtEnd;
-	u32 ulGppPa = 0;
-	u32 ulGppVa = 0;
-	u32 ulDspVa = 0;
-	u32 ulSegSize = 0;
-	u32 ulPadSize = 0;
+	struct cod_manager *cod_man;
+	struct chnl_mgr *hchnl_mgr;
+	struct msg_mgr *hmsg_mgr;
+	u32 ul_shm_base;
+	u32 ul_shm_base_offset;
+	u32 ul_shm_limit;
+	u32 ul_shm_length = -1;
+	u32 ul_mem_length = -1;
+	u32 ul_msg_base;
+	u32 ul_msg_limit;
+	u32 ul_msg_length = -1;
+	u32 ul_ext_end;
+	u32 ul_gpp_pa = 0;
+	u32 ul_gpp_va = 0;
+	u32 ul_dsp_va = 0;
+	u32 ul_seg_size = 0;
+	u32 ul_pad_size = 0;
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
-	u32 uNumProcs = 0;
+	dsp_status status = DSP_SOK;
+	u32 num_procs = 0;
 	s32 ndx = 0;
 	/* DSP MMU setup table */
-	struct WMDIOCTL_EXTPROC aEProc[WMDIOCTL_NUMOFMMUTLB];
-	struct CFG_HOSTRES hostRes;
-	u32 mapAttrs;
-	u32 ulShm0End;
-	u32 ulDynExtBase;
-	u32 ulSeg1Size = 0;
-	u32 paCurr = 0;
-	u32 vaCurr = 0;
-	u32 gppVaCurr = 0;
-	u32 numBytes = 0;
-	u32 allBits = 0;
-	u32 pgSize[] = { HW_PAGE_SIZE_16MB, HW_PAGE_SIZE_1MB,
-			   HW_PAGE_SIZE_64KB, HW_PAGE_SIZE_4KB };
-
-	DEV_GetCodMgr(hIOMgr->hDevObject, &hCodMan);
-	if (!hCodMan) {
+	struct wmdioctl_extproc ae_proc[WMDIOCTL_NUMOFMMUTLB];
+	struct cfg_hostres host_res;
+	u32 map_attrs;
+	u32 shm0_end;
+	u32 ul_dyn_ext_base;
+	u32 ul_seg1_size = 0;
+	u32 pa_curr = 0;
+	u32 va_curr = 0;
+	u32 gpp_va_curr = 0;
+	u32 num_bytes = 0;
+	u32 all_bits = 0;
+	u32 page_size[] = { HW_PAGE_SIZE16MB, HW_PAGE_SIZE1MB,
+		HW_PAGE_SIZE64KB, HW_PAGE_SIZE4KB
+	};
+
+	dev_get_cod_mgr(hio_mgr->hdev_obj, &cod_man);
+	if (!cod_man) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hChnlMgr = hIOMgr->hChnlMgr;
+	hchnl_mgr = hio_mgr->hchnl_mgr;
 	/* The message manager is destroyed when the board is stopped. */
-	DEV_GetMsgMgr(hIOMgr->hDevObject, &hIOMgr->hMsgMgr);
-	hMsgMgr = hIOMgr->hMsgMgr;
-	if (!MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE) ||
-	   !MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE)) {
+	dev_get_msg_mgr(hio_mgr->hdev_obj, &hio_mgr->hmsg_mgr);
+	hmsg_mgr = hio_mgr->hmsg_mgr;
+	if (!MEM_IS_VALID_HANDLE(hchnl_mgr, CHNL_MGRSIGNATURE) ||
+	    !MEM_IS_VALID_HANDLE(hmsg_mgr, MSGMGR_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	if (hIOMgr->pSharedMem)
-		hIOMgr->pSharedMem = NULL;
+	if (hio_mgr->shared_mem)
+		hio_mgr->shared_mem = NULL;
 
 	/* Get start and length of channel part of shared memory */
-	status = COD_GetSymValue(hCodMan, CHNL_SHARED_BUFFER_BASE_SYM,
-				 &ulShmBase);
+	status = cod_get_sym_value(cod_man, CHNL_SHARED_BUFFER_BASE_SYM,
+				   &ul_shm_base);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
 		goto func_end;
 	}
-	status = COD_GetSymValue(hCodMan, CHNL_SHARED_BUFFER_LIMIT_SYM,
-				&ulShmLimit);
+	status = cod_get_sym_value(cod_man, CHNL_SHARED_BUFFER_LIMIT_SYM,
+				   &ul_shm_limit);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
 		goto func_end;
 	}
-	if (ulShmLimit <= ulShmBase) {
+	if (ul_shm_limit <= ul_shm_base) {
 		status = CHNL_E_INVALIDMEMBASE;
 		goto func_end;
 	}
 	/* Get total length in bytes */
-	ulShmLength = (ulShmLimit - ulShmBase + 1) * hIOMgr->uWordSize;
+	ul_shm_length = (ul_shm_limit - ul_shm_base + 1) * hio_mgr->word_size;
 	/* Calculate size of a PROCCOPY shared memory region */
 	dev_dbg(bridge, "%s: (proc)proccopy shmmem size: 0x%x bytes\n",
-				__func__, (ulShmLength - sizeof(struct SHM)));
+		__func__, (ul_shm_length - sizeof(struct shm)));
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
-		status = COD_GetSymValue(hCodMan, MSG_SHARED_BUFFER_BASE_SYM,
-					&ulMsgBase);
+		status = cod_get_sym_value(cod_man, MSG_SHARED_BUFFER_BASE_SYM,
+					   &ul_msg_base);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_GetSymValue(hCodMan, MSG_SHARED_BUFFER_LIMIT_SYM,
-					&ulMsgLimit);
+		status = cod_get_sym_value(cod_man, MSG_SHARED_BUFFER_LIMIT_SYM,
+					   &ul_msg_limit);
 		if (DSP_SUCCEEDED(status)) {
-			if (ulMsgLimit <= ulMsgBase) {
+			if (ul_msg_limit <= ul_msg_base) {
 				status = CHNL_E_INVALIDMEMBASE;
 			} else {
 				/*
 				 * Length (bytes) of messaging part of shared
 				 * memory.
 				 */
-				ulMsgLength = (ulMsgLimit - ulMsgBase + 1) *
-					      hIOMgr->uWordSize;
+				ul_msg_length =
+				    (ul_msg_limit - ul_msg_base +
+				     1) * hio_mgr->word_size;
 				/*
 				 * Total length (bytes) of shared memory:
 				 * chnl + msg.
 				 */
-				ulMemLength = ulShmLength + ulMsgLength;
+				ul_mem_length = ul_shm_length + ul_msg_length;
 			}
 		} else {
 			status = CHNL_E_NOMEMMAP;
@@ -429,69 +431,76 @@ DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr)
 	}
 	if (DSP_SUCCEEDED(status)) {
 #ifndef DSP_TRACEBUF_DISABLED
-		status = COD_GetSymValue(hCodMan, DSP_TRACESEC_END, &ulShm0End);
+		status =
+		    cod_get_sym_value(cod_man, DSP_TRACESEC_END, &shm0_end);
 #else
-		status = COD_GetSymValue(hCodMan, SHM0_SHARED_END_SYM,
-					 &ulShm0End);
+		status = cod_get_sym_value(cod_man, SHM0_SHARED_END_SYM,
+					   &shm0_end);
 #endif
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_GetSymValue(hCodMan, DYNEXTBASE, &ulDynExtBase);
+		status =
+		    cod_get_sym_value(cod_man, DYNEXTBASE, &ul_dyn_ext_base);
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_GetSymValue(hCodMan, EXTEND, &ulExtEnd);
+		status = cod_get_sym_value(cod_man, EXTEND, &ul_ext_end);
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Get memory reserved in host resources */
-		(void)MGR_EnumProcessorInfo(0,
-			(struct DSP_PROCESSORINFO *)&hIOMgr->extProcInfo,
-			sizeof(struct MGR_PROCESSOREXTINFO), &uNumProcs);
-		CFG_GetHostResources((
-			struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&hostRes);
+		(void)mgr_enum_processor_info(0, (struct dsp_processorinfo *)
+					      &hio_mgr->ext_proc_info,
+					      sizeof(struct
+						     mgr_processorextinfo),
+					      &num_procs);
+		cfg_get_host_resources((struct cfg_devnode *)
+				       drv_get_first_dev_extension(),
+				       &host_res);
 		/* The first MMU TLB entry(TLB_0) in DCD is ShmBase. */
 		ndx = 0;
-		ulGppPa = hostRes.dwMemPhys[1];
-		ulGppVa = hostRes.dwMemBase[1];
+		ul_gpp_pa = host_res.dw_mem_phys[1];
+		ul_gpp_va = host_res.dw_mem_base[1];
 		/* This is the virtual uncached ioremapped address!!! */
 		/* Why can't we directly take the DSPVA from the symbols? */
-		ulDspVa = hIOMgr->extProcInfo.tyTlb[0].ulDspVirt;
-		ulSegSize = (ulShm0End - ulDspVa) * hIOMgr->uWordSize;
-		ulSeg1Size = (ulExtEnd - ulDynExtBase) * hIOMgr->uWordSize;
-		ulSeg1Size = (ulSeg1Size + 0xFFF) & (~0xFFFUL); /* 4K align*/
-		ulSegSize = (ulSegSize + 0xFFFF) & (~0xFFFFUL); /* 64K align*/
-		ulPadSize = ulPageAlignSize - ((ulGppPa + ulSeg1Size) %
-			     ulPageAlignSize);
-			if (ulPadSize == ulPageAlignSize)
-				ulPadSize = 0x0;
-
-		 dev_dbg(bridge, "%s: ulGppPa %x, ulGppVa %x, ulDspVa %x, "
-				"ulShm0End %x, ulDynExtBase %x, ulExtEnd %x, "
-				"ulSegSize %x ulSeg1Size %x \n", __func__,
-				ulGppPa, ulGppVa, ulDspVa, ulShm0End,
-				ulDynExtBase, ulExtEnd, ulSegSize, ulSeg1Size);
-
-		if ((ulSegSize + ulSeg1Size + ulPadSize) >
-		   hostRes.dwMemLength[1]) {
-			pr_err("%s: SHM Error, reserved 0x%x required 0x%x\n",
-					__func__, hostRes.dwMemLength[1],
-					ulSegSize + ulSeg1Size + ulPadSize);
+		ul_dsp_va = hio_mgr->ext_proc_info.ty_tlb[0].ul_dsp_virt;
+		ul_seg_size = (shm0_end - ul_dsp_va) * hio_mgr->word_size;
+		ul_seg1_size =
+		    (ul_ext_end - ul_dyn_ext_base) * hio_mgr->word_size;
+		/* 4K align */
+		ul_seg1_size = (ul_seg1_size + 0xFFF) & (~0xFFFUL);
+		/* 64K align */
+		ul_seg_size = (ul_seg_size + 0xFFFF) & (~0xFFFFUL);
+		ul_pad_size = UL_PAGE_ALIGN_SIZE - ((ul_gpp_pa + ul_seg1_size) %
+						    UL_PAGE_ALIGN_SIZE);
+		if (ul_pad_size == UL_PAGE_ALIGN_SIZE)
+			ul_pad_size = 0x0;
+
+		dev_dbg(bridge, "%s: ul_gpp_pa %x, ul_gpp_va %x, ul_dsp_va %x, "
+			"shm0_end %x, ul_dyn_ext_base %x, ul_ext_end %x, "
+			"ul_seg_size %x ul_seg1_size %x \n", __func__,
+			ul_gpp_pa, ul_gpp_va, ul_dsp_va, shm0_end,
+			ul_dyn_ext_base, ul_ext_end, ul_seg_size, ul_seg1_size);
+
+		if ((ul_seg_size + ul_seg1_size + ul_pad_size) >
+		    host_res.dw_mem_length[1]) {
+			pr_err("%s: shm Error, reserved 0x%x required 0x%x\n",
+			       __func__, host_res.dw_mem_length[1],
+			       ul_seg_size + ul_seg1_size + ul_pad_size);
 			status = DSP_EMEMORY;
 		}
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	paCurr = ulGppPa;
-	vaCurr = ulDynExtBase * hIOMgr->uWordSize;
-	gppVaCurr = ulGppVa;
-	numBytes = ulSeg1Size;
+	pa_curr = ul_gpp_pa;
+	va_curr = ul_dyn_ext_base * hio_mgr->word_size;
+	gpp_va_curr = ul_gpp_va;
+	num_bytes = ul_seg1_size;
 
 	/*
 	 * Try to fit into TLB entries. If not possible, push them to page
@@ -499,32 +508,36 @@ DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr)
 	 * bigger page boundary, we may end up making several small pages.
 	 * So, push them onto page tables, if that is the case.
 	 */
-	mapAttrs = 0x00000000;
-	mapAttrs = DSP_MAPLITTLEENDIAN;
-	mapAttrs |= DSP_MAPPHYSICALADDR;
-	mapAttrs |= DSP_MAPELEMSIZE32;
-	mapAttrs |= DSP_MAPDONOTLOCK;
+	map_attrs = 0x00000000;
+	map_attrs = DSP_MAPLITTLEENDIAN;
+	map_attrs |= DSP_MAPPHYSICALADDR;
+	map_attrs |= DSP_MAPELEMSIZE32;
+	map_attrs |= DSP_MAPDONOTLOCK;
 
-	while (numBytes) {
+	while (num_bytes) {
 		/*
 		 * To find the max. page size with which both PA & VA are
 		 * aligned.
 		 */
-		allBits = paCurr | vaCurr;
-		dev_dbg(bridge, "allBits %x, paCurr %x, vaCurr %x, "
-			 "numBytes %x\n", allBits, paCurr, vaCurr, numBytes);
+		all_bits = pa_curr | va_curr;
+		dev_dbg(bridge, "all_bits %x, pa_curr %x, va_curr %x, "
+			"num_bytes %x\n", all_bits, pa_curr, va_curr,
+			num_bytes);
 		for (i = 0; i < 4; i++) {
-			if ((numBytes >= pgSize[i]) && ((allBits &
-			   (pgSize[i] - 1)) == 0)) {
-				status = hIOMgr->pIntfFxns->pfnBrdMemMap
-					(hIOMgr->hWmdContext, paCurr, vaCurr,
-					pgSize[i], mapAttrs);
+			if ((num_bytes >= page_size[i]) && ((all_bits &
+							     (page_size[i] -
+							      1)) == 0)) {
+				status =
+				    hio_mgr->intf_fxns->
+				    pfn_brd_mem_map(hio_mgr->hwmd_context,
+						    pa_curr, va_curr,
+						    page_size[i], map_attrs);
 				if (DSP_FAILED(status))
 					goto func_end;
-				paCurr += pgSize[i];
-				vaCurr += pgSize[i];
-				gppVaCurr += pgSize[i];
-				numBytes -= pgSize[i];
+				pa_curr += page_size[i];
+				va_curr += page_size[i];
+				gpp_va_curr += page_size[i];
+				num_bytes -= page_size[i];
 				/*
 				 * Don't try smaller sizes. Hopefully we have
 				 * reached an address aligned to a bigger page
@@ -534,67 +547,70 @@ DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr)
 			}
 		}
 	}
-	paCurr += ulPadSize;
-	vaCurr += ulPadSize;
-	gppVaCurr += ulPadSize;
+	pa_curr += ul_pad_size;
+	va_curr += ul_pad_size;
+	gpp_va_curr += ul_pad_size;
 
 	/* Configure the TLB entries for the next cacheable segment */
-	numBytes = ulSegSize;
-	vaCurr = ulDspVa * hIOMgr->uWordSize;
-	while (numBytes ) {
+	num_bytes = ul_seg_size;
+	va_curr = ul_dsp_va * hio_mgr->word_size;
+	while (num_bytes) {
 		/*
 		 * To find the max. page size with which both PA & VA are
 		 * aligned.
 		 */
-		allBits = paCurr | vaCurr;
-		dev_dbg(bridge, "allBits for Seg1 %x, paCurr %x, "
-			 "vaCurr %x, numBytes %x\n", allBits, paCurr, vaCurr,
-			 numBytes);
+		all_bits = pa_curr | va_curr;
+		dev_dbg(bridge, "all_bits for Seg1 %x, pa_curr %x, "
+			"va_curr %x, num_bytes %x\n", all_bits, pa_curr,
+			va_curr, num_bytes);
 		for (i = 0; i < 4; i++) {
-			if (!(numBytes >= pgSize[i]) ||
-			   !((allBits & (pgSize[i]-1)) == 0))
+			if (!(num_bytes >= page_size[i]) ||
+			    !((all_bits & (page_size[i] - 1)) == 0))
 				continue;
 			if (ndx < MAX_LOCK_TLB_ENTRIES) {
 				/*
 				 * This is the physical address written to
 				 * DSP MMU.
 				 */
-				aEProc[ndx].ulGppPa = paCurr;
+				ae_proc[ndx].ul_gpp_pa = pa_curr;
 				/*
 				 * This is the virtual uncached ioremapped
 				 * address!!!
 				 */
-				aEProc[ndx].ulGppVa = gppVaCurr;
-				aEProc[ndx].ulDspVa = vaCurr / hIOMgr->
-						      uWordSize;
-				aEProc[ndx].ulSize = pgSize[i];
-				aEProc[ndx].endianism = HW_LITTLE_ENDIAN;
-				aEProc[ndx].elemSize = HW_ELEM_SIZE_16BIT;
-				aEProc[ndx].mixedMode = HW_MMU_CPUES;
-				dev_dbg(bridge, "SHM MMU TLB entry PA %x"
-					 " VA %x DSP_VA %x Size %x\n",
-					 aEProc[ndx].ulGppPa,
-					 aEProc[ndx].ulGppVa,
-					 aEProc[ndx].ulDspVa *
-					 hIOMgr->uWordSize, pgSize[i]);
+				ae_proc[ndx].ul_gpp_va = gpp_va_curr;
+				ae_proc[ndx].ul_dsp_va =
+				    va_curr / hio_mgr->word_size;
+				ae_proc[ndx].ul_size = page_size[i];
+				ae_proc[ndx].endianism = HW_LITTLE_ENDIAN;
+				ae_proc[ndx].elem_size = HW_ELEM_SIZE16BIT;
+				ae_proc[ndx].mixed_mode = HW_MMU_CPUES;
+				dev_dbg(bridge, "shm MMU TLB entry PA %x"
+					" VA %x DSP_VA %x Size %x\n",
+					ae_proc[ndx].ul_gpp_pa,
+					ae_proc[ndx].ul_gpp_va,
+					ae_proc[ndx].ul_dsp_va *
+					hio_mgr->word_size, page_size[i]);
 				ndx++;
 			} else {
-				status = hIOMgr->pIntfFxns->pfnBrdMemMap(
-				hIOMgr->hWmdContext, paCurr, vaCurr, pgSize[i],
-					mapAttrs);
-				dev_dbg(bridge, "SHM MMU PTE entry PA %x"
-					 " VA %x DSP_VA %x Size %x\n",
-					 aEProc[ndx].ulGppPa,
-					 aEProc[ndx].ulGppVa,
-					 aEProc[ndx].ulDspVa *
-					 hIOMgr->uWordSize, pgSize[i]);
+				status =
+				    hio_mgr->intf_fxns->
+				    pfn_brd_mem_map(hio_mgr->hwmd_context,
+						    pa_curr, va_curr,
+						    page_size[i], map_attrs);
+				dev_dbg(bridge,
+					"shm MMU PTE entry PA %x"
+					" VA %x DSP_VA %x Size %x\n",
+					ae_proc[ndx].ul_gpp_pa,
+					ae_proc[ndx].ul_gpp_va,
+					ae_proc[ndx].ul_dsp_va *
+					hio_mgr->word_size, page_size[i]);
 				if (DSP_FAILED(status))
 					goto func_end;
 			}
-			paCurr += pgSize[i];
-			vaCurr += pgSize[i];
-			gppVaCurr += pgSize[i];
-			numBytes -= pgSize[i];
+			pa_curr += page_size[i];
+			va_curr += page_size[i];
+			gpp_va_curr += page_size[i];
+			num_bytes -= page_size[i];
 			/*
 			 * Don't try smaller sizes. Hopefully we have reached
 			 * an address aligned to a bigger page size.
@@ -605,99 +621,103 @@ DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr)
 
 	/*
 	 * Copy remaining entries from CDB. All entries are 1 MB and
-	 * should not conflict with SHM entries on MPU or DSP side.
+	 * should not conflict with shm entries on MPU or DSP side.
 	 */
 	for (i = 3; i < 7 && ndx < WMDIOCTL_NUMOFMMUTLB; i++) {
-		if (hIOMgr->extProcInfo.tyTlb[i].ulGppPhys == 0)
+		if (hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys == 0)
 			continue;
 
-		if ((hIOMgr->extProcInfo.tyTlb[i].ulGppPhys > ulGppPa - 0x100000
-			&& hIOMgr->extProcInfo.tyTlb[i].ulGppPhys <=
-				ulGppPa + ulSegSize)
-			|| (hIOMgr->extProcInfo.tyTlb[i].ulDspVirt > ulDspVa -
-				0x100000 / hIOMgr->uWordSize && hIOMgr->
-				extProcInfo.tyTlb[i].ulDspVirt
-				<= ulDspVa + ulSegSize / hIOMgr->uWordSize)) {
-			dev_dbg(bridge, "CDB MMU entry %d conflicts with "
-				 "SHM.\n\tCDB: GppPa %x, DspVa %x.\n\tSHM: "
-				 "GppPa %x, DspVa %x, Bytes %x.\n", i,
-				 hIOMgr->extProcInfo.tyTlb[i].ulGppPhys,
-				 hIOMgr->extProcInfo.tyTlb[i].ulDspVirt,
-				 ulGppPa, ulDspVa, ulSegSize);
+		if ((hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys >
+		     ul_gpp_pa - 0x100000
+		     && hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys <=
+		     ul_gpp_pa + ul_seg_size)
+		    || (hio_mgr->ext_proc_info.ty_tlb[i].ul_dsp_virt >
+			ul_dsp_va - 0x100000 / hio_mgr->word_size
+			&& hio_mgr->ext_proc_info.ty_tlb[i].ul_dsp_virt <=
+			ul_dsp_va + ul_seg_size / hio_mgr->word_size)) {
+			dev_dbg(bridge,
+				"CDB MMU entry %d conflicts with "
+				"shm.\n\tCDB: GppPa %x, DspVa %x.\n\tSHM: "
+				"GppPa %x, DspVa %x, Bytes %x.\n", i,
+				hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys,
+				hio_mgr->ext_proc_info.ty_tlb[i].ul_dsp_virt,
+				ul_gpp_pa, ul_dsp_va, ul_seg_size);
 			status = DSP_EFAIL;
 		} else {
 			if (ndx < MAX_LOCK_TLB_ENTRIES) {
-				aEProc[ndx].ulDspVa = hIOMgr->extProcInfo.
-					tyTlb[i].ulDspVirt;
-				aEProc[ndx].ulGppPa = hIOMgr->extProcInfo.
-					tyTlb[i].ulGppPhys;
-				aEProc[ndx].ulGppVa = 0;
-				/* Can't convert, so set to zero */
-				aEProc[ndx].ulSize = 0x100000; 	/* 1 MB */
-				dev_dbg(bridge, "SHM MMU entry PA %x "
-					 "DSP_VA 0x%x\n", aEProc[ndx].ulGppPa,
-					aEProc[ndx].ulDspVa);
+				ae_proc[ndx].ul_dsp_va =
+				    hio_mgr->ext_proc_info.ty_tlb[i].
+				    ul_dsp_virt;
+				ae_proc[ndx].ul_gpp_pa =
+				    hio_mgr->ext_proc_info.ty_tlb[i].
+				    ul_gpp_phys;
+				ae_proc[ndx].ul_gpp_va = 0;
+				/* 1 MB */
+				ae_proc[ndx].ul_size = 0x100000;
+				dev_dbg(bridge, "shm MMU entry PA %x "
+					"DSP_VA 0x%x\n", ae_proc[ndx].ul_gpp_pa,
+					ae_proc[ndx].ul_dsp_va);
 				ndx++;
 			} else {
-				status = hIOMgr->pIntfFxns->pfnBrdMemMap
-					(hIOMgr->hWmdContext,
-					hIOMgr->extProcInfo.tyTlb[i].ulGppPhys,
-					hIOMgr->extProcInfo.tyTlb[i].ulDspVirt,
-					0x100000, mapAttrs);
+				status = hio_mgr->intf_fxns->pfn_brd_mem_map
+				    (hio_mgr->hwmd_context,
+				     hio_mgr->ext_proc_info.ty_tlb[i].
+				     ul_gpp_phys,
+				     hio_mgr->ext_proc_info.ty_tlb[i].
+				     ul_dsp_virt, 0x100000, map_attrs);
 			}
 		}
 		if (DSP_FAILED(status))
 			goto func_end;
 	}
 
-	mapAttrs = 0x00000000;
-	mapAttrs = DSP_MAPLITTLEENDIAN;
-	mapAttrs |= DSP_MAPPHYSICALADDR;
-	mapAttrs |= DSP_MAPELEMSIZE32;
-	mapAttrs |= DSP_MAPDONOTLOCK;
+	map_attrs = 0x00000000;
+	map_attrs = DSP_MAPLITTLEENDIAN;
+	map_attrs |= DSP_MAPPHYSICALADDR;
+	map_attrs |= DSP_MAPELEMSIZE32;
+	map_attrs |= DSP_MAPDONOTLOCK;
 
 	/* Map the L4 peripherals */
 	i = 0;
-	while (L4PeripheralTable[i].physAddr) {
-		status = hIOMgr->pIntfFxns->pfnBrdMemMap
-			(hIOMgr->hWmdContext, L4PeripheralTable[i].physAddr,
-			L4PeripheralTable[i].dspVirtAddr, HW_PAGE_SIZE_4KB,
-			mapAttrs);
+	while (l4_peripheral_table[i].phys_addr) {
+		status = hio_mgr->intf_fxns->pfn_brd_mem_map
+		    (hio_mgr->hwmd_context, l4_peripheral_table[i].phys_addr,
+		     l4_peripheral_table[i].dsp_virt_addr, HW_PAGE_SIZE4KB,
+		     map_attrs);
 		if (DSP_FAILED(status))
 			goto func_end;
 		i++;
 	}
 
-
 	for (i = ndx; i < WMDIOCTL_NUMOFMMUTLB; i++) {
-		aEProc[i].ulDspVa = 0;
-		aEProc[i].ulGppPa = 0;
-		aEProc[i].ulGppVa = 0;
-		aEProc[i].ulSize = 0;
+		ae_proc[i].ul_dsp_va = 0;
+		ae_proc[i].ul_gpp_pa = 0;
+		ae_proc[i].ul_gpp_va = 0;
+		ae_proc[i].ul_size = 0;
 	}
 	/*
-	 * Set the SHM physical address entry (grayed out in CDB file)
-	 * to the virtual uncached ioremapped address of SHM reserved
+	 * Set the shm physical address entry (grayed out in CDB file)
+	 * to the virtual uncached ioremapped address of shm reserved
 	 * on MPU.
 	 */
-	hIOMgr->extProcInfo.tyTlb[0].ulGppPhys = (ulGppVa + ulSeg1Size +
-						 ulPadSize);
+	hio_mgr->ext_proc_info.ty_tlb[0].ul_gpp_phys =
+	    (ul_gpp_va + ul_seg1_size + ul_pad_size);
 
 	/*
-	 * Need SHM Phys addr. IO supports only one DSP for now:
-	 * uNumProcs = 1.
+	 * Need shm Phys addr. IO supports only one DSP for now:
+	 * num_procs = 1.
 	 */
-	if (!hIOMgr->extProcInfo.tyTlb[0].ulGppPhys || uNumProcs != 1) {
+	if (!hio_mgr->ext_proc_info.ty_tlb[0].ul_gpp_phys || num_procs != 1) {
 		status = CHNL_E_NOMEMMAP;
 		goto func_end;
 	} else {
-		if (aEProc[0].ulDspVa > ulShmBase) {
+		if (ae_proc[0].ul_dsp_va > ul_shm_base) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
-		/* ulShmBase may not be at ulDspVa address */
-		ulShmBaseOffset = (ulShmBase - aEProc[0].ulDspVa) *
-				hIOMgr->uWordSize;
+		/* ul_shm_base may not be at ul_dsp_va address */
+		ul_shm_base_offset = (ul_shm_base - ae_proc[0].ul_dsp_va) *
+		    hio_mgr->word_size;
 		/*
 		 * WMD_BRD_Ctrl() will set dev context dsp-mmu info. In
 		 * _BRD_Start() the MMU will be re-programed with MMU
@@ -705,89 +725,98 @@ DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr)
 		 * (reset) state.
 		 */
 
-		status = hIOMgr->pIntfFxns->pfnDevCntrl(hIOMgr->hWmdContext,
-						WMDIOCTL_SETMMUCONFIG, aEProc);
+		status =
+		    hio_mgr->intf_fxns->pfn_dev_cntrl(hio_mgr->hwmd_context,
+						      WMDIOCTL_SETMMUCONFIG,
+						      ae_proc);
 		if (DSP_FAILED(status))
 			goto func_end;
-		ulShmBase = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
-		ulShmBase += ulShmBaseOffset;
-		ulShmBase = (u32)MEM_LinearAddress((void *)ulShmBase,
-				    ulMemLength);
-		if (ulShmBase == 0) {
+		ul_shm_base = hio_mgr->ext_proc_info.ty_tlb[0].ul_gpp_phys;
+		ul_shm_base += ul_shm_base_offset;
+		ul_shm_base = (u32) MEM_LINEAR_ADDRESS((void *)ul_shm_base,
+						       ul_mem_length);
+		if (ul_shm_base == 0) {
 			status = DSP_EPOINTER;
 			goto func_end;
 		}
 		/* Register SM */
-		status = registerSHMSegs(hIOMgr, hCodMan, aEProc[0].ulGppPa);
+		status =
+		    register_shm_segs(hio_mgr, cod_man, ae_proc[0].ul_gpp_pa);
 	}
 
-	hIOMgr->pSharedMem = (struct SHM *)ulShmBase;
-	hIOMgr->pInput = (u8 *)hIOMgr->pSharedMem + sizeof(struct SHM);
-	hIOMgr->pOutput = hIOMgr->pInput + (ulShmLength -
-						sizeof(struct SHM)) / 2;
-	hIOMgr->uSMBufSize = hIOMgr->pOutput - hIOMgr->pInput;
-
-	 /*  Set up Shared memory addresses for messaging. */
-	hIOMgr->pMsgInputCtrl = (struct MSG *)((u8 *)hIOMgr->pSharedMem
-							+ ulShmLength);
-	hIOMgr->pMsgInput = (u8 *)hIOMgr->pMsgInputCtrl + sizeof(struct MSG);
-	hIOMgr->pMsgOutputCtrl = (struct MSG *)((u8 *)hIOMgr->pMsgInputCtrl
-							+ ulMsgLength / 2);
-	hIOMgr->pMsgOutput = (u8 *)hIOMgr->pMsgOutputCtrl + sizeof(struct MSG);
-	hMsgMgr->uMaxMsgs = ((u8 *)hIOMgr->pMsgOutputCtrl - hIOMgr->pMsgInput)
-						/ sizeof(struct MSG_DSPMSG);
-	dev_dbg(bridge, "IO MGR SHM details: pSharedMem %p, pInput %p, "
-			"pOutput %p, pMsgInputCtrl %p, pMsgInput %p, "
-			"pMsgOutputCtrl %p, pMsgOutput %p\n",
-			(u8 *)hIOMgr->pSharedMem, hIOMgr->pInput,
-			hIOMgr->pOutput, (u8 *)hIOMgr->pMsgInputCtrl,
-			hIOMgr->pMsgInput, (u8 *)hIOMgr->pMsgOutputCtrl,
-			hIOMgr->pMsgOutput);
+	hio_mgr->shared_mem = (struct shm *)ul_shm_base;
+	hio_mgr->input = (u8 *) hio_mgr->shared_mem + sizeof(struct shm);
+	hio_mgr->output = hio_mgr->input + (ul_shm_length -
+					    sizeof(struct shm)) / 2;
+	hio_mgr->usm_buf_size = hio_mgr->output - hio_mgr->input;
+
+	/*  Set up Shared memory addresses for messaging. */
+	hio_mgr->msg_input_ctrl = (struct msg_ctrl *)((u8 *) hio_mgr->shared_mem
+						      + ul_shm_length);
+	hio_mgr->msg_input =
+	    (u8 *) hio_mgr->msg_input_ctrl + sizeof(struct msg_ctrl);
+	hio_mgr->msg_output_ctrl =
+	    (struct msg_ctrl *)((u8 *) hio_mgr->msg_input_ctrl +
+				ul_msg_length / 2);
+	hio_mgr->msg_output =
+	    (u8 *) hio_mgr->msg_output_ctrl + sizeof(struct msg_ctrl);
+	hmsg_mgr->max_msgs =
+	    ((u8 *) hio_mgr->msg_output_ctrl - hio_mgr->msg_input)
+	    / sizeof(struct msg_dspmsg);
+	dev_dbg(bridge, "IO MGR shm details: shared_mem %p, input %p, "
+		"output %p, msg_input_ctrl %p, msg_input %p, "
+		"msg_output_ctrl %p, msg_output %p\n",
+		(u8 *) hio_mgr->shared_mem, hio_mgr->input,
+		hio_mgr->output, (u8 *) hio_mgr->msg_input_ctrl,
+		hio_mgr->msg_input, (u8 *) hio_mgr->msg_output_ctrl,
+		hio_mgr->msg_output);
 	dev_dbg(bridge, "(proc) Mas msgs in shared memory: 0x%x\n",
-							hMsgMgr->uMaxMsgs);
-	memset((void *) hIOMgr->pSharedMem, 0, sizeof(struct SHM));
+		hmsg_mgr->max_msgs);
+	memset((void *)hio_mgr->shared_mem, 0, sizeof(struct shm));
 
 #ifndef DSP_TRACEBUF_DISABLED
 	/* Get the start address of trace buffer */
-	status = COD_GetSymValue(hCodMan, SYS_PUTCBEG,
-				 &hIOMgr->ulTraceBufferBegin);
+	status = cod_get_sym_value(cod_man, SYS_PUTCBEG,
+				   &hio_mgr->ul_trace_buffer_begin);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
 		goto func_end;
 	}
 
-	hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin =
-		(ulGppVa + ulSeg1Size + ulPadSize) +
-		(hIOMgr->ulTraceBufferBegin - ulDspVa);
+	hio_mgr->ul_gpp_read_pointer = hio_mgr->ul_trace_buffer_begin =
+	    (ul_gpp_va + ul_seg1_size + ul_pad_size) +
+	    (hio_mgr->ul_trace_buffer_begin - ul_dsp_va);
 	/* Get the end address of trace buffer */
 
-	status = COD_GetSymValue(hCodMan, SYS_PUTCEND,
-						&hIOMgr->ulTraceBufferEnd);
+	status = cod_get_sym_value(cod_man, SYS_PUTCEND,
+				   &hio_mgr->ul_trace_buffer_end);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
 		goto func_end;
 	}
-	hIOMgr->ulTraceBufferEnd = (ulGppVa + ulSeg1Size + ulPadSize) +
-				   (hIOMgr->ulTraceBufferEnd - ulDspVa);
+	hio_mgr->ul_trace_buffer_end =
+	    (ul_gpp_va + ul_seg1_size + ul_pad_size) +
+	    (hio_mgr->ul_trace_buffer_end - ul_dsp_va);
 	/* Get the current address of DSP write pointer */
-	status = COD_GetSymValue(hCodMan, BRIDGE_SYS_PUTC_current,
-					 &hIOMgr->ulTraceBufferCurrent);
+	status = cod_get_sym_value(cod_man, BRIDGE_SYS_PUTC_CURRENT,
+				   &hio_mgr->ul_trace_buffer_current);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
 		goto func_end;
 	}
-	hIOMgr->ulTraceBufferCurrent = (ulGppVa + ulSeg1Size + ulPadSize) +
-				(hIOMgr->ulTraceBufferCurrent - ulDspVa);
+	hio_mgr->ul_trace_buffer_current =
+	    (ul_gpp_va + ul_seg1_size + ul_pad_size) +
+	    (hio_mgr->ul_trace_buffer_current - ul_dsp_va);
 	/* Calculate the size of trace buffer */
-	kfree(hIOMgr->pMsg);
-	hIOMgr->pMsg = MEM_Alloc(((hIOMgr->ulTraceBufferEnd -
-				hIOMgr->ulTraceBufferBegin) *
-				hIOMgr->uWordSize) + 2, MEM_NONPAGED);
-	if (!hIOMgr->pMsg)
+	kfree(hio_mgr->pmsg);
+	hio_mgr->pmsg = mem_alloc(((hio_mgr->ul_trace_buffer_end -
+				    hio_mgr->ul_trace_buffer_begin) *
+				   hio_mgr->word_size) + 2, MEM_NONPAGED);
+	if (!hio_mgr->pmsg)
 		status = DSP_EMEMORY;
 
-	hIOMgr->ulDspVa = ulDspVa;
-	hIOMgr->ulGppVa = (ulGppVa + ulSeg1Size + ulPadSize);
+	hio_mgr->ul_dsp_va = ul_dsp_va;
+	hio_mgr->ul_gpp_va = (ul_gpp_va + ul_seg1_size + ul_pad_size);
 
 #endif
 func_end:
@@ -795,47 +824,47 @@ func_end:
 }
 
 /*
- *  ======== IO_BufSize ========
+ *  ======== io_buf_size ========
  *      Size of shared memory I/O channel.
  */
-u32 IO_BufSize(struct IO_MGR *hIOMgr)
+u32 io_buf_size(struct io_mgr *hio_mgr)
 {
-	if (MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE))
-		return hIOMgr->uSMBufSize;
+	if (MEM_IS_VALID_HANDLE(hio_mgr, IO_MGRSIGNATURE))
+		return hio_mgr->usm_buf_size;
 	else
 		return 0;
 }
 
 /*
- *  ======== IO_CancelChnl ========
+ *  ======== io_cancel_chnl ========
  *      Cancel IO on a given PCPY channel.
  */
-void IO_CancelChnl(struct IO_MGR *hIOMgr, u32 ulChnl)
+void io_cancel_chnl(struct io_mgr *hio_mgr, u32 ulChnl)
 {
-	struct IO_MGR *pIOMgr = (struct IO_MGR *)hIOMgr;
-	struct SHM *sm;
+	struct io_mgr *pio_mgr = (struct io_mgr *)hio_mgr;
+	struct shm *sm;
 
-	if (!MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(hio_mgr, IO_MGRSIGNATURE))
 		goto func_end;
-	sm = hIOMgr->pSharedMem;
+	sm = hio_mgr->shared_mem;
 
 	/* Inform DSP that we have no more buffers on this channel */
-	IO_AndValue(pIOMgr->hWmdContext, struct SHM, sm, hostFreeMask,
-		   (~(1 << ulChnl)));
+	IO_AND_VALUE(pio_mgr->hwmd_context, struct shm, sm, host_free_mask,
+		     (~(1 << ulChnl)));
 
-	sm_interrupt_dsp(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+	sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 func_end:
 	return;
 }
 
 /*
- *  ======== IO_DispatchChnl ========
+ *  ======== io_dispatch_chnl ========
  *      Proc-copy chanl dispatch.
  */
-static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
-			   IN OUT struct CHNL_OBJECT *pChnl, u32 iMode)
+static void io_dispatch_chnl(IN struct io_mgr *pio_mgr,
+			     IN OUT struct chnl_object *pchnl, u32 iMode)
 {
-	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(pio_mgr, IO_MGRSIGNATURE))
 		goto func_end;
 
 	/* See if there is any data available for transfer */
@@ -843,94 +872,97 @@ static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
 		goto func_end;
 
 	/* Any channel will do for this mode */
-	InputChnl(pIOMgr, pChnl, iMode);
-	OutputChnl(pIOMgr, pChnl, iMode);
+	input_chnl(pio_mgr, pchnl, iMode);
+	output_chnl(pio_mgr, pchnl, iMode);
 func_end:
 	return;
 }
 
 /*
- *  ======== IO_DispatchMsg ========
+ *  ======== io_dispatch_msg ========
  *      Performs I/O dispatch on message queues.
  */
-static void IO_DispatchMsg(IN struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+static void io_dispatch_msg(IN struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)
 {
-	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(pio_mgr, IO_MGRSIGNATURE))
 		goto func_end;
 
 	/* We are performing both input and output processing. */
-	InputMsg(pIOMgr, hMsgMgr);
-	OutputMsg(pIOMgr, hMsgMgr);
+	input_msg(pio_mgr, hmsg_mgr);
+	output_msg(pio_mgr, hmsg_mgr);
 func_end:
 	return;
 }
 
 /*
- *  ======== IO_DispatchPM ========
+ *  ======== io_dispatch_pm ========
  *      Performs I/O dispatch on PM related messages from DSP
  */
-static void IO_DispatchPM(struct IO_MGR *pIOMgr)
+static void io_dispatch_pm(struct io_mgr *pio_mgr)
 {
-	DSP_STATUS status;
-	u32 pArg[2];
+	dsp_status status;
+	u32 parg[2];
 
 	/* Perform Power message processing here */
-	pArg[0] = pIOMgr->wIntrVal;
+	parg[0] = pio_mgr->intr_val;
 
 	/* Send the command to the WMD clk/pwr manager to handle */
-	if (pArg[0] ==  MBX_PM_HIBERNATE_EN) {
+	if (parg[0] == MBX_PM_HIBERNATE_EN) {
 		dev_dbg(bridge, "PM: Hibernate command\n");
-		status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
-			 hWmdContext, WMDIOCTL_PWR_HIBERNATE, pArg);
+		status =
+		    pio_mgr->intf_fxns->pfn_dev_cntrl(pio_mgr->hwmd_context,
+						      WMDIOCTL_PWR_HIBERNATE,
+						      parg);
 		if (DSP_FAILED(status))
 			pr_err("%s: hibernate cmd failed 0x%x\n",
-							__func__, status);
-	} else if (pArg[0] == MBX_PM_OPP_REQ) {
-		pArg[1] = pIOMgr->pSharedMem->oppRequest.rqstOppPt;
-		dev_dbg(bridge, "PM: Requested OPP = 0x%x\n", pArg[1]);
-		status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
-			 hWmdContext, WMDIOCTL_CONSTRAINT_REQUEST,
-			 pArg);
+			       __func__, status);
+	} else if (parg[0] == MBX_PM_OPP_REQ) {
+		parg[1] = pio_mgr->shared_mem->opp_request.rqst_opp_pt;
+		dev_dbg(bridge, "PM: Requested OPP = 0x%x\n", parg[1]);
+		status =
+		    pio_mgr->intf_fxns->pfn_dev_cntrl(pio_mgr->hwmd_context,
+						      WMDIOCTL_CONSTRAINT_REQUEST,
+						      parg);
 		if (DSP_FAILED(status))
 			dev_dbg(bridge, "PM: Failed to set constraint "
-							"= 0x%x \n", pArg[1]);
+				"= 0x%x \n", parg[1]);
 	} else {
 		dev_dbg(bridge, "PM: clk control value of msg = 0x%x\n",
-								pArg[0]);
-		status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
-			 hWmdContext, WMDIOCTL_CLK_CTRL, pArg);
+			parg[0]);
+		status =
+		    pio_mgr->intf_fxns->pfn_dev_cntrl(pio_mgr->hwmd_context,
+						      WMDIOCTL_CLK_CTRL, parg);
 		if (DSP_FAILED(status))
 			dev_dbg(bridge, "PM: Failed to ctrl the DSP clk"
-							"= 0x%x\n", *pArg);
+				"= 0x%x\n", *parg);
 	}
 }
 
 /*
- *  ======== IO_DPC ========
+ *  ======== io_dpc ========
  *      Deferred procedure call for shared memory channel driver ISR.  Carries
  *      out the dispatch of I/O as a non-preemptible event.It can only be
  *      pre-empted      by an ISR.
  */
-void IO_DPC(IN OUT unsigned long pRefData)
+void io_dpc(IN OUT unsigned long pRefData)
 {
-	struct IO_MGR *pIOMgr = (struct IO_MGR *)pRefData;
-	struct CHNL_MGR *pChnlMgr;
-	struct MSG_MGR *pMsgMgr;
-	struct DEH_MGR *hDehMgr;
+	struct io_mgr *pio_mgr = (struct io_mgr *)pRefData;
+	struct chnl_mgr *chnl_mgr_obj;
+	struct msg_mgr *msg_mgr_obj;
+	struct deh_mgr *hdeh_mgr;
 	u32 requested;
 	u32 serviced;
 
-	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(pio_mgr, IO_MGRSIGNATURE))
 		goto func_end;
-	pChnlMgr = pIOMgr->hChnlMgr;
-	DEV_GetMsgMgr(pIOMgr->hDevObject, &pMsgMgr);
-	DEV_GetDehMgr(pIOMgr->hDevObject, &hDehMgr);
-	if (!MEM_IsValidHandle(pChnlMgr, CHNL_MGRSIGNATURE))
+	chnl_mgr_obj = pio_mgr->hchnl_mgr;
+	dev_get_msg_mgr(pio_mgr->hdev_obj, &msg_mgr_obj);
+	dev_get_deh_mgr(pio_mgr->hdev_obj, &hdeh_mgr);
+	if (!MEM_IS_VALID_HANDLE(chnl_mgr_obj, CHNL_MGRSIGNATURE))
 		goto func_end;
 
-
-	requested = pIOMgr->dpc_req;
-	serviced = pIOMgr->dpc_sched;
+	requested = pio_mgr->dpc_req;
+	serviced = pio_mgr->dpc_sched;
 
 	if (serviced == requested)
 		goto func_end;
@@ -938,27 +970,27 @@ void IO_DPC(IN OUT unsigned long pRefData)
 	/* Process pending DPC's */
 	do {
 		/* Check value of interrupt reg to ensure it's a valid error */
-		if ((pIOMgr->wIntrVal > DEH_BASE) &&
-		   (pIOMgr->wIntrVal < DEH_LIMIT)) {
+		if ((pio_mgr->intr_val > DEH_BASE) &&
+		    (pio_mgr->intr_val < DEH_LIMIT)) {
 			/* Notify DSP/BIOS exception */
-			if (hDehMgr)
-				WMD_DEH_Notify(hDehMgr, DSP_SYSERROR,
-						pIOMgr->wIntrVal);
+			if (hdeh_mgr)
+				bridge_deh_notify(hdeh_mgr, DSP_SYSERROR,
+						  pio_mgr->intr_val);
 		}
-		IO_DispatchChnl(pIOMgr, NULL, IO_SERVICE);
+		io_dispatch_chnl(pio_mgr, NULL, IO_SERVICE);
 #ifdef CHNL_MESSAGES
-		if (MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE))
-			IO_DispatchMsg(pIOMgr, pMsgMgr);
+		if (MEM_IS_VALID_HANDLE(msg_mgr_obj, MSGMGR_SIGNATURE))
+			io_dispatch_msg(pio_mgr, msg_mgr_obj);
 #endif
 #ifndef DSP_TRACEBUF_DISABLED
-		if (pIOMgr->wIntrVal & MBX_DBG_SYSPRINTF) {
+		if (pio_mgr->intr_val & MBX_DBG_SYSPRINTF) {
 			/* Notify DSP Trace message */
-			PrintDSPDebugTrace(pIOMgr);
+			print_dsp_debug_trace(pio_mgr);
 		}
 #endif
 		serviced++;
 	} while (serviced != requested);
-	pIOMgr->dpc_sched = requested;
+	pio_mgr->dpc_sched = requested;
 func_end:
 	return;
 }
@@ -971,23 +1003,23 @@ func_end:
  */
 void io_mbox_msg(u32 msg)
 {
-	struct IO_MGR *io_mgr;
-	struct DEV_OBJECT *dev_obj;
+	struct io_mgr *io_mgr;
+	struct dev_object *dev_obj;
 	unsigned long flags;
 
-	dev_obj = DEV_GetFirst();
-	DEV_GetIOMgr(dev_obj, &io_mgr);
+	dev_obj = dev_get_first();
+	dev_get_io_mgr(dev_obj, &io_mgr);
 
 	if (!io_mgr)
 		return;
 
-	io_mgr->wIntrVal = (u16)msg;
-	dev_dbg(bridge, "MBX: %s message %x\n", __func__, io_mgr->wIntrVal);
-	if (io_mgr->wIntrVal & MBX_PM_CLASS)
-		IO_DispatchPM(io_mgr);
+	io_mgr->intr_val = (u16) msg;
+	dev_dbg(bridge, "MBX: %s message %x\n", __func__, io_mgr->intr_val);
+	if (io_mgr->intr_val & MBX_PM_CLASS)
+		io_dispatch_pm(io_mgr);
 
-	if (io_mgr->wIntrVal == MBX_DEH_RESET) {
-		io_mgr->wIntrVal = 0;
+	if (io_mgr->intr_val == MBX_DEH_RESET) {
+		io_mgr->intr_val = 0;
 	} else {
 		spin_lock_irqsave(&io_mgr->dpc_lock, flags);
 		io_mgr->dpc_req++;
@@ -998,198 +1030,202 @@ void io_mbox_msg(u32 msg)
 }
 
 /*
- *  ======== IO_RequestChnl ========
+ *  ======== io_request_chnl ========
  *  Purpose:
  *      Request chanenel I/O from the DSP. Sets flags in shared memory, then
  *      interrupts the DSP.
  */
-void IO_RequestChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
-		   u32 iMode, OUT u16 *pwMbVal)
+void io_request_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
+		     u32 iMode, OUT u16 *pwMbVal)
 {
-	struct CHNL_MGR *pChnlMgr;
-	struct SHM *sm;
+	struct chnl_mgr *chnl_mgr_obj;
+	struct shm *sm;
 
-	if (!pChnl || !pwMbVal)
+	if (!pchnl || !pwMbVal)
 		goto func_end;
-	pChnlMgr = pIOMgr->hChnlMgr;
-	sm = pIOMgr->pSharedMem;
+	chnl_mgr_obj = pio_mgr->hchnl_mgr;
+	sm = pio_mgr->shared_mem;
 	if (iMode == IO_INPUT) {
 		/*
 		 * Assertion fires if CHNL_AddIOReq() called on a stream
 		 * which was cancelled, or attached to a dead board.
 		 */
-		DBC_Assert((pChnl->dwState == CHNL_STATEREADY) ||
-			  (pChnl->dwState == CHNL_STATEEOS));
+		DBC_ASSERT((pchnl->dw_state == CHNL_STATEREADY) ||
+			   (pchnl->dw_state == CHNL_STATEEOS));
 		/* Indicate to the DSP we have a buffer available for input */
-		IO_OrValue(pIOMgr->hWmdContext, struct SHM, sm, hostFreeMask,
-			  (1 << pChnl->uId));
+		IO_OR_VALUE(pio_mgr->hwmd_context, struct shm, sm,
+			    host_free_mask, (1 << pchnl->chnl_id));
 		*pwMbVal = MBX_PCPY_CLASS;
 	} else if (iMode == IO_OUTPUT) {
 		/*
 		 * This assertion fails if CHNL_AddIOReq() was called on a
 		 * stream which was cancelled, or attached to a dead board.
 		 */
-		DBC_Assert((pChnl->dwState & ~CHNL_STATEEOS) ==
-			  CHNL_STATEREADY);
+		DBC_ASSERT((pchnl->dw_state & ~CHNL_STATEEOS) ==
+			   CHNL_STATEREADY);
 		/*
 		 * Record the fact that we have a buffer available for
 		 * output.
 		 */
-		pChnlMgr->dwOutputMask |= (1 << pChnl->uId);
+		chnl_mgr_obj->dw_output_mask |= (1 << pchnl->chnl_id);
 	} else {
-		DBC_Assert(iMode); 	/* Shouldn't get here. */
+		DBC_ASSERT(iMode);	/* Shouldn't get here. */
 	}
 func_end:
 	return;
 }
 
 /*
- *  ======== IO_Schedule ========
+ *  ======== iosm_schedule ========
  *      Schedule DPC for IO.
  */
-void IO_Schedule(struct IO_MGR *pIOMgr)
+void iosm_schedule(struct io_mgr *pio_mgr)
 {
 	unsigned long flags;
 
-	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(pio_mgr, IO_MGRSIGNATURE))
 		return;
 
 	/* Increment count of DPC's pending. */
-	spin_lock_irqsave(&pIOMgr->dpc_lock, flags);
-	pIOMgr->dpc_req++;
-	spin_unlock_irqrestore(&pIOMgr->dpc_lock, flags);
+	spin_lock_irqsave(&pio_mgr->dpc_lock, flags);
+	pio_mgr->dpc_req++;
+	spin_unlock_irqrestore(&pio_mgr->dpc_lock, flags);
 
 	/* Schedule DPC */
-	tasklet_schedule(&pIOMgr->dpc_tasklet);
+	tasklet_schedule(&pio_mgr->dpc_tasklet);
 }
 
 /*
- *  ======== FindReadyOutput ========
+ *  ======== find_ready_output ========
  *      Search for a host output channel which is ready to send.  If this is
  *      called as a result of servicing the DPC, then implement a round
  *      robin search; otherwise, this was called by a client thread (via
  *      IO_Dispatch()), so just start searching from the current channel id.
  */
-static u32 FindReadyOutput(struct CHNL_MGR *pChnlMgr,
-			     struct CHNL_OBJECT *pChnl, u32 dwMask)
+static u32 find_ready_output(struct chnl_mgr *chnl_mgr_obj,
+			     struct chnl_object *pchnl, u32 dwMask)
 {
-	u32 uRetval = OUTPUTNOTREADY;
-	u32 id, startId;
+	u32 ret = OUTPUTNOTREADY;
+	u32 id, start_id;
 	u32 shift;
 
-	id = (pChnl != NULL ? pChnl->uId : (pChnlMgr->dwLastOutput + 1));
+	id = (pchnl !=
+	      NULL ? pchnl->chnl_id : (chnl_mgr_obj->dw_last_output + 1));
 	id = ((id == CHNL_MAXCHANNELS) ? 0 : id);
 	if (id >= CHNL_MAXCHANNELS)
 		goto func_end;
 	if (dwMask) {
 		shift = (1 << id);
-		startId = id;
+		start_id = id;
 		do {
 			if (dwMask & shift) {
-				uRetval = id;
-				if (pChnl == NULL)
-					pChnlMgr->dwLastOutput = id;
+				ret = id;
+				if (pchnl == NULL)
+					chnl_mgr_obj->dw_last_output = id;
 				break;
 			}
 			id = id + 1;
 			id = ((id == CHNL_MAXCHANNELS) ? 0 : id);
 			shift = (1 << id);
-		} while (id != startId);
+		} while (id != start_id);
 	}
 func_end:
-	return uRetval;
+	return ret;
 }
 
 /*
- *  ======== InputChnl ========
+ *  ======== input_chnl ========
  *      Dispatch a buffer on an input channel.
  */
-static void InputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
-		      u32 iMode)
+static void input_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
+		       u32 iMode)
 {
-	struct CHNL_MGR *pChnlMgr;
-	struct SHM *sm;
-	u32 chnlId;
-	u32 uBytes;
-	struct CHNL_IRP *pChirp = NULL;
-	u32 dwArg;
-	bool fClearChnl = false;
-	bool fNotifyClient = false;
-
-	sm = pIOMgr->pSharedMem;
-	pChnlMgr = pIOMgr->hChnlMgr;
+	struct chnl_mgr *chnl_mgr_obj;
+	struct shm *sm;
+	u32 chnl_id;
+	u32 bytes;
+	struct chnl_irp *chnl_packet_obj = NULL;
+	u32 dw_arg;
+	bool clear_chnl = false;
+	bool notify_client = false;
+
+	sm = pio_mgr->shared_mem;
+	chnl_mgr_obj = pio_mgr->hchnl_mgr;
 
 	/* Attempt to perform input */
-	if (!IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputFull))
-		goto func_end;
-
-	uBytes = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputSize) *
-			    pChnlMgr->uWordSize;
-	chnlId = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputId);
-	dwArg = IO_GetLong(pIOMgr->hWmdContext, struct SHM, sm, arg);
-	if (chnlId >= CHNL_MAXCHANNELS) {
-		/* Shouldn't be here: would indicate corrupted SHM. */
-		DBC_Assert(chnlId);
+	if (!IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm, input_full))
+		 goto func_end;
+
+	bytes =
+	    IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm,
+			 input_size) * chnl_mgr_obj->word_size;
+	chnl_id = IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm, input_id);
+	dw_arg = IO_GET_LONG(pio_mgr->hwmd_context, struct shm, sm, arg);
+	if (chnl_id >= CHNL_MAXCHANNELS) {
+		/* Shouldn't be here: would indicate corrupted shm. */
+		DBC_ASSERT(chnl_id);
 		goto func_end;
 	}
-	pChnl = pChnlMgr->apChannel[chnlId];
-	if ((pChnl != NULL) && CHNL_IsInput(pChnl->uMode)) {
-		if ((pChnl->dwState & ~CHNL_STATEEOS) == CHNL_STATEREADY) {
-			if (!pChnl->pIORequests)
+	pchnl = chnl_mgr_obj->ap_channel[chnl_id];
+	if ((pchnl != NULL) && CHNL_IS_INPUT(pchnl->chnl_mode)) {
+		if ((pchnl->dw_state & ~CHNL_STATEEOS) == CHNL_STATEREADY) {
+			if (!pchnl->pio_requests)
 				goto func_end;
 			/* Get the I/O request, and attempt a transfer */
-			pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->
-				 pIORequests);
-			if (pChirp) {
-				pChnl->cIOReqs--;
-				if (pChnl->cIOReqs < 0)
+			chnl_packet_obj = (struct chnl_irp *)
+			    lst_get_head(pchnl->pio_requests);
+			if (chnl_packet_obj) {
+				pchnl->cio_reqs--;
+				if (pchnl->cio_reqs < 0)
 					goto func_end;
 				/*
 				 * Ensure we don't overflow the client's
 				 * buffer.
 				 */
-				uBytes = min(uBytes, pChirp->cBytes);
+				bytes = min(bytes, chnl_packet_obj->byte_size);
 				/* Transfer buffer from DSP side */
-				uBytes = ReadData(pIOMgr->hWmdContext,
-						pChirp->pHostSysBuf,
-						pIOMgr->pInput, uBytes);
-				pChnl->cBytesMoved += uBytes;
-				pChirp->cBytes = uBytes;
-				pChirp->dwArg = dwArg;
-				pChirp->status = CHNL_IOCSTATCOMPLETE;
-
-				if (uBytes == 0) {
+				bytes = read_data(pio_mgr->hwmd_context,
+						  chnl_packet_obj->host_sys_buf,
+						  pio_mgr->input, bytes);
+				pchnl->bytes_moved += bytes;
+				chnl_packet_obj->byte_size = bytes;
+				chnl_packet_obj->dw_arg = dw_arg;
+				chnl_packet_obj->status = CHNL_IOCSTATCOMPLETE;
+
+				if (bytes == 0) {
 					/*
 					 * This assertion fails if the DSP
 					 * sends EOS more than once on this
 					 * channel.
 					 */
-					if (pChnl->dwState & CHNL_STATEEOS)
+					if (pchnl->dw_state & CHNL_STATEEOS)
 						goto func_end;
 					/*
 					 * Zero bytes indicates EOS. Update
 					 * IOC status for this chirp, and also
 					 * the channel state.
 					 */
-					pChirp->status |= CHNL_IOCSTATEOS;
-					pChnl->dwState |= CHNL_STATEEOS;
+					chnl_packet_obj->status |=
+					    CHNL_IOCSTATEOS;
+					pchnl->dw_state |= CHNL_STATEEOS;
 					/*
 					 * Notify that end of stream has
 					 * occurred.
 					 */
-					NTFY_Notify(pChnl->hNtfy,
-						   DSP_STREAMDONE);
+					ntfy_notify(pchnl->ntfy_obj,
+						    DSP_STREAMDONE);
 				}
 				/* Tell DSP if no more I/O buffers available */
-				if (!pChnl->pIORequests)
+				if (!pchnl->pio_requests)
 					goto func_end;
-				if (LST_IsEmpty(pChnl->pIORequests)) {
-					IO_AndValue(pIOMgr->hWmdContext,
-						   struct SHM, sm, hostFreeMask,
-						   ~(1 << pChnl->uId));
+				if (LST_IS_EMPTY(pchnl->pio_requests)) {
+					IO_AND_VALUE(pio_mgr->hwmd_context,
+						     struct shm, sm,
+						     host_free_mask,
+						     ~(1 << pchnl->chnl_id));
 				}
-				fClearChnl = true;
-				fNotifyClient = true;
+				clear_chnl = true;
+				notify_client = true;
 			} else {
 				/*
 				 * Input full for this channel, but we have no
@@ -1197,339 +1233,357 @@ static void InputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
 				 * "idling". Clear out the physical input
 				 * channel.
 				 */
-				fClearChnl = true;
+				clear_chnl = true;
 			}
 		} else {
 			/* Input channel cancelled: clear input channel */
-			fClearChnl = true;
+			clear_chnl = true;
 		}
 	} else {
 		/* DPC fired after host closed channel: clear input channel */
-		fClearChnl = true;
+		clear_chnl = true;
 	}
-	if (fClearChnl) {
+	if (clear_chnl) {
 		/* Indicate to the DSP we have read the input */
-		IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, inputFull, 0);
-		sm_interrupt_dsp(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+		IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, input_full,
+			     0);
+		sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 	}
-	if (fNotifyClient) {
+	if (notify_client) {
 		/* Notify client with IO completion record */
-		NotifyChnlComplete(pChnl, pChirp);
+		notify_chnl_complete(pchnl, chnl_packet_obj);
 	}
 func_end:
 	return;
 }
 
 /*
- *  ======== InputMsg ========
+ *  ======== input_msg ========
  *      Copies messages from shared memory to the message queues.
  */
-static void InputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+static void input_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)
 {
-	u32 uMsgs;
+	u32 num_msgs;
 	u32 i;
-	u8 *pMsgInput;
-	struct MSG_QUEUE *hMsgQueue;
-	struct MSG_FRAME *pMsg;
-	struct MSG_DSPMSG msg;
-	struct MSG *pCtrl;
-	u32 fInputEmpty;
+	u8 *msg_input;
+	struct msg_queue *msg_queue_obj;
+	struct msg_frame *pmsg;
+	struct msg_dspmsg msg;
+	struct msg_ctrl *msg_ctr_obj;
+	u32 input_empty;
 	u32 addr;
 
-	pCtrl = pIOMgr->pMsgInputCtrl;
+	msg_ctr_obj = pio_mgr->msg_input_ctrl;
 	/* Get the number of input messages to be read */
-	fInputEmpty = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				 bufEmpty);
-	uMsgs = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, size);
-	if (fInputEmpty)
+	input_empty =
+	    IO_GET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl, msg_ctr_obj,
+			 buf_empty);
+	num_msgs =
+	    IO_GET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl, msg_ctr_obj,
+			 size);
+	if (input_empty)
 		goto func_end;
 
-	pMsgInput = pIOMgr->pMsgInput;
-	for (i = 0; i < uMsgs; i++) {
+	msg_input = pio_mgr->msg_input;
+	for (i = 0; i < num_msgs; i++) {
 		/* Read the next message */
-		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwCmd);
-		msg.msg.dwCmd = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
-		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwArg1);
-		msg.msg.dwArg1 = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
-		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwArg2);
-		msg.msg.dwArg2 = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
-		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->dwId);
-		msg.dwId = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
-		pMsgInput += sizeof(struct MSG_DSPMSG);
-		if (!hMsgMgr->queueList)
+		addr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.dw_cmd);
+		msg.msg.dw_cmd =
+		    read_ext32_bit_dsp_data(pio_mgr->hwmd_context, addr);
+		addr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.dw_arg1);
+		msg.msg.dw_arg1 =
+		    read_ext32_bit_dsp_data(pio_mgr->hwmd_context, addr);
+		addr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.dw_arg2);
+		msg.msg.dw_arg2 =
+		    read_ext32_bit_dsp_data(pio_mgr->hwmd_context, addr);
+		addr = (u32) &(((struct msg_dspmsg *)msg_input)->msgq_id);
+		msg.msgq_id =
+		    read_ext32_bit_dsp_data(pio_mgr->hwmd_context, addr);
+		msg_input += sizeof(struct msg_dspmsg);
+		if (!hmsg_mgr->queue_list)
 			goto func_end;
 
 		/* Determine which queue to put the message in */
-		hMsgQueue = (struct MSG_QUEUE *)LST_First(hMsgMgr->queueList);
-		dev_dbg(bridge, "input msg: dwCmd=0x%x dwArg1=0x%x "
-			 "dwArg2=0x%x dwId=0x%x \n", msg.msg.dwCmd,
-			 msg.msg.dwArg1, msg.msg.dwArg2, msg.dwId);
+		msg_queue_obj =
+		    (struct msg_queue *)lst_first(hmsg_mgr->queue_list);
+		dev_dbg(bridge,	"input msg: dw_cmd=0x%x dw_arg1=0x%x "
+			"dw_arg2=0x%x msgq_id=0x%x \n", msg.msg.dw_cmd,
+			msg.msg.dw_arg1, msg.msg.dw_arg2, msg.msgq_id);
 		/*
 		 * Interrupt may occur before shared memory and message
 		 * input locations have been set up. If all nodes were
-		 * cleaned up, hMsgMgr->uMaxMsgs should be 0.
+		 * cleaned up, hmsg_mgr->max_msgs should be 0.
 		 */
-		while (hMsgQueue != NULL) {
-			if (msg.dwId == hMsgQueue->dwId) {
+		while (msg_queue_obj != NULL) {
+			if (msg.msgq_id == msg_queue_obj->msgq_id) {
 				/* Found it */
-				if (msg.msg.dwCmd == RMS_EXITACK) {
+				if (msg.msg.dw_cmd == RMS_EXITACK) {
 					/*
 					 * Call the node exit notification.
 					 * The exit message does not get
 					 * queued.
 					 */
-					(*hMsgMgr->onExit)((HANDLE)hMsgQueue->
-						hArg, msg.msg.dwArg1);
+					(*hmsg_mgr->on_exit) ((bhandle)
+							   msg_queue_obj->arg,
+							   msg.msg.dw_arg1);
 				} else {
 					/*
 					 * Not an exit acknowledgement, queue
 					 * the message.
 					 */
-					if (!hMsgQueue->msgFreeList)
+					if (!msg_queue_obj->msg_free_list)
 						goto func_end;
-					pMsg = (struct MSG_FRAME *)LST_GetHead
-						(hMsgQueue->msgFreeList);
-					if (hMsgQueue->msgUsedList && pMsg) {
-						pMsg->msgData = msg;
-						LST_PutTail(hMsgQueue->
-						    msgUsedList,
-						    (struct list_head *)pMsg);
-						NTFY_Notify(hMsgQueue->hNtfy,
-							DSP_NODEMESSAGEREADY);
-						SYNC_SetEvent(hMsgQueue->
-							hSyncEvent);
+					pmsg = (struct msg_frame *)lst_get_head
+					    (msg_queue_obj->msg_free_list);
+					if (msg_queue_obj->msg_used_list
+					    && pmsg) {
+						pmsg->msg_data = msg;
+						lst_put_tail
+						 (msg_queue_obj->msg_used_list,
+						     (struct list_head *)pmsg);
+						ntfy_notify
+						    (msg_queue_obj->ntfy_obj,
+						     DSP_NODEMESSAGEREADY);
+						sync_set_event
+						    (msg_queue_obj->sync_event);
 					} else {
 						/*
 						 * No free frame to copy the
 						 * message into.
 						 */
 						pr_err("%s: no free msg frames,"
-							" discarding msg\n",
-							__func__);
+						       " discarding msg\n",
+						       __func__);
 					}
 				}
 				break;
 			}
 
-			if (!hMsgMgr->queueList || !hMsgQueue)
+			if (!hmsg_mgr->queue_list || !msg_queue_obj)
 				goto func_end;
-			hMsgQueue = (struct MSG_QUEUE *)LST_Next(hMsgMgr->
-				    queueList, (struct list_head *)hMsgQueue);
+			msg_queue_obj =
+			    (struct msg_queue *)lst_next(hmsg_mgr->queue_list,
+							 (struct list_head *)
+							 msg_queue_obj);
 		}
 	}
 	/* Set the post SWI flag */
-	if (uMsgs > 0) {
+	if (num_msgs > 0) {
 		/* Tell the DSP we've read the messages */
-		IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, bufEmpty,
-			   true);
-		IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, postSWI,
-			   true);
-		sm_interrupt_dsp(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+		IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+			     msg_ctr_obj, buf_empty, true);
+		IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+			     msg_ctr_obj, post_swi, true);
+		sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 	}
 func_end:
 	return;
 }
 
 /*
- *  ======== NotifyChnlComplete ========
+ *  ======== notify_chnl_complete ========
  *  Purpose:
  *      Signal the channel event, notifying the client that I/O has completed.
  */
-static void NotifyChnlComplete(struct CHNL_OBJECT *pChnl,
-			      struct CHNL_IRP *pChirp)
+static void notify_chnl_complete(struct chnl_object *pchnl,
+				 struct chnl_irp *chnl_packet_obj)
 {
-	bool fSignalEvent;
+	bool signal_event;
 
-	if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE) || !pChnl->hSyncEvent ||
-	   !pChnl->pIOCompletions || !pChirp)
+	if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE) || !pchnl->sync_event ||
+	    !pchnl->pio_completions || !chnl_packet_obj)
 		goto func_end;
 
 	/*
 	 * Note: we signal the channel event only if the queue of IO
 	 * completions is empty.  If it is not empty, the event is sure to be
 	 * signalled by the only IO completion list consumer:
-	 * WMD_CHNL_GetIOC().
+	 * bridge_chnl_get_ioc().
 	 */
-	fSignalEvent = LST_IsEmpty(pChnl->pIOCompletions);
+	signal_event = LST_IS_EMPTY(pchnl->pio_completions);
 	/* Enqueue the IO completion info for the client */
-	LST_PutTail(pChnl->pIOCompletions, (struct list_head *)pChirp);
-	pChnl->cIOCs++;
+	lst_put_tail(pchnl->pio_completions,
+		     (struct list_head *)chnl_packet_obj);
+	pchnl->cio_cs++;
 
-	if (pChnl->cIOCs > pChnl->cChirps)
+	if (pchnl->cio_cs > pchnl->chnl_packets)
 		goto func_end;
 	/* Signal the channel event (if not already set) that IO is complete */
-	if (fSignalEvent)
-		SYNC_SetEvent(pChnl->hSyncEvent);
+	if (signal_event)
+		sync_set_event(pchnl->sync_event);
 
 	/* Notify that IO is complete */
-	NTFY_Notify(pChnl->hNtfy, DSP_STREAMIOCOMPLETION);
+	ntfy_notify(pchnl->ntfy_obj, DSP_STREAMIOCOMPLETION);
 func_end:
 	return;
 }
 
 /*
- *  ======== OutputChnl ========
+ *  ======== output_chnl ========
  *  Purpose:
  *      Dispatch a buffer on an output channel.
  */
-static void OutputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+static void output_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
 			u32 iMode)
 {
-	struct CHNL_MGR *pChnlMgr;
-	struct SHM *sm;
-	u32 chnlId;
-	struct CHNL_IRP *pChirp;
-	u32 dwDspFMask;
-
-	pChnlMgr = pIOMgr->hChnlMgr;
-	sm = pIOMgr->pSharedMem;
+	struct chnl_mgr *chnl_mgr_obj;
+	struct shm *sm;
+	u32 chnl_id;
+	struct chnl_irp *chnl_packet_obj;
+	u32 dw_dsp_f_mask;
+
+	chnl_mgr_obj = pio_mgr->hchnl_mgr;
+	sm = pio_mgr->shared_mem;
 	/* Attempt to perform output */
-	if (IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, outputFull))
-		goto func_end;
+	if (IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_full))
+		 goto func_end;
 
-	if (pChnl && !((pChnl->dwState & ~CHNL_STATEEOS) == CHNL_STATEREADY))
+	if (pchnl && !((pchnl->dw_state & ~CHNL_STATEEOS) == CHNL_STATEREADY))
 		goto func_end;
 
 	/* Look to see if both a PC and DSP output channel are ready */
-	dwDspFMask = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm,
-				 dspFreeMask);
-	chnlId = FindReadyOutput(pChnlMgr, pChnl, (pChnlMgr->dwOutputMask &
-				 dwDspFMask));
-	if (chnlId == OUTPUTNOTREADY)
+	dw_dsp_f_mask = IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm,
+				     dsp_free_mask);
+	chnl_id =
+	    find_ready_output(chnl_mgr_obj, pchnl,
+			      (chnl_mgr_obj->dw_output_mask & dw_dsp_f_mask));
+	if (chnl_id == OUTPUTNOTREADY)
 		goto func_end;
 
-	pChnl = pChnlMgr->apChannel[chnlId];
-	if (!pChnl || !pChnl->pIORequests) {
+	pchnl = chnl_mgr_obj->ap_channel[chnl_id];
+	if (!pchnl || !pchnl->pio_requests) {
 		/* Shouldn't get here */
 		goto func_end;
 	}
 	/* Get the I/O request, and attempt a transfer */
-	pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIORequests);
-	if (!pChirp)
+	chnl_packet_obj = (struct chnl_irp *)lst_get_head(pchnl->pio_requests);
+	if (!chnl_packet_obj)
 		goto func_end;
 
-	pChnl->cIOReqs--;
-	if (pChnl->cIOReqs < 0 || !pChnl->pIORequests)
+	pchnl->cio_reqs--;
+	if (pchnl->cio_reqs < 0 || !pchnl->pio_requests)
 		goto func_end;
 
 	/* Record fact that no more I/O buffers available */
-	if (LST_IsEmpty(pChnl->pIORequests))
-		pChnlMgr->dwOutputMask &= ~(1 << chnlId);
+	if (LST_IS_EMPTY(pchnl->pio_requests))
+		chnl_mgr_obj->dw_output_mask &= ~(1 << chnl_id);
 
 	/* Transfer buffer to DSP side */
-	pChirp->cBytes = WriteData(pIOMgr->hWmdContext, pIOMgr->pOutput,
-			pChirp->pHostSysBuf, min(pIOMgr->uSMBufSize, pChirp->
-			cBytes));
-	pChnl->cBytesMoved += pChirp->cBytes;
-	/* Write all 32 bits of arg */
-	IO_SetLong(pIOMgr->hWmdContext, struct SHM, sm, arg, pChirp->dwArg);
+	chnl_packet_obj->byte_size =
+	    write_data(pio_mgr->hwmd_context, pio_mgr->output,
+		       chnl_packet_obj->host_sys_buf, min(pio_mgr->usm_buf_size,
+						  chnl_packet_obj->byte_size));
+	pchnl->bytes_moved += chnl_packet_obj->byte_size;
+	/* mem_write all 32 bits of arg */
+	IO_SET_LONG(pio_mgr->hwmd_context, struct shm, sm, arg,
+		    chnl_packet_obj->dw_arg);
 #if _CHNL_WORDSIZE == 2
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputId,
-		   (u16)chnlId);
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputSize,
-		   (u16)(pChirp->cBytes + (pChnlMgr->uWordSize-1)) /
-		   (u16)pChnlMgr->uWordSize);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_id,
+		     (u16) chnl_id);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_size,
+		     (u16) (chnl_packet_obj->byte_size +
+			    (chnl_mgr_obj->word_size -
+			     1)) / (u16) chnl_mgr_obj->word_size);
 #else
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputId, chnlId);
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputSize,
-		   (pChirp->cBytes + (pChnlMgr->uWordSize - 1)) / pChnlMgr->
-		   uWordSize);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_id, chnl_id);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_size,
+		     (chnl_packet_obj->byte_size +
+		      (chnl_mgr_obj->word_size - 1)) / chnl_mgr_obj->word_size);
 #endif
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputFull, 1);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_full, 1);
 	/* Indicate to the DSP we have written the output */
-	sm_interrupt_dsp(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+	sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 	/* Notify client with IO completion record (keep EOS) */
-	pChirp->status &= CHNL_IOCSTATEOS;
-	NotifyChnlComplete(pChnl, pChirp);
+	chnl_packet_obj->status &= CHNL_IOCSTATEOS;
+	notify_chnl_complete(pchnl, chnl_packet_obj);
 	/* Notify if stream is done. */
-	if (pChirp->status & CHNL_IOCSTATEOS)
-		NTFY_Notify(pChnl->hNtfy, DSP_STREAMDONE);
+	if (chnl_packet_obj->status & CHNL_IOCSTATEOS)
+		ntfy_notify(pchnl->ntfy_obj, DSP_STREAMDONE);
 
 func_end:
 	return;
 }
+
 /*
- *  ======== OutputMsg ========
+ *  ======== output_msg ========
  *      Copies messages from the message queues to the shared memory.
  */
-static void OutputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+static void output_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)
 {
-	u32 uMsgs = 0;
+	u32 num_msgs = 0;
 	u32 i;
-	u8 *pMsgOutput;
-	struct MSG_FRAME *pMsg;
-	struct MSG *pCtrl;
-	u32 fOutputEmpty;
+	u8 *msg_output;
+	struct msg_frame *pmsg;
+	struct msg_ctrl *msg_ctr_obj;
+	u32 output_empty;
 	u32 val;
 	u32 addr;
 
-	pCtrl = pIOMgr->pMsgOutputCtrl;
+	msg_ctr_obj = pio_mgr->msg_output_ctrl;
 
 	/* Check if output has been cleared */
-	fOutputEmpty = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				  bufEmpty);
-	if (fOutputEmpty) {
-		uMsgs = (hMsgMgr->uMsgsPending > hMsgMgr->uMaxMsgs) ?
-			 hMsgMgr->uMaxMsgs : hMsgMgr->uMsgsPending;
-		pMsgOutput = pIOMgr->pMsgOutput;
-		/* Copy uMsgs messages into shared memory */
-		for (i = 0; i < uMsgs; i++) {
-			if (!hMsgMgr->msgUsedList) {
-				pMsg = NULL;
+	output_empty =
+	    IO_GET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl, msg_ctr_obj,
+			 buf_empty);
+	if (output_empty) {
+		num_msgs = (hmsg_mgr->msgs_pending > hmsg_mgr->max_msgs) ?
+		    hmsg_mgr->max_msgs : hmsg_mgr->msgs_pending;
+		msg_output = pio_mgr->msg_output;
+		/* Copy num_msgs messages into shared memory */
+		for (i = 0; i < num_msgs; i++) {
+			if (!hmsg_mgr->msg_used_list) {
+				pmsg = NULL;
 				goto func_end;
 			} else {
-				pMsg = (struct MSG_FRAME *)LST_GetHead(
-					hMsgMgr->msgUsedList);
+				pmsg = (struct msg_frame *)
+				    lst_get_head(hmsg_mgr->msg_used_list);
 			}
-			if (pMsg != NULL) {
-				val = (pMsg->msgData).dwId;
-				addr = (u32)&(((struct MSG_DSPMSG *)
-					pMsgOutput)->dwId);
-				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
-						     val);
-				val = (pMsg->msgData).msg.dwCmd;
-				addr = (u32)&((((struct MSG_DSPMSG *)
-					pMsgOutput)->msg).dwCmd);
-				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
-						     val);
-				val = (pMsg->msgData).msg.dwArg1;
-				addr =
-					(u32)&((((struct MSG_DSPMSG *)
-					pMsgOutput)->msg).dwArg1);
-				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
-						    val);
-				val = (pMsg->msgData).msg.dwArg2;
-				addr =
-					(u32)&((((struct MSG_DSPMSG *)
-					pMsgOutput)->msg).dwArg2);
-				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
-						    val);
-				pMsgOutput += sizeof(struct MSG_DSPMSG);
-				if (!hMsgMgr->msgFreeList)
+			if (pmsg != NULL) {
+				val = (pmsg->msg_data).msgq_id;
+				addr = (u32) &(((struct msg_dspmsg *)
+						 msg_output)->msgq_id);
+				write_ext32_bit_dsp_data(pio_mgr->hwmd_context,
+							 addr, val);
+				val = (pmsg->msg_data).msg.dw_cmd;
+				addr = (u32) &((((struct msg_dspmsg *)
+						  msg_output)->msg).dw_cmd);
+				write_ext32_bit_dsp_data(pio_mgr->hwmd_context,
+							 addr, val);
+				val = (pmsg->msg_data).msg.dw_arg1;
+				addr = (u32) &((((struct msg_dspmsg *)
+						  msg_output)->msg).dw_arg1);
+				write_ext32_bit_dsp_data(pio_mgr->hwmd_context,
+							 addr, val);
+				val = (pmsg->msg_data).msg.dw_arg2;
+				addr = (u32) &((((struct msg_dspmsg *)
+						  msg_output)->msg).dw_arg2);
+				write_ext32_bit_dsp_data(pio_mgr->hwmd_context,
+							 addr, val);
+				msg_output += sizeof(struct msg_dspmsg);
+				if (!hmsg_mgr->msg_free_list)
 					goto func_end;
-				LST_PutTail(hMsgMgr->msgFreeList,
-					   (struct list_head *)pMsg);
-				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+				lst_put_tail(hmsg_mgr->msg_free_list,
+					     (struct list_head *)pmsg);
+				sync_set_event(hmsg_mgr->sync_event);
 			}
 		}
 
-		if (uMsgs > 0) {
-			hMsgMgr->uMsgsPending -= uMsgs;
+		if (num_msgs > 0) {
+			hmsg_mgr->msgs_pending -= num_msgs;
 #if _CHNL_WORDSIZE == 2
-			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				   size, (u16)uMsgs);
+			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+				     msg_ctr_obj, size, (u16) num_msgs);
 #else
-			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				   size, uMsgs);
+			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+				     msg_ctr_obj, size, num_msgs);
 #endif
-			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				   bufEmpty, false);
+			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+				     msg_ctr_obj, buf_empty, false);
 			/* Set the post SWI flag */
-			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				   postSWI, true);
+			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+				     msg_ctr_obj, post_swi, true);
 			/* Tell the DSP we have written the output. */
-			sm_interrupt_dsp(pIOMgr->hWmdContext,
-						MBX_PCPY_CLASS);
+			sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 		}
 	}
 func_end:
@@ -1537,39 +1591,40 @@ func_end:
 }
 
 /*
- *  ======== registerSHMSegs ========
+ *  ======== register_shm_segs ========
  *  purpose:
  *      Registers GPP SM segment with CMM.
  */
-static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
-				 struct COD_MANAGER *hCodMan,
-				 u32 dwGPPBasePA)
+static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
+				    struct cod_manager *cod_man,
+				    u32 dw_gpp_base_pa)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 ulShm0_Base = 0;
-	u32 ulShm0_End = 0;
-	u32 ulShm0_RsrvdStart = 0;
-	u32 ulRsrvdSize = 0;
-	u32 ulGppPhys;
-	u32 ulDspVirt;
-	u32 ulShmSegId0 = 0;
-	u32 dwOffset, dwGPPBaseVA, ulDSPSize;
+	dsp_status status = DSP_SOK;
+	u32 ul_shm0_base = 0;
+	u32 shm0_end = 0;
+	u32 ul_shm0_rsrvd_start = 0;
+	u32 ul_rsrvd_size = 0;
+	u32 ul_gpp_phys;
+	u32 ul_dsp_virt;
+	u32 ul_shm_seg_id0 = 0;
+	u32 dw_offset, dw_gpp_base_va, ul_dsp_size;
 
 	/*
 	 * Read address and size info for first SM region.
 	 * Get start of 1st SM Heap region.
 	 */
-	status = COD_GetSymValue(hCodMan, SHM0_SHARED_BASE_SYM, &ulShm0_Base);
-	if (ulShm0_Base == 0) {
+	status =
+	    cod_get_sym_value(cod_man, SHM0_SHARED_BASE_SYM, &ul_shm0_base);
+	if (ul_shm0_base == 0) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
 	/* Get end of 1st SM Heap region */
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
-		status = COD_GetSymValue(hCodMan, SHM0_SHARED_END_SYM,
-					 &ulShm0_End);
-		if (ulShm0_End == 0) {
+		status = cod_get_sym_value(cod_man, SHM0_SHARED_END_SYM,
+					   &shm0_end);
+		if (shm0_end == 0) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
@@ -1577,52 +1632,54 @@ static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
 	/* Start of Gpp reserved region */
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
-		status = COD_GetSymValue(hCodMan, SHM0_SHARED_RESERVED_BASE_SYM,
-					&ulShm0_RsrvdStart);
-		if (ulShm0_RsrvdStart == 0) {
+		status =
+		    cod_get_sym_value(cod_man, SHM0_SHARED_RESERVED_BASE_SYM,
+				      &ul_shm0_rsrvd_start);
+		if (ul_shm0_rsrvd_start == 0) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
 	}
 	/* Register with CMM */
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetCmmMgr(hIOMgr->hDevObject, &hIOMgr->hCmmMgr);
+		status = dev_get_cmm_mgr(hio_mgr->hdev_obj, &hio_mgr->hcmm_mgr);
 		if (DSP_SUCCEEDED(status)) {
-			status = CMM_UnRegisterGPPSMSeg(hIOMgr->hCmmMgr,
-				 CMM_ALLSEGMENTS);
+			status = cmm_un_register_gppsm_seg(hio_mgr->hcmm_mgr,
+							   CMM_ALLSEGMENTS);
 		}
 	}
 	/* Register new SM region(s) */
-	if (DSP_SUCCEEDED(status) && (ulShm0_End - ulShm0_Base) > 0) {
+	if (DSP_SUCCEEDED(status) && (shm0_end - ul_shm0_base) > 0) {
 		/* Calc size (bytes) of SM the GPP can alloc from */
-		ulRsrvdSize = (ulShm0_End - ulShm0_RsrvdStart + 1) * hIOMgr->
-			      uWordSize;
-		if (ulRsrvdSize <= 0) {
+		ul_rsrvd_size =
+		    (shm0_end - ul_shm0_rsrvd_start + 1) * hio_mgr->word_size;
+		if (ul_rsrvd_size <= 0) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
 		/* Calc size of SM DSP can alloc from */
-		ulDSPSize = (ulShm0_RsrvdStart - ulShm0_Base) * hIOMgr->
-			uWordSize;
-		if (ulDSPSize <= 0) {
+		ul_dsp_size =
+		    (ul_shm0_rsrvd_start - ul_shm0_base) * hio_mgr->word_size;
+		if (ul_dsp_size <= 0) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
-		/* First TLB entry reserved for Bridge SM use.*/
-		ulGppPhys = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
+		/* First TLB entry reserved for Bridge SM use. */
+		ul_gpp_phys = hio_mgr->ext_proc_info.ty_tlb[0].ul_gpp_phys;
 		/* Get size in bytes */
-		ulDspVirt = hIOMgr->extProcInfo.tyTlb[0].ulDspVirt * hIOMgr->
-			uWordSize;
+		ul_dsp_virt =
+		    hio_mgr->ext_proc_info.ty_tlb[0].ul_dsp_virt *
+		    hio_mgr->word_size;
 		/*
 		 * Calc byte offset used to convert GPP phys <-> DSP byte
 		 * address.
 		 */
-		if (dwGPPBasePA > ulDspVirt)
-			dwOffset = dwGPPBasePA - ulDspVirt;
+		if (dw_gpp_base_pa > ul_dsp_virt)
+			dw_offset = dw_gpp_base_pa - ul_dsp_virt;
 		else
-			dwOffset = ulDspVirt - dwGPPBasePA;
+			dw_offset = ul_dsp_virt - dw_gpp_base_pa;
 
-		if (ulShm0_RsrvdStart * hIOMgr->uWordSize < ulDspVirt) {
+		if (ul_shm0_rsrvd_start * hio_mgr->word_size < ul_dsp_virt) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
@@ -1630,22 +1687,29 @@ static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
 		 * Calc Gpp phys base of SM region.
 		 * This is actually uncached kernel virtual address.
 		 */
-		dwGPPBaseVA = ulGppPhys + ulShm0_RsrvdStart * hIOMgr->uWordSize
-				- ulDspVirt;
+		dw_gpp_base_va =
+		    ul_gpp_phys + ul_shm0_rsrvd_start * hio_mgr->word_size -
+		    ul_dsp_virt;
 		/*
 		 * Calc Gpp phys base of SM region.
 		 * This is the physical address.
 		 */
-		dwGPPBasePA = dwGPPBasePA + ulShm0_RsrvdStart * hIOMgr->
-			      uWordSize - ulDspVirt;
-		/* Register SM Segment 0.*/
-		status = CMM_RegisterGPPSMSeg(hIOMgr->hCmmMgr, dwGPPBasePA,
-			 ulRsrvdSize, dwOffset, (dwGPPBasePA > ulDspVirt) ?
-			 CMM_ADDTODSPPA : CMM_SUBFROMDSPPA,
-			 (u32)(ulShm0_Base * hIOMgr->uWordSize),
-			 ulDSPSize, &ulShmSegId0, dwGPPBaseVA);
-		/* First SM region is segId = 1 */
-		if (ulShmSegId0 != 1)
+		dw_gpp_base_pa =
+		    dw_gpp_base_pa + ul_shm0_rsrvd_start * hio_mgr->word_size -
+		    ul_dsp_virt;
+		/* Register SM Segment 0. */
+		status =
+		    cmm_register_gppsm_seg(hio_mgr->hcmm_mgr, dw_gpp_base_pa,
+					   ul_rsrvd_size, dw_offset,
+					   (dw_gpp_base_pa >
+					    ul_dsp_virt) ? CMM_ADDTODSPPA :
+					   CMM_SUBFROMDSPPA,
+					   (u32) (ul_shm0_base *
+						  hio_mgr->word_size),
+					   ul_dsp_size, &ul_shm_seg_id0,
+					   dw_gpp_base_va);
+		/* First SM region is seg_id = 1 */
+		if (ul_shm_seg_id0 != 1)
 			status = DSP_EFAIL;
 	}
 func_end:
@@ -1653,50 +1717,50 @@ func_end:
 }
 
 /*
- *  ======== ReadData ========
+ *  ======== read_data ========
  *      Copies buffers from the shared memory to the host buffer.
  */
-static u32 ReadData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-		     void *pSrc, u32 uSize)
+static u32 read_data(struct wmd_dev_context *hDevContext, void *dest,
+		     void *pSrc, u32 usize)
 {
-	memcpy(pDest, pSrc, uSize);
-	return uSize;
+	memcpy(dest, pSrc, usize);
+	return usize;
 }
 
 /*
- *  ======== WriteData ========
+ *  ======== write_data ========
  *      Copies buffers from the host side buffer to the shared memory.
  */
-static u32 WriteData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-			void *pSrc, u32 uSize)
+static u32 write_data(struct wmd_dev_context *hDevContext, void *dest,
+		      void *pSrc, u32 usize)
 {
-	memcpy(pDest, pSrc, uSize);
-	return uSize;
+	memcpy(dest, pSrc, usize);
+	return usize;
 }
 
 /* ZCPY IO routines. */
-void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal)
+void io_intr_dsp2(IN struct io_mgr *pio_mgr, IN u16 mb_val)
 {
-	sm_interrupt_dsp(pIOMgr->hWmdContext, wMbVal);
+	sm_interrupt_dsp(pio_mgr->hwmd_context, mb_val);
 }
 
 /*
  *  ======== IO_SHMcontrol ========
- *      Sets the requested SHM setting.
+ *      Sets the requested shm setting.
  */
-DSP_STATUS IO_SHMsetting(struct IO_MGR *hIOMgr, u8 desc, void *pArgs)
+dsp_status io_sh_msetting(struct io_mgr *hio_mgr, u8 desc, void *pargs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 i;
 	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 
 	switch (desc) {
 	case SHM_CURROPP:
 		/* Update the shared memory with requested OPP information */
-		if (pArgs != NULL)
-			hIOMgr->pSharedMem->oppTableStruct.currOppPt =
-				*(u32 *)pArgs;
+		if (pargs != NULL)
+			hio_mgr->shared_mem->opp_table_struct.curr_opp_pt =
+			    *(u32 *) pargs;
 		else
 			return DSP_EFAIL;
 		break;
@@ -1706,36 +1770,37 @@ DSP_STATUS IO_SHMsetting(struct IO_MGR *hIOMgr, u8 desc, void *pArgs)
 		 * min and max frequency values for an OPP.
 		 */
 		for (i = 0; i <= pdata->dsp_num_speeds; i++) {
-			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].voltage =
-				pdata->dsp_freq_table[i].u_volts;
-			dev_dbg(bridge, "OPP-SHM: voltage: %lx\n",
+			hio_mgr->shared_mem->opp_table_struct.opp_point[i].
+			    voltage = pdata->dsp_freq_table[i].u_volts;
+			dev_dbg(bridge, "OPP-shm: voltage: %lx\n",
 				pdata->dsp_freq_table[i].u_volts);
-			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].
-				frequency = pdata->dsp_freq_table[i].dsp_freq;
-			dev_dbg(bridge, "OPP-SHM: frequency: %lx\n",
+			hio_mgr->shared_mem->opp_table_struct.
+			    opp_point[i].frequency =
+			    pdata->dsp_freq_table[i].dsp_freq;
+			dev_dbg(bridge, "OPP-shm: frequency: %lx\n",
 				pdata->dsp_freq_table[i].dsp_freq);
-			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].minFreq =
-				pdata->dsp_freq_table[i].thresh_min_freq;
-			dev_dbg(bridge, "OPP-SHM: min freq: %lx\n",
+			hio_mgr->shared_mem->opp_table_struct.opp_point[i].
+			    min_freq = pdata->dsp_freq_table[i].thresh_min_freq;
+			dev_dbg(bridge, "OPP-shm: min freq: %lx\n",
 				pdata->dsp_freq_table[i].thresh_min_freq);
-			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].maxFreq =
-				pdata->dsp_freq_table[i].thresh_max_freq;
-			dev_dbg(bridge, "OPP-SHM: max freq: %lx\n",
+			hio_mgr->shared_mem->opp_table_struct.opp_point[i].
+			    max_freq = pdata->dsp_freq_table[i].thresh_max_freq;
+			dev_dbg(bridge, "OPP-shm: max freq: %lx\n",
 				pdata->dsp_freq_table[i].thresh_max_freq);
 		}
-		hIOMgr->pSharedMem->oppTableStruct.numOppPts =
-			pdata->dsp_num_speeds;
-		dev_dbg(bridge, "OPP-SHM: max OPP number: %d\n",
-						pdata->dsp_num_speeds);
+		hio_mgr->shared_mem->opp_table_struct.num_opp_pts =
+		    pdata->dsp_num_speeds;
+		dev_dbg(bridge, "OPP-shm: max OPP number: %d\n",
+			pdata->dsp_num_speeds);
 		/* Update the current OPP number */
 		if (pdata->dsp_get_opp)
-			i = (*pdata->dsp_get_opp)();
-		hIOMgr->pSharedMem->oppTableStruct.currOppPt = i;
-		dev_dbg(bridge, "OPP-SHM: value programmed = %d\n", i);
+			i = (*pdata->dsp_get_opp) ();
+		hio_mgr->shared_mem->opp_table_struct.curr_opp_pt = i;
+		dev_dbg(bridge, "OPP-shm: value programmed = %d\n", i);
 		break;
 	case SHM_GETOPP:
 		/* Get the OPP that DSP has requested */
-		*(u32 *)pArgs = hIOMgr->pSharedMem->oppRequest.rqstOppPt;
+		*(u32 *) pargs = hio_mgr->shared_mem->opp_request.rqst_opp_pt;
 		break;
 	default:
 		break;
@@ -1745,225 +1810,238 @@ DSP_STATUS IO_SHMsetting(struct IO_MGR *hIOMgr, u8 desc, void *pArgs)
 }
 
 /*
- *  ======== WMD_IO_GetProcLoad ========
+ *  ======== bridge_io_get_proc_load ========
  *      Gets the Processor's Load information
  */
-DSP_STATUS WMD_IO_GetProcLoad(IN struct IO_MGR *hIOMgr,
-			     OUT struct DSP_PROCLOADSTAT *pProcStat)
+dsp_status bridge_io_get_proc_load(IN struct io_mgr *hio_mgr,
+				OUT struct dsp_procloadstat *pProcStat)
 {
-	pProcStat->uCurrLoad = hIOMgr->pSharedMem->loadMonInfo.currDspLoad;
-	pProcStat->uPredictedLoad = hIOMgr->pSharedMem->loadMonInfo.predDspLoad;
-	pProcStat->uCurrDspFreq = hIOMgr->pSharedMem->loadMonInfo.currDspFreq;
-	pProcStat->uPredictedFreq = hIOMgr->pSharedMem->loadMonInfo.predDspFreq;
+	pProcStat->curr_load = hio_mgr->shared_mem->load_mon_info.curr_dsp_load;
+	pProcStat->predicted_load =
+	    hio_mgr->shared_mem->load_mon_info.pred_dsp_load;
+	pProcStat->curr_dsp_freq =
+	    hio_mgr->shared_mem->load_mon_info.curr_dsp_freq;
+	pProcStat->predicted_freq =
+	    hio_mgr->shared_mem->load_mon_info.pred_dsp_freq;
 
 	dev_dbg(bridge, "Curr Load = %d, Pred Load = %d, Curr Freq = %d, "
-			     "Pred Freq = %d\n", pProcStat->uCurrLoad,
-			     pProcStat->uPredictedLoad, pProcStat->uCurrDspFreq,
-			     pProcStat->uPredictedFreq);
+		"Pred Freq = %d\n", pProcStat->curr_load,
+		pProcStat->predicted_load, pProcStat->curr_dsp_freq,
+		pProcStat->predicted_freq);
 	return DSP_SOK;
 }
 
 #ifndef DSP_TRACEBUF_DISABLED
-void PrintDSPDebugTrace(struct IO_MGR *hIOMgr)
+void print_dsp_debug_trace(struct io_mgr *hio_mgr)
 {
-	u32 ulNewMessageLength = 0, ulGPPCurPointer;
+	u32 ul_new_message_length = 0, ul_gpp_cur_pointer;
 
 	while (true) {
 		/* Get the DSP current pointer */
-		ulGPPCurPointer = *(u32 *) (hIOMgr->ulTraceBufferCurrent);
-		ulGPPCurPointer = hIOMgr->ulGppVa + (ulGPPCurPointer -
-				  hIOMgr->ulDspVa);
+		ul_gpp_cur_pointer =
+		    *(u32 *) (hio_mgr->ul_trace_buffer_current);
+		ul_gpp_cur_pointer =
+		    hio_mgr->ul_gpp_va + (ul_gpp_cur_pointer -
+					  hio_mgr->ul_dsp_va);
 
 		/* No new debug messages available yet */
-		if (ulGPPCurPointer == hIOMgr->ulGPPReadPointer) {
+		if (ul_gpp_cur_pointer == hio_mgr->ul_gpp_read_pointer) {
 			break;
-		} else if (ulGPPCurPointer > hIOMgr->ulGPPReadPointer) {
+		} else if (ul_gpp_cur_pointer > hio_mgr->ul_gpp_read_pointer) {
 			/* Continuous data */
-			ulNewMessageLength = ulGPPCurPointer - hIOMgr->
-					     ulGPPReadPointer;
+			ul_new_message_length =
+			    ul_gpp_cur_pointer - hio_mgr->ul_gpp_read_pointer;
 
-			memcpy(hIOMgr->pMsg, (char *)hIOMgr->ulGPPReadPointer,
-				ulNewMessageLength);
-			hIOMgr->pMsg[ulNewMessageLength] = '\0';
+			memcpy(hio_mgr->pmsg,
+			       (char *)hio_mgr->ul_gpp_read_pointer,
+			       ul_new_message_length);
+			hio_mgr->pmsg[ul_new_message_length] = '\0';
 			/*
 			 * Advance the GPP trace pointer to DSP current
 			 * pointer.
 			 */
-			hIOMgr->ulGPPReadPointer += ulNewMessageLength;
+			hio_mgr->ul_gpp_read_pointer += ul_new_message_length;
 			/* Print the trace messages */
-			pr_info("DSPTrace:%s", hIOMgr->pMsg);
-		} else if (ulGPPCurPointer < hIOMgr->ulGPPReadPointer) {
-		/* Handle trace buffer wraparound */
-			memcpy(hIOMgr->pMsg, (char *)hIOMgr->ulGPPReadPointer,
-				hIOMgr->ulTraceBufferEnd -
-				hIOMgr->ulGPPReadPointer);
-			ulNewMessageLength = ulGPPCurPointer -
-				hIOMgr->ulTraceBufferBegin;
-			memcpy(&hIOMgr->pMsg[hIOMgr->ulTraceBufferEnd -
-				hIOMgr->ulGPPReadPointer],
-				(char *)hIOMgr->ulTraceBufferBegin,
-				ulNewMessageLength);
-			hIOMgr->pMsg[hIOMgr->ulTraceBufferEnd -
-				hIOMgr->ulGPPReadPointer +
-				ulNewMessageLength] = '\0';
+			pr_info("DSPTrace:%s", hio_mgr->pmsg);
+		} else if (ul_gpp_cur_pointer < hio_mgr->ul_gpp_read_pointer) {
+			/* Handle trace buffer wraparound */
+			memcpy(hio_mgr->pmsg,
+			       (char *)hio_mgr->ul_gpp_read_pointer,
+			       hio_mgr->ul_trace_buffer_end -
+			       hio_mgr->ul_gpp_read_pointer);
+			ul_new_message_length =
+			    ul_gpp_cur_pointer - hio_mgr->ul_trace_buffer_begin;
+			memcpy(&hio_mgr->pmsg[hio_mgr->ul_trace_buffer_end -
+					      hio_mgr->ul_gpp_read_pointer],
+			       (char *)hio_mgr->ul_trace_buffer_begin,
+			       ul_new_message_length);
+			hio_mgr->pmsg[hio_mgr->ul_trace_buffer_end -
+				      hio_mgr->ul_gpp_read_pointer +
+				      ul_new_message_length] = '\0';
 			/*
 			 * Advance the GPP trace pointer to DSP current
 			 * pointer.
 			 */
-			hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin +
-						   ulNewMessageLength;
+			hio_mgr->ul_gpp_read_pointer =
+			    hio_mgr->ul_trace_buffer_begin +
+			    ul_new_message_length;
 			/* Print the trace messages */
-			pr_info("DSPTrace:%s", hIOMgr->pMsg);
+			pr_info("DSPTrace:%s", hio_mgr->pmsg);
 		}
 	}
 }
 #endif
 
 /*
- *  ======== PackTraceBuffer ========
+ *  ======== pack_trace_buffer ========
  *      Removes extra nulls from the trace buffer returned from the DSP.
  *      Works even on buffers that already are packed (null removed); but has
  *      one bug in that case -- loses the last character (replaces with '\0').
- *      Continues through conversion for full set of nBytes input characters.
+ *      Continues through conversion for full set of bytes input characters.
  *  Parameters:
  *    lpBuf:            Pointer to input/output buffer
- *    nBytes:           Number of characters in the buffer
- *    ulNumWords:       Number of DSP words in the buffer.  Indicates potential
+ *    bytes:           Number of characters in the buffer
+ *    ul_num_words:	Number of DSP words in the buffer. Indicates potential
  *                      number of extra carriage returns to generate.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Unable to allocate memory.
  *  Requires:
- *      lpBuf must be a fully allocated writable block of at least nBytes.
- *      There are no more than ulNumWords extra characters needed (the number of
- *      linefeeds minus the number of NULLS in the input buffer).
+ *      lpBuf must be a fully allocated writable block of at least bytes.
+ *      There are no more than ul_num_words extra characters needed (the number
+ *      of linefeeds minus the number of NULLS in the input buffer).
  */
-static DSP_STATUS PackTraceBuffer(char *lpBuf, u32 nBytes, u32 ulNumWords)
+static dsp_status pack_trace_buffer(char *lpBuf, u32 bytes, u32 ul_num_words)
 {
-	DSP_STATUS status = DSP_SOK;
-	char *lpTmpBuf;
-	char *lpBufStart;
-	char *lpTmpStart;
-	u32 nCnt;
-	char thisChar;
+	dsp_status status = DSP_SOK;
+	char *lp_tmp_buf;
+	char *lp_buf_start;
+	char *lp_tmp_start;
+	u32 i;
+	char this_char;
 
 	/* Tmp workspace, 1 KB longer than input buf */
-	lpTmpBuf = MEM_Calloc((nBytes + ulNumWords), MEM_PAGED);
-	if (lpTmpBuf == NULL)
+	lp_tmp_buf = mem_calloc((bytes + ul_num_words), MEM_PAGED);
+	if (lp_tmp_buf == NULL)
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status)) {
-		lpBufStart = lpBuf;
-		lpTmpStart = lpTmpBuf;
-		for (nCnt = nBytes; nCnt > 0; nCnt--) {
-			thisChar = *lpBuf++;
-			switch (thisChar) {
-			case '\0':      /* Skip null bytes */
+		lp_buf_start = lpBuf;
+		lp_tmp_start = lp_tmp_buf;
+		for (i = bytes; i > 0; i--) {
+			this_char = *lpBuf++;
+			switch (this_char) {
+			case '\0':	/* Skip null bytes */
 				break;
-			case '\n':      /* Convert \n to \r\n */
+			case '\n':	/* Convert \n to \r\n */
 				/*
 				 * NOTE: do not reverse order; Some OS
 				 * editors control doesn't understand "\n\r"
 				 */
-				*lpTmpBuf++ = '\r';
-				*lpTmpBuf++ = '\n';
+				*lp_tmp_buf++ = '\r';
+				*lp_tmp_buf++ = '\n';
 				break;
-			default:	 /* Copy in the actual ascii byte */
-				*lpTmpBuf++ = thisChar;
+			default:	/* Copy in the actual ascii byte */
+				*lp_tmp_buf++ = this_char;
 				break;
 			}
 		}
-		*lpTmpBuf = '\0';    /* Make sure tmp buf is null terminated */
+		*lp_tmp_buf = '\0';	/* Temp buf MUST be null terminated */
 		/* Cut output down to input buf size */
-		strncpy(lpBufStart, lpTmpStart, nBytes);
+		strncpy(lp_buf_start, lp_tmp_start, bytes);
 		/* Make sure output is null terminated */
-		lpBufStart[nBytes - 1] = '\0';
-		kfree(lpTmpStart);
+		lp_buf_start[bytes - 1] = '\0';
+		kfree(lp_tmp_start);
 	}
 
 	return status;
 }
 
 /*
- *  ======== PrintDspTraceBuffer ========
+ *  ======== print_dsp_trace_buffer ========
  *      Prints the trace buffer returned from the DSP (if DBG_Trace is enabled).
  *  Parameters:
- *    hDehMgr:          Handle to DEH manager object
+ *    hdeh_mgr:          Handle to DEH manager object
  *                      number of extra carriage returns to generate.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Unable to allocate memory.
  *  Requires:
- *      hDehMgr muse be valid. Checked in WMD_DEH_Notify.
+ *      hdeh_mgr muse be valid. Checked in bridge_deh_notify.
  */
-DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT *hWmdContext)
+dsp_status print_dsp_trace_buffer(struct wmd_dev_context *hwmd_context)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct COD_MANAGER *hCodMgr;
-	u32 ulTraceEnd;
-	u32 ulTraceBegin;
-	u32 ulNumBytes = 0;
-	u32 ulNumWords = 0;
-	u32 ulWordSize = 2;
-	CONST u32 uMaxSize = 512;
-	char *pszBuf;
-
-	struct WMD_DEV_CONTEXT *pWmdContext = (struct WMD_DEV_CONTEXT *)
-						     hWmdContext;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)
-					    pWmdContext->hDevObject;
-
-	DEV_GetCodMgr(pDevObject, &hCodMgr);
-	if (!hCodMgr)
+	dsp_status status = DSP_SOK;
+	struct cod_manager *cod_mgr;
+	u32 ul_trace_end;
+	u32 ul_trace_begin;
+	u32 ul_num_bytes = 0;
+	u32 ul_num_words = 0;
+	u32 ul_word_size = 2;
+	CONST u32 max_size = 512;
+	char *psz_buf;
+
+	struct wmd_dev_context *pwmd_context = (struct wmd_dev_context *)
+	    hwmd_context;
+	struct bridge_drv_interface *intf_fxns;
+	struct dev_object *dev_obj = (struct dev_object *)
+	    pwmd_context->hdev_obj;
+
+	dev_get_cod_mgr(dev_obj, &cod_mgr);
+	if (!cod_mgr)
 		status = DSP_EHANDLE;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Look for SYS_PUTCBEG/SYS_PUTCEND */
-		status = COD_GetSymValue(hCodMgr, COD_TRACEBEG, &ulTraceBegin);
+		status =
+		    cod_get_sym_value(cod_mgr, COD_TRACEBEG, &ul_trace_begin);
 	}
 	if (DSP_SUCCEEDED(status))
-		status = COD_GetSymValue(hCodMgr, COD_TRACEEND, &ulTraceEnd);
+		status =
+		    cod_get_sym_value(cod_mgr, COD_TRACEEND, &ul_trace_end);
 
 	if (DSP_SUCCEEDED(status)) {
-		ulNumBytes = (ulTraceEnd - ulTraceBegin) * ulWordSize;
+		ul_num_bytes = (ul_trace_end - ul_trace_begin) * ul_word_size;
 		/*
 		 * If the chip type is 55 then the addresses will be
 		 * byte addresses; convert them to word addresses.
 		 */
-		if (ulNumBytes > uMaxSize)
-			ulNumBytes = uMaxSize;
+		if (ul_num_bytes > max_size)
+			ul_num_bytes = max_size;
 
 		/* Make sure the data we request fits evenly */
-		ulNumBytes = (ulNumBytes / ulWordSize) * ulWordSize;
-		ulNumWords = ulNumBytes * ulWordSize;
-		DEV_GetIntfFxns(pDevObject, &pIntfFxns);
-		if (!pIntfFxns)
+		ul_num_bytes = (ul_num_bytes / ul_word_size) * ul_word_size;
+		ul_num_words = ul_num_bytes * ul_word_size;
+		dev_get_intf_fxns(dev_obj, &intf_fxns);
+		if (!intf_fxns)
 			status = DSP_EHANDLE;
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		pszBuf = MEM_Calloc(uMaxSize, MEM_NONPAGED);
-		if (pszBuf != NULL) {
+		psz_buf = mem_calloc(max_size, MEM_NONPAGED);
+		if (psz_buf != NULL) {
 			/* Read bytes from the DSP trace buffer... */
-			status = (*pIntfFxns->pfnBrdRead)(hWmdContext,
-				(u8 *)pszBuf, (u32)ulTraceBegin,
-				ulNumBytes, 0);
+			status = (*intf_fxns->pfn_brd_read) (hwmd_context,
+							     (u8 *) psz_buf,
+							     (u32)
+							     ul_trace_begin,
+							     ul_num_bytes, 0);
 
 			if (DSP_SUCCEEDED(status)) {
 				/* Pack and do newline conversion */
-				PackTraceBuffer(pszBuf, ulNumBytes, ulNumWords);
-				pr_info("%s:\n%s\n", __func__, pszBuf);
+				pack_trace_buffer(psz_buf, ul_num_bytes,
+						  ul_num_words);
+				pr_info("%s:\n%s\n", __func__, psz_buf);
 			}
-			kfree(pszBuf);
+			kfree(psz_buf);
 		} else {
-			  status = DSP_EMEMORY;
+			status = DSP_EMEMORY;
 		}
 	}
 	return status;
 }
 
-void IO_SM_init(void)
+void io_sm_init(void)
 {
 	/* Do nothing */
 }
@@ -1977,11 +2055,11 @@ void IO_SM_init(void)
  */
 void io_wdt3_ovf(unsigned long data)
 {
-	struct DEH_MGR *deh_mgr;
-	struct IO_MGR *io_mgr = (struct IO_MGR *)data;
-	DEV_GetDehMgr(io_mgr->hDevObject, &deh_mgr);
+	struct deh_mgr *deh_mgr;
+	struct io_mgr *io_mgr = (struct io_mgr *)data;
+	dev_get_deh_mgr(io_mgr->hdev_obj, &deh_mgr);
 	if (deh_mgr)
-		WMD_DEH_Notify(deh_mgr, DSP_WDTOVERFLOW, (u32)io_mgr);
+		bridge_deh_notify(deh_mgr, DSP_WDTOVERFLOW, (u32) io_mgr);
 }
 
 /*
@@ -1991,16 +2069,16 @@ void io_wdt3_ovf(unsigned long data)
 irqreturn_t io_isr_wdt3(int irq, IN void *data)
 {
 	u32 value;
-	struct IO_MGR *io_mgr = (struct IO_MGR *)data;
+	struct io_mgr *io_mgr = (struct io_mgr *)data;
 	/* The pending interrupt event is cleared when the set status bit is
 	 * overwritten by a value of 1 by a write command in the WTDi.WISR
 	 * register. Reading the WTDi.WISR register and writing the value
 	 * back allows a fast acknowledge interrupt process. */
-	if (CLK_Get_UseCnt(SERVICESCLK_wdt3_fck)) {
-		value = __raw_readl(io_mgr->hWmdContext->wdt3_base
-							+ WDT_ISR_OFFSET);
-		__raw_writel(value, io_mgr->hWmdContext->wdt3_base
-							+ WDT_ISR_OFFSET);
+	if (clk_get_use_cnt(SERVICESCLK_WDT3_FCK)) {
+		value = __raw_readl(io_mgr->hwmd_context->wdt3_base
+				    + WDT_ISR_OFFSET);
+		__raw_writel(value, io_mgr->hwmd_context->wdt3_base
+			     + WDT_ISR_OFFSET);
 	}
 	tasklet_schedule(&io_mgr->wdt3_tasklet);
 	return IRQ_HANDLED;
@@ -2015,49 +2093,49 @@ irqreturn_t io_isr_wdt3(int irq, IN void *data)
 void dsp_wdt_enable(bool enable)
 {
 	u32 tmp;
-	struct WMD_DEV_CONTEXT *dev_ctxt;
-	struct IO_MGR *io_mgr;
+	struct wmd_dev_context *dev_ctxt;
+	struct io_mgr *io_mgr;
 
 	if (!wdt3_enable)
 		return;
 
-	DEV_GetWMDContext(DEV_GetFirst(), &dev_ctxt);
-	DEV_GetIOMgr(DEV_GetFirst(), &io_mgr);
+	dev_get_wmd_context(dev_get_first(), &dev_ctxt);
+	dev_get_io_mgr(dev_get_first(), &io_mgr);
 	if (!dev_ctxt || !io_mgr)
 		return;
 
 	if (enable) {
-		CLK_Enable(SERVICESCLK_wdt3_fck);
-		CLK_Enable(SERVICESCLK_wdt3_ick);
-		io_mgr->pSharedMem->wdt_setclocks = 1;
+		services_clk_enable(SERVICESCLK_WDT3_FCK);
+		services_clk_enable(SERVICESCLK_WDT3_ICK);
+		io_mgr->shared_mem->wdt_setclocks = 1;
 		tmp = __raw_readl(dev_ctxt->wdt3_base + WDT_ISR_OFFSET);
 		__raw_writel(tmp, dev_ctxt->wdt3_base + WDT_ISR_OFFSET);
 		enable_irq(INT_34XX_WDT3_IRQ);
 	} else {
 		disable_irq(INT_34XX_WDT3_IRQ);
-		io_mgr->pSharedMem->wdt_setclocks = 0;
-		CLK_Disable(SERVICESCLK_wdt3_ick);
-		CLK_Disable(SERVICESCLK_wdt3_fck);
+		io_mgr->shared_mem->wdt_setclocks = 0;
+		services_clk_disable(SERVICESCLK_WDT3_ICK);
+		services_clk_disable(SERVICESCLK_WDT3_FCK);
 	}
 }
 
 void dsp_wdt_set_timeout(unsigned timeout)
 {
-	struct IO_MGR *io_mgr;
-	DEV_GetIOMgr(DEV_GetFirst(), &io_mgr);
-	if (io_mgr && io_mgr->pSharedMem != (void *)-1)
-		io_mgr->pSharedMem->wdt_overflow = timeout;
+	struct io_mgr *io_mgr;
+	dev_get_io_mgr(dev_get_first(), &io_mgr);
+	if (io_mgr && io_mgr->shared_mem != (void *)-1)
+		io_mgr->shared_mem->wdt_overflow = timeout;
 	else
 		pr_err("%s: DSP image not loaded\n", __func__);
 }
 
 unsigned dsp_wdt_get_timeout(void)
 {
-	struct IO_MGR *io_mgr;
-	DEV_GetIOMgr(DEV_GetFirst(), &io_mgr);
-	return (io_mgr && io_mgr->pSharedMem != (void *)-1) ?
-		io_mgr->pSharedMem->wdt_overflow :
-		(pr_err("%s: DSP image not loaded\n", __func__), 0);
+	struct io_mgr *io_mgr;
+	dev_get_io_mgr(dev_get_first(), &io_mgr);
+	return (io_mgr && io_mgr->shared_mem != (void *)-1) ?
+	    io_mgr->shared_mem->wdt_overflow :
+	    (pr_err("%s: DSP image not loaded\n", __func__), 0);
 }
 
 bool dsp_wdt_get_enable(void)
@@ -2070,4 +2148,3 @@ void dsp_wdt_set_enable(bool enable)
 	wdt3_enable = enable;
 }
 #endif
-
diff --git a/drivers/dsp/bridge/wmd/mmu_fault.c b/drivers/dsp/bridge/wmd/mmu_fault.c
index 8cac1ef..bb6e7fd 100644
--- a/drivers/dsp/bridge/wmd/mmu_fault.c
+++ b/drivers/dsp/bridge/wmd/mmu_fault.c
@@ -43,100 +43,101 @@
 #include "_tiomap.h"
 #include "mmu_fault.h"
 
-static u32 dmmuEventMask;
-u32 faultAddr;
+static u32 dmmu_event_mask;
+u32 fault_addr;
 
-static bool MMU_CheckIfFault(struct WMD_DEV_CONTEXT *pDevContext);
+static bool mmu_check_if_fault(struct wmd_dev_context *dev_context);
 
 /*
- *  ======== MMU_FaultDpc ========
+ *  ======== mmu_fault_dpc ========
  *      Deferred procedure call to handle DSP MMU fault.
  */
-void MMU_FaultDpc(IN unsigned long pRefData)
+void mmu_fault_dpc(IN unsigned long pRefData)
 {
-	struct DEH_MGR *hDehMgr = (struct DEH_MGR *)pRefData;
+	struct deh_mgr *hdeh_mgr = (struct deh_mgr *)pRefData;
 
-	if (hDehMgr)
-		WMD_DEH_Notify(hDehMgr, DSP_MMUFAULT, 0L);
+	if (hdeh_mgr)
+		bridge_deh_notify(hdeh_mgr, DSP_MMUFAULT, 0L);
 
 }
 
 /*
- *  ======== MMU_FaultIsr ========
+ *  ======== mmu_fault_isr ========
  *      ISR to be triggered by a DSP MMU fault interrupt.
  */
-irqreturn_t  MMU_FaultIsr(int irq, IN void *pRefData)
+irqreturn_t mmu_fault_isr(int irq, IN void *pRefData)
 {
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)pRefData;
-	struct WMD_DEV_CONTEXT *pDevContext;
-	struct CFG_HOSTRES resources;
-	DSP_STATUS status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)pRefData;
+	struct wmd_dev_context *dev_context;
+	struct cfg_hostres resources;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(irq == INT_DSP_MMU_IRQ);
-	DBC_Require(MEM_IsValidHandle(pDehMgr, SIGNATURE));
+	DBC_REQUIRE(irq == INT_DSP_MMU_IRQ);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE));
 
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
 
-		pDevContext = (struct WMD_DEV_CONTEXT *)pDehMgr->hWmdContext;
-		status = CFG_GetHostResources(
-			 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			 &resources);
+		dev_context =
+		    (struct wmd_dev_context *)deh_mgr_obj->hwmd_context;
+		status = cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&resources);
 		if (DSP_FAILED(status))
 			dev_dbg(bridge, "%s: Failed to get Host Resources\n",
-								__func__);
-		if (MMU_CheckIfFault(pDevContext)) {
+				__func__);
+		if (mmu_check_if_fault(dev_context)) {
 			printk(KERN_INFO "***** DSPMMU FAULT ***** IRQStatus "
-				"0x%x\n", dmmuEventMask);
-			printk(KERN_INFO "***** DSPMMU FAULT ***** faultAddr "
-				"0x%x\n", faultAddr);
+			       "0x%x\n", dmmu_event_mask);
+			printk(KERN_INFO "***** DSPMMU FAULT ***** fault_addr "
+			       "0x%x\n", fault_addr);
 			/*
 			 * Schedule a DPC directly. In the future, it may be
 			 * necessary to check if DSP MMU fault is intended for
 			 * Bridge.
 			 */
-			tasklet_schedule(&pDehMgr->dpc_tasklet);
+			tasklet_schedule(&deh_mgr_obj->dpc_tasklet);
 
-			/* Reset errInfo structure before use. */
-			pDehMgr->errInfo.dwErrMask = DSP_MMUFAULT;
-			pDehMgr->errInfo.dwVal1 = faultAddr >> 16;
-			pDehMgr->errInfo.dwVal2 = faultAddr & 0xFFFF;
-			pDehMgr->errInfo.dwVal3 = 0L;
+			/* Reset err_info structure before use. */
+			deh_mgr_obj->err_info.dw_err_mask = DSP_MMUFAULT;
+			deh_mgr_obj->err_info.dw_val1 = fault_addr >> 16;
+			deh_mgr_obj->err_info.dw_val2 = fault_addr & 0xFFFF;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
 			/* Disable the MMU events, else once we clear it will
 			 * start to raise INTs again */
-			HW_MMU_EventDisable(resources.dwDmmuBase,
-					    HW_MMU_TRANSLATION_FAULT);
+			hw_mmu_event_disable(resources.dw_dmmu_base,
+					     HW_MMU_TRANSLATION_FAULT);
 		} else {
-			HW_MMU_EventDisable(resources.dwDmmuBase,
-					    HW_MMU_ALL_INTERRUPTS);
+			hw_mmu_event_disable(resources.dw_dmmu_base,
+					     HW_MMU_ALL_INTERRUPTS);
 		}
 	}
 	return IRQ_HANDLED;
 }
 
-
 /*
- *  ======== MMU_CheckIfFault ========
+ *  ======== mmu_check_if_fault ========
  *      Check to see if MMU Fault is valid TLB miss from DSP
  *  Note: This function is called from an ISR
  */
-static bool MMU_CheckIfFault(struct WMD_DEV_CONTEXT *pDevContext)
+static bool mmu_check_if_fault(struct wmd_dev_context *dev_context)
 {
 
-
-	bool retVal = false;
-	DSP_STATUS status = DSP_SOK;
-	HW_STATUS hwStatus;
-	struct CFG_HOSTRES resources;
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	bool ret = false;
+	dsp_status status = DSP_SOK;
+	hw_status hw_status_obj;
+	struct cfg_hostres resources;
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		dev_dbg(bridge, "%s: Failed to get Host Resources in\n",
-								__func__);
+			__func__);
 
-	hwStatus = HW_MMU_EventStatus(resources.dwDmmuBase, &dmmuEventMask);
-	if (dmmuEventMask  ==  HW_MMU_TRANSLATION_FAULT) {
-		HW_MMU_FaultAddrRead(resources.dwDmmuBase, &faultAddr);
-		retVal = true;
+	hw_status_obj =
+	    hw_mmu_event_status(resources.dw_dmmu_base, &dmmu_event_mask);
+	if (dmmu_event_mask == HW_MMU_TRANSLATION_FAULT) {
+		hw_mmu_fault_addr_read(resources.dw_dmmu_base, &fault_addr);
+		ret = true;
 	}
-	return retVal;
+	return ret;
 }
diff --git a/drivers/dsp/bridge/wmd/mmu_fault.h b/drivers/dsp/bridge/wmd/mmu_fault.h
index d3849b5..537e6e7 100644
--- a/drivers/dsp/bridge/wmd/mmu_fault.h
+++ b/drivers/dsp/bridge/wmd/mmu_fault.h
@@ -20,16 +20,15 @@
 #define MMU_FAULT_
 
 /*
- *  ======== MMU_FaultDpc ========
+ *  ======== mmu_fault_dpc ========
  *      Deferred procedure call to handle DSP MMU fault.
  */
-	void MMU_FaultDpc(IN unsigned long pRefData);
+void mmu_fault_dpc(IN unsigned long pRefData);
 
 /*
- *  ======== MMU_FaultIsr ========
+ *  ======== mmu_fault_isr ========
  *      ISR to be triggered by a DSP MMU fault interrupt.
  */
-irqreturn_t  MMU_FaultIsr(int irq, IN void *pRefData);
-
-#endif				/* MMU_FAULT_ */
+irqreturn_t mmu_fault_isr(int irq, IN void *pRefData);
 
+#endif /* MMU_FAULT_ */
diff --git a/drivers/dsp/bridge/wmd/msg_sm.c b/drivers/dsp/bridge/wmd/msg_sm.c
index c97c61f..f8c95d5 100644
--- a/drivers/dsp/bridge/wmd/msg_sm.c
+++ b/drivers/dsp/bridge/wmd/msg_sm.c
@@ -43,69 +43,74 @@
 #define MSGQ_SIGNATURE      0x5147534d	/* "QGSM" */
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS AddNewMsg(struct LST_LIST *msgList);
-static void DeleteMsgMgr(struct MSG_MGR *hMsgMgr);
-static void DeleteMsgQueue(struct MSG_QUEUE *hMsgQueue, u32 uNumToDSP);
-static void FreeMsgList(struct LST_LIST *msgList);
+static dsp_status add_new_msg(struct lst_list *msgList);
+static void delete_msg_mgr(struct msg_mgr *hmsg_mgr);
+static void delete_msg_queue(struct msg_queue *msg_queue_obj, u32 uNumToDSP);
+static void free_msg_list(struct lst_list *msgList);
 
 /*
- *  ======== WMD_MSG_Create ========
+ *  ======== bridge_msg_create ========
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  */
-DSP_STATUS WMD_MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-			 struct DEV_OBJECT *hDevObject, MSG_ONEXIT msgCallback)
+dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
+			     struct dev_object *hdev_obj,
+			     msg_onexit msgCallback)
 {
-	struct MSG_MGR *pMsgMgr;
-	struct IO_MGR *hIOMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct msg_mgr *msg_mgr_obj;
+	struct io_mgr *hio_mgr;
+	dsp_status status = DSP_SOK;
 
-	if (!phMsgMgr || !msgCallback || !hDevObject) {
+	if (!phMsgMgr || !msgCallback || !hdev_obj) {
 		status = DSP_EPOINTER;
 		goto func_end;
 	}
-	DEV_GetIOMgr(hDevObject, &hIOMgr);
-	if (!hIOMgr) {
+	dev_get_io_mgr(hdev_obj, &hio_mgr);
+	if (!hio_mgr) {
 		status = DSP_EPOINTER;
 		goto func_end;
 	}
 	*phMsgMgr = NULL;
-	/* Allocate MSG manager object */
-	MEM_AllocObject(pMsgMgr, struct MSG_MGR, MSGMGR_SIGNATURE);
+	/* Allocate msg_ctrl manager object */
+	MEM_ALLOC_OBJECT(msg_mgr_obj, struct msg_mgr, MSGMGR_SIGNATURE);
 
-	if (pMsgMgr) {
-		pMsgMgr->onExit = msgCallback;
-		pMsgMgr->hIOMgr = hIOMgr;
+	if (msg_mgr_obj) {
+		msg_mgr_obj->on_exit = msgCallback;
+		msg_mgr_obj->hio_mgr = hio_mgr;
 		/* List of MSG_QUEUEs */
-		pMsgMgr->queueList = MEM_Calloc(sizeof(struct LST_LIST),
-			MEM_NONPAGED);
-		 /*  Queues of message frames for messages to the DSP. Message
-		  * frames will only be added to the free queue when a
-		  * MSG_QUEUE object is created.  */
-		pMsgMgr->msgFreeList = MEM_Calloc(sizeof(struct LST_LIST),
-					MEM_NONPAGED);
-		pMsgMgr->msgUsedList = MEM_Calloc(sizeof(struct LST_LIST),
-					MEM_NONPAGED);
-		if (pMsgMgr->queueList == NULL ||
-		    pMsgMgr->msgFreeList == NULL ||
-		    pMsgMgr->msgUsedList == NULL) {
+		msg_mgr_obj->queue_list = mem_calloc(sizeof(struct lst_list),
+						     MEM_NONPAGED);
+		/*  Queues of message frames for messages to the DSP. Message
+		 * frames will only be added to the free queue when a
+		 * msg_queue object is created. */
+		msg_mgr_obj->msg_free_list = mem_calloc(sizeof(struct lst_list),
+							MEM_NONPAGED);
+		msg_mgr_obj->msg_used_list = mem_calloc(sizeof(struct lst_list),
+							MEM_NONPAGED);
+		if (msg_mgr_obj->queue_list == NULL ||
+		    msg_mgr_obj->msg_free_list == NULL ||
+		    msg_mgr_obj->msg_used_list == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			INIT_LIST_HEAD(&pMsgMgr->queueList->head);
-			INIT_LIST_HEAD(&pMsgMgr->msgFreeList->head);
-			INIT_LIST_HEAD(&pMsgMgr->msgUsedList->head);
-			status = SYNC_InitializeDPCCS(&pMsgMgr->hSyncCS);
+			INIT_LIST_HEAD(&msg_mgr_obj->queue_list->head);
+			INIT_LIST_HEAD(&msg_mgr_obj->msg_free_list->head);
+			INIT_LIST_HEAD(&msg_mgr_obj->msg_used_list->head);
+			spin_lock_init(&msg_mgr_obj->msg_mgr_lock);
 		}
 
-		 /*  Create an event to be used by WMD_MSG_Put() in waiting
-		 *  for an available free frame from the message manager.  */
-		if (DSP_SUCCEEDED(status))
-			status = SYNC_OpenEvent(&pMsgMgr->hSyncEvent, NULL);
+		/*  Create an event to be used by bridge_msg_put() in waiting
+		 *  for an available free frame from the message manager. */
+		msg_mgr_obj->sync_event =
+				kzalloc(sizeof(struct sync_object), GFP_KERNEL);
+		if (!msg_mgr_obj->sync_event)
+			status = DSP_EMEMORY;
+		else
+			sync_init_event(msg_mgr_obj->sync_event);
 
 		if (DSP_SUCCEEDED(status))
-			*phMsgMgr = pMsgMgr;
+			*phMsgMgr = msg_mgr_obj;
 		else
-			DeleteMsgMgr(pMsgMgr);
+			delete_msg_mgr(msg_mgr_obj);
 
 	} else {
 		status = DSP_EMEMORY;
@@ -115,245 +120,275 @@ func_end:
 }
 
 /*
- *  ======== WMD_MSG_CreateQueue ========
- *      Create a MSG_QUEUE for sending/receiving messages to/from a node
+ *  ======== bridge_msg_create_queue ========
+ *      Create a msg_queue for sending/receiving messages to/from a node
  *      on the DSP.
  */
-DSP_STATUS WMD_MSG_CreateQueue(struct MSG_MGR *hMsgMgr,
-			      OUT struct MSG_QUEUE **phMsgQueue,
-			      u32 dwId, u32 uMaxMsgs, HANDLE hArg)
+dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
+				OUT struct msg_queue **phMsgQueue,
+				u32 msgq_id, u32 max_msgs, bhandle arg)
 {
 	u32 i;
-	u32 uNumAllocated = 0;
-	struct MSG_QUEUE *pMsgQ;
-	DSP_STATUS status = DSP_SOK;
+	u32 num_allocated = 0;
+	struct msg_queue *msg_q;
+	dsp_status status = DSP_SOK;
 
-	if (!MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE) ||
-	   phMsgQueue == NULL || !hMsgMgr->msgFreeList) {
+	if (!MEM_IS_VALID_HANDLE(hmsg_mgr, MSGMGR_SIGNATURE) ||
+	    phMsgQueue == NULL || !hmsg_mgr->msg_free_list) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
 	*phMsgQueue = NULL;
-	/* Allocate MSG_QUEUE object */
-	MEM_AllocObject(pMsgQ, struct MSG_QUEUE, MSGQ_SIGNATURE);
-	if (!pMsgQ) {
+	/* Allocate msg_queue object */
+	MEM_ALLOC_OBJECT(msg_q, struct msg_queue, MSGQ_SIGNATURE);
+	if (!msg_q) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	LST_InitElem((struct list_head *)pMsgQ);
-	pMsgQ->uMaxMsgs = uMaxMsgs;
-	pMsgQ->hMsgMgr = hMsgMgr;
-	pMsgQ->hArg = hArg;	/* Node handle */
-	pMsgQ->dwId = dwId;	/* Node env (not valid yet) */
+	lst_init_elem((struct list_head *)msg_q);
+	msg_q->max_msgs = max_msgs;
+	msg_q->hmsg_mgr = hmsg_mgr;
+	msg_q->arg = arg;	/* Node handle */
+	msg_q->msgq_id = msgq_id;	/* Node env (not valid yet) */
 	/* Queues of Message frames for messages from the DSP */
-	pMsgQ->msgFreeList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
-	pMsgQ->msgUsedList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
-	if (pMsgQ->msgFreeList == NULL || pMsgQ->msgUsedList == NULL)
+	msg_q->msg_free_list =
+	    mem_calloc(sizeof(struct lst_list), MEM_NONPAGED);
+	msg_q->msg_used_list =
+	    mem_calloc(sizeof(struct lst_list), MEM_NONPAGED);
+	if (msg_q->msg_free_list == NULL || msg_q->msg_used_list == NULL)
 		status = DSP_EMEMORY;
 	else {
-		INIT_LIST_HEAD(&pMsgQ->msgFreeList->head);
-		INIT_LIST_HEAD(&pMsgQ->msgUsedList->head);
+		INIT_LIST_HEAD(&msg_q->msg_free_list->head);
+		INIT_LIST_HEAD(&msg_q->msg_used_list->head);
 	}
 
-	 /*  Create event that will be signalled when a message from
-	 *  the DSP is available.  */
-	if (DSP_SUCCEEDED(status))
-		status = SYNC_OpenEvent(&pMsgQ->hSyncEvent, NULL);
+	/*  Create event that will be signalled when a message from
+	 *  the DSP is available. */
+	if (DSP_SUCCEEDED(status)) {
+		msg_q->sync_event = kzalloc(sizeof(struct sync_object),
+							GFP_KERNEL);
+		if (msg_q->sync_event)
+			sync_init_event(msg_q->sync_event);
+		else
+			status = DSP_EMEMORY;
+	}
 
 	/* Create a notification list for message ready notification. */
-	if (DSP_SUCCEEDED(status))
-		status = NTFY_Create(&pMsgQ->hNtfy);
+	if (DSP_SUCCEEDED(status)) {
+		msg_q->ntfy_obj = kmalloc(sizeof(struct ntfy_object),
+							GFP_KERNEL);
+		if (msg_q->ntfy_obj)
+			ntfy_init(msg_q->ntfy_obj);
+		else
+			status = DSP_EMEMORY;
+	}
 
-	 /*  Create events that will be used to synchronize cleanup
-	 *  when the object is deleted. hSyncDone will be set to
-	 *  unblock threads in MSG_Put() or MSG_Get(). hSyncDoneAck
+	/*  Create events that will be used to synchronize cleanup
+	 *  when the object is deleted. sync_done will be set to
+	 *  unblock threads in MSG_Put() or MSG_Get(). sync_done_ack
 	 *  will be set by the unblocked thread to signal that it
-	 *  is unblocked and will no longer reference the object.  */
-	if (DSP_SUCCEEDED(status))
-		status = SYNC_OpenEvent(&pMsgQ->hSyncDone, NULL);
+	 *  is unblocked and will no longer reference the object. */
+	if (DSP_SUCCEEDED(status)) {
+		msg_q->sync_done = kzalloc(sizeof(struct sync_object),
+							GFP_KERNEL);
+		if (msg_q->sync_event)
+			sync_init_event(msg_q->sync_event);
+		else
+			status = DSP_EMEMORY;
+	}
 
-	if (DSP_SUCCEEDED(status))
-		status = SYNC_OpenEvent(&pMsgQ->hSyncDoneAck, NULL);
+	if (DSP_SUCCEEDED(status)) {
+		msg_q->sync_done_ack = kzalloc(sizeof(struct sync_object),
+							GFP_KERNEL);
+		if (msg_q->sync_event)
+			sync_init_event(msg_q->sync_done_ack);
+		else
+			status = DSP_EMEMORY;
+	}
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Enter critical section */
-		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+		spin_lock_bh(&hmsg_mgr->msg_mgr_lock);
 		/* Initialize message frames and put in appropriate queues */
-		for (i = 0; i < uMaxMsgs && DSP_SUCCEEDED(status); i++) {
-			status = AddNewMsg(hMsgMgr->msgFreeList);
+		for (i = 0; i < max_msgs && DSP_SUCCEEDED(status); i++) {
+			status = add_new_msg(hmsg_mgr->msg_free_list);
 			if (DSP_SUCCEEDED(status)) {
-				uNumAllocated++;
-				status = AddNewMsg(pMsgQ->msgFreeList);
+				num_allocated++;
+				status = add_new_msg(msg_q->msg_free_list);
 			}
 		}
 		if (DSP_FAILED(status)) {
 			/*  Stay inside CS to prevent others from taking any
-			 *  of the newly allocated message frames.  */
-			DeleteMsgQueue(pMsgQ, uNumAllocated);
+			 *  of the newly allocated message frames. */
+			delete_msg_queue(msg_q, num_allocated);
 		} else {
-			LST_PutTail(hMsgMgr->queueList,
-				   (struct list_head *)pMsgQ);
-			*phMsgQueue = pMsgQ;
+			lst_put_tail(hmsg_mgr->queue_list,
+				     (struct list_head *)msg_q);
+			*phMsgQueue = msg_q;
 			/* Signal that free frames are now available */
-			if (!LST_IsEmpty(hMsgMgr->msgFreeList))
-				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+			if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list))
+				sync_set_event(hmsg_mgr->sync_event);
 
 		}
 		/* Exit critical section */
-		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
 	} else {
-		DeleteMsgQueue(pMsgQ, 0);
+		delete_msg_queue(msg_q, 0);
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_MSG_Delete ========
- *      Delete a MSG manager allocated in WMD_MSG_Create().
+ *  ======== bridge_msg_delete ========
+ *      Delete a msg_ctrl manager allocated in bridge_msg_create().
  */
-void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr)
+void bridge_msg_delete(struct msg_mgr *hmsg_mgr)
 {
-	if (MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE))
-		DeleteMsgMgr(hMsgMgr);
+	if (MEM_IS_VALID_HANDLE(hmsg_mgr, MSGMGR_SIGNATURE))
+		delete_msg_mgr(hmsg_mgr);
 }
 
 /*
- *  ======== WMD_MSG_DeleteQueue ========
- *      Delete a MSG queue allocated in WMD_MSG_CreateQueue.
+ *  ======== bridge_msg_delete_queue ========
+ *      Delete a msg_ctrl queue allocated in bridge_msg_create_queue.
  */
-void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue)
+void bridge_msg_delete_queue(struct msg_queue *msg_queue_obj)
 {
-	struct MSG_MGR *hMsgMgr;
-	u32 refCount;
+	struct msg_mgr *hmsg_mgr;
+	u32 io_msg_pend;
 
-	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) ||
-			!hMsgQueue->hMsgMgr)
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) ||
+	    !msg_queue_obj->hmsg_mgr)
 		goto func_end;
 
-	hMsgMgr = hMsgQueue->hMsgMgr;
-	hMsgQueue->fDone = true;
-	 /*  Unblock all threads blocked in MSG_Get() or MSG_Put().  */
-	refCount = hMsgQueue->refCount;
-	while (refCount) {
+	hmsg_mgr = msg_queue_obj->hmsg_mgr;
+	msg_queue_obj->done = true;
+	/*  Unblock all threads blocked in MSG_Get() or MSG_Put(). */
+	io_msg_pend = msg_queue_obj->io_msg_pend;
+	while (io_msg_pend) {
 		/* Unblock thread */
-		SYNC_SetEvent(hMsgQueue->hSyncDone);
+		sync_set_event(msg_queue_obj->sync_done);
 		/* Wait for acknowledgement */
-		SYNC_WaitOnEvent(hMsgQueue->hSyncDoneAck, SYNC_INFINITE);
-		refCount = hMsgQueue->refCount;
+		sync_wait_on_event(msg_queue_obj->sync_done_ack, SYNC_INFINITE);
+		io_msg_pend = msg_queue_obj->io_msg_pend;
 	}
-	/* Remove message queue from hMsgMgr->queueList */
-	(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
-	LST_RemoveElem(hMsgMgr->queueList, (struct list_head *)hMsgQueue);
+	/* Remove message queue from hmsg_mgr->queue_list */
+	spin_lock_bh(&hmsg_mgr->msg_mgr_lock);
+	lst_remove_elem(hmsg_mgr->queue_list,
+			(struct list_head *)msg_queue_obj);
 	/* Free the message queue object */
-	DeleteMsgQueue(hMsgQueue, hMsgQueue->uMaxMsgs);
-	if (!hMsgMgr->msgFreeList)
+	delete_msg_queue(msg_queue_obj, msg_queue_obj->max_msgs);
+	if (!hmsg_mgr->msg_free_list)
 		goto func_cont;
-	if (LST_IsEmpty(hMsgMgr->msgFreeList))
-		SYNC_ResetEvent(hMsgMgr->hSyncEvent);
+	if (LST_IS_EMPTY(hmsg_mgr->msg_free_list))
+		sync_reset_event(hmsg_mgr->sync_event);
 func_cont:
-	(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+	spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
 func_end:
 	return;
 }
 
 /*
- *  ======== WMD_MSG_Get ========
- *      Get a message from a MSG queue.
+ *  ======== bridge_msg_get ========
+ *      Get a message from a msg_ctrl queue.
  */
-DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE *hMsgQueue,
-		      struct DSP_MSG *pMsg, u32 uTimeout)
+dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
+			  struct dsp_msg *pmsg, u32 utimeout)
 {
-	struct MSG_FRAME *pMsgFrame;
-	struct MSG_MGR *hMsgMgr;
-	bool fGotMsg = false;
-	struct SYNC_OBJECT *hSyncs[2];
-	u32 uIndex;
-	DSP_STATUS status = DSP_SOK;
-
-	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || pMsg == NULL) {
+	struct msg_frame *msg_frame_obj;
+	struct msg_mgr *hmsg_mgr;
+	bool got_msg = false;
+	struct sync_object *syncs[2];
+	u32 index;
+	dsp_status status = DSP_SOK;
+
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) ||
+	    pmsg == NULL) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
 
-	hMsgMgr = hMsgQueue->hMsgMgr;
-	if (!hMsgQueue->msgUsedList) {
+	hmsg_mgr = msg_queue_obj->hmsg_mgr;
+	if (!msg_queue_obj->msg_used_list) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
 	/* Enter critical section */
-	(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+	spin_lock_bh(&hmsg_mgr->msg_mgr_lock);
 	/* If a message is already there, get it */
-	if (!LST_IsEmpty(hMsgQueue->msgUsedList)) {
-		pMsgFrame = (struct MSG_FRAME *)LST_GetHead(hMsgQueue->
-			    msgUsedList);
-		if (pMsgFrame != NULL) {
-			*pMsg = pMsgFrame->msgData.msg;
-			LST_PutTail(hMsgQueue->msgFreeList,
-				   (struct list_head *)pMsgFrame);
-			if (LST_IsEmpty(hMsgQueue->msgUsedList))
-				SYNC_ResetEvent(hMsgQueue->hSyncEvent);
+	if (!LST_IS_EMPTY(msg_queue_obj->msg_used_list)) {
+		msg_frame_obj = (struct msg_frame *)
+		    lst_get_head(msg_queue_obj->msg_used_list);
+		if (msg_frame_obj != NULL) {
+			*pmsg = msg_frame_obj->msg_data.msg;
+			lst_put_tail(msg_queue_obj->msg_free_list,
+				     (struct list_head *)msg_frame_obj);
+			if (LST_IS_EMPTY(msg_queue_obj->msg_used_list))
+				sync_reset_event(msg_queue_obj->sync_event);
 			else {
-				NTFY_Notify(hMsgQueue->hNtfy,
-					DSP_NODEMESSAGEREADY);
-				SYNC_SetEvent(hMsgQueue->hSyncEvent);
+				ntfy_notify(msg_queue_obj->ntfy_obj,
+					    DSP_NODEMESSAGEREADY);
+				sync_set_event(msg_queue_obj->sync_event);
 			}
 
-			fGotMsg = true;
+			got_msg = true;
 		}
 	} else {
-		if (hMsgQueue->fDone)
+		if (msg_queue_obj->done)
 			status = DSP_EFAIL;
 		else
-			hMsgQueue->refCount++;
+			msg_queue_obj->io_msg_pend++;
 
 	}
 	/* Exit critical section */
-	(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
-	if (DSP_SUCCEEDED(status) && !fGotMsg) {
+	spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
+	if (DSP_SUCCEEDED(status) && !got_msg) {
 		/*  Wait til message is available, timeout, or done. We don't
 		 *  have to schedule the DPC, since the DSP will send messages
-		 *  when they are available.  */
-		hSyncs[0] = hMsgQueue->hSyncEvent;
-		hSyncs[1] = hMsgQueue->hSyncDone;
-		status = SYNC_WaitOnMultipleEvents(hSyncs, 2, uTimeout,
-			 &uIndex);
+		 *  when they are available. */
+		syncs[0] = msg_queue_obj->sync_event;
+		syncs[1] = msg_queue_obj->sync_done;
+		status = sync_wait_on_multiple_events(syncs, 2, utimeout,
+						      &index);
 		/* Enter critical section */
-		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
-		if (hMsgQueue->fDone) {
-			hMsgQueue->refCount--;
+		spin_lock_bh(&hmsg_mgr->msg_mgr_lock);
+		if (msg_queue_obj->done) {
+			msg_queue_obj->io_msg_pend--;
 			/* Exit critical section */
-			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
-			 /*  Signal that we're not going to access hMsgQueue
-			  *  anymore, so it can be deleted.  */
-			(void)SYNC_SetEvent(hMsgQueue->hSyncDoneAck);
+			spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
+			/*  Signal that we're not going to access msg_queue_obj
+			 *  anymore, so it can be deleted. */
+			(void)sync_set_event(msg_queue_obj->sync_done_ack);
 			status = DSP_EFAIL;
 		} else {
 			if (DSP_SUCCEEDED(status)) {
-				DBC_Assert(!LST_IsEmpty(hMsgQueue->
-					  msgUsedList));
+				DBC_ASSERT(!LST_IS_EMPTY
+					   (msg_queue_obj->msg_used_list));
 				/* Get msg from used list */
-				pMsgFrame = (struct MSG_FRAME *)
-					   LST_GetHead(hMsgQueue->msgUsedList);
-				/* Copy message into pMsg and put frame on the
+				msg_frame_obj = (struct msg_frame *)
+				    lst_get_head(msg_queue_obj->msg_used_list);
+				/* Copy message into pmsg and put frame on the
 				 * free list */
-				if (pMsgFrame != NULL) {
-					*pMsg = pMsgFrame->msgData.msg;
-					LST_PutTail(hMsgQueue->msgFreeList,
-					(struct list_head *)pMsgFrame);
+				if (msg_frame_obj != NULL) {
+					*pmsg = msg_frame_obj->msg_data.msg;
+					lst_put_tail
+					    (msg_queue_obj->msg_free_list,
+					     (struct list_head *)
+					     msg_frame_obj);
 				}
 			}
-			hMsgQueue->refCount--;
+			msg_queue_obj->io_msg_pend--;
 			/* Reset the event if there are still queued messages */
-			if (!LST_IsEmpty(hMsgQueue->msgUsedList)) {
-				NTFY_Notify(hMsgQueue->hNtfy,
-					DSP_NODEMESSAGEREADY);
-				SYNC_SetEvent(hMsgQueue->hSyncEvent);
+			if (!LST_IS_EMPTY(msg_queue_obj->msg_used_list)) {
+				ntfy_notify(msg_queue_obj->ntfy_obj,
+					    DSP_NODEMESSAGEREADY);
+				sync_set_event(msg_queue_obj->sync_event);
 			}
 			/* Exit critical section */
-			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+			spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
 		}
 	}
 func_end:
@@ -361,108 +396,112 @@ func_end:
 }
 
 /*
- *  ======== WMD_MSG_Put ========
- *      Put a message onto a MSG queue.
+ *  ======== bridge_msg_put ========
+ *      Put a message onto a msg_ctrl queue.
  */
-DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE *hMsgQueue,
-		      IN CONST struct DSP_MSG *pMsg, u32 uTimeout)
+dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
+			  IN CONST struct dsp_msg *pmsg, u32 utimeout)
 {
-	struct MSG_FRAME *pMsgFrame;
-	struct MSG_MGR *hMsgMgr;
-	bool fPutMsg = false;
-	struct SYNC_OBJECT *hSyncs[2];
-	u32 uIndex;
-	DSP_STATUS status = DSP_SOK;
-
-	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || !pMsg ||
-						!hMsgQueue->hMsgMgr) {
+	struct msg_frame *msg_frame_obj;
+	struct msg_mgr *hmsg_mgr;
+	bool put_msg = false;
+	struct sync_object *syncs[2];
+	u32 index;
+	dsp_status status = DSP_SOK;
+
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) || !pmsg ||
+	    !msg_queue_obj->hmsg_mgr) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	hMsgMgr = hMsgQueue->hMsgMgr;
-	if (!hMsgMgr->msgFreeList) {
+	hmsg_mgr = msg_queue_obj->hmsg_mgr;
+	if (!hmsg_mgr->msg_free_list) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
 
-	(void) SYNC_EnterCS(hMsgMgr->hSyncCS);
+	spin_lock_bh(&hmsg_mgr->msg_mgr_lock);
 
 	/* If a message frame is available, use it */
-	if (!LST_IsEmpty(hMsgMgr->msgFreeList)) {
-		pMsgFrame = (struct MSG_FRAME *)LST_GetHead(hMsgMgr->
-			    msgFreeList);
-		if (pMsgFrame != NULL) {
-			pMsgFrame->msgData.msg = *pMsg;
-			pMsgFrame->msgData.dwId = hMsgQueue->dwId;
-			LST_PutTail(hMsgMgr->msgUsedList,
-					(struct list_head *)pMsgFrame);
-			hMsgMgr->uMsgsPending++;
-			fPutMsg = true;
+	if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list)) {
+		msg_frame_obj =
+		    (struct msg_frame *)lst_get_head(hmsg_mgr->msg_free_list);
+		if (msg_frame_obj != NULL) {
+			msg_frame_obj->msg_data.msg = *pmsg;
+			msg_frame_obj->msg_data.msgq_id =
+			    msg_queue_obj->msgq_id;
+			lst_put_tail(hmsg_mgr->msg_used_list,
+				     (struct list_head *)msg_frame_obj);
+			hmsg_mgr->msgs_pending++;
+			put_msg = true;
 		}
-		if (LST_IsEmpty(hMsgMgr->msgFreeList))
-			SYNC_ResetEvent(hMsgMgr->hSyncEvent);
+		if (LST_IS_EMPTY(hmsg_mgr->msg_free_list))
+			sync_reset_event(hmsg_mgr->sync_event);
 
 		/* Release critical section before scheduling DPC */
-		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
 		/* Schedule a DPC, to do the actual data transfer: */
-		IO_Schedule(hMsgMgr->hIOMgr);
+		iosm_schedule(hmsg_mgr->hio_mgr);
 	} else {
-		if (hMsgQueue->fDone)
+		if (msg_queue_obj->done)
 			status = DSP_EFAIL;
 		else
-			hMsgQueue->refCount++;
+			msg_queue_obj->io_msg_pend++;
 
-		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
 	}
-	if (DSP_SUCCEEDED(status) && !fPutMsg) {
+	if (DSP_SUCCEEDED(status) && !put_msg) {
 		/* Wait til a free message frame is available, timeout,
 		 * or done */
-		hSyncs[0] = hMsgMgr->hSyncEvent;
-		hSyncs[1] = hMsgQueue->hSyncDone;
-		status = SYNC_WaitOnMultipleEvents(hSyncs, 2, uTimeout,
-			 &uIndex);
+		syncs[0] = hmsg_mgr->sync_event;
+		syncs[1] = msg_queue_obj->sync_done;
+		status = sync_wait_on_multiple_events(syncs, 2, utimeout,
+						      &index);
 		if (DSP_FAILED(status))
 			goto func_end;
 		/* Enter critical section */
-		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
-		if (hMsgQueue->fDone) {
-			hMsgQueue->refCount--;
+		spin_lock_bh(&hmsg_mgr->msg_mgr_lock);
+		if (msg_queue_obj->done) {
+			msg_queue_obj->io_msg_pend--;
 			/* Exit critical section */
-			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
-			 /*  Signal that we're not going to access hMsgQueue
-			  *  anymore, so it can be deleted.  */
-			(void)SYNC_SetEvent(hMsgQueue->hSyncDoneAck);
+			spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
+			/*  Signal that we're not going to access msg_queue_obj
+			 *  anymore, so it can be deleted. */
+			(void)sync_set_event(msg_queue_obj->sync_done_ack);
 			status = DSP_EFAIL;
 		} else {
-			if (LST_IsEmpty(hMsgMgr->msgFreeList)) {
+			if (LST_IS_EMPTY(hmsg_mgr->msg_free_list)) {
 				status = DSP_EPOINTER;
 				goto func_cont;
 			}
 			/* Get msg from free list */
-			pMsgFrame = (struct MSG_FRAME *)
-					    LST_GetHead(hMsgMgr->msgFreeList);
+			msg_frame_obj = (struct msg_frame *)
+			    lst_get_head(hmsg_mgr->msg_free_list);
 			/*
-			 * Copy message into pMsg and put frame on the
-			 * used list
+			 * Copy message into pmsg and put frame on the
+			 * used list.
 			 */
-			if (pMsgFrame) {
-				pMsgFrame->msgData.msg = *pMsg;
-				pMsgFrame->msgData.dwId = hMsgQueue->dwId;
-				LST_PutTail(hMsgMgr->msgUsedList,
-					   (struct list_head *)pMsgFrame);
-				hMsgMgr->uMsgsPending++;
-				/* Schedule a DPC, to do the actual
-				 * data transfer: */
-				IO_Schedule(hMsgMgr->hIOMgr);
+			if (msg_frame_obj) {
+				msg_frame_obj->msg_data.msg = *pmsg;
+				msg_frame_obj->msg_data.msgq_id =
+				    msg_queue_obj->msgq_id;
+				lst_put_tail(hmsg_mgr->msg_used_list,
+					     (struct list_head *)msg_frame_obj);
+				hmsg_mgr->msgs_pending++;
+				/*
+				 * Schedule a DPC, to do the actual
+				 * data transfer.
+				 */
+				iosm_schedule(hmsg_mgr->hio_mgr);
 			}
 
-			hMsgQueue->refCount--;
+			msg_queue_obj->io_msg_pend--;
 			/* Reset event if there are still frames available */
-			if (!LST_IsEmpty(hMsgMgr->msgFreeList))
-				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+			if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list))
+				sync_set_event(hmsg_mgr->sync_event);
 func_cont:
 			/* Exit critical section */
-			(void) SYNC_LeaveCS(hMsgMgr->hSyncCS);
+			spin_unlock_bh(&hmsg_mgr->msg_mgr_lock);
 		}
 	}
 func_end:
@@ -470,36 +509,41 @@ func_end:
 }
 
 /*
- *  ======== WMD_MSG_RegisterNotify ========
+ *  ======== bridge_msg_register_notify ========
  */
-DSP_STATUS WMD_MSG_RegisterNotify(struct MSG_QUEUE *hMsgQueue, u32 uEventMask,
-				  u32 uNotifyType,
-				  struct DSP_NOTIFICATION *hNotification)
+dsp_status bridge_msg_register_notify(struct msg_queue *msg_queue_obj,
+				   u32 event_mask, u32 notify_type,
+				   struct dsp_notification *hnotification)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || !hNotification) {
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE)
+	    || !hnotification) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
 
-	if (!(uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0)) {
+	if (!(event_mask == DSP_NODEMESSAGEREADY || event_mask == 0)) {
 		status = DSP_ENODETYPE;
 		goto func_end;
 	}
 
-	if (uNotifyType != DSP_SIGNALEVENT) {
+	if (notify_type != DSP_SIGNALEVENT) {
 		status = DSP_EWRONGSTATE;
 		goto func_end;
 	}
 
-	status = NTFY_Register(hMsgQueue->hNtfy, hNotification, uEventMask,
-			      uNotifyType);
+	if (event_mask)
+		status = ntfy_register(msg_queue_obj->ntfy_obj, hnotification,
+						event_mask, notify_type);
+	else
+		status = ntfy_unregister(msg_queue_obj->ntfy_obj,
+							hnotification);
 
 	if (status == DSP_EVALUE) {
 		/*  Not registered. Ok, since we couldn't have known. Node
 		 *  notifications are split between node state change handled
-		 *  by NODE, and message ready handled by MSG.  */
+		 *  by NODE, and message ready handled by msg_ctrl. */
 		status = DSP_SOK;
 	}
 func_end:
@@ -507,35 +551,35 @@ func_end:
 }
 
 /*
- *  ======== WMD_MSG_SetQueueId ========
+ *  ======== bridge_msg_set_queue_id ========
  */
-void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId)
+void bridge_msg_set_queue_id(struct msg_queue *msg_queue_obj, u32 msgq_id)
 {
 	/*
 	 *  A message queue must be created when a node is allocated,
-	 *  so that NODE_RegisterNotify() can be called before the node
+	 *  so that node_register_notify() can be called before the node
 	 *  is created. Since we don't know the node environment until the
-	 *  node is created, we need this function to set hMsgQueue->dwId
+	 *  node is created, we need this function to set msg_queue_obj->msgq_id
 	 *  to the node environment, after the node is created.
 	 */
-	if (MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE))
-		hMsgQueue->dwId = dwId;
+	if (MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE))
+		msg_queue_obj->msgq_id = msgq_id;
 }
 
 /*
- *  ======== AddNewMsg ========
+ *  ======== add_new_msg ========
  *      Must be called in message manager critical section.
  */
-static DSP_STATUS AddNewMsg(struct LST_LIST *msgList)
+static dsp_status add_new_msg(struct lst_list *msgList)
 {
-	struct MSG_FRAME *pMsg;
-	DSP_STATUS status = DSP_SOK;
-
-	pMsg = (struct MSG_FRAME *)MEM_Calloc(sizeof(struct MSG_FRAME),
-		MEM_PAGED);
-	if (pMsg != NULL) {
-		LST_InitElem((struct list_head *)pMsg);
-		LST_PutTail(msgList, (struct list_head *)pMsg);
+	struct msg_frame *pmsg;
+	dsp_status status = DSP_SOK;
+
+	pmsg = (struct msg_frame *)mem_calloc(sizeof(struct msg_frame),
+					      MEM_PAGED);
+	if (pmsg != NULL) {
+		lst_init_elem((struct list_head *)pmsg);
+		lst_put_tail(msgList, (struct list_head *)pmsg);
 	} else {
 		status = DSP_EMEMORY;
 	}
@@ -544,115 +588,106 @@ static DSP_STATUS AddNewMsg(struct LST_LIST *msgList)
 }
 
 /*
- *  ======== DeleteMsgMgr ========
+ *  ======== delete_msg_mgr ========
  */
-static void DeleteMsgMgr(struct MSG_MGR *hMsgMgr)
+static void delete_msg_mgr(struct msg_mgr *hmsg_mgr)
 {
-	if (!MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(hmsg_mgr, MSGMGR_SIGNATURE))
 		goto func_end;
 
-	if (hMsgMgr->queueList) {
-		if (LST_IsEmpty(hMsgMgr->queueList)) {
-			kfree(hMsgMgr->queueList);
-			hMsgMgr->queueList = NULL;
+	if (hmsg_mgr->queue_list) {
+		if (LST_IS_EMPTY(hmsg_mgr->queue_list)) {
+			kfree(hmsg_mgr->queue_list);
+			hmsg_mgr->queue_list = NULL;
 		}
 	}
 
-	if (hMsgMgr->msgFreeList) {
-		FreeMsgList(hMsgMgr->msgFreeList);
-		hMsgMgr->msgFreeList = NULL;
+	if (hmsg_mgr->msg_free_list) {
+		free_msg_list(hmsg_mgr->msg_free_list);
+		hmsg_mgr->msg_free_list = NULL;
 	}
 
-	if (hMsgMgr->msgUsedList) {
-		FreeMsgList(hMsgMgr->msgUsedList);
-		hMsgMgr->msgUsedList = NULL;
+	if (hmsg_mgr->msg_used_list) {
+		free_msg_list(hmsg_mgr->msg_used_list);
+		hmsg_mgr->msg_used_list = NULL;
 	}
 
-	if (hMsgMgr->hSyncEvent)
-		SYNC_CloseEvent(hMsgMgr->hSyncEvent);
-
-	if (hMsgMgr->hSyncCS)
-		SYNC_DeleteCS(hMsgMgr->hSyncCS);
+	kfree(hmsg_mgr->sync_event);
 
-	MEM_FreeObject(hMsgMgr);
+	MEM_FREE_OBJECT(hmsg_mgr);
 func_end:
 	return;
 }
 
 /*
- *  ======== DeleteMsgQueue ========
+ *  ======== delete_msg_queue ========
  */
-static void DeleteMsgQueue(struct MSG_QUEUE *hMsgQueue, u32 uNumToDSP)
+static void delete_msg_queue(struct msg_queue *msg_queue_obj, u32 uNumToDSP)
 {
-       struct MSG_MGR *hMsgMgr;
-	struct MSG_FRAME *pMsg;
+	struct msg_mgr *hmsg_mgr;
+	struct msg_frame *pmsg;
 	u32 i;
 
-	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) ||
-	    !hMsgQueue->hMsgMgr || !hMsgQueue->hMsgMgr->msgFreeList)
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) ||
+	    !msg_queue_obj->hmsg_mgr || !msg_queue_obj->hmsg_mgr->msg_free_list)
 		goto func_end;
 
-	hMsgMgr = hMsgQueue->hMsgMgr;
+	hmsg_mgr = msg_queue_obj->hmsg_mgr;
 
 	/* Pull off uNumToDSP message frames from Msg manager and free */
 	for (i = 0; i < uNumToDSP; i++) {
 
-		if (!LST_IsEmpty(hMsgMgr->msgFreeList)) {
-			pMsg = (struct MSG_FRAME *)LST_GetHead(hMsgMgr->
-				msgFreeList);
-			kfree(pMsg);
+		if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list)) {
+			pmsg = (struct msg_frame *)
+			    lst_get_head(hmsg_mgr->msg_free_list);
+			kfree(pmsg);
 		} else {
 			/* Cannot free all of the message frames */
 			break;
 		}
 	}
 
-       if (hMsgQueue->msgFreeList) {
-		FreeMsgList(hMsgQueue->msgFreeList);
-		hMsgQueue->msgFreeList = NULL;
-       }
-
-       if (hMsgQueue->msgUsedList) {
-		FreeMsgList(hMsgQueue->msgUsedList);
-		hMsgQueue->msgUsedList = NULL;
-       }
-
-
-	if (hMsgQueue->hNtfy)
-		NTFY_Delete(hMsgQueue->hNtfy);
+	if (msg_queue_obj->msg_free_list) {
+		free_msg_list(msg_queue_obj->msg_free_list);
+		msg_queue_obj->msg_free_list = NULL;
+	}
 
-	if (hMsgQueue->hSyncEvent)
-		SYNC_CloseEvent(hMsgQueue->hSyncEvent);
+	if (msg_queue_obj->msg_used_list) {
+		free_msg_list(msg_queue_obj->msg_used_list);
+		msg_queue_obj->msg_used_list = NULL;
+	}
 
-	if (hMsgQueue->hSyncDone)
-		SYNC_CloseEvent(hMsgQueue->hSyncDone);
+	if (msg_queue_obj->ntfy_obj) {
+		ntfy_delete(msg_queue_obj->ntfy_obj);
+		kfree(msg_queue_obj->ntfy_obj);
+	}
 
-	if (hMsgQueue->hSyncDoneAck)
-		SYNC_CloseEvent(hMsgQueue->hSyncDoneAck);
+	kfree(msg_queue_obj->sync_event);
+	kfree(msg_queue_obj->sync_done);
+	kfree(msg_queue_obj->sync_done_ack);
 
-	MEM_FreeObject(hMsgQueue);
+	MEM_FREE_OBJECT(msg_queue_obj);
 func_end:
-       return;
+	return;
 
 }
 
 /*
- *  ======== FreeMsgList ========
+ *  ======== free_msg_list ========
  */
-static void FreeMsgList(struct LST_LIST *msgList)
+static void free_msg_list(struct lst_list *msgList)
 {
-	struct MSG_FRAME *pMsg;
+	struct msg_frame *pmsg;
 
 	if (!msgList)
 		goto func_end;
 
-	while ((pMsg = (struct MSG_FRAME *)LST_GetHead(msgList)) != NULL)
-		kfree(pMsg);
+	while ((pmsg = (struct msg_frame *)lst_get_head(msgList)) != NULL)
+		kfree(pmsg);
 
-	DBC_Assert(LST_IsEmpty(msgList));
+	DBC_ASSERT(LST_IS_EMPTY(msgList));
 
 	kfree(msgList);
 func_end:
 	return;
 }
-
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
index dee9811..034dde9 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -68,7 +68,6 @@
 #include "_tiomap_util.h"
 #include "tiomap_io.h"
 
-
 /* Offset in shared mem to write to in order to synchronize start with DSP */
 #define SHMSYNCOFFSET 4		/* GPP byte offset */
 
@@ -83,50 +82,53 @@
 #define MMU_GFLUSH 0x60
 
 /* Forward Declarations: */
-static DSP_STATUS WMD_BRD_Monitor(struct WMD_DEV_CONTEXT *pDevContext);
-static DSP_STATUS WMD_BRD_Read(struct WMD_DEV_CONTEXT *pDevContext,
-			OUT u8 *pbHostBuf,
-			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType);
-static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *pDevContext,
-			u32 dwDSPAddr);
-static DSP_STATUS WMD_BRD_Status(struct WMD_DEV_CONTEXT *pDevContext,
-			int *pdwState);
-static DSP_STATUS WMD_BRD_Stop(struct WMD_DEV_CONTEXT *pDevContext);
-static DSP_STATUS WMD_BRD_Write(struct WMD_DEV_CONTEXT *pDevContext,
-			IN u8 *pbHostBuf,
-			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType);
-static DSP_STATUS WMD_BRD_SetState(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulBrdState);
-static DSP_STATUS WMD_BRD_MemCopy(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulDspDestAddr, u32 ulDspSrcAddr,
-			u32 ulNumBytes, u32 ulMemType);
-static DSP_STATUS WMD_BRD_MemWrite(struct WMD_DEV_CONTEXT *pDevContext,
-			IN u8 *pbHostBuf, u32 dwDSPAddr,
-			u32 ulNumBytes, u32 ulMemType);
-static DSP_STATUS WMD_BRD_MemMap(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulMpuAddr, u32 ulVirtAddr, u32 ulNumBytes,
-			u32 ulMapAttr);
-static DSP_STATUS WMD_BRD_MemUnMap(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulVirtAddr, u32 ulNumBytes);
-static DSP_STATUS WMD_DEV_Create(OUT struct WMD_DEV_CONTEXT **ppDevContext,
-			struct DEV_OBJECT *hDevObject,
-			IN CONST struct CFG_HOSTRES *pConfig,
-			IN CONST struct CFG_DSPRES *pDspConfig);
-static DSP_STATUS WMD_DEV_Ctrl(struct WMD_DEV_CONTEXT *pDevContext, u32 dwCmd,
-			IN OUT void *pArgs);
-static DSP_STATUS WMD_DEV_Destroy(struct WMD_DEV_CONTEXT *pDevContext);
-static u32 user_va2pa(struct mm_struct *mm, u32 address);
-static DSP_STATUS PteUpdate(struct WMD_DEV_CONTEXT *hDevContext, u32 pa,
-			u32 va, u32 size,
-			struct HW_MMUMapAttrs_t *mapAttrs);
-static DSP_STATUS PteSet(struct PgTableAttrs *pt, u32 pa, u32 va,
-			u32 size, struct HW_MMUMapAttrs_t *attrs);
-static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulMpuAddr, u32 ulVirtAddr,
-			u32 ulNumBytes, struct HW_MMUMapAttrs_t *hwAttrs);
+static dsp_status bridge_brd_monitor(struct wmd_dev_context *dev_context);
+static dsp_status bridge_brd_read(struct wmd_dev_context *dev_context,
+				  OUT u8 *pbHostBuf,
+				  u32 dwDSPAddr, u32 ul_num_bytes,
+				  u32 ulMemType);
+static dsp_status bridge_brd_start(struct wmd_dev_context *dev_context,
+				   u32 dwDSPAddr);
+static dsp_status bridge_brd_status(struct wmd_dev_context *dev_context,
+				    int *pdwState);
+static dsp_status bridge_brd_stop(struct wmd_dev_context *dev_context);
+static dsp_status bridge_brd_write(struct wmd_dev_context *dev_context,
+				   IN u8 *pbHostBuf,
+				   u32 dwDSPAddr, u32 ul_num_bytes,
+				   u32 ulMemType);
+static dsp_status bridge_brd_set_state(struct wmd_dev_context *hDevContext,
+				    u32 ulBrdState);
+static dsp_status bridge_brd_mem_copy(struct wmd_dev_context *hDevContext,
+				   u32 ulDspDestAddr, u32 ulDspSrcAddr,
+				   u32 ul_num_bytes, u32 ulMemType);
+static dsp_status bridge_brd_mem_write(struct wmd_dev_context *dev_context,
+				    IN u8 *pbHostBuf, u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType);
+static dsp_status bridge_brd_mem_map(struct wmd_dev_context *hDevContext,
+				  u32 ul_mpu_addr, u32 ulVirtAddr,
+				  u32 ul_num_bytes, u32 ul_map_attr);
+static dsp_status bridge_brd_mem_un_map(struct wmd_dev_context *hDevContext,
+				     u32 ulVirtAddr, u32 ul_num_bytes);
+static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
+				    struct dev_object *hdev_obj,
+				    IN CONST struct cfg_hostres *pConfig,
+				    IN CONST struct cfg_dspres *pDspConfig);
+static dsp_status bridge_dev_ctrl(struct wmd_dev_context *dev_context,
+				  u32 dw_cmd, IN OUT void *pargs);
+static dsp_status bridge_dev_destroy(struct wmd_dev_context *dev_context);
+static u32 user_va2_pa(struct mm_struct *mm, u32 address);
+static dsp_status pte_update(struct wmd_dev_context *hDevContext, u32 pa,
+			     u32 va, u32 size,
+			     struct hw_mmu_map_attrs_t *map_attrs);
+static dsp_status pte_set(struct pg_table_attrs *pt, u32 pa, u32 va,
+			  u32 size, struct hw_mmu_map_attrs_t *attrs);
+static dsp_status mem_map_vmalloc(struct wmd_dev_context *hDevContext,
+				  u32 ul_mpu_addr, u32 ulVirtAddr,
+				  u32 ul_num_bytes,
+				  struct hw_mmu_map_attrs_t *hw_attrs);
 
 #ifdef CONFIG_BRIDGE_DEBUG
-static void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
+static void get_hw_regs(void __iomem *prm_base, void __iomem *cm_base)
 {
 	u32 temp;
 	temp = __raw_readl((cm_base) + 0x00);
@@ -151,7 +153,7 @@ static void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
 	dev_dbg(bridge, "CM_ICLKEN1_CORE = 0x%x \n", temp);
 }
 #else
-static inline void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
+static inline void get_hw_regs(void __iomem *prm_base, void __iomem *cm_base)
 {
 }
 #endif
@@ -159,39 +161,40 @@ static inline void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
 /*  ----------------------------------- Globals */
 
 /* Attributes of L2 page tables for DSP MMU */
-struct PageInfo {
-	u32 numEntries;	/* Number of valid PTEs in the L2 PT */
-} ;
+struct page_info {
+	u32 num_entries;	/* Number of valid PTEs in the L2 PT */
+};
 
 /* Attributes used to manage the DSP MMU page tables */
-struct PgTableAttrs {
-	struct SYNC_CSOBJECT *hCSObj;	/* Critical section object handle */
+struct pg_table_attrs {
+	spinlock_t pg_lock;	/* Critical section object handle */
 
-	u32 L1BasePa;		/* Physical address of the L1 PT */
-	u32 L1BaseVa;		/* Virtual  address of the L1 PT */
-	u32 L1size;		/* Size of the L1 PT */
-	u32 L1TblAllocPa;
+	u32 l1_base_pa;		/* Physical address of the L1 PT */
+	u32 l1_base_va;		/* Virtual  address of the L1 PT */
+	u32 l1_size;		/* Size of the L1 PT */
+	u32 l1_tbl_alloc_pa;
 	/* Physical address of Allocated mem for L1 table. May not be aligned */
-	u32 L1TblAllocVa;
+	u32 l1_tbl_alloc_va;
 	/* Virtual address of Allocated mem for L1 table. May not be aligned */
-	u32 L1TblAllocSz;
+	u32 l1_tbl_alloc_sz;
 	/* Size of consistent memory allocated for L1 table.
 	 * May not be aligned */
 
-	u32 L2BasePa;		/* Physical address of the L2 PT */
-	u32 L2BaseVa;		/* Virtual  address of the L2 PT */
-	u32 L2size;		/* Size of the L2 PT */
-	u32 L2TblAllocPa;
+	u32 l2_base_pa;		/* Physical address of the L2 PT */
+	u32 l2_base_va;		/* Virtual  address of the L2 PT */
+	u32 l2_size;		/* Size of the L2 PT */
+	u32 l2_tbl_alloc_pa;
 	/* Physical address of Allocated mem for L2 table. May not be aligned */
-	u32 L2TblAllocVa;
+	u32 l2_tbl_alloc_va;
 	/* Virtual address of Allocated mem for L2 table. May not be aligned */
-	u32 L2TblAllocSz;
+	u32 l2_tbl_alloc_sz;
 	/* Size of consistent memory allocated for L2 table.
 	 * May not be aligned */
 
-	u32 L2NumPages;	/* Number of allocated L2 PT */
-	struct PageInfo *pgInfo;  /* Array [L2NumPages] of L2 PT info structs */
-} ;
+	u32 l2_num_pages;	/* Number of allocated L2 PT */
+	/* Array [l2_num_pages] of L2 PT info structs */
+	struct page_info *pg_info;
+};
 
 /*
  *  If dsp_debug is true, do not branch to the DSP entry point and wait for DSP
@@ -202,56 +205,57 @@ extern s32 dsp_debug;
 /*
  *  This mini driver's function interface table.
  */
-static struct WMD_DRV_INTERFACE drvInterfaceFxns = {
-	WCD_MAJOR_VERSION,  /* WCD ver. for which this mini driver is built. */
+static struct bridge_drv_interface drv_interface_fxns = {
+	/* WCD ver. for which this mini driver is built. */
+	WCD_MAJOR_VERSION,
 	WCD_MINOR_VERSION,
-	WMD_DEV_Create,
-	WMD_DEV_Destroy,
-	WMD_DEV_Ctrl,
-	WMD_BRD_Monitor,
-	WMD_BRD_Start,
-	WMD_BRD_Stop,
-	WMD_BRD_Status,
-	WMD_BRD_Read,
-	WMD_BRD_Write,
-	WMD_BRD_SetState,
-	WMD_BRD_MemCopy,
-	WMD_BRD_MemWrite,
-	WMD_BRD_MemMap,
-	WMD_BRD_MemUnMap,
+	bridge_dev_create,
+	bridge_dev_destroy,
+	bridge_dev_ctrl,
+	bridge_brd_monitor,
+	bridge_brd_start,
+	bridge_brd_stop,
+	bridge_brd_status,
+	bridge_brd_read,
+	bridge_brd_write,
+	bridge_brd_set_state,
+	bridge_brd_mem_copy,
+	bridge_brd_mem_write,
+	bridge_brd_mem_map,
+	bridge_brd_mem_un_map,
 	/* The following CHNL functions are provided by chnl_io.lib: */
-	WMD_CHNL_Create,
-	WMD_CHNL_Destroy,
-	WMD_CHNL_Open,
-	WMD_CHNL_Close,
-	WMD_CHNL_AddIOReq,
-	WMD_CHNL_GetIOC,
-	WMD_CHNL_CancelIO,
-	WMD_CHNL_FlushIO,
-	WMD_CHNL_GetInfo,
-	WMD_CHNL_GetMgrInfo,
-	WMD_CHNL_Idle,
-	WMD_CHNL_RegisterNotify,
+	bridge_chnl_create,
+	bridge_chnl_destroy,
+	bridge_chnl_open,
+	bridge_chnl_close,
+	bridge_chnl_add_io_req,
+	bridge_chnl_get_ioc,
+	bridge_chnl_cancel_io,
+	bridge_chnl_flush_io,
+	bridge_chnl_get_info,
+	bridge_chnl_get_mgr_info,
+	bridge_chnl_idle,
+	bridge_chnl_register_notify,
 	/* The following DEH functions are provided by tihelen_ue_deh.c */
-	WMD_DEH_Create,
-	WMD_DEH_Destroy,
-	WMD_DEH_Notify,
-	WMD_DEH_RegisterNotify,
-	WMD_DEH_GetInfo,
+	bridge_deh_create,
+	bridge_deh_destroy,
+	bridge_deh_notify,
+	bridge_deh_register_notify,
+	bridge_deh_get_info,
 	/* The following IO functions are provided by chnl_io.lib: */
-	WMD_IO_Create,
-	WMD_IO_Destroy,
-	WMD_IO_OnLoaded,
-	WMD_IO_GetProcLoad,
-	/* The following MSG functions are provided by chnl_io.lib: */
-	WMD_MSG_Create,
-	WMD_MSG_CreateQueue,
-	WMD_MSG_Delete,
-	WMD_MSG_DeleteQueue,
-	WMD_MSG_Get,
-	WMD_MSG_Put,
-	WMD_MSG_RegisterNotify,
-	WMD_MSG_SetQueueId,
+	bridge_io_create,
+	bridge_io_destroy,
+	bridge_io_on_loaded,
+	bridge_io_get_proc_load,
+	/* The following msg_ctrl functions are provided by chnl_io.lib: */
+	bridge_msg_create,
+	bridge_msg_create_queue,
+	bridge_msg_delete,
+	bridge_msg_delete_queue,
+	bridge_msg_get,
+	bridge_msg_put,
+	bridge_msg_register_notify,
+	bridge_msg_set_queue_id,
 };
 
 static inline void tlb_flush_all(const void __iomem *base)
@@ -259,148 +263,150 @@ static inline void tlb_flush_all(const void __iomem *base)
 	__raw_writeb(__raw_readb(base + MMU_GFLUSH) | 1, base + MMU_GFLUSH);
 }
 
-static inline void flush_all(struct WMD_DEV_CONTEXT *pDevContext)
+static inline void flush_all(struct wmd_dev_context *dev_context)
 {
-	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
-				pDevContext->dwBrdState == BRD_HIBERNATION)
-		WakeDSP(pDevContext, NULL);
+	if (dev_context->dw_brd_state == BRD_DSP_HIBERNATION ||
+	    dev_context->dw_brd_state == BRD_HIBERNATION)
+		wake_dsp(dev_context, NULL);
 
-	tlb_flush_all(pDevContext->dwDSPMmuBase);
+	tlb_flush_all(dev_context->dw_dsp_mmu_base);
 }
 
 static void bad_page_dump(u32 pa, struct page *pg)
 {
 	pr_emerg("DSPBRIDGE: MAP function: COUNT 0 FOR PA 0x%x\n", pa);
 	pr_emerg("Bad page state in process '%s'\n"
-		"page:%p flags:0x%0*lx mapping:%p mapcount:%d count:%d\n"
-		"Backtrace:\n",
-		current->comm, pg, (int)(2*sizeof(unsigned long)),
-		(unsigned long)pg->flags, pg->mapping,
-		page_mapcount(pg), page_count(pg));
+		 "page:%p flags:0x%0*lx mapping:%p mapcount:%d count:%d\n"
+		 "Backtrace:\n",
+		 current->comm, pg, (int)(2 * sizeof(unsigned long)),
+		 (unsigned long)pg->flags, pg->mapping,
+		 page_mapcount(pg), page_count(pg));
 	dump_stack();
 }
 
 /*
- *  ======== WMD_DRV_Entry ========
+ *  ======== bridge_drv_entry ========
  *  purpose:
  *      Mini Driver entry point.
  */
-void WMD_DRV_Entry(OUT struct WMD_DRV_INTERFACE **ppDrvInterface,
-	      IN CONST char *pstrWMDFileName)
+void bridge_drv_entry(OUT struct bridge_drv_interface **ppDrvInterface,
+		   IN CONST char *pstrWMDFileName)
 {
 
-	DBC_Require(pstrWMDFileName != NULL);
+	DBC_REQUIRE(pstrWMDFileName != NULL);
 
-	IO_SM_init(); /* Initialization of io_sm module */
+	io_sm_init();		/* Initialization of io_sm module */
 
 	if (strcmp(pstrWMDFileName, "UMA") == 0)
-		*ppDrvInterface = &drvInterfaceFxns;
+		*ppDrvInterface = &drv_interface_fxns;
 	else
 		dev_dbg(bridge, "%s Unknown WMD file name", __func__);
 
 }
 
 /*
- *  ======== WMD_BRD_Monitor ========
+ *  ======== bridge_brd_monitor ========
  *  purpose:
- *      This WMD_BRD_Monitor puts DSP into a Loadable state.
+ *      This bridge_brd_monitor puts DSP into a Loadable state.
  *      i.e Application can load and start the device.
  *
  *  Preconditions:
  *      Device in 'OFF' state.
  */
-static DSP_STATUS WMD_BRD_Monitor(struct WMD_DEV_CONTEXT *hDevContext)
+static dsp_status bridge_brd_monitor(struct wmd_dev_context *hDevContext)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct CFG_HOSTRES resources;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct cfg_hostres resources;
 	u32 temp;
-	enum HW_PwrState_t    pwrState;
+	enum hw_pwr_state_t pwr_state;
 
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		goto error_return;
 
-	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
-	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &temp);
+	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
+	hw_pwrst_iva2_reg_get(resources.dw_prm_base, &temp);
 	if ((temp & 0x03) != 0x03 || (temp & 0x03) != 0x02) {
 		/* IVA2 is not in ON state */
 		/* Read and set PM_PWSTCTRL_IVA2  to ON */
-		HW_PWR_IVA2PowerStateSet(resources.dwPrmBase,
-					  HW_PWR_DOMAIN_DSP,
-					  HW_PWR_STATE_ON);
+		hw_pwr_iva2_power_state_set(resources.dw_prm_base,
+					    HW_PWR_DOMAIN_DSP, HW_PWR_STATE_ON);
 		/* Set the SW supervised state transition */
-		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_SW_SUP_WAKEUP);
+		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
+					    HW_SW_SUP_WAKEUP);
 		/* Wait until the state has moved to ON */
-		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-				     &pwrState);
+		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
+				      &pwr_state);
 		/* Disable Automatic transition */
-		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_AUTOTRANS_DIS);
+		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
+					    HW_AUTOTRANS_DIS);
 	}
 
-	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
-	HW_RST_UnReset(resources.dwPrmBase, HW_RST2_IVA2);
-	CLK_Enable(SERVICESCLK_iva2_ck);
+	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
+	hw_rst_un_reset(resources.dw_prm_base, HW_RST2_IVA2);
+	services_clk_enable(SERVICESCLK_IVA2_CK);
 
 	if (DSP_SUCCEEDED(status)) {
 		/* set the device state to IDLE */
-		pDevContext->dwBrdState = BRD_IDLE;
+		dev_context->dw_brd_state = BRD_IDLE;
 	}
 error_return:
-	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_Read ========
+ *  ======== bridge_brd_read ========
  *  purpose:
  *      Reads buffers for DSP memory.
  */
-static DSP_STATUS WMD_BRD_Read(struct WMD_DEV_CONTEXT *hDevContext,
-			       OUT u8 *pbHostBuf, u32 dwDSPAddr,
-			       u32 ulNumBytes, u32 ulMemType)
+static dsp_status bridge_brd_read(struct wmd_dev_context *hDevContext,
+				  OUT u8 *pbHostBuf, u32 dwDSPAddr,
+				  u32 ul_num_bytes, u32 ulMemType)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
 	u32 offset;
-	u32 dspBaseAddr = hDevContext->dwDspBaseAddr;
+	u32 dsp_base_addr = hDevContext->dw_dsp_base_addr;
 
-	if (dwDSPAddr < pDevContext->dwDSPStartAdd) {
+	if (dwDSPAddr < dev_context->dw_dsp_start_add) {
 		status = DSP_EFAIL;
 		return status;
 	}
 	/* change here to account for the 3 bands of the DSP internal memory */
-	if ((dwDSPAddr - pDevContext->dwDSPStartAdd) <
-	    pDevContext->dwInternalSize) {
-		offset = dwDSPAddr - pDevContext->dwDSPStartAdd;
+	if ((dwDSPAddr - dev_context->dw_dsp_start_add) <
+	    dev_context->dw_internal_size) {
+		offset = dwDSPAddr - dev_context->dw_dsp_start_add;
 	} else {
-		status = ReadExtDspData(pDevContext, pbHostBuf, dwDSPAddr,
-					ulNumBytes, ulMemType);
+		status = read_ext_dsp_data(dev_context, pbHostBuf, dwDSPAddr,
+					   ul_num_bytes, ulMemType);
 		return status;
 	}
 	/* copy the data from  DSP memory, */
-	memcpy(pbHostBuf, (void *)(dspBaseAddr + offset), ulNumBytes);
+	memcpy(pbHostBuf, (void *)(dsp_base_addr + offset), ul_num_bytes);
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_SetState ========
+ *  ======== bridge_brd_set_state ========
  *  purpose:
  *      This routine updates the Board status.
  */
-static DSP_STATUS WMD_BRD_SetState(struct WMD_DEV_CONTEXT *hDevContext,
-				   u32 ulBrdState)
+static dsp_status bridge_brd_set_state(struct wmd_dev_context *hDevContext,
+				    u32 ulBrdState)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
 
-	pDevContext->dwBrdState = ulBrdState;
+	dev_context->dw_brd_state = ulBrdState;
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_Start ========
+ *  ======== bridge_brd_start ========
  *  purpose:
  *      Initializes DSP MMU and Starts DSP.
  *
@@ -409,230 +415,251 @@ static DSP_STATUS WMD_BRD_SetState(struct WMD_DEV_CONTEXT *hDevContext,
  *  b) DSP_RST1 is asserted.
  *  b) DSP_RST2 is released.
  */
-static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *hDevContext,
-				u32 dwDSPAddr)
+static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
+				   u32 dwDSPAddr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	u32 dwSyncAddr = 0;
-	u32 ulShmBase;	/* Gpp Phys SM base addr(byte) */
-	u32 ulShmBaseVirt;	/* Dsp Virt SM base addr */
-	u32 ulTLBBaseVirt;	/* Base of MMU TLB entry */
-	u32 ulShmOffsetVirt;	/* offset of ulShmBaseVirt from ulTLBBaseVirt */
-	s32 iEntryNdx;
-	s32 itmpEntryNdx = 0;	/* DSP-MMU TLB entry base address */
-	struct CFG_HOSTRES resources;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	u32 dw_sync_addr = 0;
+	u32 ul_shm_base;	/* Gpp Phys SM base addr(byte) */
+	u32 ul_shm_base_virt;	/* Dsp Virt SM base addr */
+	u32 ul_tlb_base_virt;	/* Base of MMU TLB entry */
+	/* Offset of shm_base_virt from tlb_base_virt */
+	u32 ul_shm_offset_virt;
+	s32 entry_ndx;
+	s32 itmp_entry_ndx = 0;	/* DSP-MMU TLB entry base address */
+	struct cfg_hostres resources;
 	u32 temp;
-	u32 ulDspClkRate;
-	u32 ulDspClkAddr;
-	u32 ulBiosGpTimer;
-	u32 uClkCmd;
-	struct IO_MGR *hIOMgr;
-	u32 ulLoadMonitorTimer;
-	u32 extClkId = 0;
-	u32 tmpIndex;
-	u32 clkIdIndex = MBX_PM_MAX_RESOURCES;
+	u32 ul_dsp_clk_rate;
+	u32 ul_dsp_clk_addr;
+	u32 ul_bios_gp_timer;
+	u32 clk_cmd;
+	struct io_mgr *hio_mgr;
+	u32 ul_load_monitor_timer;
+	u32 ext_clk_id = 0;
+	u32 tmp_index;
+	u32 clk_id_index = MBX_PM_MAX_RESOURCES;
 
 	/* The device context contains all the mmu setup info from when the
 	 * last dsp base image was loaded. The first entry is always
 	 * SHMMEM base. */
 	/* Get SHM_BEG - convert to byte address */
-	(void) DEV_GetSymbol(pDevContext->hDevObject, SHMBASENAME,
-			     &ulShmBaseVirt);
-	ulShmBaseVirt *= DSPWORDSIZE;
-	DBC_Assert(ulShmBaseVirt != 0);
+	(void)dev_get_symbol(dev_context->hdev_obj, SHMBASENAME,
+			     &ul_shm_base_virt);
+	ul_shm_base_virt *= DSPWORDSIZE;
+	DBC_ASSERT(ul_shm_base_virt != 0);
 	/* DSP Virtual address */
-	ulTLBBaseVirt = pDevContext->aTLBEntry[0].ulDspVa;
-	DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
-	ulShmOffsetVirt = ulShmBaseVirt - (ulTLBBaseVirt * DSPWORDSIZE);
+	ul_tlb_base_virt = dev_context->atlb_entry[0].ul_dsp_va;
+	DBC_ASSERT(ul_tlb_base_virt <= ul_shm_base_virt);
+	ul_shm_offset_virt =
+	    ul_shm_base_virt - (ul_tlb_base_virt * DSPWORDSIZE);
 	/* Kernel logical address */
-	ulShmBase = pDevContext->aTLBEntry[0].ulGppVa + ulShmOffsetVirt;
+	ul_shm_base = dev_context->atlb_entry[0].ul_gpp_va + ul_shm_offset_virt;
 
-	DBC_Assert(ulShmBase != 0);
+	DBC_ASSERT(ul_shm_base != 0);
 	/* 2nd wd is used as sync field */
-	dwSyncAddr = ulShmBase + SHMSYNCOFFSET;
-	 /* Write a signature into the SHM base + offset; this will
-	 * get cleared when the DSP program starts.  */
-	if ((ulShmBaseVirt == 0) || (ulShmBase == 0)) {
+	dw_sync_addr = ul_shm_base + SHMSYNCOFFSET;
+	/* Write a signature into the shm base + offset; this will
+	 * get cleared when the DSP program starts. */
+	if ((ul_shm_base_virt == 0) || (ul_shm_base == 0)) {
 		pr_err("%s: Illegal SM base\n", __func__);
 		status = DSP_EFAIL;
 	} else
-		*((volatile u32 *)dwSyncAddr) = 0xffffffff;
+		*((volatile u32 *)dw_sync_addr) = 0xffffffff;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = CFG_GetHostResources(
-			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
-		/* Assert RST1 i.e only the RST only for DSP megacell  */
-		/* HW_RST_Reset(resources.dwPrcmBase, HW_RST1_IVA2);*/
+		status = cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&resources);
+		/* Assert RST1 i.e only the RST only for DSP megacell */
+		/* hw_rst_reset(resources.dwPrcmBase, HW_RST1_IVA2); */
 		if (DSP_SUCCEEDED(status)) {
-			HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
+			hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
 			if (dsp_debug) {
-				/* Set the bootmode to self loop  */
+				/* Set the bootmode to self loop */
 				dev_dbg(bridge, "Set boot mode to self loop"
-						" for IVA2 Device\n");
-				HW_DSPSS_BootModeSet(resources.dwSysCtrlBase,
-					HW_DSPSYSC_SELFLOOPBOOT, dwDSPAddr);
+					" for IVA2 Device\n");
+				hw_dspss_boot_mode_set
+				    (resources.dw_sys_ctrl_base,
+				     HW_DSPSYSC_SELFLOOPBOOT, dwDSPAddr);
 			} else {
 				/* Set the bootmode to '0' - direct boot */
 				dev_dbg(bridge, "Set boot mode to direct boot"
-						" for IVA2 Device\n");
-				HW_DSPSS_BootModeSet(resources.dwSysCtrlBase,
-					HW_DSPSYSC_DIRECTBOOT, dwDSPAddr);
+					" for IVA2 Device\n");
+				hw_dspss_boot_mode_set
+				    (resources.dw_sys_ctrl_base,
+				     HW_DSPSYSC_DIRECTBOOT, dwDSPAddr);
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Reset and Unreset the RST2, so that BOOTADDR is copied to
 		 * IVA2 SYSC register */
-		HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+		hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
 		udelay(100);
-		HW_RST_UnReset(resources.dwPrmBase, HW_RST2_IVA2);
+		hw_rst_un_reset(resources.dw_prm_base, HW_RST2_IVA2);
 		udelay(100);
 
-		GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+		get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 		/* Disbale the DSP MMU */
-		HW_MMU_Disable(resources.dwDmmuBase);
+		hw_mmu_disable(resources.dw_dmmu_base);
 		/* Disable TWL */
-		HW_MMU_TWLDisable(resources.dwDmmuBase);
+		hw_mmu_twl_disable(resources.dw_dmmu_base);
 
 		/* Only make TLB entry if both addresses are non-zero */
-		for (iEntryNdx = 0; iEntryNdx < WMDIOCTL_NUMOFMMUTLB;
-			iEntryNdx++) {
-			if ((pDevContext->aTLBEntry[iEntryNdx].ulGppPa != 0) &&
-			   (pDevContext->aTLBEntry[iEntryNdx].ulDspVa != 0)) {
-				dev_dbg(bridge, "(proc) MMU %d GppPa:"
-				    " 0x%x DspVa 0x%x Size 0x%x\n",
-				    itmpEntryNdx,
-				    pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
-				    pDevContext->aTLBEntry[iEntryNdx].ulDspVa,
-				    pDevContext->aTLBEntry[iEntryNdx].ulSize);
-				configureDspMmu(pDevContext,
-				    pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
-				    pDevContext->aTLBEntry[iEntryNdx].ulDspVa *
-				    DSPWORDSIZE,
-				    pDevContext->aTLBEntry[iEntryNdx].ulSize,
-				    itmpEntryNdx,
-				    pDevContext->aTLBEntry[iEntryNdx].endianism,
-				    pDevContext->aTLBEntry[iEntryNdx].elemSize,
-				    pDevContext->aTLBEntry[iEntryNdx].
-				    mixedMode);
-				itmpEntryNdx++;
+		for (entry_ndx = 0; entry_ndx < WMDIOCTL_NUMOFMMUTLB;
+		     entry_ndx++) {
+			if ((dev_context->atlb_entry[entry_ndx].ul_gpp_pa != 0)
+			    && (dev_context->atlb_entry[entry_ndx].ul_dsp_va !=
+				0)) {
+				dev_dbg(bridge,
+					"(proc) MMU %d GppPa:"
+					" 0x%x DspVa 0x%x Size 0x%x\n",
+					itmp_entry_ndx,
+					dev_context->atlb_entry[entry_ndx].
+					ul_gpp_pa,
+					dev_context->atlb_entry[entry_ndx].
+					ul_dsp_va,
+					dev_context->atlb_entry[entry_ndx].
+					ul_size);
+				configure_dsp_mmu(dev_context,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  ul_gpp_pa,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  ul_dsp_va * DSPWORDSIZE,
+						  dev_context->
+						  atlb_entry[entry_ndx].ul_size,
+						  itmp_entry_ndx,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  endianism,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  elem_size,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  mixed_mode);
+				itmp_entry_ndx++;
 			}
 		}		/* end for */
 	}
 
 	/* Lock the above TLB entries and get the BIOS and load monitor timer
-	 * information*/
+	 * information */
 	if (DSP_SUCCEEDED(status)) {
-		HW_MMU_NumLockedSet(resources.dwDmmuBase, itmpEntryNdx);
-		HW_MMU_VictimNumSet(resources.dwDmmuBase, itmpEntryNdx);
-		HW_MMU_TTBSet(resources.dwDmmuBase,
-				pDevContext->pPtAttrs->L1BasePa);
-		HW_MMU_TWLEnable(resources.dwDmmuBase);
+		hw_mmu_num_locked_set(resources.dw_dmmu_base, itmp_entry_ndx);
+		hw_mmu_victim_num_set(resources.dw_dmmu_base, itmp_entry_ndx);
+		hw_mmu_ttb_set(resources.dw_dmmu_base,
+			       dev_context->pt_attrs->l1_base_pa);
+		hw_mmu_twl_enable(resources.dw_dmmu_base);
 		/* Enable the SmartIdle and AutoIdle bit for MMU_SYSCONFIG */
 
-
-		temp = __raw_readl((resources.dwDmmuBase) + 0x10);
+		temp = __raw_readl((resources.dw_dmmu_base) + 0x10);
 		temp = (temp & 0xFFFFFFEF) | 0x11;
-		__raw_writel(temp, (resources.dwDmmuBase) + 0x10);
+		__raw_writel(temp, (resources.dw_dmmu_base) + 0x10);
 
 		/* Let the DSP MMU run */
-		HW_MMU_Enable(resources.dwDmmuBase);
-
-		/* Enable the BIOS clock  */
-		(void)DEV_GetSymbol(pDevContext->hDevObject,
-				BRIDGEINIT_BIOSGPTIMER, &ulBiosGpTimer);
-		(void)DEV_GetSymbol(pDevContext->hDevObject,
-				BRIDGEINIT_LOADMON_GPTIMER,
-				&ulLoadMonitorTimer);
+		hw_mmu_enable(resources.dw_dmmu_base);
+
+		/* Enable the BIOS clock */
+		(void)dev_get_symbol(dev_context->hdev_obj,
+				     BRIDGEINIT_BIOSGPTIMER, &ul_bios_gp_timer);
+		(void)dev_get_symbol(dev_context->hdev_obj,
+				     BRIDGEINIT_LOADMON_GPTIMER,
+				     &ul_load_monitor_timer);
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		if (ulLoadMonitorTimer != 0xFFFF) {
-			uClkCmd = (BPWR_DisableClock << MBX_PM_CLK_CMDSHIFT) |
-						ulLoadMonitorTimer;
+		if (ul_load_monitor_timer != 0xFFFF) {
+			clk_cmd = (BPWR_DISABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
+			    ul_load_monitor_timer;
 
-			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+			dsp_peripheral_clk_ctrl(dev_context, &clk_cmd);
 
-			extClkId = uClkCmd & MBX_PM_CLK_IDMASK;
-			for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES;
-			     tmpIndex++) {
-				if (extClkId == BPWR_CLKID[tmpIndex]) {
-					clkIdIndex = tmpIndex;
+			ext_clk_id = clk_cmd & MBX_PM_CLK_IDMASK;
+			for (tmp_index = 0; tmp_index < MBX_PM_MAX_RESOURCES;
+			     tmp_index++) {
+				if (ext_clk_id == bpwr_clkid[tmp_index]) {
+					clk_id_index = tmp_index;
 					break;
 				}
 			}
 
-			if (clkIdIndex < MBX_PM_MAX_RESOURCES) {
+			if (clk_id_index < MBX_PM_MAX_RESOURCES) {
 				status =
-				    CLK_Set_32KHz(BPWR_Clks[clkIdIndex].funClk);
+				    clk_set32k_hz(bpwr_clks
+						  [clk_id_index].fun_clk);
 			} else {
 				status = DSP_EFAIL;
 			}
-			uClkCmd = (BPWR_EnableClock << MBX_PM_CLK_CMDSHIFT) |
-				  ulLoadMonitorTimer;
+			clk_cmd = (BPWR_ENABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
+			    ul_load_monitor_timer;
 
-			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+			dsp_peripheral_clk_ctrl(dev_context, &clk_cmd);
 
 		} else {
 			dev_dbg(bridge, "Not able to get the symbol for Load "
-				  "Monitor Timer\n");
+				"Monitor Timer\n");
 		}
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		if (ulBiosGpTimer != 0xFFFF) {
-			uClkCmd = (BPWR_DisableClock << MBX_PM_CLK_CMDSHIFT) |
-								ulBiosGpTimer;
+		if (ul_bios_gp_timer != 0xFFFF) {
+			clk_cmd = (BPWR_DISABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
+			    ul_bios_gp_timer;
 
-			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+			dsp_peripheral_clk_ctrl(dev_context, &clk_cmd);
 
-			extClkId = uClkCmd & MBX_PM_CLK_IDMASK;
+			ext_clk_id = clk_cmd & MBX_PM_CLK_IDMASK;
 
-			for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES;
-			     tmpIndex++) {
-				if (extClkId == BPWR_CLKID[tmpIndex]) {
-					clkIdIndex = tmpIndex;
+			for (tmp_index = 0; tmp_index < MBX_PM_MAX_RESOURCES;
+			     tmp_index++) {
+				if (ext_clk_id == bpwr_clkid[tmp_index]) {
+					clk_id_index = tmp_index;
 					break;
 				}
 			}
 
-			if (clkIdIndex < MBX_PM_MAX_RESOURCES) {
-				status = CLK_Set_32KHz(
-						BPWR_Clks[clkIdIndex].funClk);
+			if (clk_id_index < MBX_PM_MAX_RESOURCES) {
+				status =
+				    clk_set32k_hz(bpwr_clks
+						  [clk_id_index].fun_clk);
 			} else {
 				status = DSP_EFAIL;
 			}
 
-			uClkCmd = (BPWR_EnableClock << MBX_PM_CLK_CMDSHIFT) |
-				   ulBiosGpTimer;
+			clk_cmd = (BPWR_ENABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
+			    ul_bios_gp_timer;
 
-			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+			dsp_peripheral_clk_ctrl(dev_context, &clk_cmd);
 
 		} else {
-		dev_dbg(bridge, "Not able to get the symbol for BIOS Timer\n");
+			dev_dbg(bridge,
+				"Not able to get the symbol for BIOS Timer\n");
 		}
 	}
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Set the DSP clock rate */
-		(void)DEV_GetSymbol(pDevContext->hDevObject,
-					"_BRIDGEINIT_DSP_FREQ", &ulDspClkAddr);
+		(void)dev_get_symbol(dev_context->hdev_obj,
+				     "_BRIDGEINIT_DSP_FREQ", &ul_dsp_clk_addr);
 		/*Set Autoidle Mode for IVA2 PLL */
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwCmBase) + 0x34));
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_cm_base) + 0x34));
 		temp = (temp & 0xFFFFFFFE) | 0x1;
-		*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x34)) =
-			(u32) temp;
-		if ((unsigned int *)ulDspClkAddr != NULL) {
+		*((reg_uword32 *) ((u32) (resources.dw_cm_base) + 0x34)) =
+		    (u32) temp;
+		if ((unsigned int *)ul_dsp_clk_addr != NULL) {
 			/* Get the clock rate */
-			status = CLK_GetRate(SERVICESCLK_iva2_ck,
-				 &ulDspClkRate);
+			status = services_clk_get_rate(SERVICESCLK_IVA2_CK,
+						       &ul_dsp_clk_rate);
 			dev_dbg(bridge, "%s: DSP clock rate (KHZ): 0x%x \n",
-							__func__, ulDspClkRate);
-			(void)WMD_BRD_Write(pDevContext, (u8 *)&ulDspClkRate,
-				 ulDspClkAddr, sizeof(u32), 0);
+				__func__, ul_dsp_clk_rate);
+			(void)bridge_brd_write(dev_context,
+					       (u8 *) &ul_dsp_clk_rate,
+					       ul_dsp_clk_addr, sizeof(u32), 0);
 		}
 		/*
 		 *Enable Mailbox events and also drain any pending
@@ -642,7 +669,7 @@ static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *hDevContext,
 		if (IS_ERR(hDevContext->mbox)) {
 			hDevContext->mbox = NULL;
 			pr_err("%s: Failed to get dsp mailbox handle\n",
-								__func__);
+			       __func__);
 			status = DSP_EFAIL;
 		}
 
@@ -650,62 +677,60 @@ static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *hDevContext,
 
 	if (DSP_SUCCEEDED(status)) {
 
-		hDevContext->mbox->rxq->callback =
-						(int (*)(void *))io_mbox_msg;
+		hDevContext->mbox->rxq->callback = (int (*)(void *))io_mbox_msg;
 
-/*PM_IVA2GRPSEL_PER = 0xC0;*/
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwPerPmBase) + 0xA8));
+/*PM_IVA2GRPSEL_PER = 0xC0; */
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_per_pm_base) + 0xA8));
 		temp = (temp & 0xFFFFFF30) | 0xC0;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8)) =
-			(u32) temp;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8)) =
+		    (u32) temp;
 
-/*PM_MPUGRPSEL_PER &= 0xFFFFFF3F;*/
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwPerPmBase) + 0xA4));
+/*PM_MPUGRPSEL_PER &= 0xFFFFFF3F; */
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_per_pm_base) + 0xA4));
 		temp = (temp & 0xFFFFFF3F);
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4)) =
-			(u32) temp;
-/*CM_SLEEPDEP_PER |= 0x04;*/
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwPerBase) + 0x44));
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4)) =
+		    (u32) temp;
+/*CM_SLEEPDEP_PER |= 0x04; */
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_per_base) + 0x44));
 		temp = (temp & 0xFFFFFFFB) | 0x04;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerBase) + 0x44)) =
-			(u32) temp;
+		*((reg_uword32 *) ((u32) (resources.dw_per_base) + 0x44)) =
+		    (u32) temp;
 
-/*CM_CLKSTCTRL_IVA2 = 0x00000003 -To Allow automatic transitions*/
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwCmBase) + 0x48));
+/*CM_CLKSTCTRL_IVA2 = 0x00000003 -To Allow automatic transitions */
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_cm_base) + 0x48));
 		temp = (temp & 0xFFFFFFFC) | 0x03;
-		*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x48)) =
-			(u32) temp;
+		*((reg_uword32 *) ((u32) (resources.dw_cm_base) + 0x48)) =
+		    (u32) temp;
 
 		/* Let DSP go */
 		dev_dbg(bridge, "%s Unreset\n", __func__);
 		/* Enable DSP MMU Interrupts */
-		HW_MMU_EventEnable(resources.dwDmmuBase,
-				HW_MMU_ALL_INTERRUPTS);
+		hw_mmu_event_enable(resources.dw_dmmu_base,
+				    HW_MMU_ALL_INTERRUPTS);
 		/* release the RST1, DSP starts executing now .. */
-		HW_RST_UnReset(resources.dwPrmBase, HW_RST1_IVA2);
+		hw_rst_un_reset(resources.dw_prm_base, HW_RST1_IVA2);
 
-		dev_dbg(bridge, "Waiting for Sync @ 0x%x\n", dwSyncAddr);
+		dev_dbg(bridge, "Waiting for Sync @ 0x%x\n", dw_sync_addr);
 		dev_dbg(bridge, "DSP c_int00 Address =  0x%x\n", dwDSPAddr);
 		if (dsp_debug)
-			while (*((volatile u16 *)dwSyncAddr))
-				;
+			while (*((volatile u16 *)dw_sync_addr)) ;
 
 		/* Wait for DSP to clear word in shared memory */
 		/* Read the Location */
-		if (!WaitForStart(pDevContext, dwSyncAddr))
+		if (!wait_for_start(dev_context, dw_sync_addr))
 			status = WMD_E_TIMEOUT;
 
-		DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
-		if (hIOMgr) {
-			IO_SHMsetting(hIOMgr, SHM_OPPINFO, NULL);
-			/* Write the synchronization bit to indicate the
+		dev_get_io_mgr(dev_context->hdev_obj, &hio_mgr);
+		if (hio_mgr) {
+			io_sh_msetting(hio_mgr, SHM_OPPINFO, NULL);
+			/* mem_write the synchronization bit to indicate the
 			 * completion of OPP table update to DSP
 			 */
-			*((volatile u32 *)dwSyncAddr) = 0XCAFECAFE;
+			*((volatile u32 *)dw_sync_addr) = 0XCAFECAFE;
 
 #ifdef CONFIG_BRIDGE_WDT3
 			/* Setting default WDT timeout  */
@@ -713,83 +738,84 @@ static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *hDevContext,
 			dsp_wdt_enable(true);
 #endif
 			/* update board state */
-			pDevContext->dwBrdState = BRD_RUNNING;
-			/* (void)CHNLSM_EnableInterrupt(pDevContext);*/
+			dev_context->dw_brd_state = BRD_RUNNING;
+			/* (void)chnlsm_enable_interrupt(dev_context); */
 		} else {
 			status = DSP_EHANDLE;
-			pDevContext->dwBrdState = BRD_UNKNOWN;
+			dev_context->dw_brd_state = BRD_UNKNOWN;
 		}
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_Stop ========
+ *  ======== bridge_brd_stop ========
  *  purpose:
  *      Puts DSP in self loop.
  *
  *  Preconditions :
  *  a) None
  */
-static DSP_STATUS WMD_BRD_Stop(struct WMD_DEV_CONTEXT *hDevContext)
+static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct CFG_HOSTRES resources;
-	struct PgTableAttrs *pPtAttrs;
-	u32 dspPwrState;
-	DSP_STATUS clk_status;
-
-	if (pDevContext->dwBrdState == BRD_STOPPED)
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct cfg_hostres resources;
+	struct pg_table_attrs *pt_attrs;
+	u32 dsp_pwr_state;
+	dsp_status clk_status;
+
+	if (dev_context->dw_brd_state == BRD_STOPPED)
 		return status;
 
 	/* as per TRM, it is advised to first drive the IVA2 to 'Standby' mode,
 	 * before turning off the clocks.. This is to ensure that there are no
 	 * pending L3 or other transactons from IVA2 */
-	status = CFG_GetHostResources(
-			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return DSP_EFAIL;
 
-	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &dspPwrState);
-	if (dspPwrState != HW_PWR_STATE_OFF && hDevContext->mbox) {
-		sm_interrupt_dsp(pDevContext, MBX_PM_DSPIDLE);
+	hw_pwrst_iva2_reg_get(resources.dw_prm_base, &dsp_pwr_state);
+	if (dsp_pwr_state != HW_PWR_STATE_OFF && hDevContext->mbox) {
+		sm_interrupt_dsp(dev_context, MBX_PM_DSPIDLE);
 		mdelay(10);
-		GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+		get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 		udelay(50);
 
-		clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
+		clk_status = services_clk_disable(SERVICESCLK_IVA2_CK);
 
 		/* IVA2 is not in OFF state */
 		/* Set PM_PWSTCTRL_IVA2  to OFF */
-		HW_PWR_IVA2PowerStateSet(resources.dwPrmBase,
-					  HW_PWR_DOMAIN_DSP,
-					  HW_PWR_STATE_OFF);
+		hw_pwr_iva2_power_state_set(resources.dw_prm_base,
+					    HW_PWR_DOMAIN_DSP,
+					    HW_PWR_STATE_OFF);
 		/* Set the SW supervised state transition for Sleep */
-		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_SW_SUP_SLEEP);
+		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
+					    HW_SW_SUP_SLEEP);
 	} else {
-		clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
+		clk_status = services_clk_disable(SERVICESCLK_IVA2_CK);
 	}
 	udelay(10);
 	/* Release the Ext Base virtual Address as the next DSP Program
 	 * may have a different load address */
-	if (pDevContext->dwDspExtBaseAddr)
-		pDevContext->dwDspExtBaseAddr = 0;
+	if (dev_context->dw_dsp_ext_base_addr)
+		dev_context->dw_dsp_ext_base_addr = 0;
 
-	pDevContext->dwBrdState = BRD_STOPPED;	/* update board state */
+	dev_context->dw_brd_state = BRD_STOPPED;	/* update board state */
 
 #ifdef CONFIG_BRIDGE_WDT3
 	dsp_wdt_enable(false);
 #endif
 
 	/* This is a good place to clear the MMU page tables as well */
-	if (pDevContext->pPtAttrs) {
-		pPtAttrs = pDevContext->pPtAttrs;
-		memset((u8 *) pPtAttrs->L1BaseVa, 0x00, pPtAttrs->L1size);
-		memset((u8 *) pPtAttrs->L2BaseVa, 0x00, pPtAttrs->L2size);
-		memset((u8 *) pPtAttrs->pgInfo, 0x00,
-		       (pPtAttrs->L2NumPages * sizeof(struct PageInfo)));
+	if (dev_context->pt_attrs) {
+		pt_attrs = dev_context->pt_attrs;
+		memset((u8 *) pt_attrs->l1_base_va, 0x00, pt_attrs->l1_size);
+		memset((u8 *) pt_attrs->l2_base_va, 0x00, pt_attrs->l2_size);
+		memset((u8 *) pt_attrs->pg_info, 0x00,
+		       (pt_attrs->l2_num_pages * sizeof(struct page_info)));
 	}
 	/* Disable the mail box interrupts */
 	if (hDevContext->mbox) {
@@ -798,59 +824,59 @@ static DSP_STATUS WMD_BRD_Stop(struct WMD_DEV_CONTEXT *hDevContext)
 		hDevContext->mbox = NULL;
 	}
 
-	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
-	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
-	HW_RST_Reset(resources.dwPrmBase, HW_RST3_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST3_IVA2);
 
 	return status;
 }
 
-
 /*
- *  ======== WMD_BRD_Delete ========
+ *  ======== wmd_brd_delete ========
  *  purpose:
  *      Puts DSP in Low power mode
  *
  *  Preconditions :
  *  a) None
  */
-static DSP_STATUS WMD_BRD_Delete(struct WMD_DEV_CONTEXT *hDevContext)
+static dsp_status wmd_brd_delete(struct wmd_dev_context *hDevContext)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct CFG_HOSTRES resources;
-	struct PgTableAttrs *pPtAttrs;
-	DSP_STATUS clk_status;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct cfg_hostres resources;
+	struct pg_table_attrs *pt_attrs;
+	dsp_status clk_status;
 
-	if (pDevContext->dwBrdState == BRD_STOPPED)
+	if (dev_context->dw_brd_state == BRD_STOPPED)
 		return status;
 
 	/* as per TRM, it is advised to first drive
 	 * the IVA2 to 'Standby' mode, before turning off the clocks.. This is
 	 * to ensure that there are no pending L3 or other transactons from
 	 * IVA2 */
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return DSP_EFAIL;
 
-	status = SleepDSP(pDevContext, PWR_EMERGENCYDEEPSLEEP, NULL);
-	clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
+	status = sleep_dsp(dev_context, PWR_EMERGENCYDEEPSLEEP, NULL);
+	clk_status = services_clk_disable(SERVICESCLK_IVA2_CK);
 
 	/* Release the Ext Base virtual Address as the next DSP Program
 	 * may have a different load address */
-	if (pDevContext->dwDspExtBaseAddr)
-		pDevContext->dwDspExtBaseAddr = 0;
+	if (dev_context->dw_dsp_ext_base_addr)
+		dev_context->dw_dsp_ext_base_addr = 0;
 
-	pDevContext->dwBrdState = BRD_STOPPED;	/* update board state */
+	dev_context->dw_brd_state = BRD_STOPPED;	/* update board state */
 
 	/* This is a good place to clear the MMU page tables as well */
-	if (pDevContext->pPtAttrs) {
-		pPtAttrs = pDevContext->pPtAttrs;
-		memset((u8 *)pPtAttrs->L1BaseVa, 0x00, pPtAttrs->L1size);
-		memset((u8 *)pPtAttrs->L2BaseVa, 0x00, pPtAttrs->L2size);
-		memset((u8 *)pPtAttrs->pgInfo, 0x00,
-			(pPtAttrs->L2NumPages * sizeof(struct PageInfo)));
+	if (dev_context->pt_attrs) {
+		pt_attrs = dev_context->pt_attrs;
+		memset((u8 *) pt_attrs->l1_base_va, 0x00, pt_attrs->l1_size);
+		memset((u8 *) pt_attrs->l2_base_va, 0x00, pt_attrs->l2_size);
+		memset((u8 *) pt_attrs->pg_info, 0x00,
+		       (pt_attrs->l2_num_pages * sizeof(struct page_info)));
 	}
 	/* Disable the mail box interrupts */
 	if (hDevContext->mbox) {
@@ -859,279 +885,285 @@ static DSP_STATUS WMD_BRD_Delete(struct WMD_DEV_CONTEXT *hDevContext)
 		hDevContext->mbox = NULL;
 	}
 
-	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
-	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
-	HW_RST_Reset(resources.dwPrmBase, HW_RST3_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST3_IVA2);
 
 	return status;
 }
 
-
 /*
- *  ======== WMD_BRD_Status ========
+ *  ======== bridge_brd_status ========
  *      Returns the board status.
  */
-static DSP_STATUS WMD_BRD_Status(struct WMD_DEV_CONTEXT *hDevContext,
-				 int *pdwState)
+static dsp_status bridge_brd_status(struct wmd_dev_context *hDevContext,
+				    int *pdwState)
 {
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	*pdwState = pDevContext->dwBrdState;
+	struct wmd_dev_context *dev_context = hDevContext;
+	*pdwState = dev_context->dw_brd_state;
 	return DSP_SOK;
 }
 
 /*
- *  ======== WMD_BRD_Write ========
+ *  ======== bridge_brd_write ========
  *      Copies the buffers to DSP internal or external memory.
  */
-static DSP_STATUS WMD_BRD_Write(struct WMD_DEV_CONTEXT *hDevContext,
-				IN u8 *pbHostBuf, u32 dwDSPAddr,
-				u32 ulNumBytes, u32 ulMemType)
+static dsp_status bridge_brd_write(struct wmd_dev_context *hDevContext,
+				   IN u8 *pbHostBuf, u32 dwDSPAddr,
+				   u32 ul_num_bytes, u32 ulMemType)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
 
-	if (dwDSPAddr < pDevContext->dwDSPStartAdd) {
+	if (dwDSPAddr < dev_context->dw_dsp_start_add) {
 		status = DSP_EFAIL;
 		return status;
 	}
-	if ((dwDSPAddr - pDevContext->dwDSPStartAdd) <
-	   pDevContext->dwInternalSize) {
-		status = WriteDspData(hDevContext, pbHostBuf, dwDSPAddr,
-			 ulNumBytes, ulMemType);
+	if ((dwDSPAddr - dev_context->dw_dsp_start_add) <
+	    dev_context->dw_internal_size) {
+		status = write_dsp_data(hDevContext, pbHostBuf, dwDSPAddr,
+					ul_num_bytes, ulMemType);
 	} else {
-		status = WriteExtDspData(pDevContext, pbHostBuf, dwDSPAddr,
-					 ulNumBytes, ulMemType, false);
+		status = write_ext_dsp_data(dev_context, pbHostBuf, dwDSPAddr,
+					    ul_num_bytes, ulMemType, false);
 	}
 
 	return status;
 }
 
 /*
- *  ======== WMD_DEV_Create ========
+ *  ======== bridge_dev_create ========
  *      Creates a driver object. Puts DSP in self loop.
  */
-static DSP_STATUS WMD_DEV_Create(OUT struct WMD_DEV_CONTEXT **ppDevContext,
-				 struct DEV_OBJECT *hDevObject,
-				 IN CONST struct CFG_HOSTRES *pConfig,
-				 IN CONST struct CFG_DSPRES *pDspConfig)
+static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
+				    struct dev_object *hdev_obj,
+				    IN CONST struct cfg_hostres *pConfig,
+				    IN CONST struct cfg_dspres *pDspConfig)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = NULL;
-	s32 iEntryNdx;
-	s32 tcWordSwap;
-	u32 tcWordSwapSize = sizeof(tcWordSwap);
-	struct CFG_HOSTRES resources;
-	struct PgTableAttrs *pPtAttrs;
-	u32   pg_tbl_pa;
-	u32   pg_tbl_va;
-	u32   align_size;
-
-	 /* Allocate and initialize a data structure to contain the mini driver
-	 *  state, which becomes the context for later calls into this WMD.  */
-	pDevContext = MEM_Calloc(sizeof(struct WMD_DEV_CONTEXT), MEM_NONPAGED);
-	if (!pDevContext) {
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = NULL;
+	s32 entry_ndx;
+	s32 tc_word_swap;
+	u32 tc_word_swap_size = sizeof(tc_word_swap);
+	struct cfg_hostres resources;
+	struct pg_table_attrs *pt_attrs;
+	u32 pg_tbl_pa;
+	u32 pg_tbl_va;
+	u32 align_size;
+
+	/* Allocate and initialize a data structure to contain the mini driver
+	 *  state, which becomes the context for later calls into this WMD. */
+	dev_context = mem_calloc(sizeof(struct wmd_dev_context), MEM_NONPAGED);
+	if (!dev_context) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status)) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
 
-	pDevContext->dwDSPStartAdd = (u32)OMAP_GEM_BASE;
-	pDevContext->dwSelfLoop = (u32)NULL;
-	pDevContext->uDspPerClks = 0;
-	pDevContext->dwInternalSize = OMAP_DSP_SIZE;
+	dev_context->dw_dsp_start_add = (u32) OMAP_GEM_BASE;
+	dev_context->dw_self_loop = (u32) NULL;
+	dev_context->dsp_per_clks = 0;
+	dev_context->dw_internal_size = OMAP_DSP_SIZE;
 	/*  Clear dev context MMU table entries.
 	 *  These get set on WMD_BRD_IOCTL() call after program loaded. */
-	for (iEntryNdx = 0; iEntryNdx < WMDIOCTL_NUMOFMMUTLB; iEntryNdx++) {
-		pDevContext->aTLBEntry[iEntryNdx].ulGppPa =
-			pDevContext->aTLBEntry[iEntryNdx].ulDspVa = 0;
+	for (entry_ndx = 0; entry_ndx < WMDIOCTL_NUMOFMMUTLB; entry_ndx++) {
+		dev_context->atlb_entry[entry_ndx].ul_gpp_pa =
+		    dev_context->atlb_entry[entry_ndx].ul_dsp_va = 0;
 	}
-	pDevContext->numTLBEntries = 0;
-	pDevContext->dwDspBaseAddr = (u32)MEM_LinearAddress((void *)
-			(pConfig->dwMemBase[3]), pConfig->dwMemLength[3]);
-	if (!pDevContext->dwDspBaseAddr)
+	dev_context->num_tlb_entries = 0;
+	dev_context->dw_dsp_base_addr = (u32) MEM_LINEAR_ADDRESS((void *)
+								 (pConfig->
+								  dw_mem_base
+								  [3]),
+								 pConfig->
+								 dw_mem_length
+								 [3]);
+	if (!dev_context->dw_dsp_base_addr)
 		status = DSP_EFAIL;
 
-	pPtAttrs = MEM_Calloc(sizeof(struct PgTableAttrs), MEM_NONPAGED);
-	if (pPtAttrs != NULL) {
+	pt_attrs = mem_calloc(sizeof(struct pg_table_attrs), MEM_NONPAGED);
+	if (pt_attrs != NULL) {
 		/* Assuming that we use only DSP's memory map
 		 * until 0x4000:0000 , we would need only 1024
 		 * L1 enties i.e L1 size = 4K */
-		pPtAttrs->L1size = 0x1000;
-		align_size = pPtAttrs->L1size;
+		pt_attrs->l1_size = 0x1000;
+		align_size = pt_attrs->l1_size;
 		/* Align sizes are expected to be power of 2 */
 		/* we like to get aligned on L1 table size */
-		pg_tbl_va = (u32)MEM_AllocPhysMem(pPtAttrs->L1size,
-		    align_size, &pg_tbl_pa);
+		pg_tbl_va = (u32) mem_alloc_phys_mem(pt_attrs->l1_size,
+						     align_size, &pg_tbl_pa);
 
 		/* Check if the PA is aligned for us */
-		if ((pg_tbl_pa) & (align_size-1)) {
+		if ((pg_tbl_pa) & (align_size - 1)) {
 			/* PA not aligned to page table size ,
 			 * try with more allocation and align */
-			MEM_FreePhysMem((void *)pg_tbl_va, pg_tbl_pa,
-					pPtAttrs->L1size);
+			mem_free_phys_mem((void *)pg_tbl_va, pg_tbl_pa,
+					  pt_attrs->l1_size);
 			/* we like to get aligned on L1 table size */
-			pg_tbl_va = (u32) MEM_AllocPhysMem((pPtAttrs->L1size)*2,
-					align_size, &pg_tbl_pa);
+			pg_tbl_va =
+			    (u32) mem_alloc_phys_mem((pt_attrs->l1_size) * 2,
+						     align_size, &pg_tbl_pa);
 			/* We should be able to get aligned table now */
-			pPtAttrs->L1TblAllocPa = pg_tbl_pa;
-			pPtAttrs->L1TblAllocVa = pg_tbl_va;
-			pPtAttrs->L1TblAllocSz = pPtAttrs->L1size * 2;
+			pt_attrs->l1_tbl_alloc_pa = pg_tbl_pa;
+			pt_attrs->l1_tbl_alloc_va = pg_tbl_va;
+			pt_attrs->l1_tbl_alloc_sz = pt_attrs->l1_size * 2;
 			/* Align the PA to the next 'align'  boundary */
-			pPtAttrs->L1BasePa = ((pg_tbl_pa) + (align_size-1)) &
-				(~(align_size-1));
-			pPtAttrs->L1BaseVa = pg_tbl_va + (pPtAttrs->L1BasePa -
-				pg_tbl_pa);
+			pt_attrs->l1_base_pa =
+			    ((pg_tbl_pa) +
+			     (align_size - 1)) & (~(align_size - 1));
+			pt_attrs->l1_base_va =
+			    pg_tbl_va + (pt_attrs->l1_base_pa - pg_tbl_pa);
 		} else {
 			/* We got aligned PA, cool */
-			pPtAttrs->L1TblAllocPa = pg_tbl_pa;
-			pPtAttrs->L1TblAllocVa = pg_tbl_va;
-			pPtAttrs->L1TblAllocSz = pPtAttrs->L1size;
-			pPtAttrs->L1BasePa = pg_tbl_pa;
-			pPtAttrs->L1BaseVa = pg_tbl_va;
+			pt_attrs->l1_tbl_alloc_pa = pg_tbl_pa;
+			pt_attrs->l1_tbl_alloc_va = pg_tbl_va;
+			pt_attrs->l1_tbl_alloc_sz = pt_attrs->l1_size;
+			pt_attrs->l1_base_pa = pg_tbl_pa;
+			pt_attrs->l1_base_va = pg_tbl_va;
 		}
-		if (pPtAttrs->L1BaseVa)
-			memset((u8 *)pPtAttrs->L1BaseVa, 0x00,
-				pPtAttrs->L1size);
+		if (pt_attrs->l1_base_va)
+			memset((u8 *) pt_attrs->l1_base_va, 0x00,
+			       pt_attrs->l1_size);
 
 		/* number of L2 page tables = DMM pool used + SHMMEM +EXTMEM +
 		 * L4 pages */
-		pPtAttrs->L2NumPages = ((DMMPOOLSIZE >> 20) + 6);
-		pPtAttrs->L2size = HW_MMU_COARSE_PAGE_SIZE *
-				   pPtAttrs->L2NumPages;
-		align_size = 4; /* Make it u32 aligned  */
+		pt_attrs->l2_num_pages = ((DMMPOOLSIZE >> 20) + 6);
+		pt_attrs->l2_size = HW_MMU_COARSE_PAGE_SIZE *
+		    pt_attrs->l2_num_pages;
+		align_size = 4;	/* Make it u32 aligned */
 		/* we like to get aligned on L1 table size */
-		pg_tbl_va = (u32)MEM_AllocPhysMem(pPtAttrs->L2size,
-			    align_size, &pg_tbl_pa);
-		pPtAttrs->L2TblAllocPa = pg_tbl_pa;
-		pPtAttrs->L2TblAllocVa = pg_tbl_va;
-		pPtAttrs->L2TblAllocSz = pPtAttrs->L2size;
-		pPtAttrs->L2BasePa = pg_tbl_pa;
-		pPtAttrs->L2BaseVa = pg_tbl_va;
-
-		if (pPtAttrs->L2BaseVa)
-			memset((u8 *)pPtAttrs->L2BaseVa, 0x00,
-				pPtAttrs->L2size);
-
-		pPtAttrs->pgInfo = MEM_Calloc(pPtAttrs->L2NumPages *
-				sizeof(struct PageInfo), MEM_NONPAGED);
-		dev_dbg(bridge, "L1 pa %x, va %x, size %x\n L2 pa %x, va "
-			 "%x, size %x\n", pPtAttrs->L1BasePa,
-			 pPtAttrs->L1BaseVa, pPtAttrs->L1size,
-			 pPtAttrs->L2BasePa, pPtAttrs->L2BaseVa,
-			 pPtAttrs->L2size);
-		dev_dbg(bridge, "pPtAttrs %p L2 NumPages %x pgInfo %p\n",
-			 pPtAttrs, pPtAttrs->L2NumPages, pPtAttrs->pgInfo);
+		pg_tbl_va = (u32) mem_alloc_phys_mem(pt_attrs->l2_size,
+						     align_size, &pg_tbl_pa);
+		pt_attrs->l2_tbl_alloc_pa = pg_tbl_pa;
+		pt_attrs->l2_tbl_alloc_va = pg_tbl_va;
+		pt_attrs->l2_tbl_alloc_sz = pt_attrs->l2_size;
+		pt_attrs->l2_base_pa = pg_tbl_pa;
+		pt_attrs->l2_base_va = pg_tbl_va;
+
+		if (pt_attrs->l2_base_va)
+			memset((u8 *) pt_attrs->l2_base_va, 0x00,
+			       pt_attrs->l2_size);
+
+		pt_attrs->pg_info = mem_calloc(pt_attrs->l2_num_pages *
+					       sizeof(struct page_info),
+					       MEM_NONPAGED);
+		dev_dbg(bridge,
+			"L1 pa %x, va %x, size %x\n L2 pa %x, va "
+			"%x, size %x\n", pt_attrs->l1_base_pa,
+			pt_attrs->l1_base_va, pt_attrs->l1_size,
+			pt_attrs->l2_base_pa, pt_attrs->l2_base_va,
+			pt_attrs->l2_size);
+		dev_dbg(bridge, "pt_attrs %p L2 NumPages %x pg_info %p\n",
+			pt_attrs, pt_attrs->l2_num_pages, pt_attrs->pg_info);
 	}
-	if ((pPtAttrs != NULL) && (pPtAttrs->L1BaseVa != 0) &&
-	   (pPtAttrs->L2BaseVa != 0) && (pPtAttrs->pgInfo != NULL))
-		pDevContext->pPtAttrs = pPtAttrs;
+	if ((pt_attrs != NULL) && (pt_attrs->l1_base_va != 0) &&
+	    (pt_attrs->l2_base_va != 0) && (pt_attrs->pg_info != NULL))
+		dev_context->pt_attrs = pt_attrs;
 	else
 		status = DSP_EMEMORY;
 
-	if (DSP_SUCCEEDED(status))
-		status = SYNC_InitializeCS(&pPtAttrs->hCSObj);
-
 	if (DSP_SUCCEEDED(status)) {
-		/* Set the Endianism Register */ /* Need to set this */
+		spin_lock_init(&pt_attrs->pg_lock);
+		/* Set the Endianism Register *//* Need to set this */
 		/* Retrieve the TC u16 SWAP Option */
-		status = REG_GetValue(TCWORDSWAP, (u8 *)&tcWordSwap,
-				      &tcWordSwapSize);
+		status = reg_get_value(TCWORDSWAP, (u8 *) &tc_word_swap,
+				       &tc_word_swap_size);
 		/* Save the value */
-		pDevContext->tcWordSwapOn = tcWordSwap;
+		dev_context->tc_word_swap_on = tc_word_swap;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Set the Clock Divisor for the DSP module */
 		udelay(5);
 		/* 24xx-Linux MMU address is obtained from the host
 		 * resources struct */
-		pDevContext->dwDSPMmuBase = resources.dwDmmuBase;
+		dev_context->dw_dsp_mmu_base = resources.dw_dmmu_base;
 #ifdef CONFIG_BRIDGE_WDT3
-		pDevContext->wdt3_base = resources.dwWdTimerDspBase;
+		dev_context->wdt3_base = resources.dw_wd_timer_dsp_base;
 #endif
 	}
 	if (DSP_SUCCEEDED(status)) {
-		pDevContext->hDevObject = hDevObject;
-		pDevContext->ulIntMask = 0;
+		dev_context->hdev_obj = hdev_obj;
+		dev_context->ul_int_mask = 0;
 		/* Store current board state. */
-		pDevContext->dwBrdState = BRD_STOPPED;
-		/* Return this ptr to our device state to the WCD for storage:*/
-		*ppDevContext = pDevContext;
+		dev_context->dw_brd_state = BRD_STOPPED;
+		/* Return ptr to our device state to the WCD for storage */
+		*ppDevContext = dev_context;
 	} else {
-		if (pPtAttrs != NULL) {
-			if (pPtAttrs->hCSObj)
-				SYNC_DeleteCS(pPtAttrs->hCSObj);
-
-			kfree(pPtAttrs->pgInfo);
-
-			if (pPtAttrs->L2TblAllocVa) {
-				MEM_FreePhysMem((void *)pPtAttrs->L2TblAllocVa,
-						pPtAttrs->L2TblAllocPa,
-						pPtAttrs->L2TblAllocSz);
+		if (pt_attrs != NULL) {
+			kfree(pt_attrs->pg_info);
+
+			if (pt_attrs->l2_tbl_alloc_va) {
+				mem_free_phys_mem((void *)
+						  pt_attrs->l2_tbl_alloc_va,
+						  pt_attrs->l2_tbl_alloc_pa,
+						  pt_attrs->l2_tbl_alloc_sz);
 			}
-			if (pPtAttrs->L1TblAllocVa) {
-				MEM_FreePhysMem((void *)pPtAttrs->L1TblAllocVa,
-						pPtAttrs->L1TblAllocPa,
-						pPtAttrs->L1TblAllocSz);
+			if (pt_attrs->l1_tbl_alloc_va) {
+				mem_free_phys_mem((void *)
+						  pt_attrs->l1_tbl_alloc_va,
+						  pt_attrs->l1_tbl_alloc_pa,
+						  pt_attrs->l1_tbl_alloc_sz);
 			}
 		}
-		kfree(pPtAttrs);
-		kfree(pDevContext);
+		kfree(pt_attrs);
+		kfree(dev_context);
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_DEV_Ctrl ========
+ *  ======== bridge_dev_ctrl ========
  *      Receives device specific commands.
  */
-static DSP_STATUS WMD_DEV_Ctrl(struct WMD_DEV_CONTEXT *pDevContext, u32 dwCmd,
-				IN OUT void *pArgs)
+static dsp_status bridge_dev_ctrl(struct wmd_dev_context *dev_context,
+				  u32 dw_cmd, IN OUT void *pargs)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMDIOCTL_EXTPROC *paExtProc = (struct WMDIOCTL_EXTPROC *)pArgs;
+	dsp_status status = DSP_SOK;
+	struct wmdioctl_extproc *pa_ext_proc = (struct wmdioctl_extproc *)pargs;
 	s32 ndx;
 
-	switch (dwCmd) {
+	switch (dw_cmd) {
 	case WMDIOCTL_CHNLREAD:
 		break;
 	case WMDIOCTL_CHNLWRITE:
 		break;
 	case WMDIOCTL_SETMMUCONFIG:
 		/* store away dsp-mmu setup values for later use */
-		for (ndx = 0; ndx < WMDIOCTL_NUMOFMMUTLB; ndx++, paExtProc++)
-			pDevContext->aTLBEntry[ndx] = *paExtProc;
+		for (ndx = 0; ndx < WMDIOCTL_NUMOFMMUTLB; ndx++, pa_ext_proc++)
+			dev_context->atlb_entry[ndx] = *pa_ext_proc;
 		break;
 	case WMDIOCTL_DEEPSLEEP:
 	case WMDIOCTL_EMERGENCYSLEEP:
 		/* Currently only DSP Idle is supported Need to update for
 		 * later releases */
-		status = SleepDSP(pDevContext, PWR_DEEPSLEEP, pArgs);
+		status = sleep_dsp(dev_context, PWR_DEEPSLEEP, pargs);
 		break;
 	case WMDIOCTL_WAKEUP:
-		status = WakeDSP(pDevContext, pArgs);
+		status = wake_dsp(dev_context, pargs);
 		break;
 	case WMDIOCTL_CLK_CTRL:
 		status = DSP_SOK;
 		/* Looking For Baseport Fix for Clocks */
-		status = DSPPeripheralClkCtrl(pDevContext, pArgs);
+		status = dsp_peripheral_clk_ctrl(dev_context, pargs);
 		break;
 	case WMDIOCTL_PWR_HIBERNATE:
-		status = handle_hibernation_fromDSP(pDevContext);
+		status = handle_hibernation_from_dsp(dev_context);
 		break;
 	case WMDIOCTL_PRESCALE_NOTIFY:
-		status = PreScale_DSP(pDevContext, pArgs);
+		status = pre_scale_dsp(dev_context, pargs);
 		break;
 	case WMDIOCTL_POSTSCALE_NOTIFY:
-		status = PostScale_DSP(pDevContext, pArgs);
+		status = post_scale_dsp(dev_context, pargs);
 		break;
 	case WMDIOCTL_CONSTRAINT_REQUEST:
-		status = handle_constraints_set(pDevContext, pArgs);
+		status = handle_constraints_set(dev_context, pargs);
 		break;
 	default:
 		status = DSP_EFAIL;
@@ -1141,112 +1173,115 @@ static DSP_STATUS WMD_DEV_Ctrl(struct WMD_DEV_CONTEXT *pDevContext, u32 dwCmd,
 }
 
 /*
- *  ======== WMD_DEV_Destroy ========
+ *  ======== bridge_dev_destroy ========
  *      Destroys the driver object.
  */
-static DSP_STATUS WMD_DEV_Destroy(struct WMD_DEV_CONTEXT *hDevContext)
+static dsp_status bridge_dev_destroy(struct wmd_dev_context *hDevContext)
 {
-	struct PgTableAttrs *pPtAttrs;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = (struct WMD_DEV_CONTEXT *)
-						hDevContext;
+	struct pg_table_attrs *pt_attrs;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = (struct wmd_dev_context *)
+	    hDevContext;
 
 	/* It should never happen */
 	if (!hDevContext)
 		return DSP_EHANDLE;
 
 	/* first put the device to stop state */
-	WMD_BRD_Delete(pDevContext);
-	if (pDevContext->pPtAttrs) {
-		pPtAttrs = pDevContext->pPtAttrs;
-		if (pPtAttrs->hCSObj)
-			SYNC_DeleteCS(pPtAttrs->hCSObj);
-
-		kfree(pPtAttrs->pgInfo);
-
-		if (pPtAttrs->L2TblAllocVa) {
-			MEM_FreePhysMem((void *)pPtAttrs->L2TblAllocVa,
-					pPtAttrs->L2TblAllocPa, pPtAttrs->
-					L2TblAllocSz);
+	wmd_brd_delete(dev_context);
+	if (dev_context->pt_attrs) {
+		pt_attrs = dev_context->pt_attrs;
+		kfree(pt_attrs->pg_info);
+
+		if (pt_attrs->l2_tbl_alloc_va) {
+			mem_free_phys_mem((void *)pt_attrs->l2_tbl_alloc_va,
+					  pt_attrs->l2_tbl_alloc_pa,
+					  pt_attrs->l2_tbl_alloc_sz);
 		}
-		if (pPtAttrs->L1TblAllocVa) {
-			MEM_FreePhysMem((void *)pPtAttrs->L1TblAllocVa,
-					pPtAttrs->L1TblAllocPa, pPtAttrs->
-					L1TblAllocSz);
+		if (pt_attrs->l1_tbl_alloc_va) {
+			mem_free_phys_mem((void *)pt_attrs->l1_tbl_alloc_va,
+					  pt_attrs->l1_tbl_alloc_pa,
+					  pt_attrs->l1_tbl_alloc_sz);
 		}
-		kfree(pPtAttrs);
+		kfree(pt_attrs);
 
 	}
 	/* Free the driver's device context: */
-	kfree((void *) hDevContext);
+	kfree((void *)hDevContext);
 	return status;
 }
 
-static DSP_STATUS WMD_BRD_MemCopy(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 ulDspDestAddr, u32 ulDspSrcAddr,
-				  u32 ulNumBytes, u32 ulMemType)
+static dsp_status bridge_brd_mem_copy(struct wmd_dev_context *hDevContext,
+				   u32 ulDspDestAddr, u32 ulDspSrcAddr,
+				   u32 ul_num_bytes, u32 ulMemType)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 srcAddr = ulDspSrcAddr;
-	u32 destAddr = ulDspDestAddr;
-	u32 copyBytes = 0;
-	u32 totalBytes = ulNumBytes;
-	u8 hostBuf[BUFFERSIZE];
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	while ((totalBytes > 0) && DSP_SUCCEEDED(status)) {
-		copyBytes = totalBytes > BUFFERSIZE ? BUFFERSIZE : totalBytes;
+	dsp_status status = DSP_SOK;
+	u32 src_addr = ulDspSrcAddr;
+	u32 dest_addr = ulDspDestAddr;
+	u32 copy_bytes = 0;
+	u32 total_bytes = ul_num_bytes;
+	u8 host_buf[BUFFERSIZE];
+	struct wmd_dev_context *dev_context = hDevContext;
+	while ((total_bytes > 0) && DSP_SUCCEEDED(status)) {
+		copy_bytes =
+		    total_bytes > BUFFERSIZE ? BUFFERSIZE : total_bytes;
 		/* Read from External memory */
-		status = ReadExtDspData(hDevContext, hostBuf, srcAddr,
-					copyBytes, ulMemType);
+		status = read_ext_dsp_data(hDevContext, host_buf, src_addr,
+					   copy_bytes, ulMemType);
 		if (DSP_SUCCEEDED(status)) {
-			if (destAddr < (pDevContext->dwDSPStartAdd +
-			    pDevContext->dwInternalSize)) {
+			if (dest_addr < (dev_context->dw_dsp_start_add +
+					 dev_context->dw_internal_size)) {
 				/* Write to Internal memory */
-				status = WriteDspData(hDevContext, hostBuf,
-					 destAddr, copyBytes, ulMemType);
+				status = write_dsp_data(hDevContext, host_buf,
+							dest_addr, copy_bytes,
+							ulMemType);
 			} else {
 				/* Write to External memory */
-				status = WriteExtDspData(hDevContext, hostBuf,
-					 destAddr, copyBytes, ulMemType, false);
+				status =
+				    write_ext_dsp_data(hDevContext, host_buf,
+						       dest_addr, copy_bytes,
+						       ulMemType, false);
 			}
 		}
-		totalBytes -= copyBytes;
-		srcAddr += copyBytes;
-		destAddr += copyBytes;
+		total_bytes -= copy_bytes;
+		src_addr += copy_bytes;
+		dest_addr += copy_bytes;
 	}
 	return status;
 }
 
-/* Mem Write does not halt the DSP to write unlike WMD_BRD_Write */
-static DSP_STATUS WMD_BRD_MemWrite(struct WMD_DEV_CONTEXT *hDevContext,
-				   IN u8 *pbHostBuf, u32 dwDSPAddr,
-				   u32 ulNumBytes, u32 ulMemType)
+/* Mem Write does not halt the DSP to write unlike bridge_brd_write */
+static dsp_status bridge_brd_mem_write(struct wmd_dev_context *hDevContext,
+				    IN u8 *pbHostBuf, u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	u32 ulRemainBytes = 0;
-	u32 ulBytes = 0;
-	ulRemainBytes = ulNumBytes;
-	while (ulRemainBytes > 0 && DSP_SUCCEEDED(status)) {
-		ulBytes =
-			ulRemainBytes > BUFFERSIZE ? BUFFERSIZE : ulRemainBytes;
-		if (dwDSPAddr < (pDevContext->dwDSPStartAdd +
-		    pDevContext->dwInternalSize)) {
-			status = WriteDspData(hDevContext, pbHostBuf, dwDSPAddr,
-					      ulBytes, ulMemType);
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	u32 ul_remain_bytes = 0;
+	u32 ul_bytes = 0;
+	ul_remain_bytes = ul_num_bytes;
+	while (ul_remain_bytes > 0 && DSP_SUCCEEDED(status)) {
+		ul_bytes =
+		    ul_remain_bytes > BUFFERSIZE ? BUFFERSIZE : ul_remain_bytes;
+		if (dwDSPAddr < (dev_context->dw_dsp_start_add +
+				 dev_context->dw_internal_size)) {
+			status =
+			    write_dsp_data(hDevContext, pbHostBuf, dwDSPAddr,
+					   ul_bytes, ulMemType);
 		} else {
-			status = WriteExtDspData(hDevContext, pbHostBuf,
-				 dwDSPAddr, ulBytes, ulMemType, true);
+			status = write_ext_dsp_data(hDevContext, pbHostBuf,
+						    dwDSPAddr, ul_bytes,
+						    ulMemType, true);
 		}
-		ulRemainBytes -= ulBytes;
-		dwDSPAddr += ulBytes;
-		pbHostBuf = pbHostBuf + ulBytes;
+		ul_remain_bytes -= ul_bytes;
+		dwDSPAddr += ul_bytes;
+		pbHostBuf = pbHostBuf + ul_bytes;
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_MemMap ========
+ *  ======== bridge_brd_mem_map ========
  *      This function maps MPU buffer to the DSP address space. It performs
  *  linear to physical address translation if required. It translates each
  *  page since linear addresses can be physically non-contiguous
@@ -1254,59 +1289,60 @@ static DSP_STATUS WMD_BRD_MemWrite(struct WMD_DEV_CONTEXT *hDevContext,
  *
  *  TODO: Disable MMU while updating the page tables (but that'll stall DSP)
  */
-static DSP_STATUS WMD_BRD_MemMap(struct WMD_DEV_CONTEXT *hDevContext,
-				 u32 ulMpuAddr, u32 ulVirtAddr,
-				 u32 ulNumBytes, u32 ulMapAttr)
+static dsp_status bridge_brd_mem_map(struct wmd_dev_context *hDevContext,
+				  u32 ul_mpu_addr, u32 ulVirtAddr,
+				  u32 ul_num_bytes, u32 ul_map_attr)
 {
 	u32 attrs;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct HW_MMUMapAttrs_t hwAttrs;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct hw_mmu_map_attrs_t hw_attrs;
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
 	u32 write = 0;
-	u32 numUsrPgs = 0;
-	struct page *mappedPage, *pg;
-	s32 pgNum;
+	u32 num_usr_pgs = 0;
+	struct page *mapped_page, *pg;
+	s32 pg_num;
 	u32 va = ulVirtAddr;
 	struct task_struct *curr_task = current;
-	u32 pgI = 0;
-	u32 mpuAddr, pa;
-
-	dev_dbg(bridge, "%s hDevCtxt %p, pa %x, va %x, size %x, ulMapAttr %x\n",
-				__func__, hDevContext, ulMpuAddr, ulVirtAddr,
-				ulNumBytes, ulMapAttr);
-	if (ulNumBytes == 0)
+	u32 pg_i = 0;
+	u32 mpu_addr, pa;
+
+	dev_dbg(bridge,
+		"%s hDevCtxt %p, pa %x, va %x, size %x, ul_map_attr %x\n",
+		__func__, hDevContext, ul_mpu_addr, ulVirtAddr, ul_num_bytes,
+		ul_map_attr);
+	if (ul_num_bytes == 0)
 		return DSP_EINVALIDARG;
 
-	if (ulMapAttr & DSP_MAP_DIR_MASK) {
-		attrs = ulMapAttr;
+	if (ul_map_attr & DSP_MAP_DIR_MASK) {
+		attrs = ul_map_attr;
 	} else {
 		/* Assign default attributes */
-		attrs = ulMapAttr | (DSP_MAPVIRTUALADDR | DSP_MAPELEMSIZE16);
+		attrs = ul_map_attr | (DSP_MAPVIRTUALADDR | DSP_MAPELEMSIZE16);
 	}
 	/* Take mapping properties */
 	if (attrs & DSP_MAPBIGENDIAN)
-		hwAttrs.endianism = HW_BIG_ENDIAN;
+		hw_attrs.endianism = HW_BIG_ENDIAN;
 	else
-		hwAttrs.endianism = HW_LITTLE_ENDIAN;
+		hw_attrs.endianism = HW_LITTLE_ENDIAN;
 
-	hwAttrs.mixedSize = (enum HW_MMUMixedSize_t)
-			       ((attrs & DSP_MAPMIXEDELEMSIZE) >> 2);
-	/* Ignore elementSize if mixedSize is enabled */
-	if (hwAttrs.mixedSize == 0) {
+	hw_attrs.mixed_size = (enum hw_mmu_mixed_size_t)
+	    ((attrs & DSP_MAPMIXEDELEMSIZE) >> 2);
+	/* Ignore element_size if mixed_size is enabled */
+	if (hw_attrs.mixed_size == 0) {
 		if (attrs & DSP_MAPELEMSIZE8) {
 			/* Size is 8 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_8BIT;
+			hw_attrs.element_size = HW_ELEM_SIZE8BIT;
 		} else if (attrs & DSP_MAPELEMSIZE16) {
 			/* Size is 16 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_16BIT;
+			hw_attrs.element_size = HW_ELEM_SIZE16BIT;
 		} else if (attrs & DSP_MAPELEMSIZE32) {
 			/* Size is 32 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_32BIT;
+			hw_attrs.element_size = HW_ELEM_SIZE32BIT;
 		} else if (attrs & DSP_MAPELEMSIZE64) {
 			/* Size is 64 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_64BIT;
+			hw_attrs.element_size = HW_ELEM_SIZE64BIT;
 		} else {
 			/*
 			 * Mixedsize isn't enabled, so size can't be
@@ -1316,70 +1352,72 @@ static DSP_STATUS WMD_BRD_MemMap(struct WMD_DEV_CONTEXT *hDevContext,
 		}
 	}
 	if (attrs & DSP_MAPDONOTLOCK)
-		hwAttrs.donotlockmpupage = 1;
+		hw_attrs.donotlockmpupage = 1;
 	else
-		hwAttrs.donotlockmpupage = 0;
+		hw_attrs.donotlockmpupage = 0;
 
 	if (attrs & DSP_MAPVMALLOCADDR) {
-		return MemMapVmalloc(hDevContext, ulMpuAddr, ulVirtAddr,
-				       ulNumBytes, &hwAttrs);
+		return mem_map_vmalloc(hDevContext, ul_mpu_addr, ulVirtAddr,
+				       ul_num_bytes, &hw_attrs);
 	}
 	/*
 	 * Do OS-specific user-va to pa translation.
 	 * Combine physically contiguous regions to reduce TLBs.
-	 * Pass the translated pa to PteUpdate.
+	 * Pass the translated pa to pte_update.
 	 */
 	if ((attrs & DSP_MAPPHYSICALADDR)) {
-		status = PteUpdate(pDevContext, ulMpuAddr, ulVirtAddr,
-			 ulNumBytes, &hwAttrs);
+		status = pte_update(dev_context, ul_mpu_addr, ulVirtAddr,
+				    ul_num_bytes, &hw_attrs);
 		goto func_cont;
 	}
 
 	/*
-	 * Important Note: ulMpuAddr is mapped from user application process
+	 * Important Note: ul_mpu_addr is mapped from user application process
 	 * to current process - it must lie completely within the current
 	 * virtual memory address space in order to be of use to us here!
 	 */
 	down_read(&mm->mmap_sem);
-	vma = find_vma(mm, ulMpuAddr);
+	vma = find_vma(mm, ul_mpu_addr);
 	if (vma)
-		dev_dbg(bridge, "VMAfor UserBuf: ulMpuAddr=%x, ulNumBytes=%x, "
-				"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n",
-				ulMpuAddr, ulNumBytes, vma->vm_start,
-				vma->vm_end, vma->vm_flags);
+		dev_dbg(bridge,
+			"VMAfor UserBuf: ul_mpu_addr=%x, ul_num_bytes=%x, "
+			"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n", ul_mpu_addr,
+			ul_num_bytes, vma->vm_start, vma->vm_end,
+			vma->vm_flags);
 
 	/*
 	 * It is observed that under some circumstances, the user buffer is
 	 * spread across several VMAs. So loop through and check if the entire
 	 * user buffer is covered
 	 */
-	while ((vma) && (ulMpuAddr + ulNumBytes > vma->vm_end)) {
+	while ((vma) && (ul_mpu_addr + ul_num_bytes > vma->vm_end)) {
 		/* jump to the next VMA region */
 		vma = find_vma(mm, vma->vm_end + 1);
-		dev_dbg(bridge, "VMA for UserBuf ulMpuAddr=%x ulNumBytes=%x, "
-				"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n",
-				ulMpuAddr, ulNumBytes, vma->vm_start,
-				vma->vm_end, vma->vm_flags);
+		dev_dbg(bridge,
+			"VMA for UserBuf ul_mpu_addr=%x ul_num_bytes=%x, "
+			"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n", ul_mpu_addr,
+			ul_num_bytes, vma->vm_start, vma->vm_end,
+			vma->vm_flags);
 	}
 	if (!vma) {
 		pr_err("%s: Failed to get VMA region for 0x%x (%d)\n",
-					__func__, ulMpuAddr, ulNumBytes);
+		       __func__, ul_mpu_addr, ul_num_bytes);
 		status = DSP_EINVALIDARG;
 		up_read(&mm->mmap_sem);
 		goto func_cont;
 	}
 
 	if (vma->vm_flags & VM_IO) {
-		numUsrPgs =  ulNumBytes / PG_SIZE_4K;
-		mpuAddr = ulMpuAddr;
+		num_usr_pgs = ul_num_bytes / PG_SIZE4K;
+		mpu_addr = ul_mpu_addr;
 
 		/* Get the physical addresses for user buffer */
-		for (pgI = 0; pgI < numUsrPgs; pgI++) {
-			pa = user_va2pa(mm, mpuAddr);
+		for (pg_i = 0; pg_i < num_usr_pgs; pg_i++) {
+			pa = user_va2_pa(mm, mpu_addr);
 			if (!pa) {
 				status = DSP_EFAIL;
 				pr_err("DSPBRIDGE: VM_IO mapping physical"
-						"address is invalid\n");
+				       "address is invalid\n");
 				break;
 			}
 			if (pfn_valid(__phys_to_pfn(pa))) {
@@ -1390,48 +1428,47 @@ static DSP_STATUS WMD_BRD_MemMap(struct WMD_DEV_CONTEXT *hDevContext,
 					bad_page_dump(pa, pg);
 				}
 			}
-			status = PteSet(pDevContext->pPtAttrs, pa,
-					va, HW_PAGE_SIZE_4KB, &hwAttrs);
+			status = pte_set(dev_context->pt_attrs, pa,
+					 va, HW_PAGE_SIZE4KB, &hw_attrs);
 			if (DSP_FAILED(status))
 				break;
 
-			va += HW_PAGE_SIZE_4KB;
-			mpuAddr += HW_PAGE_SIZE_4KB;
-			pa += HW_PAGE_SIZE_4KB;
+			va += HW_PAGE_SIZE4KB;
+			mpu_addr += HW_PAGE_SIZE4KB;
+			pa += HW_PAGE_SIZE4KB;
 		}
 	} else {
-		numUsrPgs =  ulNumBytes / PG_SIZE_4K;
+		num_usr_pgs = ul_num_bytes / PG_SIZE4K;
 		if (vma->vm_flags & (VM_WRITE | VM_MAYWRITE))
 			write = 1;
 
-		for (pgI = 0; pgI < numUsrPgs; pgI++) {
-			pgNum = get_user_pages(curr_task, mm, ulMpuAddr, 1,
-						write, 1, &mappedPage, NULL);
-			if (pgNum > 0) {
-				if (page_count(mappedPage) < 1) {
+		for (pg_i = 0; pg_i < num_usr_pgs; pg_i++) {
+			pg_num = get_user_pages(curr_task, mm, ul_mpu_addr, 1,
+						write, 1, &mapped_page, NULL);
+			if (pg_num > 0) {
+				if (page_count(mapped_page) < 1) {
 					pr_err("Bad page count after doing"
-							"get_user_pages on"
-							"user buffer\n");
-					bad_page_dump(page_to_phys(mappedPage),
-								mappedPage);
+					       "get_user_pages on"
+					       "user buffer\n");
+					bad_page_dump(page_to_phys(mapped_page),
+						      mapped_page);
 				}
-				status = PteSet(pDevContext->pPtAttrs,
-					page_to_phys(mappedPage), va,
-					HW_PAGE_SIZE_4KB, &hwAttrs);
+				status = pte_set(dev_context->pt_attrs,
+						 page_to_phys(mapped_page), va,
+						 HW_PAGE_SIZE4KB, &hw_attrs);
 				if (DSP_FAILED(status))
 					break;
 
-				va += HW_PAGE_SIZE_4KB;
-				ulMpuAddr += HW_PAGE_SIZE_4KB;
+				va += HW_PAGE_SIZE4KB;
+				ul_mpu_addr += HW_PAGE_SIZE4KB;
 			} else {
 				pr_err("DSPBRIDGE: get_user_pages FAILED,"
-						"MPU addr = 0x%x,"
-						"vma->vm_flags = 0x%lx,"
-						"get_user_pages Err"
-						"Value = %d, Buffer"
-						"size=0x%x\n", ulMpuAddr,
-						vma->vm_flags, pgNum,
-						ulNumBytes);
+				       "MPU addr = 0x%x,"
+				       "vma->vm_flags = 0x%lx,"
+				       "get_user_pages Err"
+				       "Value = %d, Buffer"
+				       "size=0x%x\n", ul_mpu_addr,
+				       vma->vm_flags, pg_num, ul_num_bytes);
 				status = DSP_EFAIL;
 				break;
 			}
@@ -1447,203 +1484,205 @@ func_cont:
 		 * Roll out the mapped pages incase it failed in middle of
 		 * mapping
 		 */
-		if (pgI) {
-			WMD_BRD_MemUnMap(pDevContext, ulVirtAddr,
-						(pgI * PG_SIZE_4K));
+		if (pg_i) {
+			bridge_brd_mem_un_map(dev_context, ulVirtAddr,
+					   (pg_i * PG_SIZE4K));
 		}
 		status = DSP_EFAIL;
 	}
 	/*
 	 * In any case, flush the TLB
-	 * This is called from here instead from PteUpdate to avoid unnecessary
+	 * This is called from here instead from pte_update to avoid unnecessary
 	 * repetition while mapping non-contiguous physical regions of a virtual
 	 * region
 	 */
-	flush_all(pDevContext);
+	flush_all(dev_context);
 	dev_dbg(bridge, "%s status %x\n", __func__, status);
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_MemUnMap ========
+ *  ======== bridge_brd_mem_un_map ========
  *      Invalidate the PTEs for the DSP VA block to be unmapped.
  *
  *      PTEs of a mapped memory block are contiguous in any page table
  *      So, instead of looking up the PTE address for every 4K block,
  *      we clear consecutive PTEs until we unmap all the bytes
  */
-static DSP_STATUS WMD_BRD_MemUnMap(struct WMD_DEV_CONTEXT *hDevContext,
-				   u32 ulVirtAddr, u32 ulNumBytes)
+static dsp_status bridge_brd_mem_un_map(struct wmd_dev_context *hDevContext,
+				     u32 ulVirtAddr, u32 ul_num_bytes)
 {
-	u32 L1BaseVa;
-	u32 L2BaseVa;
-	u32 L2BasePa;
-	u32 L2PageNum;
-	u32 pteVal;
-	u32 pteSize;
-	u32 pteCount;
-	u32 pteAddrL1;
-	u32 pteAddrL2 = 0;
-	u32 remBytes;
-	u32 remBytesL2;
-	u32 vaCurr;
+	u32 l1_base_va;
+	u32 l2_base_va;
+	u32 l2_base_pa;
+	u32 l2_page_num;
+	u32 pte_val;
+	u32 pte_size;
+	u32 pte_count;
+	u32 pte_addr_l1;
+	u32 pte_addr_l2 = 0;
+	u32 rem_bytes;
+	u32 rem_bytes_l2;
+	u32 va_curr;
 	struct page *pg = NULL;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct PgTableAttrs *pt = pDevContext->pPtAttrs;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct pg_table_attrs *pt = dev_context->pt_attrs;
 	u32 temp;
-	u32 pAddr;
-	u32 numof4KPages = 0;
-
-	vaCurr = ulVirtAddr;
-	remBytes = ulNumBytes;
-	remBytesL2 = 0;
-	L1BaseVa = pt->L1BaseVa;
-	pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, vaCurr);
-	dev_dbg(bridge, "%s hDevContext %p, va %x, NumBytes %x L1BaseVa %x, "
-			"pteAddrL1 %x\n", __func__, hDevContext, ulVirtAddr,
-			ulNumBytes, L1BaseVa, pteAddrL1);
-
-	while (remBytes && (DSP_SUCCEEDED(status))) {
-		u32 vaCurrOrig = vaCurr;
+	u32 paddr;
+	u32 numof4k_pages = 0;
+
+	va_curr = ulVirtAddr;
+	rem_bytes = ul_num_bytes;
+	rem_bytes_l2 = 0;
+	l1_base_va = pt->l1_base_va;
+	pte_addr_l1 = hw_mmu_pte_addr_l1(l1_base_va, va_curr);
+	dev_dbg(bridge, "%s hDevContext %p, va %x, NumBytes %x l1_base_va %x, "
+		"pte_addr_l1 %x\n", __func__, hDevContext, ulVirtAddr,
+		ul_num_bytes, l1_base_va, pte_addr_l1);
+
+	while (rem_bytes && (DSP_SUCCEEDED(status))) {
+		u32 va_curr_orig = va_curr;
 		/* Find whether the L1 PTE points to a valid L2 PT */
-		pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, vaCurr);
-		pteVal = *(u32 *)pteAddrL1;
-		pteSize = HW_MMU_PteSizeL1(pteVal);
+		pte_addr_l1 = hw_mmu_pte_addr_l1(l1_base_va, va_curr);
+		pte_val = *(u32 *) pte_addr_l1;
+		pte_size = hw_mmu_pte_size_l1(pte_val);
 
-		if (pteSize != HW_MMU_COARSE_PAGE_SIZE)
+		if (pte_size != HW_MMU_COARSE_PAGE_SIZE)
 			goto skip_coarse_page;
 
 		/*
 		 * Get the L2 PA from the L1 PTE, and find
 		 * corresponding L2 VA
 		 */
-		L2BasePa = HW_MMU_PteCoarseL1(pteVal);
-		L2BaseVa = L2BasePa - pt->L2BasePa + pt->L2BaseVa;
-		L2PageNum = (L2BasePa - pt->L2BasePa) / HW_MMU_COARSE_PAGE_SIZE;
+		l2_base_pa = hw_mmu_pte_coarse_l1(pte_val);
+		l2_base_va = l2_base_pa - pt->l2_base_pa + pt->l2_base_va;
+		l2_page_num =
+		    (l2_base_pa - pt->l2_base_pa) / HW_MMU_COARSE_PAGE_SIZE;
 		/*
 		 * Find the L2 PTE address from which we will start
 		 * clearing, the number of PTEs to be cleared on this
 		 * page, and the size of VA space that needs to be
 		 * cleared on this L2 page
 		 */
-		pteAddrL2 = HW_MMU_PteAddrL2(L2BaseVa, vaCurr);
-		pteCount = pteAddrL2 & (HW_MMU_COARSE_PAGE_SIZE - 1);
-		pteCount = (HW_MMU_COARSE_PAGE_SIZE - pteCount) / sizeof(u32);
-		if (remBytes < (pteCount * PG_SIZE_4K))
-			pteCount = remBytes / PG_SIZE_4K;
-		remBytesL2 = pteCount * PG_SIZE_4K;
+		pte_addr_l2 = hw_mmu_pte_addr_l2(l2_base_va, va_curr);
+		pte_count = pte_addr_l2 & (HW_MMU_COARSE_PAGE_SIZE - 1);
+		pte_count = (HW_MMU_COARSE_PAGE_SIZE - pte_count) / sizeof(u32);
+		if (rem_bytes < (pte_count * PG_SIZE4K))
+			pte_count = rem_bytes / PG_SIZE4K;
+		rem_bytes_l2 = pte_count * PG_SIZE4K;
 
 		/*
 		 * Unmap the VA space on this L2 PT. A quicker way
-		 * would be to clear pteCount entries starting from
-		 * pteAddrL2. However, below code checks that we don't
+		 * would be to clear pte_count entries starting from
+		 * pte_addr_l2. However, below code checks that we don't
 		 * clear invalid entries or less than 64KB for a 64KB
 		 * entry. Similar checking is done for L1 PTEs too
 		 * below
 		 */
-		while (remBytesL2 && (DSP_SUCCEEDED(status))) {
-			pteVal = *(u32 *)pteAddrL2;
-			pteSize = HW_MMU_PteSizeL2(pteVal);
-			/* vaCurr aligned to pteSize? */
-			if (pteSize == 0 || remBytesL2 < pteSize ||
-						vaCurr & (pteSize - 1)) {
+		while (rem_bytes_l2 && (DSP_SUCCEEDED(status))) {
+			pte_val = *(u32 *) pte_addr_l2;
+			pte_size = hw_mmu_pte_size_l2(pte_val);
+			/* va_curr aligned to pte_size? */
+			if (pte_size == 0 || rem_bytes_l2 < pte_size ||
+			    va_curr & (pte_size - 1)) {
 				status = DSP_EFAIL;
 				break;
 			}
 
 			/* Collect Physical addresses from VA */
-			pAddr = (pteVal & ~(pteSize - 1));
-			if (pteSize == HW_PAGE_SIZE_64KB)
-				numof4KPages = 16;
+			paddr = (pte_val & ~(pte_size - 1));
+			if (pte_size == HW_PAGE_SIZE64KB)
+				numof4k_pages = 16;
 			else
-				numof4KPages = 1;
+				numof4k_pages = 1;
 			temp = 0;
-			while (temp++ < numof4KPages) {
-				if (!pfn_valid(__phys_to_pfn(pAddr))) {
-					pAddr += HW_PAGE_SIZE_4KB;
+			while (temp++ < numof4k_pages) {
+				if (!pfn_valid(__phys_to_pfn(paddr))) {
+					paddr += HW_PAGE_SIZE4KB;
 					continue;
 				}
-				pg = phys_to_page(pAddr);
+				pg = phys_to_page(paddr);
 				if (page_count(pg) < 1) {
 					pr_info("DSPBRIDGE: UNMAP function: "
 						"COUNT 0 FOR PA 0x%x, size = "
-						"0x%x\n", pAddr, ulNumBytes);
-					bad_page_dump(pAddr, pg);
+						"0x%x\n", paddr, ul_num_bytes);
+					bad_page_dump(paddr, pg);
 				} else {
 					SetPageDirty(pg);
 					page_cache_release(pg);
 				}
-				pAddr += HW_PAGE_SIZE_4KB;
+				paddr += HW_PAGE_SIZE4KB;
 			}
-			if (HW_MMU_PteClear(pteAddrL2, vaCurr, pteSize)
-							 == RET_FAIL) {
+			if (hw_mmu_pte_clear(pte_addr_l2, va_curr, pte_size)
+			    == RET_FAIL) {
 				status = DSP_EFAIL;
 				goto EXIT_LOOP;
 			}
 
 			status = DSP_SOK;
-			remBytesL2 -= pteSize;
-			vaCurr += pteSize;
-			pteAddrL2 += (pteSize >> 12) * sizeof(u32);
+			rem_bytes_l2 -= pte_size;
+			va_curr += pte_size;
+			pte_addr_l2 += (pte_size >> 12) * sizeof(u32);
 		}
-		SYNC_EnterCS(pt->hCSObj);
-		if (remBytesL2 == 0) {
-			pt->pgInfo[L2PageNum].numEntries -= pteCount;
-			if (pt->pgInfo[L2PageNum].numEntries == 0) {
+		spin_lock(&pt->pg_lock);
+		if (rem_bytes_l2 == 0) {
+			pt->pg_info[l2_page_num].num_entries -= pte_count;
+			if (pt->pg_info[l2_page_num].num_entries == 0) {
 				/*
 				 * Clear the L1 PTE pointing to the L2 PT
 				 */
-				if (HW_MMU_PteClear(L1BaseVa, vaCurrOrig,
-					    HW_MMU_COARSE_PAGE_SIZE) == RET_OK)
+				if (hw_mmu_pte_clear(l1_base_va, va_curr_orig,
+						     HW_MMU_COARSE_PAGE_SIZE) ==
+				    RET_OK)
 					status = DSP_SOK;
 				else {
 					status = DSP_EFAIL;
-					SYNC_LeaveCS(pt->hCSObj);
+					spin_unlock(&pt->pg_lock);
 					goto EXIT_LOOP;
 				}
 			}
-			remBytes -= pteCount * PG_SIZE_4K;
+			rem_bytes -= pte_count * PG_SIZE4K;
 		} else
 			status = DSP_EFAIL;
 
-		SYNC_LeaveCS(pt->hCSObj);
+		spin_unlock(&pt->pg_lock);
 		continue;
 skip_coarse_page:
-		/* vaCurr aligned to pteSize? */
-		/* pteSize = 1 MB or 16 MB */
-		if (pteSize == 0 || remBytes < pteSize ||
-						 vaCurr & (pteSize - 1)) {
+		/* va_curr aligned to pte_size? */
+		/* pte_size = 1 MB or 16 MB */
+		if (pte_size == 0 || rem_bytes < pte_size ||
+		    va_curr & (pte_size - 1)) {
 			status = DSP_EFAIL;
 			break;
 		}
 
-		if (pteSize == HW_PAGE_SIZE_1MB)
-			numof4KPages = 256;
+		if (pte_size == HW_PAGE_SIZE1MB)
+			numof4k_pages = 256;
 		else
-			numof4KPages = 4096;
+			numof4k_pages = 4096;
 		temp = 0;
 		/* Collect Physical addresses from VA */
-		pAddr = (pteVal & ~(pteSize - 1));
-		while (temp++ < numof4KPages) {
-			if (pfn_valid(__phys_to_pfn(pAddr))) {
-				pg = phys_to_page(pAddr);
+		paddr = (pte_val & ~(pte_size - 1));
+		while (temp++ < numof4k_pages) {
+			if (pfn_valid(__phys_to_pfn(paddr))) {
+				pg = phys_to_page(paddr);
 				if (page_count(pg) < 1) {
 					pr_info("DSPBRIDGE: UNMAP function: "
 						"COUNT 0 FOR PA 0x%x, size = "
-						"0x%x\n", pAddr, ulNumBytes);
-					bad_page_dump(pAddr, pg);
+						"0x%x\n", paddr, ul_num_bytes);
+					bad_page_dump(paddr, pg);
 				} else {
 					SetPageDirty(pg);
 					page_cache_release(pg);
 				}
 			}
-			pAddr += HW_PAGE_SIZE_4KB;
+			paddr += HW_PAGE_SIZE4KB;
 		}
-		if (HW_MMU_PteClear(L1BaseVa, vaCurr, pteSize) == RET_OK) {
+		if (hw_mmu_pte_clear(l1_base_va, va_curr, pte_size) == RET_OK) {
 			status = DSP_SOK;
-			remBytes -= pteSize;
-			vaCurr += pteSize;
+			rem_bytes -= pte_size;
+			va_curr += pte_size;
 		} else {
 			status = DSP_EFAIL;
 			goto EXIT_LOOP;
@@ -1654,20 +1693,21 @@ skip_coarse_page:
 	 * get flushed
 	 */
 EXIT_LOOP:
-	flush_all(pDevContext);
-	dev_dbg(bridge, "%s: vaCurr %x, pteAddrL1 %x pteAddrL2 %x remBytes %x,"
-		" remBytesL2 %x status %x\n", __func__, vaCurr, pteAddrL1,
-		pteAddrL2, remBytes, remBytesL2, status);
+	flush_all(dev_context);
+	dev_dbg(bridge,
+		"%s: va_curr %x, pte_addr_l1 %x pte_addr_l2 %x rem_bytes %x,"
+		" rem_bytes_l2 %x status %x\n", __func__, va_curr, pte_addr_l1,
+		pte_addr_l2, rem_bytes, rem_bytes_l2, status);
 	return status;
 }
 
 /*
- *  ======== user_va2pa ========
+ *  ======== user_va2_pa ========
  *  Purpose:
  *      This function walks through the Linux page tables to convert a userland
  *      virtual address to physical address
  */
-static u32 user_va2pa(struct mm_struct *mm, u32 address)
+static u32 user_va2_pa(struct mm_struct *mm, u32 address)
 {
 	pgd_t *pgd;
 	pmd_t *pmd;
@@ -1689,40 +1729,42 @@ static u32 user_va2pa(struct mm_struct *mm, u32 address)
 	return 0;
 }
 
-
 /*
- *  ======== PteUpdate ========
+ *  ======== pte_update ========
  *      This function calculates the optimum page-aligned addresses and sizes
  *      Caller must pass page-aligned values
  */
-static DSP_STATUS PteUpdate(struct WMD_DEV_CONTEXT *hDevContext, u32 pa,
-			    u32 va, u32 size,
-			    struct HW_MMUMapAttrs_t *mapAttrs)
+static dsp_status pte_update(struct wmd_dev_context *hDevContext, u32 pa,
+			     u32 va, u32 size,
+			     struct hw_mmu_map_attrs_t *map_attrs)
 {
 	u32 i;
-	u32 allBits;
-	u32 paCurr = pa;
-	u32 vaCurr = va;
-	u32 numBytes = size;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	DSP_STATUS status = DSP_SOK;
-	u32 pgSize[] = { HW_PAGE_SIZE_16MB, HW_PAGE_SIZE_1MB,
-			   HW_PAGE_SIZE_64KB, HW_PAGE_SIZE_4KB };
-
-	while (numBytes && DSP_SUCCEEDED(status)) {
+	u32 all_bits;
+	u32 pa_curr = pa;
+	u32 va_curr = va;
+	u32 num_bytes = size;
+	struct wmd_dev_context *dev_context = hDevContext;
+	dsp_status status = DSP_SOK;
+	u32 page_size[] = { HW_PAGE_SIZE16MB, HW_PAGE_SIZE1MB,
+		HW_PAGE_SIZE64KB, HW_PAGE_SIZE4KB
+	};
+
+	while (num_bytes && DSP_SUCCEEDED(status)) {
 		/* To find the max. page size with which both PA & VA are
 		 * aligned */
-		allBits = paCurr | vaCurr;
+		all_bits = pa_curr | va_curr;
 
 		for (i = 0; i < 4; i++) {
-			if ((numBytes >= pgSize[i]) && ((allBits &
-			   (pgSize[i] - 1)) == 0)) {
-				status = PteSet(pDevContext->pPtAttrs, paCurr,
-						vaCurr, pgSize[i], mapAttrs);
-				paCurr += pgSize[i];
-				vaCurr += pgSize[i];
-				numBytes -= pgSize[i];
-				 /* Don't try smaller sizes. Hopefully we have
+			if ((num_bytes >= page_size[i]) && ((all_bits &
+							     (page_size[i] -
+							      1)) == 0)) {
+				status =
+				    pte_set(dev_context->pt_attrs, pa_curr,
+					    va_curr, page_size[i], map_attrs);
+				pa_curr += page_size[i];
+				va_curr += page_size[i];
+				num_bytes -= page_size[i];
+				/* Don't try smaller sizes. Hopefully we have
 				 * reached an address aligned to a bigger page
 				 * size */
 				break;
@@ -1734,63 +1776,67 @@ static DSP_STATUS PteUpdate(struct WMD_DEV_CONTEXT *hDevContext, u32 pa,
 }
 
 /*
- *  ======== PteSet ========
+ *  ======== pte_set ========
  *      This function calculates PTE address (MPU virtual) to be updated
  *      It also manages the L2 page tables
  */
-static DSP_STATUS PteSet(struct PgTableAttrs *pt, u32 pa, u32 va,
-			 u32 size, struct HW_MMUMapAttrs_t *attrs)
+static dsp_status pte_set(struct pg_table_attrs *pt, u32 pa, u32 va,
+			  u32 size, struct hw_mmu_map_attrs_t *attrs)
 {
 	u32 i;
-	u32 pteVal;
-	u32 pteAddrL1;
-	u32 pteSize;
-	u32 pgTblVa;      /* Base address of the PT that will be updated */
-	u32 L1BaseVa;
+	u32 pte_val;
+	u32 pte_addr_l1;
+	u32 pte_size;
+	/* Base address of the PT that will be updated */
+	u32 pg_tbl_va;
+	u32 l1_base_va;
 	/* Compiler warns that the next three variables might be used
 	 * uninitialized in this function. Doesn't seem so. Working around,
-	 * anyways.  */
-	u32 L2BaseVa = 0;
-	u32 L2BasePa = 0;
-	u32 L2PageNum = 0;
-	DSP_STATUS status = DSP_SOK;
-
-	L1BaseVa = pt->L1BaseVa;
-	pgTblVa = L1BaseVa;
-	if ((size == HW_PAGE_SIZE_64KB) || (size == HW_PAGE_SIZE_4KB)) {
+	 * anyways. */
+	u32 l2_base_va = 0;
+	u32 l2_base_pa = 0;
+	u32 l2_page_num = 0;
+	dsp_status status = DSP_SOK;
+
+	l1_base_va = pt->l1_base_va;
+	pg_tbl_va = l1_base_va;
+	if ((size == HW_PAGE_SIZE64KB) || (size == HW_PAGE_SIZE4KB)) {
 		/* Find whether the L1 PTE points to a valid L2 PT */
-		pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, va);
-		if (pteAddrL1 <= (pt->L1BaseVa + pt->L1size)) {
-			pteVal = *(u32 *)pteAddrL1;
-			pteSize = HW_MMU_PteSizeL1(pteVal);
+		pte_addr_l1 = hw_mmu_pte_addr_l1(l1_base_va, va);
+		if (pte_addr_l1 <= (pt->l1_base_va + pt->l1_size)) {
+			pte_val = *(u32 *) pte_addr_l1;
+			pte_size = hw_mmu_pte_size_l1(pte_val);
 		} else {
 			return DSP_EFAIL;
 		}
-		SYNC_EnterCS(pt->hCSObj);
-		if (pteSize == HW_MMU_COARSE_PAGE_SIZE) {
+		spin_lock(&pt->pg_lock);
+		if (pte_size == HW_MMU_COARSE_PAGE_SIZE) {
 			/* Get the L2 PA from the L1 PTE, and find
 			 * corresponding L2 VA */
-			L2BasePa = HW_MMU_PteCoarseL1(pteVal);
-			L2BaseVa = L2BasePa - pt->L2BasePa + pt->L2BaseVa;
-			L2PageNum = (L2BasePa - pt->L2BasePa) /
-				    HW_MMU_COARSE_PAGE_SIZE;
-		} else if (pteSize == 0) {
+			l2_base_pa = hw_mmu_pte_coarse_l1(pte_val);
+			l2_base_va =
+			    l2_base_pa - pt->l2_base_pa + pt->l2_base_va;
+			l2_page_num =
+			    (l2_base_pa -
+			     pt->l2_base_pa) / HW_MMU_COARSE_PAGE_SIZE;
+		} else if (pte_size == 0) {
 			/* L1 PTE is invalid. Allocate a L2 PT and
 			 * point the L1 PTE to it */
 			/* Find a free L2 PT. */
-			for (i = 0; (i < pt->L2NumPages) &&
-			    (pt->pgInfo[i].numEntries != 0); i++)
-				;;
-			if (i < pt->L2NumPages) {
-				L2PageNum = i;
-				L2BasePa = pt->L2BasePa + (L2PageNum *
-					   HW_MMU_COARSE_PAGE_SIZE);
-				L2BaseVa = pt->L2BaseVa + (L2PageNum *
-					   HW_MMU_COARSE_PAGE_SIZE);
+			for (i = 0; (i < pt->l2_num_pages) &&
+			     (pt->pg_info[i].num_entries != 0); i++) ;;
+			if (i < pt->l2_num_pages) {
+				l2_page_num = i;
+				l2_base_pa = pt->l2_base_pa + (l2_page_num *
+						HW_MMU_COARSE_PAGE_SIZE);
+				l2_base_va = pt->l2_base_va + (l2_page_num *
+						HW_MMU_COARSE_PAGE_SIZE);
 				/* Endianness attributes are ignored for
 				 * HW_MMU_COARSE_PAGE_SIZE */
-				status = HW_MMU_PteSet(L1BaseVa, L2BasePa, va,
-					 HW_MMU_COARSE_PAGE_SIZE, attrs);
+				status =
+				    hw_mmu_pte_set(l1_base_va, l2_base_pa, va,
+						   HW_MMU_COARSE_PAGE_SIZE,
+						   attrs);
 			} else {
 				status = DSP_EMEMORY;
 			}
@@ -1800,92 +1846,95 @@ static DSP_STATUS PteSet(struct PgTableAttrs *pt, u32 pa, u32 va,
 			status = DSP_EFAIL;
 		}
 		if (DSP_SUCCEEDED(status)) {
-			pgTblVa = L2BaseVa;
-			if (size == HW_PAGE_SIZE_64KB)
-				pt->pgInfo[L2PageNum].numEntries += 16;
+			pg_tbl_va = l2_base_va;
+			if (size == HW_PAGE_SIZE64KB)
+				pt->pg_info[l2_page_num].num_entries += 16;
 			else
-				pt->pgInfo[L2PageNum].numEntries++;
+				pt->pg_info[l2_page_num].num_entries++;
 			dev_dbg(bridge, "PTE: L2 BaseVa %x, BasePa %x, PageNum "
-					"%x, numEntries %x\n", L2BaseVa,
-					L2BasePa, L2PageNum,
-					pt->pgInfo[L2PageNum].numEntries);
+				"%x, num_entries %x\n", l2_base_va,
+				l2_base_pa, l2_page_num,
+				pt->pg_info[l2_page_num].num_entries);
 		}
-		SYNC_LeaveCS(pt->hCSObj);
+		spin_unlock(&pt->pg_lock);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		dev_dbg(bridge, "PTE: pgTblVa %x, pa %x, va %x, size %x\n",
-							pgTblVa, pa, va, size);
-		dev_dbg(bridge, "PTE: endianism %x, elementSize %x, "
-					"mixedSize %x\n", attrs->endianism,
-					attrs->elementSize, attrs->mixedSize);
-		status = HW_MMU_PteSet(pgTblVa, pa, va, size, attrs);
+		dev_dbg(bridge, "PTE: pg_tbl_va %x, pa %x, va %x, size %x\n",
+			pg_tbl_va, pa, va, size);
+		dev_dbg(bridge, "PTE: endianism %x, element_size %x, "
+			"mixed_size %x\n", attrs->endianism,
+			attrs->element_size, attrs->mixed_size);
+		status = hw_mmu_pte_set(pg_tbl_va, pa, va, size, attrs);
 	}
 
 	return status;
 }
 
 /* Memory map kernel VA -- memory allocated with vmalloc */
-static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *pDevContext,
-				u32 ulMpuAddr, u32 ulVirtAddr, u32 ulNumBytes,
-				struct HW_MMUMapAttrs_t *hwAttrs)
+static dsp_status mem_map_vmalloc(struct wmd_dev_context *dev_context,
+				  u32 ul_mpu_addr, u32 ulVirtAddr,
+				  u32 ul_num_bytes,
+				  struct hw_mmu_map_attrs_t *hw_attrs)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct page *pPage[1];
+	dsp_status status = DSP_SOK;
+	struct page *page[1];
 	u32 i;
-	u32 paCurr;
-	u32 paNext;
-	u32 vaCurr;
-	u32 sizeCurr;
-	u32 numPages;
+	u32 pa_curr;
+	u32 pa_next;
+	u32 va_curr;
+	u32 size_curr;
+	u32 num_pages;
 	u32 pa;
-	u32 numOf4KPages;
+	u32 num_of4k_pages;
 	u32 temp = 0;
 
 	/*
 	 * Do Kernel va to pa translation.
 	 * Combine physically contiguous regions to reduce TLBs.
-	 * Pass the translated pa to PteUpdate.
+	 * Pass the translated pa to pte_update.
 	 */
-	numPages = ulNumBytes / PAGE_SIZE; /* PAGE_SIZE = OS page size */
+	num_pages = ul_num_bytes / PAGE_SIZE;	/* PAGE_SIZE = OS page size */
 	i = 0;
-	vaCurr = ulMpuAddr;
-	pPage[0] = vmalloc_to_page((void *)vaCurr);
-	paNext = page_to_phys(pPage[0]);
-	while (DSP_SUCCEEDED(status) && (i < numPages)) {
+	va_curr = ul_mpu_addr;
+	page[0] = vmalloc_to_page((void *)va_curr);
+	pa_next = page_to_phys(page[0]);
+	while (DSP_SUCCEEDED(status) && (i < num_pages)) {
 		/*
-		 * Reuse paNext from the previous iteraion to avoid
+		 * Reuse pa_next from the previous iteraion to avoid
 		 * an extra va2pa call
 		 */
-		paCurr = paNext;
-		sizeCurr = PAGE_SIZE;
+		pa_curr = pa_next;
+		size_curr = PAGE_SIZE;
 		/*
 		 * If the next page is physically contiguous,
 		 * map it with the current one by increasing
 		 * the size of the region to be mapped
 		 */
-		while (++i < numPages) {
-			pPage[0] = vmalloc_to_page((void *)(vaCurr + sizeCurr));
-			paNext = page_to_phys(pPage[0]);
+		while (++i < num_pages) {
+			page[0] =
+			    vmalloc_to_page((void *)(va_curr + size_curr));
+			pa_next = page_to_phys(page[0]);
 
-			if (paNext == (paCurr + sizeCurr))
-				sizeCurr += PAGE_SIZE;
+			if (pa_next == (pa_curr + size_curr))
+				size_curr += PAGE_SIZE;
 			else
 				break;
 
 		}
-		if (paNext == 0) {
+		if (pa_next == 0) {
 			status = DSP_EMEMORY;
 			break;
 		}
-		pa = paCurr;
-		numOf4KPages = sizeCurr / HW_PAGE_SIZE_4KB;
-		while (temp++ < numOf4KPages) {
+		pa = pa_curr;
+		num_of4k_pages = size_curr / HW_PAGE_SIZE4KB;
+		while (temp++ < num_of4k_pages) {
 			get_page(phys_to_page(pa));
-			pa += HW_PAGE_SIZE_4KB;
+			pa += HW_PAGE_SIZE4KB;
 		}
-		status = PteUpdate(pDevContext, paCurr, ulVirtAddr +
-				  (vaCurr - ulMpuAddr), sizeCurr, hwAttrs);
-		vaCurr += sizeCurr;
+		status = pte_update(dev_context, pa_curr, ulVirtAddr +
+				    (va_curr - ul_mpu_addr), size_curr,
+				    hw_attrs);
+		va_curr += size_curr;
 	}
 	/* Don't propogate Linux or HW status to upper layers */
 	if (DSP_SUCCEEDED(status))
@@ -1895,48 +1944,49 @@ static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *pDevContext,
 
 	/*
 	 * In any case, flush the TLB
-	 * This is called from here instead from PteUpdate to avoid unnecessary
+	 * This is called from here instead from pte_update to avoid unnecessary
 	 * repetition while mapping non-contiguous physical regions of a virtual
 	 * region
 	 */
-	flush_all(pDevContext);
+	flush_all(dev_context);
 	dev_dbg(bridge, "%s status %x\n", __func__, status);
 	return status;
 }
 
 /*
- *  ======== configureDspMmu ========
+ *  ======== configure_dsp_mmu ========
  *      Make DSP MMU page table entries.
  */
-void configureDspMmu(struct WMD_DEV_CONTEXT *pDevContext, u32 dataBasePhys,
-		    u32 dspBaseVirt, u32 sizeInBytes, s32 nEntryStart,
-		    enum HW_Endianism_t endianism,
-		    enum HW_ElementSize_t elemSize,
-		    enum HW_MMUMixedSize_t mixedSize)
+void configure_dsp_mmu(struct wmd_dev_context *dev_context, u32 dataBasePhys,
+		       u32 dspBaseVirt, u32 sizeInBytes, s32 nEntryStart,
+		       enum hw_endianism_t endianism,
+		       enum hw_element_size_t elem_size,
+		       enum hw_mmu_mixed_size_t mixed_size)
 {
-	struct HW_MMUMapAttrs_t mapAttrs = { endianism, elemSize, mixedSize };
+	struct hw_mmu_map_attrs_t map_attrs =
+	    { endianism, elem_size, mixed_size };
 
-	DBC_Require(sizeInBytes > 0);
+	DBC_REQUIRE(sizeInBytes > 0);
 	dev_dbg(bridge, "%s: entry %x pa %x, va %x, bytes %x endianism %x, "
-			"elemSize %x, mixedSize %x", __func__, nEntryStart,
-			dataBasePhys, dspBaseVirt, sizeInBytes, endianism,
-			elemSize, mixedSize);
+		"elem_size %x, mixed_size %x", __func__, nEntryStart,
+		dataBasePhys, dspBaseVirt, sizeInBytes, endianism,
+		elem_size, mixed_size);
 
-	HW_MMU_TLBAdd(pDevContext->dwDSPMmuBase, dataBasePhys,
-				dspBaseVirt, sizeInBytes, nEntryStart,
-				&mapAttrs, HW_SET, HW_SET);
+	hw_mmu_tlb_add(dev_context->dw_dsp_mmu_base, dataBasePhys,
+		       dspBaseVirt, sizeInBytes, nEntryStart,
+		       &map_attrs, HW_SET, HW_SET);
 }
 
 /*
- *  ======== WaitForStart ========
+ *  ======== wait_for_start ========
  *      Wait for the singal from DSP that it has started, or time out.
  */
-bool WaitForStart(struct WMD_DEV_CONTEXT *pDevContext, u32 dwSyncAddr)
+bool wait_for_start(struct wmd_dev_context *dev_context, u32 dw_sync_addr)
 {
 	u16 timeout = TIHELEN_ACKTIMEOUT;
 
 	/*  Wait for response from board */
-	while (*((volatile u16 *)dwSyncAddr) && --timeout)
+	while (*((volatile u16 *)dw_sync_addr) && --timeout)
 		udelay(10);
 
 	/*  If timed out: return FALSE */
diff --git a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
index a1eb448..f21eeba 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
@@ -52,27 +52,27 @@
 #ifdef CONFIG_PM
 extern s32 dsp_test_sleepstate;
 #endif
-extern struct MAILBOX_CONTEXT mboxsetting;
+extern struct mailbox_context mboxsetting;
 
 /*
  *  ======== handle_constraints_set ========
  *  	Sets new DSP constraint
  */
-DSP_STATUS handle_constraints_set(struct WMD_DEV_CONTEXT *pDevContext,
-				  IN void *pArgs)
+dsp_status handle_constraints_set(struct wmd_dev_context *dev_context,
+				  IN void *pargs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 opp_idx;
 	struct dspbridge_platform_data *pdata =
-		omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 
 	/* pick up the opp index */
-	opp_idx = *(((u32 *)(pArgs)) + 1);
+	opp_idx = *(((u32 *) (pargs)) + 1);
 
 	/* Sanity check to ensure things are fine */
 	if (!opp_idx || (opp_idx > pdata->dsp_num_speeds)) {
 		pr_err("%s: DSP requested for an invalid OPP %d Vs %d->%d!\n",
-			__func__, opp_idx, 1, pdata->dsp_num_speeds);
+		       __func__, opp_idx, 1, pdata->dsp_num_speeds);
 		return DSP_EINVALIDARG;
 	}
 	/* Read the target value requested by DSP  */
@@ -80,44 +80,45 @@ DSP_STATUS handle_constraints_set(struct WMD_DEV_CONTEXT *pDevContext,
 
 	/* Set the new opp value */
 	if (pdata->dsp_set_min_opp)
-		(*pdata->dsp_set_min_opp)(opp_idx);
+		(*pdata->dsp_set_min_opp) (opp_idx);
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 	return DSP_SOK;
 }
 
 /*
- *  ======== handle_hibernation_fromDSP ========
+ *  ======== handle_hibernation_from_dsp ========
  *  	Handle Hibernation requested from DSP
  */
-DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext)
+dsp_status handle_hibernation_from_dsp(struct wmd_dev_context *dev_context)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 #ifdef CONFIG_PM
 	u16 timeout = PWRSTST_TIMEOUT / 10;
-	struct CFG_HOSTRES resources;
-	enum HW_PwrState_t pwrState;
+	struct cfg_hostres resources;
+	enum hw_pwr_state_t pwr_state;
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 opplevel;
-	struct IO_MGR *hIOMgr;
+	struct io_mgr *hio_mgr;
 	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 #endif
 
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return status;
 
-	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-			    &pwrState);
+	hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
+			      &pwr_state);
 	/* Wait for DSP to move into OFF state */
-	while ((pwrState != HW_PWR_STATE_OFF) && --timeout) {
+	while ((pwr_state != HW_PWR_STATE_OFF) && --timeout) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP OFF mode interrupted\n");
 			return DSP_EFAIL;
 		}
-		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-				    &pwrState);
+		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
+				      &pwr_state);
 	}
 	if (timeout == 0) {
 		pr_err("%s: Timed out waiting for DSP off mode\n", __func__);
@@ -126,10 +127,10 @@ DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext)
 	} else {
 
 		/* Save mailbox settings */
-		omap_mbox_save_ctx(pDevContext->mbox);
+		omap_mbox_save_ctx(dev_context->mbox);
 
 		/* Turn off DSP Peripheral clocks and DSP Load monitor timer */
-		status = DSP_PeripheralClocks_Disable(pDevContext, NULL);
+		status = dsp_peripheral_clocks_disable(dev_context, NULL);
 #ifdef CONFIG_BRIDGE_WDT3
 		/*
 		 * Disable WDT clocks and ISR on DSP commanded
@@ -141,19 +142,19 @@ DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext)
 
 		if (DSP_SUCCEEDED(status)) {
 			/* Update the Bridger Driver state */
-			pDevContext->dwBrdState = BRD_DSP_HIBERNATION;
+			dev_context->dw_brd_state = BRD_DSP_HIBERNATION;
 #ifdef CONFIG_BRIDGE_DVFS
-			DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
-			if (!hIOMgr)
+			dev_get_io_mgr(dev_context->hdev_obj, &hio_mgr);
+			if (!hio_mgr)
 				return DSP_EHANDLE;
-			IO_SHMsetting(hIOMgr, SHM_GETOPP, &opplevel);
+			io_sh_msetting(hio_mgr, SHM_GETOPP, &opplevel);
 
 			/*
 			 * Set the OPP to low level before moving to OFF
 			 * mode
 			 */
 			if (pdata->dsp_set_min_opp)
-				(*pdata->dsp_set_min_opp)(VDD1_OPP1);
+				(*pdata->dsp_set_min_opp) (VDD1_OPP1);
 			status = DSP_SOK;
 #endif /* CONFIG_BRIDGE_DVFS */
 		}
@@ -163,51 +164,49 @@ DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext)
 }
 
 /*
- *  ======== SleepDSP ========
+ *  ======== sleep_dsp ========
  *  	Put DSP in low power consuming state.
  */
-DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwCmd,
-		   IN void *pArgs)
+dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
+		     IN void *pargs)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 #ifdef CONFIG_PM
-	struct CFG_HOSTRES resources;
+	struct cfg_hostres resources;
 #ifdef CONFIG_BRIDGE_NTFY_PWRERR
-	struct DEH_MGR *hDehMgr;
+	struct deh_mgr *hdeh_mgr;
 #endif /* CONFIG_BRIDGE_NTFY_PWRERR */
 	u16 timeout = PWRSTST_TIMEOUT / 10;
-	enum HW_PwrState_t pwrState, targetPwrState;
+	enum hw_pwr_state_t pwr_state, target_pwr_state;
 
 	/* Check if sleep code is valid */
-	if ((dwCmd != PWR_DEEPSLEEP) && (dwCmd != PWR_EMERGENCYDEEPSLEEP))
+	if ((dw_cmd != PWR_DEEPSLEEP) && (dw_cmd != PWR_EMERGENCYDEEPSLEEP))
 		return DSP_EINVALIDARG;
 
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return status;
 
-	switch (pDevContext->dwBrdState) {
+	switch (dev_context->dw_brd_state) {
 	case BRD_RUNNING:
-		omap_mbox_save_ctx(pDevContext->mbox);
+		omap_mbox_save_ctx(dev_context->mbox);
 		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
-			sm_interrupt_dsp(pDevContext,
-					     MBX_PM_DSPHIBERNATE);
+			sm_interrupt_dsp(dev_context, MBX_PM_DSPHIBERNATE);
 			dev_dbg(bridge, "PM: %s - sent hibernate cmd to DSP\n",
-								__func__);
-			targetPwrState = HW_PWR_STATE_OFF;
+				__func__);
+			target_pwr_state = HW_PWR_STATE_OFF;
 		} else {
-			sm_interrupt_dsp(pDevContext,
-					     MBX_PM_DSPRETENTION);
-			targetPwrState = HW_PWR_STATE_RET;
+			sm_interrupt_dsp(dev_context, MBX_PM_DSPRETENTION);
+			target_pwr_state = HW_PWR_STATE_RET;
 		}
 		break;
 	case BRD_RETENTION:
-		omap_mbox_save_ctx(pDevContext->mbox);
+		omap_mbox_save_ctx(dev_context->mbox);
 		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
-			sm_interrupt_dsp(pDevContext,
-					     MBX_PM_DSPHIBERNATE);
-			targetPwrState = HW_PWR_STATE_OFF;
+			sm_interrupt_dsp(dev_context, MBX_PM_DSPHIBERNATE);
+			target_pwr_state = HW_PWR_STATE_OFF;
 		} else
 			return DSP_SOK;
 		break;
@@ -215,47 +214,47 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwCmd,
 	case BRD_DSP_HIBERNATION:
 		/* Already in Hibernation, so just return */
 		dev_dbg(bridge, "PM: %s - DSP already in hibernation\n",
-								__func__);
+			__func__);
 		return DSP_SOK;
 	case BRD_STOPPED:
 		dev_dbg(bridge, "PM: %s - Board in STOP state\n", __func__);
 		return DSP_SALREADYASLEEP;
 	default:
 		dev_dbg(bridge, "PM: %s - Bridge in Illegal state\n", __func__);
-			return DSP_EFAIL;
+		return DSP_EFAIL;
 	}
 
 	/* Get the PRCM DSP power domain status */
-	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-			&pwrState);
+	hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
+			      &pwr_state);
 
 	/* Wait for DSP to move into target power state */
-	while ((pwrState != targetPwrState) && --timeout) {
+	while ((pwr_state != target_pwr_state) && --timeout) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP to Suspend interrupted\n");
 			return DSP_EFAIL;
 		}
-		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-				    &pwrState);
+		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
+				      &pwr_state);
 	}
 
 	if (!timeout) {
 		pr_err("%s: Timed out waiting for DSP off mode, state %x\n",
-							__func__, pwrState);
+		       __func__, pwr_state);
 #ifdef CONFIG_BRIDGE_NTFY_PWRERR
-		DEV_GetDehMgr(pDevContext->hDevObject, &hDehMgr);
-		WMD_DEH_Notify(hDehMgr, DSP_PWRERROR, 0);
+		dev_get_deh_mgr(dev_context->hdev_obj, &hdeh_mgr);
+		bridge_deh_notify(hdeh_mgr, DSP_PWRERROR, 0);
 #endif /* CONFIG_BRIDGE_NTFY_PWRERR */
 		return WMD_E_TIMEOUT;
 	} else {
 		/* Update the Bridger Driver state */
 		if (dsp_test_sleepstate == HW_PWR_STATE_OFF)
-			pDevContext->dwBrdState = BRD_HIBERNATION;
+			dev_context->dw_brd_state = BRD_HIBERNATION;
 		else
-			pDevContext->dwBrdState = BRD_RETENTION;
+			dev_context->dw_brd_state = BRD_RETENTION;
 
-		/* Turn off DSP Peripheral clocks  */
-		status = DSP_PeripheralClocks_Disable(pDevContext, NULL);
+		/* Turn off DSP Peripheral clocks */
+		status = dsp_peripheral_clocks_disable(dev_context, NULL);
 #ifdef CONFIG_BRIDGE_WDT3
 		/*
 		 * Disable WDT clocks and ISR on BSP commanded
@@ -268,14 +267,14 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwCmd,
 			return status;
 		}
 #ifdef CONFIG_BRIDGE_DVFS
-		else if (targetPwrState == HW_PWR_STATE_OFF) {
+		else if (target_pwr_state == HW_PWR_STATE_OFF) {
 			struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+			    omap_dspbridge_dev->dev.platform_data;
 			/*
 			 * Set the OPP to low level before moving to OFF mode
 			 */
 			if (pdata->dsp_set_min_opp)
-				(*pdata->dsp_set_min_opp)(VDD1_OPP1);
+				(*pdata->dsp_set_min_opp) (VDD1_OPP1);
 		}
 #endif /* CONFIG_BRIDGE_DVFS */
 	}
@@ -283,118 +282,118 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwCmd,
 	return status;
 }
 
-
 /*
- *  ======== WakeDSP ========
+ *  ======== wake_dsp ========
  *  	Wake up DSP from sleep.
  */
-DSP_STATUS WakeDSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+dsp_status wake_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 #ifdef CONFIG_PM
 
 	/* Check the BRD/WMD state, if it is not 'SLEEP' then return failure */
-	if (pDevContext->dwBrdState == BRD_RUNNING ||
-	    pDevContext->dwBrdState == BRD_STOPPED) {
+	if (dev_context->dw_brd_state == BRD_RUNNING ||
+	    dev_context->dw_brd_state == BRD_STOPPED) {
 		/* The Device is in 'RET' or 'OFF' state and WMD state is not
-		 * 'SLEEP', this means state inconsistency, so return  */
+		 * 'SLEEP', this means state inconsistency, so return */
 		return DSP_SOK;
 	}
 
 	/* Send a wakeup message to DSP */
-	sm_interrupt_dsp(pDevContext, MBX_PM_DSPWAKEUP);
+	sm_interrupt_dsp(dev_context, MBX_PM_DSPWAKEUP);
 
 	/* Set the device state to RUNNIG */
-	pDevContext->dwBrdState = BRD_RUNNING;
+	dev_context->dw_brd_state = BRD_RUNNING;
 #endif /* CONFIG_PM */
 	return status;
 }
 
 /*
- *  ======== DSPPeripheralClkCtrl ========
+ *  ======== dsp_peripheral_clk_ctrl ========
  *  	Enable/Disable the DSP peripheral clocks as needed..
  */
-DSP_STATUS DSPPeripheralClkCtrl(struct WMD_DEV_CONTEXT *pDevContext,
-				IN void *pArgs)
+dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
+				   IN void *pargs)
 {
-	u32 extClk = 0;
-	u32 extClkId = 0;
-	u32 extClkCmd = 0;
-	u32 clkIdIndex = MBX_PM_MAX_RESOURCES;
-	u32 tmpIndex;
-	u32 dspPerClksBefore;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	struct CFG_HOSTRES resources;
+	u32 ext_clk = 0;
+	u32 ext_clk_id = 0;
+	u32 ext_clk_cmd = 0;
+	u32 clk_id_index = MBX_PM_MAX_RESOURCES;
+	u32 tmp_index;
+	u32 dsp_per_clks_before;
+	dsp_status status = DSP_SOK;
+	dsp_status status1 = DSP_SOK;
+	struct cfg_hostres resources;
 	u32 value;
 
-	dspPerClksBefore = pDevContext->uDspPerClks;
+	dsp_per_clks_before = dev_context->dsp_per_clks;
 
-	extClk = (u32)*((u32 *)pArgs);
+	ext_clk = (u32) *((u32 *) pargs);
 
-	status = CFG_GetHostResources(
-			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 
 	if (DSP_FAILED(status))
 		return DSP_EFAIL;
 
-	extClkId = extClk & MBX_PM_CLK_IDMASK;
+	ext_clk_id = ext_clk & MBX_PM_CLK_IDMASK;
 
 	/* process the power message -- TODO, keep it in a separate function */
-	for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES; tmpIndex++) {
-		if (extClkId == BPWR_CLKID[tmpIndex]) {
-			clkIdIndex = tmpIndex;
+	for (tmp_index = 0; tmp_index < MBX_PM_MAX_RESOURCES; tmp_index++) {
+		if (ext_clk_id == bpwr_clkid[tmp_index]) {
+			clk_id_index = tmp_index;
 			break;
 		}
 	}
 	/* TODO -- Assert may be a too hard restriction here.. May be we should
 	 * just return with failure when the CLK ID does not match */
-	/* DBC_Assert(clkIdIndex < MBX_PM_MAX_RESOURCES);*/
-	if (clkIdIndex == MBX_PM_MAX_RESOURCES) {
+	/* DBC_ASSERT(clk_id_index < MBX_PM_MAX_RESOURCES); */
+	if (clk_id_index == MBX_PM_MAX_RESOURCES) {
 		/* return with a more meaningfull error code */
 		return DSP_EFAIL;
 	}
-	extClkCmd = (extClk >> MBX_PM_CLK_CMDSHIFT) & MBX_PM_CLK_CMDMASK;
-	switch (extClkCmd) {
-	case BPWR_DisableClock:
+	ext_clk_cmd = (ext_clk >> MBX_PM_CLK_CMDSHIFT) & MBX_PM_CLK_CMDMASK;
+	switch (ext_clk_cmd) {
+	case BPWR_DISABLE_CLOCK:
 		/* Call BP to disable the needed clock */
-		status1 = CLK_Disable(BPWR_Clks[clkIdIndex].intClk);
-		status = CLK_Disable(BPWR_Clks[clkIdIndex].funClk);
-		if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP1) {
+		status1 = services_clk_disable(bpwr_clks[clk_id_index].int_clk);
+		status = services_clk_disable(bpwr_clks[clk_id_index].fun_clk);
+		if (bpwr_clkid[clk_id_index] == BPWR_MCBSP1) {
 			/* clear MCBSP1_CLKS, on McBSP1 OFF */
-			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value = __raw_readl(resources.dw_sys_ctrl_base + 0x274);
 			value &= ~(1 << 2);
-			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
-		} else if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP2) {
+			__raw_writel(value, resources.dw_sys_ctrl_base + 0x274);
+		} else if (bpwr_clkid[clk_id_index] == BPWR_MCBSP2) {
 			/* clear MCBSP2_CLKS, on McBSP2 OFF */
-			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value = __raw_readl(resources.dw_sys_ctrl_base + 0x274);
 			value &= ~(1 << 6);
-			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+			__raw_writel(value, resources.dw_sys_ctrl_base + 0x274);
 		}
-		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, false);
+		dsp_clk_wakeup_event_ctrl(bpwr_clks[clk_id_index].clk_id,
+					  false);
 		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
-			(pDevContext->uDspPerClks) &=
-				(~((u32) (1 << clkIdIndex)));
+			(dev_context->dsp_per_clks) &=
+			    (~((u32) (1 << clk_id_index)));
 		}
 		break;
-	case BPWR_EnableClock:
-		status1 = CLK_Enable(BPWR_Clks[clkIdIndex].intClk);
-		status = CLK_Enable(BPWR_Clks[clkIdIndex].funClk);
-		if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP1) {
+	case BPWR_ENABLE_CLOCK:
+		status1 = services_clk_enable(bpwr_clks[clk_id_index].int_clk);
+		status = services_clk_enable(bpwr_clks[clk_id_index].fun_clk);
+		if (bpwr_clkid[clk_id_index] == BPWR_MCBSP1) {
 			/* set MCBSP1_CLKS, on McBSP1 ON */
-			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value = __raw_readl(resources.dw_sys_ctrl_base + 0x274);
 			value |= 1 << 2;
-			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
-		} else if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP2) {
+			__raw_writel(value, resources.dw_sys_ctrl_base + 0x274);
+		} else if (bpwr_clkid[clk_id_index] == BPWR_MCBSP2) {
 			/* set MCBSP2_CLKS, on McBSP2 ON */
-			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value = __raw_readl(resources.dw_sys_ctrl_base + 0x274);
 			value |= 1 << 6;
-			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+			__raw_writel(value, resources.dw_sys_ctrl_base + 0x274);
 		}
-		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, true);
+		dsp_clk_wakeup_event_ctrl(bpwr_clks[clk_id_index].clk_id, true);
 		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
-			(pDevContext->uDspPerClks) |= (1 << clkIdIndex);
+			(dev_context->dsp_per_clks) |= (1 << clk_id_index);
 		}
 		break;
 	default:
@@ -407,30 +406,31 @@ DSP_STATUS DSPPeripheralClkCtrl(struct WMD_DEV_CONTEXT *pDevContext,
 }
 
 /*
- *  ========PreScale_DSP========
+ *  ========pre_scale_dsp========
  *  Sends prescale notification to DSP
  *
  */
-DSP_STATUS PreScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+dsp_status pre_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 level;
 	u32 voltage_domain;
 
-	voltage_domain = *((u32 *)pArgs);
-	level = *((u32 *)pArgs + 1);
+	voltage_domain = *((u32 *) pargs);
+	level = *((u32 *) pargs + 1);
 
 	dev_dbg(bridge, "OPP: %s voltage_domain = %x, level = 0x%x\n",
-					__func__, voltage_domain, level);
-	if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
-			(pDevContext->dwBrdState == BRD_RETENTION) ||
-			(pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
-		dev_dbg(bridge, "OPP: %s IVA in sleep. No message to DSP\n", __func__);
+		__func__, voltage_domain, level);
+	if ((dev_context->dw_brd_state == BRD_HIBERNATION) ||
+	    (dev_context->dw_brd_state == BRD_RETENTION) ||
+	    (dev_context->dw_brd_state == BRD_DSP_HIBERNATION)) {
+		dev_dbg(bridge, "OPP: %s IVA in sleep. No message to DSP\n",
+			__func__);
 		return DSP_SOK;
-	} else if ((pDevContext->dwBrdState == BRD_RUNNING)) {
+	} else if ((dev_context->dw_brd_state == BRD_RUNNING)) {
 		/* Send a prenotificatio to DSP */
 		dev_dbg(bridge, "OPP: %s sent notification to DSP\n", __func__);
-		sm_interrupt_dsp(pDevContext, MBX_PM_SETPOINT_PRENOTIFY);
+		sm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_PRENOTIFY);
 		return DSP_SOK;
 	} else {
 		return DSP_EFAIL;
@@ -440,40 +440,40 @@ DSP_STATUS PreScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
 }
 
 /*
- *  ========PostScale_DSP========
+ *  ========post_scale_dsp========
  *  Sends postscale notification to DSP
  *
  */
-DSP_STATUS PostScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+dsp_status post_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 level;
 	u32 voltage_domain;
-	struct IO_MGR *hIOMgr;
+	struct io_mgr *hio_mgr;
 
-	status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
-	if (!hIOMgr)
+	status = dev_get_io_mgr(dev_context->hdev_obj, &hio_mgr);
+	if (!hio_mgr)
 		return DSP_EHANDLE;
 
-	voltage_domain = *((u32 *)pArgs);
-	level = *((u32 *)pArgs + 1);
+	voltage_domain = *((u32 *) pargs);
+	level = *((u32 *) pargs + 1);
 	dev_dbg(bridge, "OPP: %s voltage_domain = %x, level = 0x%x\n",
-					__func__, voltage_domain, level);
-	if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
-			(pDevContext->dwBrdState == BRD_RETENTION) ||
-			(pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
+		__func__, voltage_domain, level);
+	if ((dev_context->dw_brd_state == BRD_HIBERNATION) ||
+	    (dev_context->dw_brd_state == BRD_RETENTION) ||
+	    (dev_context->dw_brd_state == BRD_DSP_HIBERNATION)) {
 		/* Update the OPP value in shared memory */
-		IO_SHMsetting(hIOMgr, SHM_CURROPP, &level);
-		dev_dbg(bridge, "OPP: %s IVA in sleep. Wrote to SHM\n",
-								__func__);
-	} else  if ((pDevContext->dwBrdState == BRD_RUNNING)) {
+		io_sh_msetting(hio_mgr, SHM_CURROPP, &level);
+		dev_dbg(bridge, "OPP: %s IVA in sleep. Wrote to shm\n",
+			__func__);
+	} else if ((dev_context->dw_brd_state == BRD_RUNNING)) {
 		/* Update the OPP value in shared memory */
-		IO_SHMsetting(hIOMgr, SHM_CURROPP, &level);
+		io_sh_msetting(hio_mgr, SHM_CURROPP, &level);
 		/* Send a post notification to DSP */
-		sm_interrupt_dsp(pDevContext, MBX_PM_SETPOINT_POSTNOTIFY);
-		dev_dbg(bridge, "OPP: %s wrote to SHM. Sent post notification "
-							"to DSP\n", __func__);
+		sm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_POSTNOTIFY);
+		dev_dbg(bridge, "OPP: %s wrote to shm. Sent post notification "
+			"to DSP\n", __func__);
 	} else {
 		status = DSP_EFAIL;
 	}
@@ -482,84 +482,88 @@ DSP_STATUS PostScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
 }
 
 /*
- *  ========DSP_PeripheralClocks_Disable========
+ *  ========dsp_peripheral_clocks_disable========
  *  Disables all the peripheral clocks that were requested by DSP
  */
-DSP_STATUS DSP_PeripheralClocks_Disable(struct WMD_DEV_CONTEXT *pDevContext,
-					IN void *pArgs)
+dsp_status dsp_peripheral_clocks_disable(struct wmd_dev_context *dev_context,
+					 IN void *pargs)
 {
-	u32 clkIdx;
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_HOSTRES resources;
+	u32 clk_idx;
+	dsp_status status = DSP_SOK;
+	struct cfg_hostres resources;
 	u32 value;
 
-	status = CFG_GetHostResources(
-			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 
-	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
-		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
+	for (clk_idx = 0; clk_idx < MBX_PM_MAX_RESOURCES; clk_idx++) {
+		if (((dev_context->dsp_per_clks) >> clk_idx) & 0x01) {
 			/* Disables the interface clock of the peripheral */
-			status = CLK_Disable(BPWR_Clks[clkIdx].intClk);
-			if (BPWR_CLKID[clkIdx] == BPWR_MCBSP1) {
+			status =
+			    services_clk_disable(bpwr_clks[clk_idx].int_clk);
+			if (bpwr_clkid[clk_idx] == BPWR_MCBSP1) {
 				/* clear MCBSP1_CLKS, on McBSP1 OFF */
-				value = __raw_readl(resources.dwSysCtrlBase
-								+ 0x274);
+				value = __raw_readl(resources.dw_sys_ctrl_base
+						    + 0x274);
 				value &= ~(1 << 2);
-				__raw_writel(value, resources.dwSysCtrlBase
-								+ 0x274);
-			} else if (BPWR_CLKID[clkIdx] == BPWR_MCBSP2) {
+				__raw_writel(value, resources.dw_sys_ctrl_base
+					     + 0x274);
+			} else if (bpwr_clkid[clk_idx] == BPWR_MCBSP2) {
 				/* clear MCBSP2_CLKS, on McBSP2 OFF */
-				value = __raw_readl(resources.dwSysCtrlBase
-								+ 0x274);
+				value = __raw_readl(resources.dw_sys_ctrl_base
+						    + 0x274);
 				value &= ~(1 << 6);
-				__raw_writel(value, resources.dwSysCtrlBase
-								+ 0x274);
+				__raw_writel(value, resources.dw_sys_ctrl_base
+					     + 0x274);
 			}
 
 			/* Disables the functional clock of the periphearl */
-			status = CLK_Disable(BPWR_Clks[clkIdx].funClk);
+			status =
+			    services_clk_disable(bpwr_clks[clk_idx].fun_clk);
 		}
 	}
 	return status;
 }
 
 /*
- *  ========DSP_PeripheralClocks_Enable========
+ *  ========dsp_peripheral_clocks_enable========
  *  Enables all the peripheral clocks that were requested by DSP
  */
-DSP_STATUS DSP_PeripheralClocks_Enable(struct WMD_DEV_CONTEXT *pDevContext,
-				      IN void *pArgs)
+dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
+					IN void *pargs)
 {
-	u32 clkIdx;
-	DSP_STATUS int_clk_status = DSP_EFAIL, fun_clk_status = DSP_EFAIL;
-	struct CFG_HOSTRES resources;
+	u32 clk_idx;
+	dsp_status int_clk_status = DSP_EFAIL, fun_clk_status = DSP_EFAIL;
+	struct cfg_hostres resources;
 	u32 value;
 
-	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
+	cfg_get_host_resources((struct cfg_devnode *)
+			       drv_get_first_dev_extension(), &resources);
 
-	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
-		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
+	for (clk_idx = 0; clk_idx < MBX_PM_MAX_RESOURCES; clk_idx++) {
+		if (((dev_context->dsp_per_clks) >> clk_idx) & 0x01) {
 			/* Enable the interface clock of the peripheral */
-			int_clk_status = CLK_Enable(BPWR_Clks[clkIdx].intClk);
-			if (BPWR_CLKID[clkIdx] == BPWR_MCBSP1) {
+			int_clk_status =
+			    services_clk_enable(bpwr_clks[clk_idx].int_clk);
+			if (bpwr_clkid[clk_idx] == BPWR_MCBSP1) {
 				/* set MCBSP1_CLKS, on McBSP1 ON */
-				value = __raw_readl(resources.dwSysCtrlBase
-								+ 0x274);
+				value = __raw_readl(resources.dw_sys_ctrl_base
+						    + 0x274);
 				value |= 1 << 2;
-				__raw_writel(value, resources.dwSysCtrlBase
-								+ 0x274);
-			} else if (BPWR_CLKID[clkIdx] == BPWR_MCBSP2) {
+				__raw_writel(value, resources.dw_sys_ctrl_base
+					     + 0x274);
+			} else if (bpwr_clkid[clk_idx] == BPWR_MCBSP2) {
 				/* set MCBSP2_CLKS, on McBSP2 ON */
-				value = __raw_readl(resources.dwSysCtrlBase
-								+ 0x274);
+				value = __raw_readl(resources.dw_sys_ctrl_base
+						    + 0x274);
 				value |= 1 << 6;
-				__raw_writel(value, resources.dwSysCtrlBase
-								+ 0x274);
+				__raw_writel(value, resources.dw_sys_ctrl_base
+					     + 0x274);
 			}
 			/* Enable the functional clock of the periphearl */
-			fun_clk_status = CLK_Enable(BPWR_Clks[clkIdx].funClk);
+			fun_clk_status =
+			    services_clk_enable(bpwr_clks[clk_idx].fun_clk);
 		}
 	}
 	if ((int_clk_status | fun_clk_status) != DSP_SOK)
@@ -567,24 +571,27 @@ DSP_STATUS DSP_PeripheralClocks_Enable(struct WMD_DEV_CONTEXT *pDevContext,
 	return DSP_SOK;
 }
 
-void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
+void dsp_clk_wakeup_event_ctrl(u32 ClkId, bool enable)
 {
-	struct CFG_HOSTRES resources;
-	DSP_STATUS status = DSP_SOK;
+	struct cfg_hostres resources;
+	dsp_status status = DSP_SOK;
 	u32 iva2_grpsel;
 	u32 mpu_grpsel;
 
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return;
 
 	switch (ClkId) {
-	case BPWR_GPTimer5:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+	case BPWR_GP_TIMER5:
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_GPT5;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT5;
@@ -592,16 +599,18 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_GPT5;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT5;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-				= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-				= mpu_grpsel;
-	break;
-	case BPWR_GPTimer6:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
+	case BPWR_GP_TIMER6:
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_GPT6;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT6;
@@ -609,16 +618,18 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_GPT6;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT6;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
-	case BPWR_GPTimer7:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
+	case BPWR_GP_TIMER7:
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_GPT7;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT7;
@@ -626,16 +637,18 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_GPT7;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT7;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
-	case BPWR_GPTimer8:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
+	case BPWR_GP_TIMER8:
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_GPT8;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT8;
@@ -643,16 +656,18 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_GPT8;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT8;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP1:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwCorePmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwCorePmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_core_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_core_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP1;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
@@ -660,16 +675,18 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP1;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_core_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_core_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP2:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP2;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
@@ -677,16 +694,18 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP2;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP3:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP3;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
@@ -694,16 +713,18 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP3;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP4:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP4;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
@@ -711,16 +732,18 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP4;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP5:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwCorePmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwCorePmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_core_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_core_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP5;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
@@ -728,10 +751,10 @@ void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP5;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_core_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_core_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	}
 }
diff --git a/drivers/dsp/bridge/wmd/tiomap_io.c b/drivers/dsp/bridge/wmd/tiomap_io.c
index 355c7fd..527968b 100644
--- a/drivers/dsp/bridge/wmd/tiomap_io.c
+++ b/drivers/dsp/bridge/wmd/tiomap_io.c
@@ -37,360 +37,383 @@
 #include "_tiomap_pwr.h"
 #include "tiomap_io.h"
 
-static u32 ulExtBase;
-static u32 ulExtEnd;
+static u32 ul_ext_base;
+static u32 ul_ext_end;
 
-static u32 ulShm0End;
-static u32 ulDynExtBase;
-static u32 ulTraceSecBeg;
-static u32 ulTraceSecEnd;
-static u32 ulShmBaseVirt;
+static u32 shm0_end;
+static u32 ul_dyn_ext_base;
+static u32 ul_trace_sec_beg;
+static u32 ul_trace_sec_end;
+static u32 ul_shm_base_virt;
 
-bool bSymbolsReloaded = true;
+bool symbols_reloaded = true;
 
 /*
- *  ======== ReadExtDspData ========
+ *  ======== read_ext_dsp_data ========
  *      Copies DSP external memory buffers to the host side buffers.
  */
-DSP_STATUS ReadExtDspData(struct WMD_DEV_CONTEXT *hDevContext,
-			 OUT u8 *pbHostBuf, u32 dwDSPAddr,
-			 u32 ulNumBytes, u32 ulMemType)
+dsp_status read_ext_dsp_data(struct wmd_dev_context *hDevContext,
+			     OUT u8 *pbHostBuf, u32 dwDSPAddr,
+			     u32 ul_num_bytes, u32 ulMemType)
 {
-	DSP_STATUS	status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	u32	offset;
-	u32	ulTLBBaseVirt = 0;
-	u32	ulShmOffsetVirt = 0;
-	u32	dwExtProgVirtMem;
-	u32	dwBaseAddr = pDevContext->dwDspExtBaseAddr;
-	bool	bTraceRead = false;
-
-	if (!ulShmBaseVirt) {
-		status = DEV_GetSymbol(pDevContext->hDevObject,
-		SHMBASENAME, &ulShmBaseVirt);
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	u32 offset;
+	u32 ul_tlb_base_virt = 0;
+	u32 ul_shm_offset_virt = 0;
+	u32 dw_ext_prog_virt_mem;
+	u32 dw_base_addr = dev_context->dw_dsp_ext_base_addr;
+	bool trace_read = false;
+
+	if (!ul_shm_base_virt) {
+		status = dev_get_symbol(dev_context->hdev_obj,
+					SHMBASENAME, &ul_shm_base_virt);
 	}
-	DBC_Assert(ulShmBaseVirt != 0);
+	DBC_ASSERT(ul_shm_base_virt != 0);
 
 	/* Check if it is a read of Trace section */
-	if (DSP_SUCCEEDED(status) && !ulTraceSecBeg) {
-		status = DEV_GetSymbol(pDevContext->hDevObject,
-		DSP_TRACESEC_BEG, &ulTraceSecBeg);
+	if (DSP_SUCCEEDED(status) && !ul_trace_sec_beg) {
+		status = dev_get_symbol(dev_context->hdev_obj,
+					DSP_TRACESEC_BEG, &ul_trace_sec_beg);
 	}
-	DBC_Assert(ulTraceSecBeg != 0);
+	DBC_ASSERT(ul_trace_sec_beg != 0);
 
-	if (DSP_SUCCEEDED(status) && !ulTraceSecEnd) {
-		status = DEV_GetSymbol(pDevContext->hDevObject,
-		DSP_TRACESEC_END, &ulTraceSecEnd);
+	if (DSP_SUCCEEDED(status) && !ul_trace_sec_end) {
+		status = dev_get_symbol(dev_context->hdev_obj,
+					DSP_TRACESEC_END, &ul_trace_sec_end);
 	}
-	DBC_Assert(ulTraceSecEnd != 0);
+	DBC_ASSERT(ul_trace_sec_end != 0);
 
 	if (DSP_SUCCEEDED(status)) {
-		if ((dwDSPAddr <= ulTraceSecEnd) &&
-			(dwDSPAddr >= ulTraceSecBeg))
-			bTraceRead = true;
+		if ((dwDSPAddr <= ul_trace_sec_end) &&
+		    (dwDSPAddr >= ul_trace_sec_beg))
+			trace_read = true;
 	}
 
 	/* If reading from TRACE, force remap/unmap */
-	if (bTraceRead && dwBaseAddr) {
-		dwBaseAddr = 0;
-		pDevContext->dwDspExtBaseAddr = 0;
+	if (trace_read && dw_base_addr) {
+		dw_base_addr = 0;
+		dev_context->dw_dsp_ext_base_addr = 0;
 	}
 
-	if (!dwBaseAddr) {
-		/* Initialize ulExtBase and ulExtEnd */
-		ulExtBase = 0;
-		ulExtEnd = 0;
+	if (!dw_base_addr) {
+		/* Initialize ul_ext_base and ul_ext_end */
+		ul_ext_base = 0;
+		ul_ext_end = 0;
 
-		/* Get DYNEXT_BEG, EXT_BEG and EXT_END.*/
-		if (DSP_SUCCEEDED(status) && !ulDynExtBase) {
-			status = DEV_GetSymbol(pDevContext->hDevObject,
-					DYNEXTBASE, &ulDynExtBase);
+		/* Get DYNEXT_BEG, EXT_BEG and EXT_END. */
+		if (DSP_SUCCEEDED(status) && !ul_dyn_ext_base) {
+			status = dev_get_symbol(dev_context->hdev_obj,
+						DYNEXTBASE, &ul_dyn_ext_base);
 		}
-		DBC_Assert(ulDynExtBase != 0);
+		DBC_ASSERT(ul_dyn_ext_base != 0);
 
 		if (DSP_SUCCEEDED(status)) {
-			status = DEV_GetSymbol(pDevContext->hDevObject,
-				 EXTBASE, &ulExtBase);
+			status = dev_get_symbol(dev_context->hdev_obj,
+						EXTBASE, &ul_ext_base);
 		}
-		DBC_Assert(ulExtBase != 0);
+		DBC_ASSERT(ul_ext_base != 0);
 
 		if (DSP_SUCCEEDED(status)) {
-			status = DEV_GetSymbol(pDevContext->hDevObject,
-					EXTEND,	&ulExtEnd);
+			status = dev_get_symbol(dev_context->hdev_obj,
+						EXTEND, &ul_ext_end);
 		}
-		DBC_Assert(ulExtEnd != 0);
+		DBC_ASSERT(ul_ext_end != 0);
 
-	/* Trace buffer is right after the SHM SEG0,
-	*  so set the base address to SHMBASE */
-		if (bTraceRead) {
-			ulExtBase = ulShmBaseVirt;
-			ulExtEnd = ulTraceSecEnd;
+		/* Trace buffer is right after the shm SEG0,
+		 *  so set the base address to SHMBASE */
+		if (trace_read) {
+			ul_ext_base = ul_shm_base_virt;
+			ul_ext_end = ul_trace_sec_end;
 		}
 
-		DBC_Assert(ulExtEnd != 0);
-		DBC_Assert(ulExtEnd > ulExtBase);
+		DBC_ASSERT(ul_ext_end != 0);
+		DBC_ASSERT(ul_ext_end > ul_ext_base);
 
-		if (ulExtEnd < ulExtBase)
+		if (ul_ext_end < ul_ext_base)
 			status = DSP_EFAIL;
 
 		if (DSP_SUCCEEDED(status)) {
-			ulTLBBaseVirt =
-			pDevContext->aTLBEntry[0].ulDspVa * DSPWORDSIZE;
-			DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
-			dwExtProgVirtMem = pDevContext->aTLBEntry[0].ulGppVa;
-
-			if (!bTraceRead) {
-				ulShmOffsetVirt = ulShmBaseVirt - ulTLBBaseVirt;
-				ulShmOffsetVirt += PG_ALIGN_HIGH(ulExtEnd -
-						ulDynExtBase + 1,
-						HW_PAGE_SIZE_64KB);
-				dwExtProgVirtMem -= ulShmOffsetVirt;
-				dwExtProgVirtMem += (ulExtBase - ulDynExtBase);
-				pDevContext->dwDspExtBaseAddr =
-						dwExtProgVirtMem;
-
-	/* This dwDspExtBaseAddr will get cleared only when the board is
-	* stopped. */
-				if (!pDevContext->dwDspExtBaseAddr)
+			ul_tlb_base_virt =
+			    dev_context->atlb_entry[0].ul_dsp_va * DSPWORDSIZE;
+			DBC_ASSERT(ul_tlb_base_virt <= ul_shm_base_virt);
+			dw_ext_prog_virt_mem =
+			    dev_context->atlb_entry[0].ul_gpp_va;
+
+			if (!trace_read) {
+				ul_shm_offset_virt =
+				    ul_shm_base_virt - ul_tlb_base_virt;
+				ul_shm_offset_virt +=
+				    PG_ALIGN_HIGH(ul_ext_end - ul_dyn_ext_base +
+						  1, HW_PAGE_SIZE64KB);
+				dw_ext_prog_virt_mem -= ul_shm_offset_virt;
+				dw_ext_prog_virt_mem +=
+				    (ul_ext_base - ul_dyn_ext_base);
+				dev_context->dw_dsp_ext_base_addr =
+				    dw_ext_prog_virt_mem;
+
+				/*
+				 * This dw_dsp_ext_base_addr will get cleared
+				 * only when the board is stopped.
+				*/
+				if (!dev_context->dw_dsp_ext_base_addr)
 					status = DSP_EFAIL;
 			}
 
-			dwBaseAddr = dwExtProgVirtMem;
+			dw_base_addr = dw_ext_prog_virt_mem;
 		}
 	}
 
-	if (!dwBaseAddr || !ulExtBase || !ulExtEnd)
+	if (!dw_base_addr || !ul_ext_base || !ul_ext_end)
 		status = DSP_EFAIL;
 
-	offset = dwDSPAddr - ulExtBase;
+	offset = dwDSPAddr - ul_ext_base;
 
 	if (DSP_SUCCEEDED(status))
-		memcpy(pbHostBuf, (u8 *)dwBaseAddr+offset, ulNumBytes);
+		memcpy(pbHostBuf, (u8 *) dw_base_addr + offset, ul_num_bytes);
 
 	return status;
 }
+
 /*
- *  ======== WriteDspData ========
+ *  ======== write_dsp_data ========
  *  purpose:
  *      Copies buffers to the DSP internal/external memory.
  */
-DSP_STATUS WriteDspData(struct WMD_DEV_CONTEXT *hDevContext, IN u8 *pbHostBuf,
-			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType)
+dsp_status write_dsp_data(struct wmd_dev_context *hDevContext,
+			  IN u8 *pbHostBuf, u32 dwDSPAddr, u32 ul_num_bytes,
+			  u32 ulMemType)
 {
 	u32 offset;
-	u32 dwBaseAddr = hDevContext->dwDspBaseAddr;
-	struct CFG_HOSTRES resources;
-	DSP_STATUS status;
+	u32 dw_base_addr = hDevContext->dw_dsp_base_addr;
+	struct cfg_hostres resources;
+	dsp_status status;
 	u32 base1, base2, base3;
 	base1 = OMAP_DSP_MEM1_SIZE;
 	base2 = OMAP_DSP_MEM2_BASE - OMAP_DSP_MEM1_BASE;
 	base3 = OMAP_DSP_MEM3_BASE - OMAP_DSP_MEM1_BASE;
 
-	status =  CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 
 	if (DSP_FAILED(status))
 		return status;
 
-	offset = dwDSPAddr - hDevContext->dwDSPStartAdd;
+	offset = dwDSPAddr - hDevContext->dw_dsp_start_add;
 	if (offset < base1) {
-		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[2],
-						resources.dwMemLength[2]);
-	} else if (offset > base1 && offset < base2+OMAP_DSP_MEM2_SIZE) {
-		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[3],
-						resources.dwMemLength[3]);
+		dw_base_addr = MEM_LINEAR_ADDRESS(resources.dw_mem_base[2],
+						  resources.dw_mem_length[2]);
+	} else if (offset > base1 && offset < base2 + OMAP_DSP_MEM2_SIZE) {
+		dw_base_addr = MEM_LINEAR_ADDRESS(resources.dw_mem_base[3],
+						  resources.dw_mem_length[3]);
 		offset = offset - base2;
-	} else if (offset >= base2+OMAP_DSP_MEM2_SIZE &&
-		offset < base3 + OMAP_DSP_MEM3_SIZE) {
-		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[4],
-						resources.dwMemLength[4]);
+	} else if (offset >= base2 + OMAP_DSP_MEM2_SIZE &&
+		   offset < base3 + OMAP_DSP_MEM3_SIZE) {
+		dw_base_addr = MEM_LINEAR_ADDRESS(resources.dw_mem_base[4],
+						  resources.dw_mem_length[4]);
 		offset = offset - base3;
-	} else{
+	} else {
 		return DSP_EFAIL;
 	}
-	if (ulNumBytes)
-		memcpy((u8 *) (dwBaseAddr+offset), pbHostBuf, ulNumBytes);
+	if (ul_num_bytes)
+		memcpy((u8 *) (dw_base_addr + offset), pbHostBuf, ul_num_bytes);
 	else
-		*((u32 *) pbHostBuf) = dwBaseAddr+offset;
+		*((u32 *) pbHostBuf) = dw_base_addr + offset;
 
 	return status;
 }
 
 /*
- *  ======== WriteExtDspData ========
+ *  ======== write_ext_dsp_data ========
  *  purpose:
  *      Copies buffers to the external memory.
  *
  */
-DSP_STATUS WriteExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
-			  IN u8 *pbHostBuf, u32 dwDSPAddr, u32 ulNumBytes,
-			  u32 ulMemType, bool bDynamicLoad)
+dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
+			      IN u8 *pbHostBuf, u32 dwDSPAddr,
+			      u32 ul_num_bytes, u32 ulMemType,
+			      bool bDynamicLoad)
 {
-	u32 dwBaseAddr = pDevContext->dwDspExtBaseAddr;
-	u32 dwOffset = 0;
-	u8 bTempByte1, bTempByte2;
-	u8 remainByte[4];
+	u32 dw_base_addr = dev_context->dw_dsp_ext_base_addr;
+	u32 dw_offset = 0;
+	u8 temp_byte1, temp_byte2;
+	u8 remain_byte[4];
 	s32 i;
-	DSP_STATUS retVal = DSP_SOK;
-	u32 dwExtProgVirtMem;
-	u32 ulTLBBaseVirt = 0;
-	u32 ulShmOffsetVirt = 0;
-	struct CFG_HOSTRES hostRes;
-	bool bTraceLoad = false;
-	bTempByte1 = 0x0;
-	bTempByte2 = 0x0;
-
-	  if (bSymbolsReloaded) {
+	dsp_status ret = DSP_SOK;
+	u32 dw_ext_prog_virt_mem;
+	u32 ul_tlb_base_virt = 0;
+	u32 ul_shm_offset_virt = 0;
+	struct cfg_hostres host_res;
+	bool trace_load = false;
+	temp_byte1 = 0x0;
+	temp_byte2 = 0x0;
+
+	if (symbols_reloaded) {
 		/* Check if it is a load to Trace section */
-		retVal = DEV_GetSymbol(pDevContext->hDevObject,
-					DSP_TRACESEC_BEG, &ulTraceSecBeg);
-		if (DSP_SUCCEEDED(retVal))
-			retVal = DEV_GetSymbol(pDevContext->hDevObject,
-				 DSP_TRACESEC_END, &ulTraceSecEnd);
+		ret = dev_get_symbol(dev_context->hdev_obj,
+				     DSP_TRACESEC_BEG, &ul_trace_sec_beg);
+		if (DSP_SUCCEEDED(ret))
+			ret = dev_get_symbol(dev_context->hdev_obj,
+					     DSP_TRACESEC_END,
+					     &ul_trace_sec_end);
 	}
-	if (DSP_SUCCEEDED(retVal)) {
-		if ((dwDSPAddr <= ulTraceSecEnd) &&
-		   (dwDSPAddr >= ulTraceSecBeg))
-			bTraceLoad = true;
+	if (DSP_SUCCEEDED(ret)) {
+		if ((dwDSPAddr <= ul_trace_sec_end) &&
+		    (dwDSPAddr >= ul_trace_sec_beg))
+			trace_load = true;
 	}
 
 	/* If dynamic, force remap/unmap */
-	if ((bDynamicLoad || bTraceLoad) && dwBaseAddr) {
-		dwBaseAddr = 0;
-		MEM_UnmapLinearAddress((void *)pDevContext->dwDspExtBaseAddr);
-		pDevContext->dwDspExtBaseAddr = 0x0;
+	if ((bDynamicLoad || trace_load) && dw_base_addr) {
+		dw_base_addr = 0;
+		MEM_UNMAP_LINEAR_ADDRESS((void *)
+					 dev_context->dw_dsp_ext_base_addr);
+		dev_context->dw_dsp_ext_base_addr = 0x0;
 	}
-	if (!dwBaseAddr) {
-		if (bSymbolsReloaded)
+	if (!dw_base_addr) {
+		if (symbols_reloaded)
 			/* Get SHM_BEG  EXT_BEG and EXT_END. */
-			retVal = DEV_GetSymbol(pDevContext->hDevObject,
-						SHMBASENAME, &ulShmBaseVirt);
-		DBC_Assert(ulShmBaseVirt != 0);
+			ret = dev_get_symbol(dev_context->hdev_obj,
+					     SHMBASENAME, &ul_shm_base_virt);
+		DBC_ASSERT(ul_shm_base_virt != 0);
 		if (bDynamicLoad) {
-			if (DSP_SUCCEEDED(retVal)) {
-				if (bSymbolsReloaded)
-					retVal = DEV_GetSymbol(pDevContext->
-						hDevObject, DYNEXTBASE,
-						&ulExtBase);
+			if (DSP_SUCCEEDED(ret)) {
+				if (symbols_reloaded)
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, DYNEXTBASE,
+					     &ul_ext_base);
 			}
-			DBC_Assert(ulExtBase != 0);
-			if (DSP_SUCCEEDED(retVal)) {
+			DBC_ASSERT(ul_ext_base != 0);
+			if (DSP_SUCCEEDED(ret)) {
 				/* DR  OMAPS00013235 : DLModules array may be
 				 * in EXTMEM. It is expected that DYNEXTMEM and
 				 * EXTMEM are contiguous, so checking for the
 				 * upper bound at EXTEND should be Ok. */
-				if (bSymbolsReloaded)
-					retVal = DEV_GetSymbol(pDevContext->
-						hDevObject, EXTEND, &ulExtEnd);
+				if (symbols_reloaded)
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, EXTEND,
+					     &ul_ext_end);
 			}
 		} else {
-			if (bSymbolsReloaded) {
-				if (DSP_SUCCEEDED(retVal))
-					retVal = DEV_GetSymbol(pDevContext->
-						hDevObject, EXTBASE,
-						&ulExtBase);
-				DBC_Assert(ulExtBase != 0);
-				if (DSP_SUCCEEDED(retVal))
-					retVal = DEV_GetSymbol(pDevContext->
-						hDevObject, EXTEND, &ulExtEnd);
+			if (symbols_reloaded) {
+				if (DSP_SUCCEEDED(ret))
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, EXTBASE,
+					     &ul_ext_base);
+				DBC_ASSERT(ul_ext_base != 0);
+				if (DSP_SUCCEEDED(ret))
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, EXTEND,
+					     &ul_ext_end);
 			}
 		}
-		/* Trace buffer it right after the SHM SEG0, so set the
-		 * 	base address to SHMBASE */
-		if (bTraceLoad)
-			ulExtBase = ulShmBaseVirt;
-
-		DBC_Assert(ulExtEnd != 0);
-		DBC_Assert(ulExtEnd > ulExtBase);
-		if (ulExtEnd < ulExtBase)
-			retVal = DSP_EFAIL;
-
-		if (DSP_SUCCEEDED(retVal)) {
-			ulTLBBaseVirt = pDevContext->aTLBEntry[0].ulDspVa *
-					DSPWORDSIZE;
-			DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
-
-			if (bSymbolsReloaded) {
-				if (DSP_SUCCEEDED(retVal)) {
-					retVal = DEV_GetSymbol(pDevContext->
-						 hDevObject, DSP_TRACESEC_END,
-						 &ulShm0End);
+		/* Trace buffer it right after the shm SEG0, so set the
+		 *      base address to SHMBASE */
+		if (trace_load)
+			ul_ext_base = ul_shm_base_virt;
+
+		DBC_ASSERT(ul_ext_end != 0);
+		DBC_ASSERT(ul_ext_end > ul_ext_base);
+		if (ul_ext_end < ul_ext_base)
+			ret = DSP_EFAIL;
+
+		if (DSP_SUCCEEDED(ret)) {
+			ul_tlb_base_virt =
+			    dev_context->atlb_entry[0].ul_dsp_va * DSPWORDSIZE;
+			DBC_ASSERT(ul_tlb_base_virt <= ul_shm_base_virt);
+
+			if (symbols_reloaded) {
+				if (DSP_SUCCEEDED(ret)) {
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj,
+					     DSP_TRACESEC_END, &shm0_end);
 				}
-				if (DSP_SUCCEEDED(retVal)) {
-					retVal = DEV_GetSymbol(pDevContext->
-						 hDevObject, DYNEXTBASE,
-						 &ulDynExtBase);
+				if (DSP_SUCCEEDED(ret)) {
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, DYNEXTBASE,
+					     &ul_dyn_ext_base);
 				}
 			}
-			ulShmOffsetVirt = ulShmBaseVirt - ulTLBBaseVirt;
-			if (bTraceLoad) {
-				dwExtProgVirtMem = pDevContext->aTLBEntry[0].
-						   ulGppVa;
+			ul_shm_offset_virt =
+			    ul_shm_base_virt - ul_tlb_base_virt;
+			if (trace_load) {
+				dw_ext_prog_virt_mem =
+				    dev_context->atlb_entry[0].ul_gpp_va;
 			} else {
-				CFG_GetHostResources(
-					(struct CFG_DEVNODE *)
-					DRV_GetFirstDevExtension(), &hostRes);
-				dwExtProgVirtMem = hostRes.dwMemBase[1];
-				dwExtProgVirtMem += (ulExtBase - ulDynExtBase);
+				cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&host_res);
+				dw_ext_prog_virt_mem = host_res.dw_mem_base[1];
+				dw_ext_prog_virt_mem +=
+				    (ul_ext_base - ul_dyn_ext_base);
 			}
 
-			pDevContext->dwDspExtBaseAddr =
-				(u32)MEM_LinearAddress((void *)dwExtProgVirtMem,
-					ulExtEnd - ulExtBase);
-			dwBaseAddr += pDevContext->dwDspExtBaseAddr;
-			/* This dwDspExtBaseAddr will get cleared only when
-			 * the board is stopped.  */
-			if (!pDevContext->dwDspExtBaseAddr)
-				retVal = DSP_EFAIL;
+			dev_context->dw_dsp_ext_base_addr =
+			    (u32) MEM_LINEAR_ADDRESS((void *)
+						     dw_ext_prog_virt_mem,
+						     ul_ext_end - ul_ext_base);
+			dw_base_addr += dev_context->dw_dsp_ext_base_addr;
+			/* This dw_dsp_ext_base_addr will get cleared only when
+			 * the board is stopped. */
+			if (!dev_context->dw_dsp_ext_base_addr)
+				ret = DSP_EFAIL;
 		}
 	}
-	if (!dwBaseAddr || !ulExtBase || !ulExtEnd)
-		retVal = DSP_EFAIL;
+	if (!dw_base_addr || !ul_ext_base || !ul_ext_end)
+		ret = DSP_EFAIL;
 
-	if (DSP_SUCCEEDED(retVal)) {
+	if (DSP_SUCCEEDED(ret)) {
 		for (i = 0; i < 4; i++)
-			remainByte[i] = 0x0;
+			remain_byte[i] = 0x0;
 
-		dwOffset = dwDSPAddr - ulExtBase;
-		/* Also make sure the dwDSPAddr is < ulExtEnd */
-		if (dwDSPAddr > ulExtEnd || dwOffset > dwDSPAddr)
-			retVal = DSP_EFAIL;
+		dw_offset = dwDSPAddr - ul_ext_base;
+		/* Also make sure the dwDSPAddr is < ul_ext_end */
+		if (dwDSPAddr > ul_ext_end || dw_offset > dwDSPAddr)
+			ret = DSP_EFAIL;
 	}
-	if (DSP_SUCCEEDED(retVal)) {
-		if (ulNumBytes)
-			memcpy((u8 *) dwBaseAddr + dwOffset, pbHostBuf,
-				ulNumBytes);
+	if (DSP_SUCCEEDED(ret)) {
+		if (ul_num_bytes)
+			memcpy((u8 *) dw_base_addr + dw_offset, pbHostBuf,
+			       ul_num_bytes);
 		else
-			*((u32 *) pbHostBuf) = dwBaseAddr+dwOffset;
+			*((u32 *) pbHostBuf) = dw_base_addr + dw_offset;
 	}
 	/* Unmap here to force remap for other Ext loads */
-	if ((bDynamicLoad || bTraceLoad) && pDevContext->dwDspExtBaseAddr) {
-		MEM_UnmapLinearAddress((void *) pDevContext->dwDspExtBaseAddr);
-		pDevContext->dwDspExtBaseAddr = 0x0;
+	if ((bDynamicLoad || trace_load) && dev_context->dw_dsp_ext_base_addr) {
+		MEM_UNMAP_LINEAR_ADDRESS((void *)
+					 dev_context->dw_dsp_ext_base_addr);
+		dev_context->dw_dsp_ext_base_addr = 0x0;
 	}
-	bSymbolsReloaded = false;
-	return retVal;
+	symbols_reloaded = false;
+	return ret;
 }
 
-DSP_STATUS sm_interrupt_dsp(struct WMD_DEV_CONTEXT *pDevContext,
-				u16 wMbVal)
+dsp_status sm_interrupt_dsp(struct wmd_dev_context * dev_context, u16 mb_val)
 {
-	struct CFG_HOSTRES resources;
-	DSP_STATUS status = DSP_SOK;
+	struct cfg_hostres resources;
+	dsp_status status = DSP_SOK;
 	u32 temp;
 
-	if (!pDevContext->mbox)
+	if (!dev_context->mbox)
 		return DSP_SOK;
 
-	status = CFG_GetHostResources((struct CFG_DEVNODE *)
-			DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return DSP_EFAIL;
 
-	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
-	    pDevContext->dwBrdState == BRD_HIBERNATION) {
+	if (dev_context->dw_brd_state == BRD_DSP_HIBERNATION ||
+	    dev_context->dw_brd_state == BRD_HIBERNATION) {
 		/* Restart the peripheral clocks */
-		DSP_PeripheralClocks_Enable(pDevContext, NULL);
+		dsp_peripheral_clocks_enable(dev_context, NULL);
 
 #ifdef CONFIG_BRIDGE_WDT3
 		dsp_wdt_enable(true);
@@ -400,37 +423,36 @@ DSP_STATUS sm_interrupt_dsp(struct WMD_DEV_CONTEXT *pDevContext,
 		 * 2:0 AUTO_IVA2_DPLL - Enabling IVA2 DPLL auto control
 		 *     in CM_AUTOIDLE_PLL_IVA2 register
 		 */
-		*(REG_UWORD32 *)(resources.dwCmBase + 0x34) = 0x1;
+		*(reg_uword32 *) (resources.dw_cm_base + 0x34) = 0x1;
 
 		/*
 		 * 7:4 IVA2_DPLL_FREQSEL - IVA2 internal frq set to
 		 *     0.75 MHz - 1.0 MHz
 		 * 2:0 EN_IVA2_DPLL - Enable IVA2 DPLL in lock mode
 		 */
-		temp = *(REG_UWORD32 *)(resources.dwCmBase + 0x4);
+		temp = *(reg_uword32 *) (resources.dw_cm_base + 0x4);
 		temp = (temp & 0xFFFFFF08) | 0x37;
-		*(REG_UWORD32 *)(resources.dwCmBase + 0x4) = temp;
+		*(reg_uword32 *) (resources.dw_cm_base + 0x4) = temp;
 
 		/* Restore mailbox settings */
-		omap_mbox_restore_ctx(pDevContext->mbox);
+		omap_mbox_restore_ctx(dev_context->mbox);
 
 		/* Access MMU SYS CONFIG register to generate a short wakeup */
-		temp = *(REG_UWORD32 *)(resources.dwDmmuBase + 0x10);
+		temp = *(reg_uword32 *) (resources.dw_dmmu_base + 0x10);
 
-		pDevContext->dwBrdState = BRD_RUNNING;
-	} else if (pDevContext->dwBrdState == BRD_RETENTION) {
+		dev_context->dw_brd_state = BRD_RUNNING;
+	} else if (dev_context->dw_brd_state == BRD_RETENTION) {
 		/* Restart the peripheral clocks */
-		DSP_PeripheralClocks_Enable(pDevContext, NULL);
+		dsp_peripheral_clocks_enable(dev_context, NULL);
 	}
 
-	status = omap_mbox_msg_send(pDevContext->mbox, wMbVal);
+	status = omap_mbox_msg_send(dev_context->mbox, mb_val);
 
 	if (status) {
 		pr_err("omap_mbox_msg_send Fail and status = %d\n", status);
 		status = DSP_EFAIL;
 	}
 
-	dev_dbg(bridge, "MBX: writing %x to Mailbox\n", wMbVal);
+	dev_dbg(bridge, "MBX: writing %x to Mailbox\n", mb_val);
 	return DSP_SOK;
 }
-
diff --git a/drivers/dsp/bridge/wmd/tiomap_io.h b/drivers/dsp/bridge/wmd/tiomap_io.h
index 4d97147..ac78538 100644
--- a/drivers/dsp/bridge/wmd/tiomap_io.h
+++ b/drivers/dsp/bridge/wmd/tiomap_io.h
@@ -33,70 +33,72 @@
 #define IVAEXTMEMBASE   "_IVAEXTMEM_BEG"
 #define IVAEXTMEMEND   "_IVAEXTMEM_END"
 
-
 #define DSP_TRACESEC_BEG  "_BRIDGE_TRACE_BEG"
 #define DSP_TRACESEC_END  "_BRIDGE_TRACE_END"
 
 #define SYS_PUTCBEG               "_SYS_PUTCBEG"
 #define SYS_PUTCEND               "_SYS_PUTCEND"
-#define BRIDGE_SYS_PUTC_current   "_BRIDGE_SYS_PUTC_current"
-
+#define BRIDGE_SYS_PUTC_CURRENT   "_BRIDGE_SYS_PUTC_current"
 
 #define WORDSWAP_ENABLE 0x3	/* Enable word swap */
 
 /*
- *  ======== ReadExtDspData ========
+ *  ======== read_ext_dsp_data ========
  *  Reads it from DSP External memory. The external memory for the DSP
- * is configured by the combination of DSP MMU and SHM Memory manager in the CDB
+ * is configured by the combination of DSP MMU and shm Memory manager in the CDB
  */
-extern DSP_STATUS ReadExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
-				OUT u8 *pbHostBuf, u32 dwDSPAddr,
-				u32 ulNumBytes, u32 ulMemType);
+extern dsp_status read_ext_dsp_data(struct wmd_dev_context *dev_context,
+				    OUT u8 *pbHostBuf, u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType);
 
 /*
- *  ======== WriteDspData ========
+ *  ======== write_dsp_data ========
  */
-extern DSP_STATUS WriteDspData(struct WMD_DEV_CONTEXT *pDevContext,
-			       OUT u8 *pbHostBuf, u32 dwDSPAddr,
-			       u32 ulNumBytes, u32 ulMemType);
+extern dsp_status write_dsp_data(struct wmd_dev_context *dev_context,
+				 OUT u8 *pbHostBuf, u32 dwDSPAddr,
+				 u32 ul_num_bytes, u32 ulMemType);
 
 /*
- *  ======== WriteExtDspData ========
+ *  ======== write_ext_dsp_data ========
  *  Writes to the DSP External memory for external program.
  *  The ext mem for progra is configured by the combination of DSP MMU and
- *  SHM Memory manager in the CDB
+ *  shm Memory manager in the CDB
  */
-extern DSP_STATUS WriteExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
-				 IN u8 *pbHostBuf, u32 dwDSPAddr,
-				 u32 ulNumBytes, u32 ulMemType,
-				 bool bDynamicLoad);
+extern dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
+				     IN u8 *pbHostBuf, u32 dwDSPAddr,
+				     u32 ul_num_bytes, u32 ulMemType,
+				     bool bDynamicLoad);
 
 /*
- * ======== WriteExt32BitDspData ========
+ * ======== write_ext32_bit_dsp_data ========
  * Writes 32 bit data to the external memory
  */
-extern inline void WriteExt32BitDspData(IN const
-		struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwDSPAddr,
-		IN u32 val)
+extern inline void write_ext32_bit_dsp_data(IN const
+					    struct wmd_dev_context *dev_context,
+					    IN u32 dwDSPAddr, IN u32 val)
 {
-	*(u32 *)dwDSPAddr = ((pDevContext->tcWordSwapOn) ? (((val << 16) &
-			      0xFFFF0000) | ((val >> 16) & 0x0000FFFF)) : val);
+	*(u32 *) dwDSPAddr = ((dev_context->tc_word_swap_on) ? (((val << 16) &
+								 0xFFFF0000) |
+								((val >> 16) &
+								 0x0000FFFF)) :
+			      val);
 }
 
 /*
- * ======== ReadExt32BitDspData ========
+ * ======== read_ext32_bit_dsp_data ========
  * Reads 32 bit data from the external memory
  */
-extern inline u32 ReadExt32BitDspData(IN const struct WMD_DEV_CONTEXT
-				       *pDevContext, IN u32 dwDSPAddr)
+extern inline u32 read_ext32_bit_dsp_data(IN const struct wmd_dev_context
+					  *dev_context, IN u32 dwDSPAddr)
 {
-	u32 retVal;
-	retVal = *(u32 *)dwDSPAddr;
+	u32 ret;
+	ret = *(u32 *) dwDSPAddr;
 
-	retVal = ((pDevContext->tcWordSwapOn) ? (((retVal << 16)
-		 & 0xFFFF0000) | ((retVal >> 16) & 0x0000FFFF)) : retVal);
-	return retVal;
+	ret = ((dev_context->tc_word_swap_on) ? (((ret << 16)
+						  & 0xFFFF0000) | ((ret >> 16) &
+								   0x0000FFFF))
+	       : ret);
+	return ret;
 }
 
-#endif				/* _TIOMAP_IO_ */
-
+#endif /* _TIOMAP_IO_ */
diff --git a/drivers/dsp/bridge/wmd/ue_deh.c b/drivers/dsp/bridge/wmd/ue_deh.c
index d8c7133..82885f6 100644
--- a/drivers/dsp/bridge/wmd/ue_deh.c
+++ b/drivers/dsp/bridge/wmd/ue_deh.c
@@ -52,59 +52,69 @@
 #include "_tiomap_pwr.h"
 #include <dspbridge/io_sm.h>
 
-static struct HW_MMUMapAttrs_t  mapAttrs = { HW_LITTLE_ENDIAN,
-					HW_ELEM_SIZE_16BIT,
-					HW_MMU_CPUES} ;
-#define VirtToPhys(x)       ((x) - PAGE_OFFSET + PHYS_OFFSET)
+static struct hw_mmu_map_attrs_t map_attrs = { HW_LITTLE_ENDIAN,
+	HW_ELEM_SIZE16BIT,
+	HW_MMU_CPUES
+};
 
-static u32 dummyVaAddr;
+#define VIRT_TO_PHYS(x)       ((x) - PAGE_OFFSET + PHYS_OFFSET)
+
+static u32 dummy_va_addr;
 /*
- *  ======== WMD_DEH_Create ========
+ *  ======== bridge_deh_create ========
  *      Creates DEH manager object.
  */
-DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
-			 struct DEV_OBJECT *hDevObject)
+dsp_status bridge_deh_create(OUT struct deh_mgr **phDehMgr,
+			     struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEH_MGR *pDehMgr = NULL;
-	struct CFG_HOSTRES cfgHostRes;
-	struct CFG_DEVNODE *hDevNode;
-	struct WMD_DEV_CONTEXT *hWmdContext = NULL;
+	dsp_status status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = NULL;
+	struct cfg_hostres cfg_host_res;
+	struct cfg_devnode *dev_node_obj;
+	struct wmd_dev_context *hwmd_context = NULL;
 
-	 /*  Message manager will be created when a file is loaded, since
+	/*  Message manager will be created when a file is loaded, since
 	 *  size of message buffer in shared memory is configurable in
-	 *  the base image.  */
+	 *  the base image. */
 	/* Get WMD context info. */
-	DEV_GetWMDContext(hDevObject, &hWmdContext);
-	DBC_Assert(hWmdContext);
-	dummyVaAddr = 0;
+	dev_get_wmd_context(hdev_obj, &hwmd_context);
+	DBC_ASSERT(hwmd_context);
+	dummy_va_addr = 0;
 	/* Allocate IO manager object: */
-	MEM_AllocObject(pDehMgr, struct DEH_MGR, SIGNATURE);
-	if (pDehMgr == NULL) {
+	MEM_ALLOC_OBJECT(deh_mgr_obj, struct deh_mgr, SIGNATURE);
+	if (deh_mgr_obj == NULL) {
 		status = DSP_EMEMORY;
 	} else {
 		/* Create an NTFY object to manage notifications */
-		status = NTFY_Create(&pDehMgr->hNtfy);
+		deh_mgr_obj->ntfy_obj = kmalloc(sizeof(struct ntfy_object),
+							GFP_KERNEL);
+		if (deh_mgr_obj->ntfy_obj)
+			ntfy_init(deh_mgr_obj->ntfy_obj);
+		else
+			status = DSP_EMEMORY;
 
 		/* Create a MMUfault DPC */
-		tasklet_init(&pDehMgr->dpc_tasklet, MMU_FaultDpc, (u32)pDehMgr);
+		tasklet_init(&deh_mgr_obj->dpc_tasklet, mmu_fault_dpc,
+			     (u32) deh_mgr_obj);
 
 		if (DSP_SUCCEEDED(status))
-			status = DEV_GetDevNode(hDevObject, &hDevNode);
+			status = dev_get_dev_node(hdev_obj, &dev_node_obj);
 
 		if (DSP_SUCCEEDED(status))
-			status = CFG_GetHostResources(hDevNode, &cfgHostRes);
+			status =
+			    cfg_get_host_resources(dev_node_obj, &cfg_host_res);
 
 		if (DSP_SUCCEEDED(status)) {
 			/* Fill in context structure */
-			pDehMgr->hWmdContext = hWmdContext;
-			pDehMgr->errInfo.dwErrMask = 0L;
-			pDehMgr->errInfo.dwVal1 = 0L;
-			pDehMgr->errInfo.dwVal2 = 0L;
-			pDehMgr->errInfo.dwVal3 = 0L;
+			deh_mgr_obj->hwmd_context = hwmd_context;
+			deh_mgr_obj->err_info.dw_err_mask = 0L;
+			deh_mgr_obj->err_info.dw_val1 = 0L;
+			deh_mgr_obj->err_info.dw_val2 = 0L;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
 			/* Install ISR function for DSP MMU fault */
-			if ((request_irq(INT_DSP_MMU_IRQ, MMU_FaultIsr, 0,
-			   "DspBridge\tiommu fault", (void *)pDehMgr)) == 0)
+			if ((request_irq(INT_DSP_MMU_IRQ, mmu_fault_isr, 0,
+					 "DspBridge\tiommu fault",
+					 (void *)deh_mgr_obj)) == 0)
 				status = DSP_SOK;
 			else
 				status = DSP_EFAIL;
@@ -112,182 +122,194 @@ DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
 	}
 	if (DSP_FAILED(status)) {
 		/* If create failed, cleanup */
-		WMD_DEH_Destroy((struct DEH_MGR *)pDehMgr);
+		bridge_deh_destroy((struct deh_mgr *)deh_mgr_obj);
 		*phDehMgr = NULL;
 	} else {
-		*phDehMgr = (struct DEH_MGR *)pDehMgr;
+		*phDehMgr = (struct deh_mgr *)deh_mgr_obj;
 	}
 
 	return status;
 }
 
 /*
- *  ======== WMD_DEH_Destroy ========
+ *  ======== bridge_deh_destroy ========
  *      Destroys DEH manager object.
  */
-DSP_STATUS WMD_DEH_Destroy(struct DEH_MGR *hDehMgr)
+dsp_status bridge_deh_destroy(struct deh_mgr *hdeh_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
+	dsp_status status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)hdeh_mgr;
 
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
 		/* Release dummy VA buffer */
-		WMD_DEH_ReleaseDummyMem();
+		bridge_deh_release_dummy_mem();
 		/* If notification object exists, delete it */
-		if (pDehMgr->hNtfy)
-			(void)NTFY_Delete(pDehMgr->hNtfy);
+		if (deh_mgr_obj->ntfy_obj) {
+			(void)ntfy_delete(deh_mgr_obj->ntfy_obj);
+			kfree(deh_mgr_obj->ntfy_obj);
+		}
 		/* Disable DSP MMU fault */
-		free_irq(INT_DSP_MMU_IRQ, pDehMgr);
+		free_irq(INT_DSP_MMU_IRQ, deh_mgr_obj);
 
 		/* Free DPC object */
-		tasklet_kill(&pDehMgr->dpc_tasklet);
+		tasklet_kill(&deh_mgr_obj->dpc_tasklet);
 
 		/* Deallocate the DEH manager object */
-		MEM_FreeObject(pDehMgr);
+		MEM_FREE_OBJECT(deh_mgr_obj);
 	}
 
 	return status;
 }
 
 /*
- *  ======== WMD_DEH_RegisterNotify ========
+ *  ======== bridge_deh_register_notify ========
  *      Registers for DEH notifications.
  */
-DSP_STATUS WMD_DEH_RegisterNotify(struct DEH_MGR *hDehMgr, u32 uEventMask,
-				 u32 uNotifyType,
-				 struct DSP_NOTIFICATION *hNotification)
+dsp_status bridge_deh_register_notify(struct deh_mgr *hdeh_mgr, u32 event_mask,
+				   u32 notify_type,
+				   struct dsp_notification *hnotification)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
-
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
-		status = NTFY_Register(pDehMgr->hNtfy, hNotification,
-			 uEventMask, uNotifyType);
+	dsp_status status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)hdeh_mgr;
+
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
+		if (event_mask)
+			status = ntfy_register(deh_mgr_obj->ntfy_obj,
+				hnotification, event_mask, notify_type);
+		else
+			status = ntfy_unregister(deh_mgr_obj->ntfy_obj,
+							hnotification);
 	}
 
 	return status;
 }
 
-
 /*
- *  ======== WMD_DEH_Notify ========
+ *  ======== bridge_deh_notify ========
  *      DEH error notification function. Informs user about the error.
  */
-void WMD_DEH_Notify(struct DEH_MGR *hDehMgr, u32 ulEventMask,
-			 u32 dwErrInfo)
+void bridge_deh_notify(struct deh_mgr *hdeh_mgr, u32 ulEventMask, u32 dwErrInfo)
 {
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
-	struct WMD_DEV_CONTEXT *pDevContext;
-	DSP_STATUS status = DSP_SOK;
-	u32 memPhysical = 0;
-	u32 HW_MMU_MAX_TLB_COUNT = 31;
-	extern u32 faultAddr;
-	struct CFG_HOSTRES resources;
-	HW_STATUS hwStatus;
-
-	status = CFG_GetHostResources(
-			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
-
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
-		printk(KERN_INFO "WMD_DEH_Notify: ********** DEVICE EXCEPTION "
-			"**********\n");
-		pDevContext = (struct WMD_DEV_CONTEXT *)pDehMgr->hWmdContext;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)hdeh_mgr;
+	struct wmd_dev_context *dev_context;
+	dsp_status status = DSP_SOK;
+	u32 mem_physical = 0;
+	u32 hw_mmu_max_tlb_count = 31;
+	extern u32 fault_addr;
+	struct cfg_hostres resources;
+	hw_status hw_status_obj;
+
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
+
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
+		printk(KERN_INFO
+		       "bridge_deh_notify: ********** DEVICE EXCEPTION "
+		       "**********\n");
+		dev_context =
+		    (struct wmd_dev_context *)deh_mgr_obj->hwmd_context;
 
 		switch (ulEventMask) {
 		case DSP_SYSERROR:
-			/* reset errInfo structure before use */
-			pDehMgr->errInfo.dwErrMask = DSP_SYSERROR;
-			pDehMgr->errInfo.dwVal1 = 0L;
-			pDehMgr->errInfo.dwVal2 = 0L;
-			pDehMgr->errInfo.dwVal3 = 0L;
-			pDehMgr->errInfo.dwVal1 = dwErrInfo;
-			printk(KERN_ERR "WMD_DEH_Notify: DSP_SYSERROR, errInfo "
-				"= 0x%x\n", dwErrInfo);
+			/* reset err_info structure before use */
+			deh_mgr_obj->err_info.dw_err_mask = DSP_SYSERROR;
+			deh_mgr_obj->err_info.dw_val1 = 0L;
+			deh_mgr_obj->err_info.dw_val2 = 0L;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
+			deh_mgr_obj->err_info.dw_val1 = dwErrInfo;
+			printk(KERN_ERR
+			       "bridge_deh_notify: DSP_SYSERROR, err_info "
+			       "= 0x%x\n", dwErrInfo);
 			break;
 		case DSP_MMUFAULT:
 			/* MMU fault routine should have set err info
 			 * structure */
-			pDehMgr->errInfo.dwErrMask = DSP_MMUFAULT;
-			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT,"
-				"errInfo = 0x%x\n", dwErrInfo);
-			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, High "
-				"Address = 0x%x\n",
-				(unsigned int)pDehMgr->errInfo.dwVal1);
-			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, Low "
-				"Address = 0x%x\n",
-				(unsigned int)pDehMgr->errInfo.dwVal2);
-			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, fault "
-				"address = 0x%x\n", (unsigned int)faultAddr);
-			dummyVaAddr = (u32)MEM_Calloc(sizeof(char) * 0x1000,
-					MEM_PAGED);
-			memPhysical  = VirtToPhys(PG_ALIGN_LOW((u32)dummyVaAddr,
-								PG_SIZE_4K));
-			pDevContext = (struct WMD_DEV_CONTEXT *)
-						pDehMgr->hWmdContext;
+			deh_mgr_obj->err_info.dw_err_mask = DSP_MMUFAULT;
+			printk(KERN_INFO "bridge_deh_notify: DSP_MMUFAULT,"
+			       "err_info = 0x%x\n", dwErrInfo);
+			printk(KERN_INFO
+			       "bridge_deh_notify: DSP_MMUFAULT, High "
+			       "Address = 0x%x\n",
+			       (unsigned int)deh_mgr_obj->err_info.dw_val1);
+			printk(KERN_INFO "bridge_deh_notify: DSP_MMUFAULT, Low "
+			       "Address = 0x%x\n",
+			       (unsigned int)deh_mgr_obj->err_info.dw_val2);
+			printk(KERN_INFO
+			       "bridge_deh_notify: DSP_MMUFAULT, fault "
+			       "address = 0x%x\n", (unsigned int)fault_addr);
+			dummy_va_addr =
+			    (u32) mem_calloc(sizeof(char) * 0x1000, MEM_PAGED);
+			mem_physical =
+			    VIRT_TO_PHYS(PG_ALIGN_LOW
+					 ((u32) dummy_va_addr, PG_SIZE4K));
+			dev_context = (struct wmd_dev_context *)
+			    deh_mgr_obj->hwmd_context;
 			/* Reset the dynamic mmu index to fixed count if it
 			 * exceeds 31. So that the dynmmuindex is always
 			 * between the range of standard/fixed entries
-			 * and 31.  */
-			if (pDevContext->numTLBEntries >
-			   HW_MMU_MAX_TLB_COUNT) {
-				pDevContext->numTLBEntries = pDevContext->
-					fixedTLBEntries;
+			 * and 31. */
+			if (dev_context->num_tlb_entries >
+			    hw_mmu_max_tlb_count) {
+				dev_context->num_tlb_entries =
+				    dev_context->fixed_tlb_entries;
 			}
 			if (DSP_SUCCEEDED(status)) {
-				hwStatus = HW_MMU_TLBAdd(resources.dwDmmuBase,
-					memPhysical, faultAddr,
-					HW_PAGE_SIZE_4KB, 1, &mapAttrs,
-					HW_SET, HW_SET);
+				hw_status_obj =
+				    hw_mmu_tlb_add(resources.dw_dmmu_base,
+						   mem_physical, fault_addr,
+						   HW_PAGE_SIZE4KB, 1,
+						   &map_attrs, HW_SET, HW_SET);
 			}
 			/* send an interrupt to DSP */
-			omap_mbox_msg_send(pDevContext->mbox,
-					MBX_DEH_CLASS | MBX_DEH_EMMU);
+			omap_mbox_msg_send(dev_context->mbox,
+					   MBX_DEH_CLASS | MBX_DEH_EMMU);
 			/* Clear MMU interrupt */
-			HW_MMU_EventAck(resources.dwDmmuBase,
+			hw_mmu_event_ack(resources.dw_dmmu_base,
 					 HW_MMU_TRANSLATION_FAULT);
 			break;
 #ifdef CONFIG_BRIDGE_NTFY_PWRERR
 		case DSP_PWRERROR:
-			/* reset errInfo structure before use */
-			pDehMgr->errInfo.dwErrMask = DSP_PWRERROR;
-			pDehMgr->errInfo.dwVal1 = 0L;
-			pDehMgr->errInfo.dwVal2 = 0L;
-			pDehMgr->errInfo.dwVal3 = 0L;
-			pDehMgr->errInfo.dwVal1 = dwErrInfo;
-			printk(KERN_ERR "WMD_DEH_Notify: DSP_PWRERROR, errInfo "
-					"= 0x%x\n", dwErrInfo);
+			/* reset err_info structure before use */
+			deh_mgr_obj->err_info.dw_err_mask = DSP_PWRERROR;
+			deh_mgr_obj->err_info.dw_val1 = 0L;
+			deh_mgr_obj->err_info.dw_val2 = 0L;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
+			deh_mgr_obj->err_info.dw_val1 = dwErrInfo;
+			printk(KERN_ERR
+			       "bridge_deh_notify: DSP_PWRERROR, err_info "
+			       "= 0x%x\n", dwErrInfo);
 			break;
 #endif /* CONFIG_BRIDGE_NTFY_PWRERR */
 #ifdef CONFIG_BRIDGE_WDT3
 		case DSP_WDTOVERFLOW:
-			pDehMgr->errInfo.dwErrMask = DSP_WDTOVERFLOW;
-			pDehMgr->errInfo.dwVal1 = 0L;
-			pDehMgr->errInfo.dwVal2 = 0L;
-			pDehMgr->errInfo.dwVal3 = 0L;
-			pr_err("WMD_DEH_Notify: DSP_WDTOVERFLOW \n ");
+			deh_mgr_obj->err_info.dw_err_mask = DSP_WDTOVERFLOW;
+			deh_mgr_obj->err_info.dw_val1 = 0L;
+			deh_mgr_obj->err_info.dw_val2 = 0L;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
+			pr_err("bridge_deh_notify: DSP_WDTOVERFLOW \n ");
 			break;
 #endif
 		default:
-			dev_dbg(bridge, "%s: Unknown Error, errInfo = 0x%x\n",
-							__func__, dwErrInfo);
+			dev_dbg(bridge, "%s: Unknown Error, err_info = 0x%x\n",
+				__func__, dwErrInfo);
 			break;
 		}
 
 		/* Filter subsequent notifications when an error occurs */
-		if (pDevContext->dwBrdState != BRD_ERROR) {
-			NTFY_Notify(pDehMgr->hNtfy, ulEventMask);
+		if (dev_context->dw_brd_state != BRD_ERROR) {
+			ntfy_notify(deh_mgr_obj->ntfy_obj, ulEventMask);
 #ifdef CONFIG_BRIDGE_RECOVERY
 			bridge_recover_schedule();
 #endif
 		}
 
 		/* Set the Board state as ERROR */
-		pDevContext->dwBrdState = BRD_ERROR;
+		dev_context->dw_brd_state = BRD_ERROR;
 		/* Disable all the clocks that were enabled by DSP */
-		(void)DSP_PeripheralClocks_Disable(pDevContext, NULL);
+		(void)dsp_peripheral_clocks_disable(dev_context, NULL);
 		/* Call DSP Trace Buffer */
-		PrintDspTraceBuffer(hDehMgr->hWmdContext);
+		print_dsp_trace_buffer(hdeh_mgr->hwmd_context);
 #ifdef CONFIG_BRIDGE_WDT3
 		/*
 		 * Avoid the subsequent WDT if it happens once,
@@ -300,25 +322,25 @@ void WMD_DEH_Notify(struct DEH_MGR *hDehMgr, u32 ulEventMask,
 }
 
 /*
- *  ======== WMD_DEH_GetInfo ========
+ *  ======== bridge_deh_get_info ========
  *      Retrieves error information.
  */
-DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
-			  struct DSP_ERRORINFO *pErrInfo)
+dsp_status bridge_deh_get_info(struct deh_mgr *hdeh_mgr,
+			    struct dsp_errorinfo *pErrInfo)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
+	dsp_status status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)hdeh_mgr;
 
-	DBC_Require(pDehMgr);
-	DBC_Require(pErrInfo);
+	DBC_REQUIRE(deh_mgr_obj);
+	DBC_REQUIRE(pErrInfo);
 
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
 		/* Copy DEH error info structure to PROC error info
 		 * structure. */
-		pErrInfo->dwErrMask = pDehMgr->errInfo.dwErrMask;
-		pErrInfo->dwVal1 = pDehMgr->errInfo.dwVal1;
-		pErrInfo->dwVal2 = pDehMgr->errInfo.dwVal2;
-		pErrInfo->dwVal3 = pDehMgr->errInfo.dwVal3;
+		pErrInfo->dw_err_mask = deh_mgr_obj->err_info.dw_err_mask;
+		pErrInfo->dw_val1 = deh_mgr_obj->err_info.dw_val1;
+		pErrInfo->dw_val2 = deh_mgr_obj->err_info.dw_val2;
+		pErrInfo->dw_val3 = deh_mgr_obj->err_info.dw_val3;
 	} else {
 		status = DSP_EHANDLE;
 	}
@@ -326,14 +348,12 @@ DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
 	return status;
 }
 
-
 /*
- *  ======== WMD_DEH_ReleaseDummyMem ========
+ *  ======== bridge_deh_release_dummy_mem ========
  *      Releases memory allocated for dummy page
  */
-void WMD_DEH_ReleaseDummyMem(void)
+void bridge_deh_release_dummy_mem(void)
 {
-	kfree((void *)dummyVaAddr);
-	dummyVaAddr = 0;
+	kfree((void *)dummy_va_addr);
+	dummy_va_addr = 0;
 }
-
-- 
1.6.0.4

