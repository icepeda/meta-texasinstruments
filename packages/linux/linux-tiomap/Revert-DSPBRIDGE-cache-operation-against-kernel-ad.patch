From 4df85c1484ce2114507b0d5d134251483a49dfeb Mon Sep 17 00:00:00 2001
From: Xavier Boudet <x-boudet@ti.com>
Date: Tue, 23 Feb 2010 15:51:03 +0100
Subject: [PATCH] Revert "DSPBRIDGE: cache operation against kernel address instead of user's"

This reverts commit 819e49415750a3430643a13b08e6ae2537175608.

Conflicts:

	drivers/dsp/bridge/rmgr/proc.c

Signed-off-by: Xavier Boudet <x-boudet@ti.com>
---
 drivers/dsp/bridge/rmgr/proc.c |   69 ++++++++++------------------------------
 mm/memory.c                    |    1 -
 2 files changed, 17 insertions(+), 53 deletions(-)

diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index 4f179ac..1399f6f 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -564,43 +564,8 @@ DSP_STATUS PROC_EnumNodes(void *hProcessor, void **aNodeTab,
 	return status;
 }
 
-/* Cache operation against kernel address instead of users */
-static int memory_sync_page(struct vm_area_struct *vma, unsigned long start,
-			    ssize_t len, enum DSP_FLUSHTYPE ftype)
-{
-	struct page *page;
-	void *kaddr;
-	unsigned long offset;
-	ssize_t rest;
-
-	while (len) {
-		page = follow_page(vma, start, FOLL_GET);
-		if (!page) {
-			pr_err("%s: no page for %08lx\n", __func__, start);
-			return -EINVAL;
-		} else if (IS_ERR(page)) {
-			pr_err("%s: err page for %08lx(%lu)\n", __func__, start,
-			       IS_ERR(page));
-			return IS_ERR(page);
-		}
-
-		offset = start & ~PAGE_MASK;
-		kaddr = page_address(page) + offset;
-		rest = min_t(ssize_t, PAGE_SIZE - offset, len);
-
-		MEM_FlushCache(kaddr, rest, ftype);
-
-		put_page(page);
-		len -= rest;
-		start += rest;
-	}
-
-	return 0;
-}
-
 /* Check if the given area blongs to process virtul memory address space */
-static int memory_sync_vma(unsigned long start, u32 len,
-			   enum DSP_FLUSHTYPE ftype)
+static int memory_check_vma(unsigned long start, u32 len)
 {
 	int err = 0;
 	unsigned long end;
@@ -610,19 +575,14 @@ static int memory_sync_vma(unsigned long start, u32 len,
 	if (end <= start)
 		return -EINVAL;
 
-	while ((vma = find_vma(current->mm, start)) != NULL) {
-		ssize_t size;
-
-		if (vma->vm_flags & (VM_IO | VM_PFNMAP))
-			return -EINVAL;
+	down_read(&current->mm->mmap_sem);
 
-		if (vma->vm_start > start)
-			return -EINVAL;
+	while ((vma = find_vma(current->mm, start)) != NULL) {
 
-		size = min_t(ssize_t, vma->vm_end - start, len);
-		err = memory_sync_page(vma, start, size, ftype);
-		if (err)
+		if (vma->vm_start > start) {
+			err = -EINVAL;
 			break;
+		}
 
 		if (end <= vma->vm_end)
 			break;
@@ -633,6 +593,8 @@ static int memory_sync_vma(unsigned long start, u32 len,
 	if (!vma)
 		err = -EINVAL;
 
+	up_read(&current->mm->mmap_sem);
+
 	return err;
 }
 
@@ -649,16 +611,19 @@ static DSP_STATUS proc_memory_sync(void *hProcessor, void *pMpuAddr,
 		  "hProcessor: 0x%x pMpuAddr: 0x%x ulSize 0x%x, ulFlags 0x%x\n",
 		  __func__, hProcessor, pMpuAddr, ulSize, ulFlags);
 
-	down_read(&current->mm->mmap_sem);
-
-	if (memory_sync_vma((u32)pMpuAddr, ulSize, FlushMemType)) {
-		pr_err("%s: InValid address parameters %p %x\n",
-		       __func__, pMpuAddr, ulSize);
+	if (memory_check_vma((u32)pMpuAddr, ulSize)) {
+		GT_3trace(PROC_DebugMask, GT_7CLASS,
+			  "%s: InValid address parameters\n",
+			  __func__, pMpuAddr, ulSize);
 		status = DSP_EHANDLE;
+		goto err_out;
 	}
 
-	up_read(&current->mm->mmap_sem);
+	(void)SYNC_EnterCS(hProcLock);
+	MEM_FlushCache(pMpuAddr, ulSize, FlushMemType);
+	(void)SYNC_LeaveCS(hProcLock);
 
+err_out:
 	GT_2trace(PROC_DebugMask, GT_ENTER,
 		  "Leaving %s [0x%x]", __func__, status);
 
diff --git a/mm/memory.c b/mm/memory.c
index 5516b67..a54b2c4 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1241,7 +1241,6 @@ no_page_table:
 		return ERR_PTR(-EFAULT);
 	return page;
 }
-EXPORT_SYMBOL_GPL(follow_page);
 
 int __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 		     unsigned long start, int nr_pages, unsigned int gup_flags,
-- 
1.6.0.4

