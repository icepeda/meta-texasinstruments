Index: wpa_supplicant-0.5.11/Makefile
===================================================================
--- wpa_supplicant-0.5.11.orig/Makefile	2010-02-11 19:02:54.000028000 +0100
+++ wpa_supplicant-0.5.11/Makefile	2010-02-11 19:03:34.003138000 +0100
@@ -172,6 +172,12 @@
 OBJS_d += driver_test.o
 endif
 
+ifdef CONFIG_EAP_WSC
+CFLAGS += -DCONFIG_EAP_WSC
+CFLAGS += -DTI_WLAN_DRIVER
+OBJS_d += CipherWrapper.o bufferObj.o eap_wsc.o wsc_supplicant.o	
+endif
+
 ifndef CONFIG_L2_PACKET
 CONFIG_L2_PACKET=linux
 endif
Index: wpa_supplicant-0.5.11/config.c
===================================================================
--- wpa_supplicant-0.5.11.orig/config.c	2010-02-11 19:07:04.000040000 +0100
+++ wpa_supplicant-0.5.11/config.c	2010-02-11 19:07:23.000010000 +0100
@@ -22,6 +22,14 @@
 #include "l2_packet.h"
 #include "config.h"
 
+#ifdef CONFIG_EAP_WSC 
+#include "WscTypes.h" 
+#include <openssl/ossl_typ.h>
+#include <openssl/rand.h> 
+#include "wsc_supplicant.h" 
+#endif 
+
+
 
 /*
  * Structure for network configuration parsing. This data is used to implement
@@ -1033,6 +1041,120 @@
 }
 
 
+ #ifdef CONFIG_EAP_WSC
+ static int wpa_config_parse_wsc_pin(const struct parse_data *data,
+                   struct wpa_ssid *ssid, int line,
+                    const char *value)
+ {
+   size_t res_len;
+   char c_devPwd[32];
+   u32 val;
+   u32 checksum;
+   u8 devPwd[10];
+   u8 password[LONG_PIN_LEN+1];
+
+   if(!ssid->wsc_pin)
+   {
+       free(ssid->wsc_pin);
+   }
+   ssid->wsc_pin = wpa_config_parse_string(value, &res_len);
+
+   if (ssid->wsc_pin == NULL)
+   {
+       wpa_printf(MSG_ERROR, "Line %d: failed to parse %s '%s'.",
+              line, data->name, value);
+       return -1;
+   }
+
+   if ((res_len != SHORT_PIN_LEN) && (res_len != LONG_PIN_LEN))
+   {
+       wpa_printf(MSG_ERROR, "Line %d: failed to parse %s '%s'. Pin length: %d is invalid",
+              line, data->name, value, res_len);
+       return -1;
+   }
+
+   if (strncmp(ssid->wsc_pin, RANDOM_PIN_NUMBER, (sizeof(RANDOM_PIN_NUMBER) - 1)) == 0)
+   {
+       RAND_bytes(devPwd, LONG_PIN_LEN);
+      sprintf(c_devPwd, "%08u", *(u32 *)devPwd);
+
+       /* Compute the checksum */
+       c_devPwd[7] = '\0';
+       val = strtoul(c_devPwd, NULL, 10 );
+       checksum = wsc_supplicant_ComputeChecksum( val );
+       val = val*10 + checksum;
+       sprintf((char *)password, "%d", val );
+       password[LONG_PIN_LEN] = '\0';
+       free(ssid->wsc_pin);
+       ssid->wsc_pin = strdup((char *)password);
+
+       wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c-%c-%c-%c-%c\n", password[0], password[1], password[2], password[3], password[4], password[5], password[6], password[7]);
+   }
+   else if (strncmp(ssid->wsc_pin, RANDOM_SHORT_PIN_NUMBER, (sizeof(RANDOM_SHORT_PIN_NUMBER) - 1)) == 0)
+   {
+       RAND_bytes(devPwd, SHORT_PIN_LEN);
+       sprintf(c_devPwd, "%04u", *(u32 *)devPwd);
+       c_devPwd[SHORT_PIN_LEN] = '\0';
+
+       /* save randomized PIN created */
+       strcpy((char *)password, c_devPwd);
+       free(ssid->wsc_pin);
+       ssid->wsc_pin = strdup((char *)password);
+
+       wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c\n", password[0], password[1], password[2], password[3]);
+   }
+   else
+   {
+       wpa_printf(MSG_DEBUG, "PIN exist='%s'", ssid->wsc_pin);
+
+       /* (if res_len==4 no checksum check is required) */
+       if (res_len == LONG_PIN_LEN)
+       {
+           /* check the checksum */
+           strcpy(c_devPwd, ssid->wsc_pin);
+           c_devPwd[7] = '\0';
+           val = strtoul(c_devPwd, NULL, 10 );
+           checksum = wsc_supplicant_ComputeChecksum( val );
+           if (checksum != (ssid->wsc_pin[7] - '0'))
+           {
+               /* checksum is incorrect */
+               wpa_printf(MSG_ERROR, "checksum is incorrect :\nCalculated checksum = %d, wsc_pin[7] = %c, Randomizing new PIN...", checksum, ssid->wsc_pin[7]);
+
+               /* Randomize new PIN */
+               RAND_bytes(devPwd, LONG_PIN_LEN);
+               sprintf(c_devPwd, "%08u", *(u32 *)devPwd);
+
+               /* Compute the checksum */
+               c_devPwd[7] = '\0';
+               val = strtoul(c_devPwd, NULL, 10 );
+               checksum = wsc_supplicant_ComputeChecksum( val );
+               val = val*10 + checksum;
+               sprintf((char *)password, "%d", val );
+               password[LONG_PIN_LEN] = '\0';
+               free(ssid->wsc_pin);
+               ssid->wsc_pin = strdup((char *)password);
+
+               wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c-%c-%c-%c-%c\n", password[0], password[1], password[2], password[3], password[4], password[5], password[6], password[7]);
+           }
+       }
+   }
+
+   return 0;
+ }
+
+static char * wpa_config_write_wsc_pin(const struct parse_data *data,
+                   struct wpa_ssid *ssid)
+ {
+   if (ssid->wsc_pin)
+   {
+       return wpa_config_write_string_ascii((const u8 *) ssid->wsc_pin, strlen(ssid->wsc_pin));
+   }
+   return NULL;
+ }
+
+#endif /* CONFIG_EAP_WSC */
+
+
 /* Helper macros for network block parser */
 
 #ifdef OFFSET
@@ -1160,7 +1282,13 @@
 #endif /* CONFIG_IEEE80211W */
 	{ INT_RANGE(peerkey, 0, 1) },
 	{ INT_RANGE(mixed_cell, 0, 1) },
+#ifndef CONFIG_EAP_WSC
 	{ INT_RANGE(frequency, 0, 10000) }
+#else
+    { INT_RANGE(frequency, 0, 10000) }, 
+    { FUNC(wsc_pin) }, 
+    { INT(wsc_mode) } 
+#endif /* CONFIG_EAP_WSC */
 };
 
 #undef OFFSET
Index: wpa_supplicant-0.5.11/config_file.c
===================================================================
--- wpa_supplicant-0.5.11.orig/config_file.c	2010-02-11 19:06:44.000028000 +0100
+++ wpa_supplicant-0.5.11/config_file.c	2010-02-11 19:07:02.000007000 +0100
@@ -560,6 +560,21 @@
 }
 
 
+ #ifdef CONFIG_EAP_WSC
+ static void write_wsc_pin(FILE *f, struct wpa_ssid *ssid)
+ {
+   char *value;
+
+   value = wpa_config_get(ssid, "wsc_pin");
+   if (value == NULL)
+       return;
+   if (value[0])
+       fprintf(f, "\twsc_pin=%s\n", value);
+   free(value);
+ }
+ #endif /* CONFIG_EAP_WSC */
+
+
 static void wpa_config_write_network(FILE *f, struct wpa_ssid *ssid)
 {
 	int i;
@@ -577,6 +592,9 @@
 	write_pairwise(f, ssid);
 	write_group(f, ssid);
 	write_auth_alg(f, ssid);
+#ifdef CONFIG_EAP_WSC
+    write_wsc_pin(f, ssid);
+#endif /* CONFIG_EAP_WSC */
 #ifdef IEEE8021X_EAPOL
 	write_eap(f, ssid);
 	STR(identity);
Index: wpa_supplicant-0.5.11/config_ssid.h
===================================================================
--- wpa_supplicant-0.5.11.orig/config_ssid.h	2010-02-11 19:06:24.000032000 +0100
+++ wpa_supplicant-0.5.11/config_ssid.h	2010-02-11 19:06:42.000008000 +0100
@@ -15,6 +15,8 @@
 #ifndef CONFIG_SSID_H
 #define CONFIG_SSID_H
 
+#include <netinet/if_ether.h>
+
 #ifndef BIT
 #define BIT(n) (1 << (n))
 #endif
@@ -46,6 +48,13 @@
 #define EAP_PSK_LEN_MIN 16
 #define EAP_PSK_LEN_MAX 32
 
+#ifdef CONFIG_EAP_WSC
+#define WSC_MODE_OFF  0
+#define WSC_MODE_PIN  1
+#define WSC_MODE_PBC  2
+#endif
+
+
 
 #define DEFAULT_EAP_WORKAROUND ((unsigned int) -1)
 #define DEFAULT_EAPOL_FLAGS (EAPOL_FLAG_REQUIRE_KEY_UNICAST | \
@@ -199,6 +208,25 @@
 	 * such drivers to use hidden SSIDs.
 	 */
 	int scan_ssid;
+#ifdef CONFIG_EAP_WSC
+   /**
+    * wsc_mode - the WSC mode enum
+    *
+    * this the WSC mode:
+    *  0 - WSC_MODE_OFF
+    *  1 - WSC_MODE_PIN
+    *  2 - WSC_MODE_PBC
+    */
+   u32 wsc_mode;
+   /**
+    * wsc_pin -the WSC PIN string
+    *
+    * this the WSC PIN identification string
+    */
+   char* wsc_pin;
+
+#endif /* CONFIG_EAP_WSC */
+
 
 #ifdef IEEE8021X_EAPOL
 
Index: wpa_supplicant-0.5.11/ctrl_iface.c
===================================================================
--- wpa_supplicant-0.5.11.orig/ctrl_iface.c	2010-02-11 19:05:59.000036000 +0100
+++ wpa_supplicant-0.5.11/ctrl_iface.c	2010-02-11 19:06:22.000009000 +0100
@@ -541,12 +541,96 @@
 }
 
 
+#ifdef TI_WLAN_DRIVER
+ static int wpa_supplicant_compare_ssid(struct wpa_ssid *ssid1, struct wpa_ssid *ssid2)
+ {
+    int is_identical = 1,i;
+
+    if (ssid1->mode != ssid2->mode)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->ssid_len != ssid2->ssid_len)
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->ssid) && (!ssid2->ssid)) || ((!ssid1->ssid) && (ssid2->ssid))
+      || (ssid1->ssid && ssid2->ssid && (strcmp((char *)ssid1->ssid,(char *)ssid2->ssid) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->bssid) && (!ssid2->bssid)) || ((!ssid1->bssid) && (ssid2->bssid))
+      || (ssid1->bssid && ssid2->bssid && (memcmp((char *)ssid1->bssid,(char *)ssid2->bssid,ETH_ALEN) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->key_mgmt != ssid2->key_mgmt)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->group_cipher != ssid2->group_cipher)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->pairwise_cipher != ssid2->pairwise_cipher)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->proto != ssid2->proto)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->auth_alg != ssid2->auth_alg)
+    {
+          is_identical = 0;
+         is_identical = 0;
+    }else
+    if (ssid1->wep_tx_keyidx != ssid2->wep_tx_keyidx)
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->psk) && (!ssid2->psk)) || ((!ssid1->psk) && (ssid2->psk))
+      || (ssid1->psk && ssid2->psk && (strcmp((char *)ssid1->psk,(char *)ssid2->psk) != 0)))
+    {
+          is_identical = 0;
+    }else
+ #ifdef CONFIG_EAP_WSC
+    if (((ssid1->wsc_pin) && (!ssid2->wsc_pin)) || ((!ssid1->wsc_pin) && (ssid2->wsc_pin))
+      || (ssid1->wsc_pin && ssid2->wsc_pin && (strcmp((char *)ssid1->wsc_pin,(char *)ssid2->wsc_pin) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->wsc_mode != ssid2->wsc_mode)
+    {
+          is_identical = 0;
+    }else
+ #endif /* CONFIG_EAP_WSC */
+    {
+       for (i=0 ; i < NUM_WEP_KEYS; i++)
+       {
+           if ((ssid1->wep_key_len[i] != ssid2->wep_key_len[i])
+                || (memcmp(ssid1->wep_key[i], ssid2->wep_key[i], ssid1->wep_key_len[i]) != 0))
+           {
+               is_identical = 0;
+           }
+       }
+    }
+
+    return (is_identical);
+ }
+#endif /* TI_WLAN_DRIVER */
+
+
 static int wpa_supplicant_ctrl_iface_select_network(
 	struct wpa_supplicant *wpa_s, char *cmd)
 {
 	int id;
 	struct wpa_ssid *ssid;
 
+#ifdef TI_WLAN_DRIVER
+     struct wpa_ssid *selected_ssid;
+#endif /* TI_WLAN_DRIVER */
+
 	/* cmd: "<network id>" or "any" */
 	if (os_strcmp(cmd, "any") == 0) {
 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: SELECT_NETWORK any");
@@ -573,6 +657,27 @@
 	if (ssid != wpa_s->current_ssid && wpa_s->current_ssid)
 		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
 
+#ifdef TI_WLAN_DRIVER
+   selected_ssid = ssid;
+
+   /* remove all matching networks */
+   ssid = wpa_s->conf->ssid;
+   while (ssid)
+   {
+       if ((ssid != selected_ssid) && (wpa_supplicant_compare_ssid(ssid, selected_ssid)))
+       {
+           wpa_printf(MSG_DEBUG, "CTRL_IFACE: found matching block !!! ssid = %s",ssid->ssid);
+           if (wpa_config_remove_network(wpa_s->conf, ssid->id) < 0)
+           {
+               wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not remove network id=%d", ssid->id);
+           }
+           break;
+       }
+       ssid = ssid->next;
+   }
+#endif /* TI_WLAN_DRIVER */
+
+
 	/* Mark all other networks disabled and trigger reassociation */
 	ssid = wpa_s->conf->ssid;
 	while (ssid) {
@@ -626,6 +731,28 @@
 	id = atoi(cmd);
 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: DISABLE_NETWORK id=%d", id);
 
+#ifdef TI_WLAN_DRIVER 
+	if(id == -1) 
+	{ 
+   	/* disable the current network */ 
+    if(wpa_s->current_ssid) 
+       ssid = wpa_s->current_ssid; 
+    else 
+       return -1; 
+ 	} 
+	else 
+	{ 
+#endif /* TI_WLAN_DRIVER */ 
+	ssid = wpa_config_get_network(wpa_s->conf, id); 
+ 	if (ssid == NULL) { 
+   		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network " 
+   								                                "id=%d", id); 
+        return -1; 
+    } 
+#ifdef TI_WLAN_DRIVER 
+  } 
+#endif /* TI_WLAN_DRIVER */ 
+
 	ssid = wpa_config_get_network(wpa_s->conf, id);
 	if (ssid == NULL) {
 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
Index: wpa_supplicant-0.5.11/driver.h
===================================================================
--- wpa_supplicant-0.5.11.orig/driver.h	2010-02-11 19:05:42.000032000 +0100
+++ wpa_supplicant-0.5.11/driver.h	2010-02-11 19:05:57.000008000 +0100
@@ -752,6 +752,21 @@
 	 * (management frame processing) to wpa_supplicant.
 	 */
 	 int (*mlme_remove_sta)(void *priv, const u8 *addr);
+
+#ifdef CONFIG_EAP_WSC
+   /**
+    * set_wsc_mode - set the driver wsc mode
+    * @priv: Private driver interface data
+    * @WscMode: wsc mode
+    * @probeReqBuf: the probe request
+    * Returns: 0 on success, -1 on failure
+    *
+    * This function is only needed for drivers that export MLME
+    * (management frame processing) to wpa_supplicant.
+    */
+    int (*set_wsc_mode)(void *priv, const u32 WscMode, const void* probeReqBuf, int probeReqBufLen);
+#endif
+
 };
 
 #endif /* DRIVER_H */
Index: wpa_supplicant-0.5.11/driver_wext.c
===================================================================
--- wpa_supplicant-0.5.11.orig/driver_wext.c	2010-02-11 19:05:23.000052000 +0100
+++ wpa_supplicant-0.5.11/driver_wext.c	2010-02-11 19:05:40.000013000 +0100
@@ -32,6 +32,12 @@
 #include "driver_wext.h"
 #include "wpa.h"
 
+#ifdef CONFIG_EAP_WSC
+#ifdef TI_WLAN_DRIVER
+#include "TI_IPC_Api.h"
+#endif
+#endif
+
 #ifdef CONFIG_CLIENT_MLME
 #include <netpacket/packet.h>
 #include <hostapd_ioctl.h>
@@ -402,8 +408,16 @@
 		wpa_supplicant_event(ctx, EVENT_STKSTART, &data);
 #endif /* CONFIG_PEERKEY */
 	}
-}
 
+#ifdef TI_WLAN_DRIVER
+#ifdef CONFIG_EAP_WSC
+   else if(((IPC_EV_DATA*)custom)->EvParams.uEventType == IPC_EVENT_WPS_SESSION_OVERLAP)
+   {
+       wpa_supplicant_event(ctx, EVENT_WSC_PBC_OVERLAP, NULL);
+   }
+#endif /* CONFIG_EAP_WSC */
+#endif /* TI_WLAN_DRIVER */
+}
 
 static int wpa_driver_wext_event_wireless_michaelmicfailure(
 	void *ctx, const char *ev, size_t len)
@@ -1811,7 +1820,7 @@
 				    reason_code);
 }
 
-
+#ifndef TI_WLAN_DRIVER
 static int wpa_driver_wext_set_gen_ie(void *priv, const u8 *ie,
 				      size_t ie_len)
 {
@@ -1831,7 +1840,7 @@
 
 	return ret;
 }
-
+#endif
 
 static int wpa_driver_wext_cipher2wext(int cipher)
 {
@@ -1935,12 +1944,14 @@
 
 	if (wpa_driver_wext_set_mode(drv, params->mode) < 0)
 		ret = -1;
+#ifndef TI_WLAN_DRIVER
 	/* TODO: should consider getting wpa version and cipher/key_mgmt suites
 	 * from configuration, not from here, where only the selected suite is
 	 * available */
 	if (wpa_driver_wext_set_gen_ie(drv, params->wpa_ie, params->wpa_ie_len)
 	    < 0)
 		ret = -1;
+#endif
 	if (params->wpa_ie == NULL || params->wpa_ie_len == 0)
 		value = IW_AUTH_WPA_VERSION_DISABLED;
 	else if (params->wpa_ie[0] == RSN_INFO_ELEM)
@@ -2434,6 +2445,46 @@
 
 #endif /* CONFIG_CLIENT_MLME */
 
+#ifdef CONFIG_EAP_WSC
+ static int wpa_driver_wext_set_wsc_mode(void *priv, const u32 WscMode, const void* probeReqBuf, int probeReqBufLen)
+ {
+ #ifdef TI_WLAN_DRIVER
+   struct wpa_driver_wext_data *drv = priv;
+   struct iwreq iwr;
+   private_cmd_t private_cmd;
+   TWscMode WcsModeStruct;
+   int ret = 0;
+   WcsModeStruct.WSCMode = WscMode;
+   WcsModeStruct.uWscIeSize = probeReqBufLen;
+   memset(WcsModeStruct.probeReqWSCIE, 0, DOT11_WSC_PROBE_REQ_MAX_LENGTH);
+   memcpy(WcsModeStruct.probeReqWSCIE, probeReqBuf, probeReqBufLen);
+
+   private_cmd.cmd = SITE_MGR_SIMPLE_CONFIG_MODE;
+   private_cmd.flags = PRIVATE_CMD_SET_FLAG;
+   private_cmd.in_buffer = &WcsModeStruct;
+       private_cmd.in_buffer_len = sizeof(TWscMode);
+   private_cmd.out_buffer = NULL;
+       private_cmd.out_buffer_len = 0;
+
+   os_memset(&iwr, 0, sizeof(iwr));
+   os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+
+   iwr.u.data.pointer = &private_cmd;
+   iwr.u.data.length = sizeof(private_cmd_t);
+   iwr.u.data.flags = 0;
+   if (ioctl(drv->ioctl_sock, SIOCIWFIRSTPRIV, &iwr) < 0) {
+       perror("ioctl[SIOCIWFIRSTPRIV]");
+       ret = -1;
+   }
+
+   return ret;
+ #else
+   wpa_printf(MSG_ERROR,"wpa_driver_wext_set_wsc_mode: wpa_driver_wext_set_wsc_mode: this implementation is working only for TI WLAN driver\n");
+   return -1;
+#endif
+
+}
+#endif
 
 static int wpa_driver_wext_set_param(void *priv, const char *param)
 {
@@ -2511,4 +2562,8 @@
 	.mlme_add_sta = wpa_driver_wext_mlme_add_sta,
 	.mlme_remove_sta = wpa_driver_wext_mlme_remove_sta,
 #endif /* CONFIG_CLIENT_MLME */
+
+#ifdef CONFIG_EAP_WSC
+	 .set_wsc_mode = wpa_driver_wext_set_wsc_mode,
+#endif
 };
Index: wpa_supplicant-0.5.11/eap.c
===================================================================
--- wpa_supplicant-0.5.11.orig/eap.c	2010-02-11 19:04:56.000048000 +0100
+++ wpa_supplicant-0.5.11/eap.c	2010-02-11 19:05:13.000012000 +0100
@@ -50,6 +50,9 @@
 static const char * eap_sm_decision_txt(EapDecision decision);
 #endif /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
 
+#ifdef CONFIG_EAP_WSC
+ void EapWsc_EapFailureRecv(void *priv);
+#endif
 
 
 static Boolean eapol_get_bool(struct eap_sm *sm, enum eapol_bool_var var)
@@ -1140,6 +1143,16 @@
 	case EAP_CODE_FAILURE:
 		wpa_printf(MSG_DEBUG, "EAP: Received EAP-Failure");
 		sm->rxFailure = TRUE;
+
+#ifdef CONFIG_EAP_WSC
+
+       if (sm->m && sm->eap_method_priv)
+       {
+           EapWsc_EapFailureRecv(sm->eap_method_priv);
+       }
+
+ #endif /* CONFIG_EAP_WSC */
+
 		break;
 	default:
 		wpa_printf(MSG_DEBUG, "EAP: Ignored EAP-Packet with unknown "
Index: wpa_supplicant-0.5.11/eap_defs.h
===================================================================
--- wpa_supplicant-0.5.11.orig/eap_defs.h	2010-02-11 19:04:31.000020000 +0100
+++ wpa_supplicant-0.5.11/eap_defs.h	2010-02-11 19:04:54.000005000 +0100
@@ -58,7 +58,12 @@
 	EAP_TYPE_PAX = 46 /* RFC 4746 */,
 	EAP_TYPE_PSK = 47 /* RFC 4764 */,
 	EAP_TYPE_SAKE = 48 /* RFC 4763 */,
-	EAP_TYPE_EXPANDED = 254 /* RFC 3748 */,
+#ifdef CONFIG_EAP_WSC
+    EAP_TYPE_EXPANDED = 253 /* RFC 3748 */,
+    EAP_TYPE_WSC = 254, /*Wireless Simple Config */
+#else
+    EAP_TYPE_EXPANDED = 254 /* RFC 3748 */,
+#endif /* CONFIG_DRIVER_TI */
 	EAP_TYPE_GPSK = 255 /* EXPERIMENTAL - type not yet allocated
 			     * draft-ietf-emu-eap-gpsk-01.txt */
 } EapType;
Index: wpa_supplicant-0.5.11/eap_methods.c
===================================================================
--- wpa_supplicant-0.5.11.orig/eap_methods.c	2010-02-11 19:04:07.000024000 +0100
+++ wpa_supplicant-0.5.11/eap_methods.c	2010-02-11 19:04:28.000006000 +0100
@@ -455,6 +455,14 @@
 	}
 #endif /* EAP_GPSK */
 
+#ifdef CONFIG_EAP_WSC
+   if (ret == 0) {
+       int eap_peer_wsc_register(void);
+       ret = eap_peer_wsc_register();
+   }
+#endif /* CONFIG_EAP_WSC */
+
+
 #ifdef EAP_VENDOR_TEST
 	if (ret == 0) {
 		int eap_peer_vendor_test_register(void);
Index: wpa_supplicant-0.5.11/events.c
===================================================================
--- wpa_supplicant-0.5.11.orig/events.c	2010-02-11 19:03:41.000028000 +0100
+++ wpa_supplicant-0.5.11/events.c	2010-02-11 19:04:05.000007000 +0100
@@ -28,6 +28,10 @@
 #include "wpa_ctrl.h"
 #include "eap.h"
 #include "ctrl_iface_dbus.h"
+#ifdef CONFIG_EAP_WSC
+ #include "wsc_supplicant.h"
+#endif
+
 
 
 static int wpa_supplicant_select_config(struct wpa_supplicant *wpa_s)
@@ -725,6 +729,13 @@
 		wpa_supplicant_req_auth_timeout(wpa_s, 10, 0);
 	}
 	wpa_supplicant_cancel_scan(wpa_s);
+
+#ifdef CONFIG_EAP_WSC
+   if(wpa_s->current_ssid)
+   {
+       wsc_supplicant_event_assoc(wpa_s->current_ssid);
+   }
+#endif
 }
 
 
@@ -874,6 +885,12 @@
 		wpa_supplicant_event_stkstart(wpa_s, data);
 		break;
 #endif /* CONFIG_PEERKEY */
+
+#ifdef CONFIG_EAP_WSC
+   case EVENT_WSC_PBC_OVERLAP:
+       wsc_supplicant_event_overlap();
+       break;
+#endif /* CONFIG_EAP_WSC */
 	default:
 		wpa_printf(MSG_INFO, "Unknown event %d", event);
 		break;
Index: wpa_supplicant-0.5.11/wpa.c
===================================================================
--- wpa_supplicant-0.5.11.orig/wpa.c	2010-02-11 19:07:25.000076000 +0100
+++ wpa_supplicant-0.5.11/wpa.c	2010-02-11 19:07:46.000019000 +0100
@@ -1649,6 +1649,16 @@
 	int ret = 0;
 
 	switch (group_cipher) {
+
+    case (WPA_CIPHER_TKIP | WPA_CIPHER_CCMP):
+       if (keylen != 32 && keylen != 16) {
+           ret = -1;
+           break;
+       }
+       *key_rsc_len = 6;
+       *alg = WPA_ALG_TKIP | WPA_ALG_CCMP;
+       break;
+
 	case WPA_CIPHER_CCMP:
 		if (keylen != 16 || maxkeylen < 16) {
 			ret = -1;
Index: wpa_supplicant-0.5.11/wpa_supplicant.c
===================================================================
--- wpa_supplicant-0.5.11.orig/wpa_supplicant.c	2010-02-11 19:02:30.000056000 +0100
+++ wpa_supplicant-0.5.11/wpa_supplicant.c	2010-02-11 19:02:50.000014000 +0100
@@ -35,6 +35,10 @@
 #include "pmksa_cache.h"
 #include "wpa_ctrl.h"
 #include "mlme.h"
+#ifdef CONFIG_EAP_WSC
+ #include "wsc_supplicant.h"
+#endif
+
 
 const char *wpa_supplicant_version =
 "wpa_supplicant v" VERSION_STR "\n"
@@ -1380,6 +1384,14 @@
 	 * previous association. */
 	wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, NULL, 0);
 
+#ifdef CONFIG_EAP_WSC
+   if(ssid->wsc_mode)
+   {
+       wsc_supplicant_associate(wpa_s, ssid, ssid->wsc_mode);
+   }
+#endif
+
+
 #ifdef IEEE8021X_EAPOL
 	if (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
 		if (ssid->leap) {
@@ -1488,6 +1500,7 @@
 	} else {
 		params.ssid = ssid->ssid;
 		params.ssid_len = ssid->ssid_len;
+		params.bssid = ssid->bssid;
 	}
 	if (ssid->mode == 1 && ssid->frequency > 0 && params.freq == 0)
 		params.freq = ssid->frequency; /* Initial channel for IBSS */
@@ -1550,6 +1563,10 @@
 			/* give IBSS a bit more time */
  			timeout = ssid->mode ? 20 : 10;
 		}
+#ifdef CONFIG_EAP_WSC
+       timeout += wsc_supplicant_associate_timeout_calc();
+#endif
+
 		wpa_supplicant_req_auth_timeout(wpa_s, timeout, 0);
 	}
 
@@ -1620,6 +1637,12 @@
 				   int reason_code)
 {
 	u8 *addr = NULL;
+
+#ifdef CONFIG_EAP_WSC
+  if(wpa_s->current_ssid && wpa_s->current_ssid->wsc_mode)
+       wsc_supplicant_stop();
+#endif
+
 	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
 	if (os_memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0)
 	{
@@ -1799,6 +1822,25 @@
 		entry = entry->next;
 	}
 
+#ifdef TI_WLAN_DRIVER
+   entry = wpa_s->conf->ssid;
+   while (entry) {
+       if (!entry->disabled &&
+           entry->ssid_len == 0)
+           {
+               entry->ssid_len = ssid_len;
+                 entry->ssid = realloc(entry->ssid,ssid_len);
+                 if (entry->ssid == NULL) {
+                     wpa_printf(MSG_WARNING, "Could not realloc ssid entry.");
+                     return NULL;
+                 }
+               os_memcpy(entry->ssid, ssid, ssid_len);
+               return entry;
+           }
+       entry = entry->next;
+   }
+#endif
+
 	return NULL;
 }
 
Index: wpa_supplicant-0.5.11/wpa_supplicant.h
===================================================================
--- wpa_supplicant-0.5.11.orig/wpa_supplicant.h	2010-02-11 19:02:01.000027000 +0100
+++ wpa_supplicant-0.5.11/wpa_supplicant.h	2010-02-11 19:02:21.000006000 +0100
@@ -123,6 +123,17 @@
 	 */
 	EVENT_PMKID_CANDIDATE,
 
+#ifdef CONFIG_EAP_WSC
+   /**
+    * EVENT_WSC_PBC_OVERLAP - notfication of a PBC overlap
+    *
+    * This event is used to inform the WSC of the supplicant that more
+    * than on AP is in PBC mode
+    */
+   EVENT_WSC_PBC_OVERLAP,
+#endif
+
+
 	/**
 	 * EVENT_STKSTART - Request STK handshake (MLME-STKSTART.request)
 	 *
Index: wpa_supplicant-0.5.11/wpa_supplicant_i.h
===================================================================
--- wpa_supplicant-0.5.11.orig/wpa_supplicant_i.h	2010-02-11 19:01:19.000006000 +0100
+++ wpa_supplicant-0.5.11/wpa_supplicant_i.h	2010-02-11 19:01:59.000007000 +0100
@@ -693,4 +693,16 @@
 	return -1;
 }
 
+#ifdef CONFIG_EAP_WSC
+ static inline int wpa_drv_set_wsc_mode(struct wpa_supplicant *wpa_s,
+                     u32 WscMode,
+                     void* probeReqBuf,
+                     int probeReqBufLen)
+ {
+   if (wpa_s->driver->set_wsc_mode)
+       return wpa_s->driver->set_wsc_mode(wpa_s->drv_priv, WscMode, probeReqBuf, probeReqBufLen);
+   return -1;
+ }
+#endif
+
 #endif /* WPA_SUPPLICANT_I_H */
