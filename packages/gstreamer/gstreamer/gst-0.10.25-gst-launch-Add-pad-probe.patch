From 4733e42ba46e58f500340e5a4b0fbd7b09d995a8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Roberto=20Guti=C3=A9rrez?= <jesusgutierrez70@gmail.com>
Date: Fri, 5 Feb 2010 10:51:11 -0600
Subject: [PATCH] gst-launch: Add pad probe.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Daniel DÃ­az <yosoy@danieldiaz.org>
---
 tools/gst-launch.c |  145 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 145 insertions(+), 0 deletions(-)

Index: git/tools/gst-launch.c
===================================================================
--- git.orig/tools/gst-launch.c	2009-11-04 02:44:16.000000000 -0600
+++ git/tools/gst-launch.c	2010-02-05 15:30:05.000000000 -0600
@@ -33,6 +33,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <signal.h>
+#include <sys/time.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -41,6 +42,8 @@
 #endif
 #include <locale.h>             /* for LC_ALL */
 #include "tools.h"
+#include "gst/gstelement.h"
+#include "gst/gstpad.h"
 
 /* FIXME: This is just a temporary hack.  We should have a better
  * check for siginfo handling. */
@@ -76,6 +79,46 @@
 /* convenience macro so we don't have to litter the code with if(!quiet) */
 #define PRINT if(!quiet)g_print
 
+GTimeVal        start_time;
+GTimeVal        end_time;
+GTimeVal        diff_time;
+
+struct timeval  s1time;
+struct timeval  etime;
+struct timeval  currenttime;
+struct timeval  result;
+struct tm*      ptm;
+long            count=0;
+long            past_count=0;
+struct          itimerval val, curval;
+gboolean        timer = FALSE;
+
+/* http://www.gnu.org/s/libc/manual/html_node/Elapsed-Time.html */
+int
+timeval_subtract (result, x, y)
+     struct timeval *result, *x, *y;
+{
+  /* Perform the carry for the later subtraction by updating y. */
+  if (x->tv_usec < y->tv_usec) {
+    int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
+    y->tv_usec -= 1000000 * nsec;
+    y->tv_sec += nsec;
+  }
+  if (x->tv_usec - y->tv_usec > 1000000) {
+    int nsec = (x->tv_usec - y->tv_usec) / 1000000;
+    y->tv_usec += 1000000 * nsec;
+    y->tv_sec -= nsec;
+  }
+
+  /* Compute the time remaining to wait.
+     tv_usec is certainly positive. */
+  result->tv_sec = x->tv_sec - y->tv_sec;
+  result->tv_usec = x->tv_usec - y->tv_usec;
+
+  /* Return 1 if result is negative. */
+  return x->tv_sec < y->tv_sec;
+}
+
 #ifndef GST_DISABLE_LOADSAVE
 static GstElement *
 xmllaunch_parse_cmdline (const gchar ** argv)
@@ -132,6 +175,7 @@
     *value++ = '\0';
 
     e = gst_bin_get_by_name (GST_BIN (pipeline), element);
+    g_print ("Looking...\n");
     if (!e) {
       g_printerr (_("WARNING: element named '%s' not found.\n"), element);
     } else {
@@ -657,6 +701,37 @@
   }
 }
 
+void alarm_awake()
+{
+  long framesinsec=0;
+  static long past_count=0;
+
+  struct tm* tptr;
+  time_t t = time(NULL);
+
+  /*g_print ("alarm ticked every second\n"); */
+  framesinsec = count-past_count;
+
+  if (count > 0 && timer == TRUE) {
+           tptr = localtime(&t);
+           g_print ("FPS: %3d  TIME %02d:%02d:%02d\n",(int)framesinsec,tptr->tm_hour, tptr->tm_min, tptr->tm_sec);
+  }
+
+  past_count=count;
+}
+
+static gboolean
+cb_have_data_sink (GstPad  *pad,
+              GstBuffer *buffer,
+              gpointer   u_data)
+{
+  g_get_current_time (&end_time);
+  gettimeofday (&etime, NULL);
+  count=count+1;
+
+  return TRUE;
+}
+
 int
 main (int argc, char *argv[])
 {
@@ -667,6 +742,8 @@
   gboolean eos_on_shutdown = FALSE;
   gchar *savefile = NULL;
   gchar *exclude_args = NULL;
+  gchar *element_pad = NULL;
+
 #ifndef GST_DISABLE_OPTION_PARSING
   GOptionEntry options[] = {
     {"tags", 't', 0, G_OPTION_ARG_NONE, &tags,
@@ -689,6 +766,10 @@
         N_("Print alloc trace (if enabled at compile time)"), NULL},
     {"eos-on-shutdown", 'e', 0, G_OPTION_ARG_NONE, &eos_on_shutdown,
         N_("Force EOS on sources before shutting the pipeline down"), NULL},
+    {"padprobe", 'p', 0, G_OPTION_ARG_STRING, &element_pad,
+        N_("Instrumentation metrics for calculating frames per second"), NULL},
+    {"timer", 'r', 0, G_OPTION_ARG_NONE, &timer,
+        N_("Display FPS timer every second"), NULL},
     GST_TOOLS_GOPTION_VERSION,
     {NULL}
   };
@@ -774,6 +855,50 @@
     return 1;
   }
 
+  if (element_pad)
+  {
+    char e_name[50], e_pad[30];
+    GstElement *element = NULL;
+    GstPad *pad;
+    char *pch;
+    int l1, l2;
+
+    pch = strchr (element_pad, ':');
+    if (pch != NULL)
+        strncpy (e_name, element_pad, pch-element_pad + 1);
+    else{
+        g_print ("Couldn't find character ':'; -padprobe discarded.\n");
+        goto cont;
+    }
+
+    e_name[pch-element_pad] = '\0';
+    strcpy (e_pad, pch+1);
+    l1 = strlen (e_name);
+    l2 = strlen (e_pad);
+
+    /*
+    g_printf (" element = %s %d\n", e_name, l1);
+    g_printf (" pad = %s %d\n", e_pad, l2);
+    */
+
+    element = gst_bin_get_by_name (GST_BIN (pipeline), e_name);
+    if (element == NULL) {
+       g_print ("Couldn't find element %s; -padprobe discarded.\n", e_name);
+    }
+    else
+    {
+       pad = gst_element_get_static_pad (element, e_pad);
+       if (pad == NULL) {
+          g_print ("Couldn't find pad %s; -padprobe discarded.\n", e_pad);
+       } else
+          gst_pad_add_buffer_probe (pad, G_CALLBACK (cb_have_data_sink), NULL);
+       gst_object_unref (element);
+    }
+    /* TI change */
+  }
+
+cont:
+
   if (verbose) {
     gchar **exclude_list =
         exclude_args ? g_strsplit (exclude_args, ",", 0) : NULL;
@@ -860,6 +985,16 @@
         goto end;
       }
 
+      signal (SIGALRM, alarm_awake);
+
+      val.it_interval.tv_sec  = 1;      /* ie. every second */
+      val.it_interval.tv_usec = 0;
+      val.it_value.tv_sec     = 1;      /* initialise counter */
+      val.it_value.tv_usec    = 0;
+
+      setitimer (ITIMER_REAL, &val, 0);
+
+      g_get_current_time (&start_time);
       tfthen = gst_util_get_timestamp ();
       caught_error = event_loop (pipeline, TRUE, GST_STATE_PLAYING);
       if (eos_on_shutdown && caught_error == ELR_INTERRUPT) {
@@ -877,6 +1012,9 @@
         }
       }
       tfnow = gst_util_get_timestamp ();
+      g_get_current_time (&end_time);
+   
+      signal (SIGALRM, SIG_IGN);
 
       diff = GST_CLOCK_DIFF (tfthen, tfnow);
 
@@ -901,6 +1039,17 @@
     gst_element_get_state (pipeline, &state, &pending, GST_CLOCK_TIME_NONE);
   }
 
+  timeval_subtract (&diff_time, &end_time, &start_time);
+  g_print ("Total time: %lf seconds\n", (float)diff_time.tv_sec + (float) diff_time.tv_usec / G_USEC_PER_SEC);
+
+  if (element_pad)
+  {
+    g_print ("Frames: %d processed\n", (int)count);
+
+     /* g_print ("Avg. FPS: %.2lf\n", (float) ((float)count / ((float)diff_time.tv_sec)+(float)diff_time.tv_usec) ); */
+      g_print ("Avg. FPS: %.2lf\n", (float)  (count / (float)(diff_time.tv_sec * G_USEC_PER_SEC + diff_time.tv_usec) * G_USEC_PER_SEC));
+  }
+
   PRINT (_("Freeing pipeline ...\n"));
   gst_object_unref (pipeline);
 
